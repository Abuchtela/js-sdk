var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// local-tests/shim.mjs
import { createRequire } from "module";
var require2;
var init_shim = __esm({
  "local-tests/shim.mjs"() {
    require2 = createRequire(import.meta.url);
    global.require = require2;
  }
});

// node_modules/@ethersproject/bignumber/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@ethersproject/bignumber/node_modules/bn.js/lib/bn.js"(exports, module2) {
    init_shim();
    (function(module3, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base2, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = __require("buffer").Buffer;
        }
      } catch (e2) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base2, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r3 = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r3 *= mul3;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul3, "Invalid character");
          r3 += b;
        }
        return r3;
      }
      BN3.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r3 = new BN3(null);
        this.copy(r3);
        return r3;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e2) {
          BN3.prototype.inspect = inspect4;
        }
      } else {
        BN3.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r3 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN3.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r3 = 0;
          if (t2 >= 4096) {
            r3 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r3 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r3 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r3 += 2;
            t2 >>>= 2;
          }
          return r3 + t2;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w;
        var r3 = 0;
        if ((t2 & 8191) === 0) {
          r3 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r3 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r3 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r3 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r3 += b;
          if (b !== 26)
            break;
        }
        return r3;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a2;
        var b;
        if (this.length > num.length) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a2, b;
        if (this.length > num.length) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r3 = (a2.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN3.prototype.add = function add5(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b;
        if (cmp > 0) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r3 = (a2.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r3 = a2 * b;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a2 = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r3 = a2 * b + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b = num.words;
        var o2 = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c !== 0) {
          o2[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a2 = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r3 = a2 * b;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l2 = BN3.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t2[i2] = this.revBin(i2, l2, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x, l2, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x & 1) << l2 - i2 - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p = 0; p < N2; p += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s2];
              var io = itws[p + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s2] = re - ro;
              itws[p + j + s2] = ie - io;
              if (j !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N2 = Math.max(m, n2) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i2;
        if (r3 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r3;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h -= s2;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q = 1 << r3;
        if (this.length <= s2)
          return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a2.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a2.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a2 = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a2.words[b.length + j] | 0) * 67108864 + (a2.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b, qj, j);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b, 1, j);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a2._strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a2
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A2 = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D3 = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B.isOdd()) {
                A2.iadd(yp);
                B.isub(xp);
              }
              A2.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D3.isOdd()) {
                C.iadd(yp);
                D3.isub(xp);
              }
              C.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A2.isub(C);
            B.isub(D3);
          } else {
            y.isub(x);
            C.isub(A2);
            D3.isub(B);
          }
        }
        return {
          a: C,
          b: D3,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a2 = this;
        var b = p.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a2.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b) >= 0) {
            a2.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b = num.clone();
        a2.negative = 0;
        b.negative = 0;
        for (var shift = 0; a2.isEven() && b.isEven(); shift++) {
          a2.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r3 = a2.cmp(b);
          if (r3 < 0) {
            var t2 = a2;
            a2 = b;
            b = t2;
          } else if (r3 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a2.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a2 === b)
            continue;
          if (a2 < b) {
            res = -1;
          } else if (a2 > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b) {
        assert2((a2.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        move(a2, a2.umod(this.m)._forceRed(this));
        return a2;
      };
      Red.prototype.neg = function neg3(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add5(a2, b) {
        this._verify2(a2, b);
        var res = a2.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b) {
        this._verify2(a2, b);
        var res = a2.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b) {
        this._verify2(a2, b);
        var res = a2.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b) {
        this._verify2(a2, b);
        var res = a2.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b) {
        this._verify2(a2, b);
        return this.imod(a2.imul(b));
      };
      Red.prototype.mul = function mul3(a2, b) {
        this._verify2(a2, b);
        return this.imod(a2.mul(b));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r3 = this.pow(a2, q.addn(1).iushrn(1));
        var t2 = this.pow(a2, q);
        var m = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b = this.pow(c, new BN3(1).iushln(m - i2 - 1));
          r3 = r3.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m = i2;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a2, b) {
        if (a2.isZero() || b.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a2, b) {
        if (a2.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t2 = a2.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version2;
var init_version = __esm({
  "node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    init_shim();
    version2 = "logger/5.7.0";
  }
});

// node_modules/@ethersproject/logger/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  ErrorCode: () => ErrorCode,
  LogLevel: () => LogLevel,
  Logger: () => Logger
});
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_version();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel3) {
      LogLevel3["DEBUG"] = "DEBUG";
      LogLevel3["INFO"] = "INFO";
      LogLevel3["WARNING"] = "WARNING";
      LogLevel3["ERROR"] = "ERROR";
      LogLevel3["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class _Logger {
      constructor(version28) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version28,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(_Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(_Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(_Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key2) => {
          const value = params[key2];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i2 = 0; i2 < value.length; i2++) {
                hex += HEX[value[i2] >> 4];
                hex += HEX[value[i2] & 15];
              }
              messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key2 + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key2) {
          error[key2] = params[key2];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger(version2);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version28) {
        return new _Logger(version28);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version3;
var init_version2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    init_shim();
    version3 = "bytes/5.7.0";
  }
});

// node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  arrayify: () => arrayify,
  concat: () => concat,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  joinSignature: () => joinSignature,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  zeroPad: () => zeroPad
});
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v = value[i2];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v = value[i2];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var logger, HexCharacters;
var init_lib2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib();
    init_version2();
    logger = new Logger(version3);
    HexCharacters = "0123456789abcdef";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version4;
var init_version3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    init_shim();
    version4 = "bignumber/5.7.0";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
var import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    init_shim();
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version3();
    BN = import_bn.default.BN;
    logger2 = new Logger(version4);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class _BigNumber {
      constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return _BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o2 = _BigNumber.from(other);
        if (o2.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e2) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key2) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof _BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new _BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new _BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return _BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return _BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return _BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return _BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return _BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE, BUMP;
var init_fixednumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib();
    init_version3();
    init_bignumber();
    logger3 = new Logger(version4);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class _FixedFormat {
      constructor(constructorGuard, signed2, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed2;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value) {
        if (value instanceof _FixedFormat) {
          return value;
        }
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed2 = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed2 = false;
          } else {
            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger3.throwArgumentError("invalid fixed format", "format", value);
            }
            signed2 = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          const check = (key2, type, defaultValue) => {
            if (value[key2] == null) {
              return defaultValue;
            }
            if (typeof value[key2] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
            }
            return value[key2];
          };
          signed2 = check("signed", "boolean", signed2);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new _FixedFormat(_constructorGuard2, signed2, width, decimals);
      }
    };
    FixedNumber = class _FixedNumber {
      constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.add(b), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.sub(b), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a2 = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return _FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = _FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      // @TODO: Support other rounding algorithms
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return _FixedNumber.fromString(this._value, format);
      }
      static fromValue(value, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      }
      static fromString(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value, format) {
        if (typeof value === "string") {
          return _FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
          return _FixedNumber.fromBytes(value, format);
        }
        try {
          return _FixedNumber.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
      }
      static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
      }
    };
    ONE = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/index.js
var init_lib3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    init_shim();
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version5;
var init_version4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/_version.js"() {
    init_shim();
    version5 = "properties/5.7.0";
  }
});

// node_modules/@ethersproject/properties/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  Description: () => Description,
  checkProperties: () => checkProperties,
  deepCopy: () => deepCopy,
  defineReadOnly: () => defineReadOnly,
  getStatic: () => getStatic,
  resolveProperties: () => resolveProperties,
  shallowCopy: () => shallowCopy
});
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v) => ({ key: key2, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger4.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
var __awaiter, logger4, opaque, Description;
var init_lib4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib();
    init_version4();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger4 = new Logger(version5);
    opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    Description = class {
      constructor(info) {
        for (const key2 in info) {
          this[key2] = deepCopy(info[key2]);
        }
      }
    };
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version6;
var init_version5 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/_version.js"() {
    init_shim();
    version6 = "abstract-provider/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter2, logger5, ForkEvent, Provider;
var init_lib5 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib3();
    init_lib4();
    init_lib();
    init_version5();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger5 = new Logger(version6);
    ForkEvent = class extends Description {
      static isForkEvent(value) {
        return !!(value && value._isForkEvent);
      }
    };
    Provider = class _Provider {
      constructor() {
        logger5.checkAbstract(new.target, _Provider);
        defineReadOnly(this, "_isProvider", true);
      }
      getFeeData() {
        return __awaiter2(this, void 0, void 0, function* () {
          const { block, gasPrice } = yield resolveProperties({
            block: this.getBlock("latest"),
            gasPrice: this.getGasPrice().catch((error) => {
              return null;
            })
          });
          let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
          if (block && block.baseFeePerGas) {
            lastBaseFeePerGas = block.baseFeePerGas;
            maxPriorityFeePerGas = BigNumber.from("1500000000");
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
          }
          return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
      }
      // Alias for "on"
      addListener(eventName, listener) {
        return this.on(eventName, listener);
      }
      // Alias for "off"
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
      static isProvider(value) {
        return !!(value && value._isProvider);
      }
    };
  }
});

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify(data);
}
function encode(data) {
  data = arrayify(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}
var init_base64 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/base64.js"() {
    "use strict";
    init_shim();
    init_lib2();
  }
});

// node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  decode: () => decode,
  encode: () => encode
});
var init_lib6 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_base64();
  }
});

// node_modules/@ethersproject/basex/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  Base32: () => Base32,
  Base58: () => Base58,
  BaseX: () => BaseX
});
var BaseX, Base32, Base58;
var init_lib7 = __esm({
  "node_modules/@ethersproject/basex/lib.esm/index.js"() {
    init_shim();
    init_lib2();
    init_lib4();
    BaseX = class {
      constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        for (let i2 = 0; i2 < alphabet.length; i2++) {
          this._alphabetMap[alphabet.charAt(i2)] = i2;
        }
      }
      encode(value) {
        let source = arrayify(value);
        if (source.length === 0) {
          return "";
        }
        let digits = [0];
        for (let i2 = 0; i2 < source.length; ++i2) {
          let carry = source[i2];
          for (let j = 0; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        let string = "";
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
          string += this._leader;
        }
        for (let q = digits.length - 1; q >= 0; --q) {
          string += this.alphabet[digits[q]];
        }
        return string;
      }
      decode(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
          return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i2 = 0; i2 < value.length; i2++) {
          let byte = this._alphabetMap[value[i2]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          let carry = byte;
          for (let j = 0; j < bytes.length; ++j) {
            carry += bytes[j] * this.base;
            bytes[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
          bytes.push(0);
        }
        return arrayify(new Uint8Array(bytes.reverse()));
      }
    };
    Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero;
var init_addresses = __esm({
  "node_modules/@ethersproject/constants/lib.esm/addresses.js"() {
    init_shim();
    AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2, Zero2, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256;
var init_bignumbers = __esm({
  "node_modules/@ethersproject/constants/lib.esm/bignumbers.js"() {
    init_shim();
    init_lib3();
    NegativeOne2 = /* @__PURE__ */ BigNumber.from(-1);
    Zero2 = /* @__PURE__ */ BigNumber.from(0);
    One = /* @__PURE__ */ BigNumber.from(1);
    Two = /* @__PURE__ */ BigNumber.from(2);
    WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000");
    MaxUint256 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero;
var init_hashes = __esm({
  "node_modules/@ethersproject/constants/lib.esm/hashes.js"() {
    init_shim();
    HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol;
var init_strings = __esm({
  "node_modules/@ethersproject/constants/lib.esm/strings.js"() {
    init_shim();
    EtherSymbol = "\u039E";
  }
});

// node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports6 = {};
__export(lib_exports6, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});
var init_lib8 = __esm({
  "node_modules/@ethersproject/constants/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_addresses();
    init_bignumbers();
    init_hashes();
    init_strings();
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module2) {
    init_shim();
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n2, s2) {
          return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key2, message, outputBits, s2) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n2, s2) {
          if (!n2 && !s2) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n2, s2], w);
          }
        };
        method.update = function(message, outputBits, n2, s2) {
          return method.create(outputBits, n2, s2).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key2, outputBits, s2) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w).bytepad([key2], w);
        };
        method.update = function(key2, message, outputBits, s2) {
          return method.create(key2, outputBits, s2).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i2 = 0; i2 < algorithms.length; ++i2) {
        var algorithm = algorithms[i2];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i3 = 0; i3 < 50; ++i3) {
          this.s[i3] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          if (notString) {
            for (i3 = this.start; index < length && i3 < byteCount; ++index) {
              blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
            }
          } else {
            for (i3 = this.start; index < length && i3 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i3 >> 2] |= code << SHIFT[i3++ & 3];
              } else if (code < 2048) {
                blocks[i3 >> 2] |= (192 | code >> 6) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i3 >> 2] |= (224 | code >> 12) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i3 >> 2] |= (240 | code >> 18) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              }
            }
          }
          this.lastByteIndex = i3;
          if (i3 >= byteCount) {
            this.start = i3 - byteCount;
            this.block = blocks[blockCount];
            for (i3 = 0; i3 < blockCount; ++i3) {
              s2[i3] ^= blocks[i3];
            }
            f(s2);
            this.reset = true;
          } else {
            this.start = i3;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o2 = x & 255, n2 = 1;
        var bytes = [o2];
        x = x >> 8;
        o2 = x & 255;
        while (o2 > 0) {
          bytes.unshift(o2);
          x = x >> 8;
          o2 = x & 255;
          ++n2;
        }
        if (right) {
          bytes.push(n2);
        } else {
          bytes.unshift(n2);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i3 = 0; i3 < str.length; ++i3) {
            var code = str.charCodeAt(i3);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i3) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i3 = 0; i3 < strs.length; ++i3) {
          bytes += this.encodeString(strs[i3]);
        }
        var paddingBytes = w - bytes % w;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i3 >> 2] |= this.padding[i3 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i3 = 0; i3 < blockCount; ++i3) {
          s2[i3] ^= blocks[i3];
        }
        f(s2);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            block = s2[i3];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s2);
            i3 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            array[j2] = s2[i3];
          }
          if (j2 % blockCount === 0) {
            f(s2);
          }
        }
        if (extraBytes) {
          array[i3] = s2[i3];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
            offset = j2 << 2;
            block = s2[i3];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s2);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s2[i3];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s2) {
        var h, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l2 = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h;
          s2[1] ^= l2;
          s2[10] ^= h;
          s2[11] ^= l2;
          s2[20] ^= h;
          s2[21] ^= l2;
          s2[30] ^= h;
          s2[31] ^= l2;
          s2[40] ^= h;
          s2[41] ^= l2;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l2 = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h;
          s2[3] ^= l2;
          s2[12] ^= h;
          s2[13] ^= l2;
          s2[22] ^= h;
          s2[23] ^= l2;
          s2[32] ^= h;
          s2[33] ^= l2;
          s2[42] ^= h;
          s2[43] ^= l2;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l2 = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h;
          s2[5] ^= l2;
          s2[14] ^= h;
          s2[15] ^= l2;
          s2[24] ^= h;
          s2[25] ^= l2;
          s2[34] ^= h;
          s2[35] ^= l2;
          s2[44] ^= h;
          s2[45] ^= l2;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l2 = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h;
          s2[7] ^= l2;
          s2[16] ^= h;
          s2[17] ^= l2;
          s2[26] ^= h;
          s2[27] ^= l2;
          s2[36] ^= h;
          s2[37] ^= l2;
          s2[46] ^= h;
          s2[47] ^= l2;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l2 = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h;
          s2[9] ^= l2;
          s2[18] ^= h;
          s2[19] ^= l2;
          s2[28] ^= h;
          s2[29] ^= l2;
          s2[38] ^= h;
          s2[39] ^= l2;
          s2[48] ^= h;
          s2[49] ^= l2;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b2 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b22 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b2 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b22 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b2 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b22 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b2;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b22;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n2];
          s2[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i2 = 0; i2 < methodNames.length; ++i2) {
          root[methodNames[i2]] = methods[methodNames[i2]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  keccak256: () => keccak256
});
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}
var import_js_sha3;
var init_lib9 = __esm({
  "node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    init_shim();
    import_js_sha3 = __toESM(require_sha3());
    init_lib2();
  }
});

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version8;
var init_version6 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/_version.js"() {
    init_shim();
    version8 = "strings/5.7.0";
  }
});

// node_modules/@ethersproject/strings/lib.esm/utf8.js
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger7.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o2 = offset + 1; o2 < bytes.length; o2++) {
      if (bytes[o2] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c = bytes[i2++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger7.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c = str.charCodeAt(i2);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i2++;
      const c2 = str.charCodeAt(i2);
      if (i2 >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var logger7, UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs;
var init_utf8 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/utf8.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib();
    init_version6();
    logger7 = new Logger(version8);
    (function(UnicodeNormalizationForm2) {
      UnicodeNormalizationForm2["current"] = "";
      UnicodeNormalizationForm2["NFC"] = "NFC";
      UnicodeNormalizationForm2["NFD"] = "NFD";
      UnicodeNormalizationForm2["NFKC"] = "NFKC";
      UnicodeNormalizationForm2["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason || (Utf8ErrorReason = {}));
    Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
  }
});

// node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = arrayify(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
var init_bytes32 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/bytes32.js"() {
    "use strict";
    init_shim();
    init_lib8();
    init_lib2();
    init_utf8();
  }
});

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range = ranges[i2];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name = _toUtf8String(codes);
  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name;
}
var Table_A_1_ranges, Table_B_1_flags, Table_B_2_ranges, Table_B_2_lut_abs, Table_B_2_lut_rel, Table_B_2_complex, Table_C_ranges;
var init_idna = __esm({
  "node_modules/@ethersproject/strings/lib.esm/idna.js"() {
    "use strict";
    init_shim();
    init_utf8();
    Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
    Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  }
});

// node_modules/@ethersproject/strings/lib.esm/index.js
var lib_exports8 = {};
__export(lib_exports8, {
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  formatBytes32String: () => formatBytes32String,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String
});
var init_lib10 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_bytes32();
    init_idna();
    init_utf8();
  }
});

// node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
var init_id = __esm({
  "node_modules/@ethersproject/hash/lib.esm/id.js"() {
    init_shim();
    init_lib9();
    init_lib10();
  }
});

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version9;
var init_version7 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/_version.js"() {
    init_shim();
    version9 = "hash/5.7.0";
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i2 = 0; i2 < array.length; i2++) {
    const value = array[i2];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N2; i2++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a2 = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a2 ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a2 & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_counts(n2, next) {
  let v = Array(n2);
  for (let i2 = 0; i2 < n2; i2++)
    v[i2] = 1 + next();
  return v;
}
function read_ascending(n2, next) {
  let v = Array(n2);
  for (let i2 = 0, x = -1; i2 < n2; i2++)
    v[i2] = x += 1 + next();
  return v;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i2 = 0, x = 0; i2 < n2; i2++)
    v[i2] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n2 = next();
  let vX = read_ascending(n2, next);
  let vN = read_counts(n2, next);
  for (let i2 = 0; i2 < n2; i2++) {
    for (let j = 0; j < vN[i2]; j++) {
      v.push(vX[i2] + j);
    }
  }
  return lookup ? v.map((x) => lookup[x]) : v;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i2 = next();
    if (i2 == 0)
      break;
    v.push(i2);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill(void 0).map(() => []);
  for (let i2 = 0; i2 < w; i2++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map((v, i2) => {
    const x = v[0], ys = v.slice(1);
    return Array(vN[i2]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  }));
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a2, b) => a2 - b);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read() });
    }
    branches.sort((a2, b) => b.set.size - a2.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
var init_decoder = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js"() {
    init_shim();
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
var init_include = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js"() {
    init_shim();
    init_lib6();
    init_decoder();
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
function explode_cp(name) {
  return toUtf8CodePoints(name);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name) {
  for (let label of name.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i2 = cps.lastIndexOf(UNDERSCORE) - 1; i2 >= 0; i2--) {
        if (cps[i2] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name;
}
function ens_normalize(name) {
  return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
  let input = explode_cp(name).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = (_a = node.branches.find((x) => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
var r, VALID, IGNORED, MAPPED, EMOJI_ROOT, HYPHEN, UNDERSCORE;
var init_lib11 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js"() {
    init_shim();
    init_lib10();
    init_include();
    init_decoder();
    r = getData();
    VALID = new Set(read_member_array(r));
    IGNORED = new Set(read_member_array(r));
    MAPPED = read_mapped_map(r);
    EMOJI_ROOT = read_emoji_trie(r);
    HYPHEN = 45;
    UNDERSCORE = 95;
  }
});

// node_modules/@ethersproject/hash/lib.esm/namehash.js
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name) {
  const bytes = toUtf8Bytes(ens_normalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i2 = 0; i2 < bytes.length; i2++) {
    const d = bytes[i2];
    if (d === 46) {
      comps.push(checkComponent(bytes.slice(last, i2)));
      last = i2 + 1;
    }
  }
  if (last >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function ensNormalize(name) {
  return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  if (typeof name !== "string") {
    logger8.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
var logger8, Zeros;
var init_namehash = __esm({
  "node_modules/@ethersproject/hash/lib.esm/namehash.js"() {
    init_shim();
    init_lib2();
    init_lib10();
    init_lib9();
    init_lib();
    init_version7();
    init_lib11();
    logger8 = new Logger(version9);
    Zeros = new Uint8Array(32);
    Zeros.fill(0);
  }
});

// node_modules/@ethersproject/hash/lib.esm/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var messagePrefix;
var init_message = __esm({
  "node_modules/@ethersproject/hash/lib.esm/message.js"() {
    init_shim();
    init_lib2();
    init_lib9();
    init_lib10();
    messagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version10;
var init_version8 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    init_shim();
    version10 = "rlp/5.7.0";
  }
});

// node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports9 = {};
__export(lib_exports9, {
  decode: () => decode2,
  encode: () => encode2
});
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger9.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode2(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger9.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger9.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger9.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode2(data) {
  const bytes = arrayify(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger9.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
var logger9;
var init_lib12 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib();
    init_version8();
    logger9 = new Logger(version10);
  }
});

// node_modules/@ethersproject/address/lib.esm/_version.js
var version11;
var init_version9 = __esm({
  "node_modules/@ethersproject/address/lib.esm/_version.js"() {
    init_shim();
    version11 = "address/5.7.0";
  }
});

// node_modules/@ethersproject/address/lib.esm/index.js
var lib_exports10 = {};
__export(lib_exports10, {
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  isAddress: () => isAddress
});
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger10.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger10.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger10.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger10.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger10.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger10.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode2([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger10.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger10.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
var logger10, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib13 = __esm({
  "node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib3();
    init_lib9();
    init_lib12();
    init_lib();
    init_version9();
    logger10 = new Logger(version11);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i2 = 0; i2 < 10; i2++) {
      ibanLookup[String(i2)] = String(i2);
    }
    for (let i2 = 0; i2 < 26; i2++) {
      ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger11.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger11.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2562.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v = BigNumber.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger11.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger11.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger11.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
var __awaiter3, logger11, padding, NegativeOne3, Zero3, One2, MaxUint2562, hexTrue, hexFalse, domainFieldTypes, domainFieldNames, domainChecks, TypedDataEncoder;
var init_typed_data = __esm({
  "node_modules/@ethersproject/hash/lib.esm/typed-data.js"() {
    init_shim();
    init_lib13();
    init_lib3();
    init_lib2();
    init_lib9();
    init_lib4();
    init_lib();
    init_version7();
    init_id();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger11 = new Logger(version9);
    padding = new Uint8Array(32);
    padding.fill(0);
    NegativeOne3 = BigNumber.from(-1);
    Zero3 = BigNumber.from(0);
    One2 = BigNumber.from(1);
    MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    hexTrue = hexZeroPad(One2.toHexString(), 32);
    hexFalse = hexZeroPad(Zero3.toHexString(), 32);
    domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger11.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return getAddress(value).toLowerCase();
        } catch (error) {
        }
        return logger11.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          const bytes = arrayify(value);
          if (bytes.length !== 32) {
            throw new Error("bad length");
          }
          return hexlify(bytes);
        } catch (error) {
        }
        return logger11.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
      }
    };
    TypedDataEncoder = class _TypedDataEncoder {
      constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        const links = {};
        const parents = {};
        const subtypes = {};
        Object.keys(types).forEach((type) => {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        for (const name in types) {
          const uniqueNames = {};
          types[name].forEach((field) => {
            if (uniqueNames[field.name]) {
              logger11.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
            }
            uniqueNames[field.name] = true;
            const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name) {
              logger11.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
            }
            const encoder = getBaseEncoder(baseType);
            if (encoder) {
              return;
            }
            if (!parents[baseType]) {
              logger11.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
            }
            parents[baseType].push(name);
            links[name][baseType] = true;
          });
        }
        const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
        if (primaryTypes.length === 0) {
          logger11.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger11.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger11.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach((child) => {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach((subtype) => {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (const name in subtypes) {
          const st = Object.keys(subtypes[name]);
          st.sort();
          this._types[name] = encodeType(name, types[name]) + st.map((t2) => encodeType(t2, types[t2])).join("");
        }
      }
      getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
          encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
      }
      _getEncoder(type) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return encoder;
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const subEncoder = this.getEncoder(subtype);
          const length = parseInt(match[3]);
          return (value) => {
            if (length >= 0 && value.length !== length) {
              logger11.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            let result = value.map(subEncoder);
            if (this._types[subtype]) {
              result = result.map(keccak256);
            }
            return keccak256(hexConcat(result));
          };
        }
        const fields = this.types[type];
        if (fields) {
          const encodedType = id(this._types[type]);
          return (value) => {
            const values = fields.map(({ name, type: type2 }) => {
              const result = this.getEncoder(type2)(value[name]);
              if (this._types[type2]) {
                return keccak256(result);
              }
              return result;
            });
            values.unshift(encodedType);
            return hexConcat(values);
          };
        }
        return logger11.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      encodeType(name) {
        const result = this._types[name];
        if (!result) {
          logger11.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
      }
      encodeData(type, value) {
        return this.getEncoder(type)(value);
      }
      hashStruct(name, value) {
        return keccak256(this.encodeData(name, value));
      }
      encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      _visit(type, value, callback) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          const subtype = match[1];
          const length = parseInt(match[3]);
          if (length >= 0 && value.length !== length) {
            logger11.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          return value.map((v) => this._visit(subtype, v, callback));
        }
        const fields = this.types[type];
        if (fields) {
          return fields.reduce((accum, { name, type: type2 }) => {
            accum[name] = this._visit(type2, value[name], callback);
            return accum;
          }, {});
        }
        return logger11.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      static from(types) {
        return new _TypedDataEncoder(types);
      }
      static getPrimaryType(types) {
        return _TypedDataEncoder.from(types).primaryType;
      }
      static hashStruct(name, types, value) {
        return _TypedDataEncoder.from(types).hashStruct(name, value);
      }
      static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
          const type = domainFieldTypes[name];
          if (!type) {
            logger11.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
          }
          domainFields.push({ name, type });
        }
        domainFields.sort((a2, b) => {
          return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b.name);
        });
        return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      }
      static encode(domain, types, value) {
        return hexConcat([
          "0x1901",
          _TypedDataEncoder.hashDomain(domain),
          _TypedDataEncoder.from(types).hash(value)
        ]);
      }
      static hash(domain, types, value) {
        return keccak256(_TypedDataEncoder.encode(domain, types, value));
      }
      // Replaces all address types with ENS names with their looked up address
      static resolveNames(domain, types, value, resolveName2) {
        return __awaiter3(this, void 0, void 0, function* () {
          domain = shallowCopy(domain);
          const ensCache = {};
          if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
          }
          const encoder = _TypedDataEncoder.from(types);
          encoder.visit(value, (type, value2) => {
            if (type === "address" && !isHexString(value2, 20)) {
              ensCache[value2] = "0x";
            }
            return value2;
          });
          for (const name in ensCache) {
            ensCache[name] = yield resolveName2(name);
          }
          if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
          }
          value = encoder.visit(value, (type, value2) => {
            if (type === "address" && ensCache[value2]) {
              return ensCache[value2];
            }
            return value2;
          });
          return { domain, value };
        });
      }
      static getPayload(domain, types, value) {
        _TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
          const value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value2);
          domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = _TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
          logger11.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, (type, value2) => {
            if (type.match(/^bytes(\d*)/)) {
              return hexlify(arrayify(value2));
            }
            if (type.match(/^u?int/)) {
              return BigNumber.from(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                if (typeof value2 !== "string") {
                  logger11.throwArgumentError(`invalid string`, "value", value2);
                }
                return value2;
            }
            return logger11.throwArgumentError("unsupported type", "type", type);
          })
        };
      }
    };
  }
});

// node_modules/@ethersproject/hash/lib.esm/index.js
var lib_exports11 = {};
__export(lib_exports11, {
  _TypedDataEncoder: () => TypedDataEncoder,
  dnsEncode: () => dnsEncode,
  ensNormalize: () => ensNormalize,
  hashMessage: () => hashMessage,
  id: () => id,
  isValidName: () => isValidName,
  messagePrefix: () => messagePrefix,
  namehash: () => namehash
});
var init_lib14 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_id();
    init_namehash();
    init_message();
    init_namehash();
    init_typed_data();
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module2) {
    init_shim();
    module2.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual2(l2, r3, msg) {
      if (l2 != r3)
        throw new Error(msg || "Assertion failed: " + l2 + " != " + r3);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    init_shim();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    init_shim();
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e2) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    init_shim();
    var assert2 = require_minimalistic_assert();
    var inherits = require_inherits();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296) {
        return false;
      }
      if (i2 < 0 || i2 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c = msg.charCodeAt(i2);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i2)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else {
        for (i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports.toHex = toHex2;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++) {
        var w = msg[i2];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i2 = 0, k = start; i2 < res.length; i2++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i2] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
        var m = msg[i2];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a2, b) {
      return a2 + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a2, b, c) {
      return a2 + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a2, b, c, d) {
      return a2 + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a2, b, c, d, e2) {
      return a2 + b + c + d + e2 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r3 = al << 32 - num | ah >>> num;
      return r3 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r3 = ah << 32 - num | al >>> num;
      return r3 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r3 = ah << 32 - num | al >>> num;
      return r3 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r3 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r3, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r3, this.endian);
        for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i2 = 1; i2 < k; i2++)
        res[i2] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len & 255;
      } else {
        res[i2++] = len & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        for (t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s2, x, y, z) {
      if (s2 === 0)
        return ch32(x, y, z);
      if (s2 === 1 || s2 === 3)
        return p32(x, y, z);
      if (s2 === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W[i2] = msg[start + i2];
      for (; i2 < W.length; i2++)
        W[i2] = rotl32(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
      var a2 = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e2 = this.h[4];
      for (i2 = 0; i2 < W.length; i2++) {
        var s2 = ~~(i2 / 20);
        var t2 = sum32_5(rotl32(a2, 5), ft_1(s2, b, c, d), e2, W[i2], sha1_K[s2]);
        e2 = d;
        d = c;
        c = rotl32(b, 30);
        b = a2;
        a2 = t2;
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e2);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W[i2] = msg[start + i2];
      for (; i2 < W.length; i2++)
        W[i2] = sum32_4(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
      var a2 = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e2 = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert2(this.k.length === W.length);
      for (i2 = 0; i2 < W.length; i2++) {
        var T1 = sum32_5(h, s1_256(e2), ch32(e2, f, g), this.k[i2], W[i2]);
        var T2 = sum32(s0_256(a2), maj32(a2, b, c));
        h = g;
        g = f;
        f = e2;
        e2 = sum32(d, T1);
        d = c;
        c = b;
        b = a2;
        a2 = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i2 = 0; i2 < 32; i2++)
        W[i2] = msg[start + i2];
      for (; i2 < W.length; i2 += 2) {
        var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]);
        var c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]);
        var c1_hi = W[i2 - 14];
        var c1_lo = W[i2 - 13];
        var c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]);
        var c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]);
        var c3_hi = W[i2 - 32];
        var c3_lo = W[i2 - 31];
        W[i2] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i2 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W.length);
      for (var i2 = 0; i2 < W.length; i2 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i2];
        var c3_lo = this.k[i2 + 1];
        var c4_hi = W[i2];
        var c4_lo = W[i2 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r3 = xh & yh ^ ~xh & zh;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r3 = xl & yl ^ ~xl & zl;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r3 = xh & yh ^ xh & zh ^ yh & zh;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r3 = xl & yl ^ xl & zl ^ yl & zl;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r3 = c0_hi ^ c1_hi ^ c2_hi;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r3 = c0_lo ^ c1_lo ^ c2_lo;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r3 = c0_hi ^ c1_hi ^ c2_hi;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r3 = c0_lo ^ c1_lo ^ c2_lo;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r3 = c0_hi ^ c1_hi ^ c2_hi;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r3 = c0_lo ^ c1_lo ^ c2_lo;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r3 = c0_hi ^ c1_hi ^ c2_hi;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r3 = c0_lo ^ c1_lo ^ c2_lo;
      if (r3 < 0)
        r3 += 4294967296;
      return r3;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    init_shim();
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update2(msg, start) {
      var A2 = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D3 = this.h[3];
      var E = this.h[4];
      var Ah = A2;
      var Bh = B;
      var Ch2 = C;
      var Dh = D3;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A2, f(j, B, C, D3), msg[r3[j] + start], K2(j)),
            s2[j]
          ),
          E
        );
        A2 = E;
        E = D3;
        D3 = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch2, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch2, 10);
        Ch2 = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D3, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A2, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch2);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K2(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r3 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s2 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash3, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key2, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init3(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert2(key2.length <= this.blockSize);
      for (var i2 = key2.length; i2 < this.blockSize; i2++)
        key2.push(0);
      for (i2 = 0; i2 < key2.length; i2++)
        key2[i2] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i2 = 0; i2 < key2.length; i2++)
        key2[i2] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    init_shim();
    var hash3 = exports;
    hash3.utils = require_utils();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
var init_types = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/types.js"() {
    init_shim();
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm || (SupportedAlgorithm = {}));
  }
});

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version12;
var init_version10 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/_version.js"() {
    init_shim();
    version12 = "sha2/5.7.0";
  }
});

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
function ripemd160(data) {
  return "0x" + import_hash.default.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256(data) {
  return "0x" + import_hash.default.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + import_hash.default.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger12.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash.default.hmac(import_hash.default[algorithm], arrayify(key2)).update(arrayify(data)).digest("hex");
}
var import_hash, logger12;
var init_sha2 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/sha2.js"() {
    "use strict";
    init_shim();
    import_hash = __toESM(require_hash());
    init_lib2();
    init_types();
    init_lib();
    init_version10();
    logger12 = new Logger(version12);
  }
});

// node_modules/@ethersproject/sha2/lib.esm/index.js
var lib_exports12 = {};
__export(lib_exports12, {
  SupportedAlgorithm: () => SupportedAlgorithm,
  computeHmac: () => computeHmac,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_lib15 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/index.js"() {
    init_shim();
    init_sha2();
    init_types();
  }
});

// node_modules/@ethersproject/web/lib.esm/_version.js
var version13;
var init_version11 = __esm({
  "node_modules/@ethersproject/web/lib.esm/_version.js"() {
    init_shim();
    version13 = "web/5.7.1";
  }
});

// node_modules/@ethersproject/web/lib.esm/geturl.js
function getUrl(href, options) {
  return __awaiter4(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter4;
var init_geturl = __esm({
  "node_modules/@ethersproject/web/lib.esm/geturl.js"() {
    "use strict";
    init_shim();
    init_lib2();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  }
});

// node_modules/@ethersproject/web/lib.esm/index.js
var lib_exports13 = {};
__export(lib_exports13, {
  _fetchData: () => _fetchData,
  fetchJson: () => fetchJson,
  poll: () => poll
});
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger13.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger13.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger13.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger13.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger13.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger13.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter5(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger13.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger13.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger13.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger13.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger13.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var __awaiter5, logger13;
var init_lib16 = __esm({
  "node_modules/@ethersproject/web/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib6();
    init_lib2();
    init_lib4();
    init_lib10();
    init_lib();
    init_version11();
    init_geturl();
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger13 = new Logger(version13);
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module2) {
    "use strict";
    init_shim();
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0)
        throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i2 = 0; i2 < prefix.length; ++i2) {
        var c = prefix.charCodeAt(i2);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i2 = 0; i2 < prefix.length; ++i2) {
        var v = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode6(prefix, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i2 = 0; i2 < words2.length; ++i2) {
        var x2 = words2[i2];
        if (x2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i2 = 0; i2 < 6; ++i2) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i2 = 0; i2 < 6; ++i2) {
        var v = chk >> (5 - i2) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i2 = 0; i2 < wordChars.length; ++i2) {
        var c = wordChars.charAt(i2);
        var v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i2 + 6 >= wordChars.length)
          continue;
        words2.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words2 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode6(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i2 = 0; i2 < data.length; ++i2) {
        value = value << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode: decode6,
      encode: encode6,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/signing-key/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@ethersproject/signing-key/node_modules/bn.js/lib/bn.js"(exports, module2) {
    init_shim();
    (function(module3, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base2, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = __require("buffer").Buffer;
        }
      } catch (e2) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base2, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
            w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w = parseHexByte(number, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r3 = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c = str.charCodeAt(i2) - 48;
          r3 *= mul3;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul3, "Invalid character");
          r3 += b;
        }
        return r3;
      }
      BN3.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base2);
          for (i2 = 0; i2 < mod; i2++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r3 = new BN3(null);
        this.copy(r3);
        return r3;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e2) {
          BN3.prototype.inspect = inspect4;
        }
      } else {
        BN3.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString2(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r3 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN3.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r3 = 0;
          if (t2 >= 4096) {
            r3 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r3 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r3 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r3 += 2;
            t2 >>>= 2;
          }
          return r3 + t2;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w;
        var r3 = 0;
        if ((t2 & 8191) === 0) {
          r3 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r3 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r3 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r3 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r3 += b;
          if (b !== 26)
            break;
        }
        return r3;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a2;
        var b;
        if (this.length > num.length) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a2, b;
        if (this.length > num.length) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r3 = (a2.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN3.prototype.add = function add5(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b;
        if (cmp > 0) {
          a2 = this;
          b = num;
        } else {
          a2 = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r3 = (a2.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r3 = a2 * b;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j | 0;
            a2 = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r3 = a2 * b + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b = num.words;
        var o2 = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c !== 0) {
          o2[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i2 = k - j;
            var a2 = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r3 = a2 * b;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l2 = BN3.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t2[i2] = this.revBin(i2, l2, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x, l2, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x & 1) << l2 - i2 - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p = 0; p < N2; p += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s2];
              var io = itws[p + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s2] = re - ro;
              itws[p + j + s2] = ie - io;
              if (j !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N2 = Math.max(m, n2) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i2;
        if (r3 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r3;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h -= s2;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q = 1 << r3;
        if (this.length <= s2)
          return false;
        var w = this.words[s2];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a2.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a2.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i2 = 0; i2 < q.length; i2++) {
            q.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a2 = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a2.words[b.length + j] | 0) * 67108864 + (a2.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b, qj, j);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b, 1, j);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a2._strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a2
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A2 = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D3 = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B.isOdd()) {
                A2.iadd(yp);
                B.isub(xp);
              }
              A2.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D3.isOdd()) {
                C.iadd(yp);
                D3.isub(xp);
              }
              C.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A2.isub(C);
            B.isub(D3);
          } else {
            y.isub(x);
            C.isub(A2);
            D3.isub(B);
          }
        }
        return {
          a: C,
          b: D3,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a2 = this;
        var b = p.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b.clone();
        while (a2.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b) >= 0) {
            a2.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b = num.clone();
        a2.negative = 0;
        b.negative = 0;
        for (var shift = 0; a2.isEven() && b.isEven(); shift++) {
          a2.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r3 = a2.cmp(b);
          if (r3 < 0) {
            var t2 = a2;
            a2 = b;
            b = t2;
          } else if (r3 === 0 || b.cmpn(1) === 0) {
            break;
          }
          a2.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a2 === b)
            continue;
          if (a2 < b) {
            res = -1;
          } else if (a2 > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b) {
        assert2((a2.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        move(a2, a2.umod(this.m)._forceRed(this));
        return a2;
      };
      Red.prototype.neg = function neg3(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add5(a2, b) {
        this._verify2(a2, b);
        var res = a2.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b) {
        this._verify2(a2, b);
        var res = a2.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b) {
        this._verify2(a2, b);
        var res = a2.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b) {
        this._verify2(a2, b);
        var res = a2.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b) {
        this._verify2(a2, b);
        return this.imod(a2.imul(b));
      };
      Red.prototype.mul = function mul3(a2, b) {
        this._verify2(a2, b);
        return this.imod(a2.mul(b));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r3 = this.pow(a2, q.addn(1).iushrn(1));
        var t2 = this.pow(a2, q);
        var m = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m);
          var b = this.pow(c, new BN3(1).iushln(m - i2 - 1));
          r3 = r3.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m = i2;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a2, b) {
        if (a2.isZero() || b.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a2, b) {
        if (a2.isZero() || b.isZero())
          return new BN3(0)._forceRed(this);
        var t2 = a2.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module2.path : base2);
    }
  }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    this.z = new import_bn2.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var import_bn2, import_hash2, minimalisticAssert, utils_1, utils_1$1, getNAF, getJSF, assert$1, base, inherits_browser, assert$2, short_1, curve_1, curves_1, hmacDrbg, assert$3, key, assert$4, signature, rand, assert$5, ec, elliptic_1, EC$1;
var init_elliptic = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/elliptic.js"() {
    init_shim();
    import_bn2 = __toESM(require_bn2());
    import_hash2 = __toESM(require_hash());
    minimalisticAssert = assert;
    assert.equal = function assertEqual(l2, r3, msg) {
      if (l2 != r3)
        throw new Error(msg || "Assertion failed: " + l2 + " != " + r3);
    };
    utils_1 = createCommonjsModule(function(module2, exports) {
      "use strict";
      var utils = exports;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i2 = 0; i2 < msg.length; i2++)
            res[i2] = msg[i2] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        } else {
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c = msg.charCodeAt(i2);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i2 = 0; i2 < msg.length; i2++)
          res += zero2(msg[i2].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode6(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    });
    utils_1$1 = createCommonjsModule(function(module2, exports) {
      "use strict";
      var utils = exports;
      utils.assert = minimalisticAssert;
      utils.toArray = utils_1.toArray;
      utils.zero2 = utils_1.zero2;
      utils.toHex = utils_1.toHex;
      utils.encode = utils_1.encode;
      function getNAF2(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i2 = 0; i2 < naf.length; i2++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i2] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF2;
      function getJSF2(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF2;
      function cachedProperty(obj, name, computer) {
        var key2 = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new import_bn2.default(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    });
    getNAF = utils_1$1.getNAF;
    getJSF = utils_1$1.getJSF;
    assert$1 = utils_1$1.assert;
    base = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert$1(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I2 /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l2 = j + doubles.step - 1; l2 >= j; l2--)
          nafW = (nafW << 1) + naf[l2];
        repr.push(nafW);
      }
      var a2 = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i2 = I2; i2 > 0; i2--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i2)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i2)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a2 = a2.add(b);
      }
      return a2.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1; i2 >= 0; i2--) {
        for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
          l2++;
        if (i2 >= 0)
          l2++;
        acc = acc.dblp(l2);
        if (i2 < 0)
          break;
        var z = naf[i2];
        assert$1(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i2;
      var j;
      var p;
      for (i2 = 0; i2 < len; i2++) {
        p = points[i2];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd;
        wnd[i2] = nafPoints.points;
      }
      for (i2 = len - 1; i2 >= 1; i2 -= 2) {
        var a2 = i2 - 1;
        var b = i2;
        if (wndWidth[a2] !== 1 || wndWidth[b] !== 1) {
          naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a2].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a2],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a2].y.cmp(points[b].y) === 0) {
          comb[1] = points[a2].add(points[b]);
          comb[2] = points[a2].toJ().mixedAdd(points[b].neg());
        } else if (points[a2].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a2].toJ().mixedAdd(points[b]);
          comb[2] = points[a2].add(points[b].neg());
        } else {
          comb[1] = points[a2].toJ().mixedAdd(points[b]);
          comb[2] = points[a2].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a2], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a2] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a2][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a2] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i2 = max; i2 >= 0; i2--) {
        var k = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i2] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i2--;
        }
        if (i2 >= 0)
          k++;
        acc = acc.dblp(k);
        if (i2 < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i2 = 0; i2 < len; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils_1$1.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert$1(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert$1(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode3(enc, compact) {
      return utils_1$1.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i2 = 0; i2 < power; i2 += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl3 = max === 1 ? null : this.dbl();
      for (var i2 = 1; i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r3 = this;
      for (var i2 = 0; i2 < k; i2++)
        r3 = r3.dbl();
      return r3;
    };
    inherits_browser = createCommonjsModule(function(module2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    });
    assert$2 = utils_1$1.assert;
    inherits_browser(ShortCurve, base);
    short_1 = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new import_bn2.default(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new import_bn2.default(vec.a, 16),
            b: new import_bn2.default(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : import_bn2.default.mont(num);
      var tinv = new import_bn2.default(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l2 = ntinv.redSub(s2).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new import_bn2.default(1);
      var y1 = new import_bn2.default(0);
      var x2 = new import_bn2.default(0);
      var y2 = new import_bn2.default(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i2 = 0;
      var r3;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r3 = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x;
        } else if (a1 && ++i2 === 2) {
          break;
        }
        prevR = r3;
        v = u;
        u = r3;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r3.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new import_bn2.default(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate3(point3) {
      if (point3.inf)
        return true;
      var x = point3.x;
      var y = point3.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i2 = 0; i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]);
        var p = points[i2];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i2 * 2] = p;
        npoints[i2 * 2 + 1] = beta;
        ncoeffs[i2 * 2] = split.k1;
        ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j = 0; j < i2 * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    inherits_browser(Point, base.BasePoint);
    ShortCurve.prototype.point = function point2(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta2() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a2 = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new import_bn2.default(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq2(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    inherits_browser(JPoint, base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg2() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add2(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r3 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r3.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r3.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r3 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r3.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r3.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp2(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i2 = 0; i2 < pow; i2++)
          r3 = r3.dbl();
        return r3;
      }
      var a2 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i2 = 0; i2 < pow; i2++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl2() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t2 = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t2;
        ny = m.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a2 = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a2).redISub(c);
        d = d.redIAdd(d);
        var e2 = a2.redAdd(a2).redIAdd(a2);
        var f = e2.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e2.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t2 = m.redSqr().redISub(s2).redISub(s2);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a2 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2);
      e2 = e2.redAdd(e2).redIAdd(e2);
      e2 = e2.redISub(mm);
      var ee = e2.redSqr();
      var t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      var u = m.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e2.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul2(k, kbase) {
      k = new import_bn2.default(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq3(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t2 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity2() {
      return this.z.cmpn(0) === 0;
    };
    curve_1 = createCommonjsModule(function(module2, exports) {
      "use strict";
      var curve = exports;
      curve.base = base;
      curve.short = short_1;
      curve.mont = /*RicMoo:ethers:require(./mont)*/
      null;
      curve.edwards = /*RicMoo:ethers:require(./edwards)*/
      null;
    });
    curves_1 = createCommonjsModule(function(module2, exports) {
      "use strict";
      var curves = exports;
      var assert2 = utils_1$1.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve_1.short(options);
        else if (options.type === "edwards")
          this.curve = new curve_1.edwards(options);
        else
          this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert2(this.g.validate(), "Invalid curve");
        assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve
            });
            return curve;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: import_hash2.default.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: import_hash2.default.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
        null.crash();
      } catch (e2) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: import_hash2.default.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    });
    hmacDrbg = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i2 = 0; i2 < this.V.length; i2++) {
        this.K[i2] = 0;
        this.V[i2] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new import_hash2.default.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add5, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add5;
        add5 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils_1.toArray(entropy, entropyEnc);
      add5 = utils_1.toArray(add5, addEnc);
      minimalisticAssert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add5 || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add5, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add5;
        add5 = enc;
        enc = null;
      }
      if (add5) {
        add5 = utils_1.toArray(add5, addEnc || "hex");
        this._update(add5);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add5);
      this._reseed++;
      return utils_1.encode(res, enc);
    };
    assert$3 = utils_1$1.assert;
    key = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate4() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new import_bn2.default(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert$3(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert$3(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert$3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair.prototype.inspect = function inspect3() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    assert$4 = utils_1$1.assert;
    signature = Signature;
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils_1$1.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r3 = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s2 = data.slice(p.place, slen + p.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new import_bn2.default(r3);
      this.s = new import_bn2.default(s2);
      this.recoveryParam = null;
      return true;
    };
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils_1$1.encode(res, enc);
    };
    rand = /*RicMoo:ethers:require(brorand)*/
    function() {
      throw new Error("unsupported");
    };
    assert$5 = utils_1$1.assert;
    ec = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new key(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return key.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return key.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new import_bn2.default(2));
      for (; ; ) {
        var priv = new import_bn2.default(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new import_bn2.default(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k.invm(this.n).mul(r3.mul(key2.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature$1 = new signature(signature$1, "hex");
      var r3 = signature$1.r;
      var s2 = signature$1.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r3).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key2.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r3) === 0;
      }
      p = this.g.jmulAdd(u1, key2.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
      assert$5((3 & j) === j, "The recovery param is more than two bits");
      signature$1 = new signature(signature$1, enc);
      var n2 = this.n;
      var e2 = new import_bn2.default(msg);
      var r3 = signature$1.r;
      var s2 = signature$1.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature$1.r.invm(n2);
      var s1 = n2.sub(e2).mul(rInv).umod(n2);
      var s22 = s2.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q, enc) {
      signature$1 = new signature(signature$1, enc);
      if (signature$1.recoveryParam !== null)
        return signature$1.recoveryParam;
      for (var i2 = 0; i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature$1, i2);
        } catch (e3) {
          continue;
        }
        if (Qprime.eq(Q))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    elliptic_1 = createCommonjsModule(function(module2, exports) {
      "use strict";
      var elliptic = exports;
      elliptic.version = /*RicMoo:ethers*/
      { version: "6.5.4" }.version;
      elliptic.utils = utils_1$1;
      elliptic.rand = /*RicMoo:ethers:require(brorand)*/
      function() {
        throw new Error("unsupported");
      };
      elliptic.curve = curve_1;
      elliptic.curves = curves_1;
      elliptic.ec = ec;
      elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
      null;
    });
    EC$1 = elliptic_1.ec;
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version15;
var init_version12 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/_version.js"() {
    init_shim();
    version15 = "signing-key/5.7.0";
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/index.js
var lib_exports14 = {};
__export(lib_exports14, {
  SigningKey: () => SigningKey,
  computePublicKey: () => computePublicKey,
  recoverPublicKey: () => recoverPublicKey
});
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
function recoverPublicKey(digest, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger14.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var logger14, _curve, SigningKey;
var init_lib17 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_elliptic();
    init_lib2();
    init_lib4();
    init_lib();
    init_version12();
    logger14 = new Logger(version15);
    _curve = null;
    SigningKey = class {
      constructor(privateKey) {
        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        if (hexDataLength(this.privateKey) !== 32) {
          logger14.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
      }
      _addPoint(other) {
        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      }
      signDigest(digest) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const digestBytes = arrayify(digest);
        if (digestBytes.length !== 32) {
          logger14.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature2 = keyPair2.sign(digestBytes, { canonical: true });
        return splitSignature({
          recoveryParam: signature2.recoveryParam,
          r: hexZeroPad("0x" + signature2.r.toString(16), 32),
          s: hexZeroPad("0x" + signature2.s.toString(16), 32)
        });
      }
      computeSharedSecret(otherKey) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
        return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
      }
      static isSigningKey(value) {
        return !!(value && value._isSigningKey);
      }
    };
  }
});

// node_modules/@ethersproject/transactions/lib.esm/_version.js
var version16;
var init_version13 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/_version.js"() {
    init_shim();
    version16 = "transactions/5.7.0";
  }
});

// node_modules/@ethersproject/transactions/lib.esm/index.js
var lib_exports15 = {};
__export(lib_exports15, {
  TransactionTypes: () => TransactionTypes,
  accessListify: () => accessListify,
  computeAddress: () => computeAddress,
  parse: () => parse,
  recoverAddress: () => recoverAddress,
  serialize: () => serialize
});
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest), signature2));
}
function formatNumber(value, name) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger15.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger15.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger15.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b) => a2.address.localeCompare(b.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger15.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode2(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode2(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger15.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger15.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger15.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode2(raw);
  }
  const sig = splitSignature(signature2);
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v) {
      logger15.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v) {
    logger15.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode2(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger15.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger15.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger15.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode2(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger15.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode2(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger15.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode2(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger15.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak256(encode2(raw));
    try {
      tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger15.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
var logger15, TransactionTypes, transactionFields, allowedTransactionKeys;
var init_lib18 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib13();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib9();
    init_lib4();
    init_lib12();
    init_lib17();
    init_lib();
    init_version13();
    logger15 = new Logger(version16);
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes || (TransactionTypes = {}));
    transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    allowedTransactionKeys = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version17;
var init_version14 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/_version.js"() {
    init_shim();
    version17 = "abstract-signer/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter7, logger18, allowedTransactionKeys2, forwardErrors, Signer, VoidSigner;
var init_lib19 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib4();
    init_lib();
    init_version14();
    __awaiter7 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger18 = new Logger(version17);
    allowedTransactionKeys2 = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    forwardErrors = [
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    Signer = class _Signer {
      ///////////////////
      // Sub-classes MUST call super
      constructor() {
        logger18.checkAbstract(new.target, _Signer);
        defineReadOnly(this, "_isSigner", true);
      }
      ///////////////////
      // Sub-classes MAY override these
      getBalance(blockTag) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("getBalance");
          return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
      }
      getTransactionCount(blockTag) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("getTransactionCount");
          return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
      }
      // Populates "from" if unspecified, and estimates the gas for the transaction
      estimateGas(transaction) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("estimateGas");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.estimateGas(tx);
        });
      }
      // Populates "from" if unspecified, and calls with the transaction
      call(transaction, blockTag) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("call");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.call(tx, blockTag);
        });
      }
      // Populates all fields in a transaction, signs it and sends it to the network
      sendTransaction(transaction) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("sendTransaction");
          const tx = yield this.populateTransaction(transaction);
          const signedTx = yield this.signTransaction(tx);
          return yield this.provider.sendTransaction(signedTx);
        });
      }
      getChainId() {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("getChainId");
          const network = yield this.provider.getNetwork();
          return network.chainId;
        });
      }
      getGasPrice() {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("getGasPrice");
          return yield this.provider.getGasPrice();
        });
      }
      getFeeData() {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("getFeeData");
          return yield this.provider.getFeeData();
        });
      }
      resolveName(name) {
        return __awaiter7(this, void 0, void 0, function* () {
          this._checkProvider("resolveName");
          return yield this.provider.resolveName(name);
        });
      }
      // Checks a transaction does not contain invalid keys and if
      // no "from" is provided, populates it.
      // - does NOT require a provider
      // - adds "from" is not present
      // - returns a COPY (safe to mutate the result)
      // By default called from: (overriding these prevents it)
      //   - call
      //   - estimateGas
      //   - populateTransaction (and therefor sendTransaction)
      checkTransaction(transaction) {
        for (const key2 in transaction) {
          if (allowedTransactionKeys2.indexOf(key2) === -1) {
            logger18.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
          }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then((result) => {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger18.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      }
      // Populates ALL keys for a transaction and checks that "from" matches
      // this Signer. Should be used by sendTransaction but NOT by signTransaction.
      // By default called from: (overriding these prevents it)
      //   - sendTransaction
      //
      // Notes:
      //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
      populateTransaction(transaction) {
        return __awaiter7(this, void 0, void 0, function* () {
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to) => __awaiter7(this, void 0, void 0, function* () {
              if (to == null) {
                return null;
              }
              const address = yield this.resolveName(to);
              if (address == null) {
                logger18.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
              }
              return address;
            }));
            tx.to.catch((error) => {
            });
          }
          const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
          if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
            logger18.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
          } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
            logger18.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
          }
          if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
            tx.type = 2;
          } else if (tx.type === 0 || tx.type === 1) {
            if (tx.gasPrice == null) {
              tx.gasPrice = this.getGasPrice();
            }
          } else {
            const feeData = yield this.getFeeData();
            if (tx.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                tx.type = 2;
                if (tx.gasPrice != null) {
                  const gasPrice = tx.gasPrice;
                  delete tx.gasPrice;
                  tx.maxFeePerGas = gasPrice;
                  tx.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                if (hasEip1559) {
                  logger18.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                  });
                }
                if (tx.gasPrice == null) {
                  tx.gasPrice = feeData.gasPrice;
                }
                tx.type = 0;
              } else {
                logger18.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "signer.getFeeData"
                });
              }
            } else if (tx.type === 2) {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          if (tx.nonce == null) {
            tx.nonce = this.getTransactionCount("pending");
          }
          if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
              if (forwardErrors.indexOf(error.code) >= 0) {
                throw error;
              }
              return logger18.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                error,
                tx
              });
            });
          }
          if (tx.chainId == null) {
            tx.chainId = this.getChainId();
          } else {
            tx.chainId = Promise.all([
              Promise.resolve(tx.chainId),
              this.getChainId()
            ]).then((results) => {
              if (results[1] !== 0 && results[0] !== results[1]) {
                logger18.throwArgumentError("chainId address mismatch", "transaction", transaction);
              }
              return results[0];
            });
          }
          return yield resolveProperties(tx);
        });
      }
      ///////////////////
      // Sub-classes SHOULD leave these alone
      _checkProvider(operation) {
        if (!this.provider) {
          logger18.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      }
      static isSigner(value) {
        return !!(value && value._isSigner);
      }
    };
    VoidSigner = class _VoidSigner extends Signer {
      constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      _fail(message, operation) {
        return Promise.resolve().then(() => {
          logger18.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      }
      signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      }
      signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      }
      _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      }
      connect(provider) {
        return new _VoidSigner(this.address, provider);
      }
    };
  }
});

// node_modules/@ethersproject/random/lib.esm/_version.js
var version18;
var init_version15 = __esm({
  "node_modules/@ethersproject/random/lib.esm/_version.js"() {
    init_shim();
    version18 = "random/5.7.0";
  }
});

// node_modules/@ethersproject/random/lib.esm/random.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger26.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto2.getRandomValues(result);
  return arrayify(result);
}
var logger26, anyGlobal, crypto2;
var init_random = __esm({
  "node_modules/@ethersproject/random/lib.esm/random.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib();
    init_version15();
    logger26 = new Logger(version18);
    anyGlobal = getGlobal();
    crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto2 || !crypto2.getRandomValues) {
      logger26.warn("WARNING: Missing strong random number source");
      crypto2 = {
        getRandomValues: function(buffer) {
          return logger26.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
  }
});

// node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j];
    array[j] = tmp;
  }
  return array;
}
var init_shuffle = __esm({
  "node_modules/@ethersproject/random/lib.esm/shuffle.js"() {
    "use strict";
    init_shim();
  }
});

// node_modules/@ethersproject/random/lib.esm/index.js
var lib_exports16 = {};
__export(lib_exports16, {
  randomBytes: () => randomBytes,
  shuffled: () => shuffled
});
var init_lib20 = __esm({
  "node_modules/@ethersproject/random/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_random();
    init_shuffle();
  }
});

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version19;
var init_version16 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    init_shim();
    version19 = "abi/5.7.0";
  }
});

// node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger33.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i2) {
    logger33.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c = param[i2];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i2);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i2);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i2);
              }
              if (node.indexed) {
                throwError2(i2);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i2);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i2);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError2(i2);
        }
    }
  }
  if (node.parent) {
    logger33.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger33.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger33.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger33.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger33.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger33.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger33.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger33.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger33.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger33.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger33.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var logger33, _constructorGuard4, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    init_shim();
    init_lib3();
    init_lib4();
    init_lib();
    init_version16();
    logger33 = new Logger(version19);
    _constructorGuard4 = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      // Bare formatting, as is needed for computing a sighash of an event or function
      sighash: "sighash",
      // Human-Readable with Minimal spacing and without names (compact human-readable)
      minimal: "minimal",
      // Human-Readable with nice spacing, including all names
      full: "full",
      // JSON-format a la Solidity
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class _ParamType {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard4) {
          logger33.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: _ParamType.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      // Format the parameter fragment
      //   - sighash: "(uint256,address)"
      //   - minimal: "tuple(uint256,address) indexed"
      //   - full:    "tuple(uint256 foo, address bar) indexed baz"
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger33.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value, allowIndexed) {
        if (typeof value === "string") {
          return _ParamType.fromString(value, allowIndexed);
        }
        return _ParamType.fromObject(value);
      }
      static fromObject(value) {
        if (_ParamType.isParamType(value)) {
          return value;
        }
        return new _ParamType(_constructorGuard4, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(_ParamType.fromObject) : null
        });
      }
      static fromString(value, allowIndexed) {
        function ParamTypify(node) {
          return _ParamType.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
        return !!(value != null && value._isParamType);
      }
    };
    Fragment = class _Fragment {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard4) {
          logger33.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value) {
        if (_Fragment.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return _Fragment.fromString(value);
        }
        return _Fragment.fromObject(value);
      }
      static fromObject(value) {
        if (_Fragment.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "error":
            return ErrorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger33.throwArgumentError("invalid fragment object", "value", value);
      }
      static fromString(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        } else if (value.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger33.throwArgumentError("unsupported fragment", "value", value);
      }
      static isFragment(value) {
        return !!(value && value._isFragment);
      }
    };
    EventFragment = class _EventFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger33.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _EventFragment.fromString(value);
        }
        return _EventFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_EventFragment.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger33.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new _EventFragment(_constructorGuard4, params);
      }
      static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
          logger33.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger33.warn("unknown modifier: " + modifier);
          }
        });
        return _EventFragment.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      }
      static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
      }
    };
    ConstructorFragment = class _ConstructorFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger33.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger33.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _ConstructorFragment.fromString(value);
        }
        return _ConstructorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_ConstructorFragment.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger33.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
          logger33.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new _ConstructorFragment(_constructorGuard4, params);
      }
      static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger33.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return _ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
      }
    };
    FunctionFragment = class _FunctionFragment extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger33.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _FunctionFragment.fromString(value);
        }
        return _FunctionFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_FunctionFragment.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger33.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new _FunctionFragment(_constructorGuard4, params);
      }
      static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
          logger33.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger33.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger33.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return _FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
      }
    };
    ErrorFragment = class _ErrorFragment extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger33.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return _ErrorFragment.fromString(value);
        }
        return _ErrorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (_ErrorFragment.isErrorFragment(value)) {
          return value;
        }
        if (value.type !== "error") {
          logger33.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new _ErrorFragment(_constructorGuard4, params));
      }
      static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
          logger33.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(_ErrorFragment.fromObject(params));
      }
      static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
      }
    };
    regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var logger34, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib();
    init_version16();
    logger34 = new Logger(version19);
    Coder = class {
      constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value) {
        logger34.throwArgumentError(message, this.localName, value);
      }
    };
    Writer = class {
      constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return hexConcat(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      }
      appendWriter(writer) {
        return this._writeData(concat(writer._data));
      }
      // Arrayish items; padded on the right to wordSize
      writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
          bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
      }
      _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
          logger34.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
          });
        }
        if (bytes.length % this.wordSize) {
          bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
      }
      // BigNumberish items; padded on the left to wordSize
      writeValue(value) {
        return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
          this._data[offset] = this._getValue(value);
        };
      }
    };
    Reader = class _Reader {
      constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return hexlify(this._data);
      }
      get consumed() {
        return this._offset;
      }
      // The default Coerce function
      static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      }
      coerce(name, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name, value);
        }
        return _Reader.coerce(name, value);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger34.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new _Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length);
      }
      readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder;
var init_address = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    init_shim();
    init_lib13();
    init_lib2();
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value) {
        try {
          value = getAddress(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_shim();
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger35.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger35.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger35.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger35.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value = values[i2];
    if (value instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var logger35, ArrayCoder;
var init_array = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    init_shim();
    init_lib();
    init_version16();
    init_abstract_coder();
    init_anonymous();
    logger35 = new Logger(version19);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger35.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
          if (count * 32 > reader._data.length) {
            logger35.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count
            });
          }
        }
        let coders = [];
        for (let i2 = 0; i2 < count; i2++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_shim();
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder;
var init_fixed_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_shim();
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder;
var init_number = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    init_shim();
    init_lib3();
    init_lib8();
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size, signed2, localName) {
        const name = (signed2 ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed2;
      }
      defaultValue() {
        return 0;
      }
      encode(writer, value) {
        let v = BigNumber.from(value);
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne2))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v.lt(Zero2) || v.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
      }
      decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder;
var init_string = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    init_shim();
    init_lib10();
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
      }
      decode(reader) {
        return toUtf8String(super.decode(reader));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_shim();
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
          values.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          values[name] = values[index];
        });
        return Object.freeze(values);
      }
      encode(writer, value) {
        return pack(writer, this.coders, value);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger36, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib4();
    init_lib();
    init_version16();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger36 = new Logger(version19);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class {
      constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size = parseInt(match[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger36.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new NumberCoder(size / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size = parseInt(match[1]);
          if (size === 0 || size > 32) {
            logger36.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size, param.name);
        }
        return logger36.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values) {
        if (types.length !== values.length) {
          logger36.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      }
      decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var logger37, LogDescription, TransactionDescription, ErrorDescription, Indexed, BuiltinErrors, Interface;
var init_interface = __esm({
  "node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    init_shim();
    init_lib13();
    init_lib3();
    init_lib2();
    init_lib14();
    init_lib9();
    init_lib4();
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    init_lib();
    init_version16();
    logger37 = new Logger(version19);
    LogDescription = class extends Description {
    };
    TransactionDescription = class extends Description {
    };
    ErrorDescription = class extends Description {
    };
    Indexed = class extends Description {
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    Interface = class {
      constructor(fragments) {
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger37.warn("duplicate definition - constructor");
                return;
              }
              defineReadOnly(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            case "error":
              bucket = this.errors;
              break;
            default:
              return;
          }
          let signature2 = fragment.format();
          if (bucket[signature2]) {
            logger37.warn("duplicate definition - " + signature2);
            return;
          }
          bucket[signature2] = fragment;
        });
        if (!this.deploy) {
          defineReadOnly(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        defineReadOnly(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger37.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
      }
      // Sub-classes can override these to handle other blockchains
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return getAddress(address);
      }
      static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return id(eventFragment.format());
      }
      // Find a function definition by any means necessary (unless it is ambiguous)
      getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          for (const name in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name)) {
              return this.functions[name];
            }
          }
          logger37.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f) => f.split(
            "("
            /* fix:) */
          )[0] === name);
          if (matching.length === 0) {
            logger37.throwArgumentError("no matching function", "name", name);
          } else if (matching.length > 1) {
            logger37.throwArgumentError("multiple matching functions", "name", name);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger37.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      // Find an event definition by any means necessary (unless it is ambiguous)
      getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name in this.events) {
            if (topichash === this.getEventTopic(name)) {
              return this.events[name];
            }
          }
          logger37.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f) => f.split(
            "("
            /* fix:) */
          )[0] === name);
          if (matching.length === 0) {
            logger37.throwArgumentError("no matching event", "name", name);
          } else if (matching.length > 1) {
            logger37.throwArgumentError("multiple matching events", "name", name);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger37.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      // Find a function definition by any means necessary (unless it is ambiguous)
      getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          const getSighash = getStatic(this.constructor, "getSighash");
          for (const name in this.errors) {
            const error = this.errors[name];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name];
            }
          }
          logger37.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.errors).filter((f) => f.split(
            "("
            /* fix:) */
          )[0] === name);
          if (matching.length === 0) {
            logger37.throwArgumentError("no matching error", "name", name);
          } else if (matching.length > 1) {
            logger37.throwArgumentError("multiple matching errors", "name", name);
          }
          return this.errors[matching[0]];
        }
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger37.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      // Get the sighash (the bytes4 selector) used by Solidity to identify a function
      getSighash(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_) {
              throw error;
            }
          }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
      }
      // Get the topic (the bytes32 hash) used by Solidity to identify an event
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
      }
      _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
      }
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
          logger37.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
      }
      encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return hexlify(concat([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values || [])
        ]));
      }
      // Decode the data for a function call (e.g. tx.data)
      decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger37.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
      }
      // Encode the data for a function call (e.g. tx.data)
      encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      }
      // Decode the result from a function call (e.g. from eth_call)
      decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes);
            } catch (error) {
            }
            break;
          case 4: {
            const selector = hexlify(bytes.slice(0, 4));
            const builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
              if (errorName === "Error") {
                message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
              } else if (errorName === "Panic") {
                message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
              }
            } else {
              try {
                const error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error) {
              }
            }
            break;
          }
        }
        return logger37.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          data: hexlify(data),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      }
      // Encode the result for a function call (e.g. for eth_call)
      encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
      }
      // Create the filter for the event with search criteria (e.g. for eth_filterLog)
      encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger37.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return id(value);
          } else if (param.type === "bytes") {
            return keccak256(hexlify(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          }
          if (param.type.match(/^u?int/)) {
            value = BigNumber.from(value).toHexString();
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value]);
          }
          return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
          let param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value != null) {
              logger37.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger37.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger37.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
          const value = values[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id(value));
            } else if (param.type === "bytes") {
              topics.push(keccak256(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      // Decode a filter for the event and the search criteria
      decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger37.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value = result[index];
            if (value instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                }
              });
            } else {
              result[param.name] = value;
            }
          }
        });
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          if (value instanceof Error) {
            Object.defineProperty(result, i2, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`index ${i2}`, value);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      // Given a transaction, find the matching function fragment (if any) and
      // determine all its properties and call parameters
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: BigNumber.from(tx.value || "0")
        });
      }
      // @TODO
      //parseCallResult(data: BytesLike): ??
      // Given an event log, find the matching event fragment (if any) and
      // determine all its properties and values
      parseLog(log3) {
        let fragment = this.getEvent(log3.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log3.data, log3.topics)
        });
      }
      parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      }
      /*
      static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
          if (Interface.isInterface(value)) {
              return value;
          }
          if (typeof(value) === "string") {
              return new Interface(JSON.parse(value));
          }
          return new Interface(value);
      }
      */
      static isInterface(value) {
        return !!(value && value._isInterface);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/index.js
var lib_exports18 = {};
__export(lib_exports18, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  ParamType: () => ParamType,
  TransactionDescription: () => TransactionDescription,
  checkResultErrors: () => checkResultErrors,
  defaultAbiCoder: () => defaultAbiCoder
});
var init_lib21 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_fragments();
    init_abi_coder();
    init_interface();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r3;
  let T;
  for (let i2 = 1; i2 <= l2; i2++) {
    block1[salt.length] = i2 >> 24 & 255;
    block1[salt.length + 1] = i2 >> 16 & 255;
    block1[salt.length + 2] = i2 >> 8 & 255;
    block1[salt.length + 3] = i2 & 255;
    let U = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r3 = keylen - (l2 - 1) * hLen;
    }
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      U = arrayify(computeHmac(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    const destPos = (i2 - 1) * hLen;
    const len = i2 === l2 ? r3 : hLen;
    DK.set(arrayify(T).slice(0, len), destPos);
  }
  return hexlify(DK);
}
var init_pbkdf2 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib15();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/index.js
var init_lib22 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/index.js"() {
    init_shim();
    init_pbkdf2();
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version21;
var init_version17 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/_version.js"() {
    init_shim();
    version21 = "wordlists/5.7.0";
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist, logger39, Wordlist;
var init_wordlist = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlist.js"() {
    "use strict";
    init_shim();
    init_lib14();
    init_lib4();
    init_lib();
    init_version17();
    exportWordlist = false;
    logger39 = new Logger(version21);
    Wordlist = class _Wordlist {
      constructor(locale) {
        logger39.checkAbstract(new.target, _Wordlist);
        defineReadOnly(this, "locale", locale);
      }
      // Subclasses may override this
      split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      }
      // Subclasses may override this
      join(words2) {
        return words2.join(" ");
      }
      static check(wordlist2) {
        const words2 = [];
        for (let i2 = 0; i2 < 2048; i2++) {
          const word = wordlist2.getWord(i2);
          if (i2 !== wordlist2.getWordIndex(word)) {
            return "0x";
          }
          words2.push(word);
        }
        return id(words2.join("\n") + "\n");
      }
      static register(lang, name) {
        if (!name) {
          name = lang.locale;
        }
        if (exportWordlist) {
          try {
            const anyGlobal2 = window;
            if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
              if (!anyGlobal2._ethers.wordlists[name]) {
                defineReadOnly(anyGlobal2._ethers.wordlists, name, lang);
              }
            }
          } catch (error) {
          }
        }
      }
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var words, wordlist, LangEn, langEn;
var init_lang_en = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/lang-en.js"() {
    "use strict";
    init_shim();
    init_wordlist();
    words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    wordlist = null;
    LangEn = class extends Wordlist {
      constructor() {
        super("en");
      }
      getWord(index) {
        loadWords(this);
        return wordlist[index];
      }
      getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      }
    };
    langEn = new LangEn();
    Wordlist.register(langEn);
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists;
var init_wordlists = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlists.js"() {
    "use strict";
    init_shim();
    init_lang_en();
    wordlists = {
      en: langEn
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/index.js
var init_lib23 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_wordlist();
    init_wordlists();
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version22;
var init_version18 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/_version.js"() {
    init_shim();
    version22 = "hdnode/5.7.0";
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/index.js
var lib_exports19 = {};
__export(lib_exports19, {
  HDNode: () => HDNode,
  defaultPath: () => defaultPath,
  entropyToMnemonic: () => entropyToMnemonic,
  getAccountPath: () => getAccountPath,
  isValidMnemonic: () => isValidMnemonic,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed
});
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger40.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger40.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i2 = 0; i2 < words2.length; i2++) {
    let index = wordlist2.getWordIndex(words2[i2].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger40.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}
var logger40, N, MasterSecret, HardenedBit, _constructorGuard5, defaultPath, HDNode;
var init_lib24 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib7();
    init_lib2();
    init_lib3();
    init_lib10();
    init_lib22();
    init_lib4();
    init_lib17();
    init_lib15();
    init_lib18();
    init_lib23();
    init_lib();
    init_version18();
    logger40 = new Logger(version22);
    N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    MasterSecret = toUtf8Bytes("Bitcoin seed");
    HardenedBit = 2147483648;
    _constructorGuard5 = {};
    defaultPath = "m/44'/60'/0'/0/0";
    HDNode = class _HDNode {
      /**
       *  This constructor should not be called directly.
       *
       *  Please use:
       *   - fromMnemonic
       *   - fromSeed
       */
      constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        if (constructorGuard !== _constructorGuard5) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "privateKey", signingKey.privateKey);
          defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          defineReadOnly(this, "privateKey", null);
          defineReadOnly(this, "publicKey", hexlify(publicKey));
        }
        defineReadOnly(this, "parentFingerprint", parentFingerprint);
        defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        defineReadOnly(this, "chainCode", chainCode);
        defineReadOnly(this, "index", index);
        defineReadOnly(this, "depth", depth);
        if (mnemonicOrPath == null) {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", mnemonicOrPath);
        } else {
          defineReadOnly(this, "mnemonic", mnemonicOrPath);
          defineReadOnly(this, "path", mnemonicOrPath.path);
        }
      }
      get extendedKey() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check(concat([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          hexlify(this.depth),
          this.parentFingerprint,
          hexZeroPad(hexlify(this.index), 4),
          this.chainCode,
          this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
        ]));
      }
      neuter() {
        return new _HDNode(_constructorGuard5, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      }
      _derive(index) {
        if (index > 4294967295) {
          throw new Error("invalid index - " + String(index));
        }
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data.set(arrayify(this.privateKey), 1);
          if (path) {
            path += "'";
          }
        } else {
          data.set(arrayify(this.publicKey));
        }
        for (let i2 = 24; i2 >= 0; i2 -= 8) {
          data[33 + (i2 >> 3)] = index >> 24 - i2 & 255;
        }
        const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
        const IL = I2.slice(0, 32);
        const IR = I2.slice(32);
        let ki = null;
        let Ki = null;
        if (this.privateKey) {
          ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          const ek = new SigningKey(hexlify(IL));
          Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new _HDNode(_constructorGuard5, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
      }
      derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
          components.shift();
        }
        let result = this;
        for (let i2 = 0; i2 < components.length; i2++) {
          const component = components[i2];
          if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      }
      static _fromSeed(seed, mnemonic) {
        const seedArray = arrayify(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new _HDNode(_constructorGuard5, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
      }
      static fromMnemonic(mnemonic, password, wordlist2) {
        wordlist2 = getWordlist(wordlist2);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
        return _HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist2.locale
        });
      }
      static fromSeed(seed) {
        return _HDNode._fromSeed(seed, null);
      }
      static fromExtendedKey(extendedKey) {
        const bytes = Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
          logger40.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = hexlify(bytes.slice(5, 9));
        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify(bytes.slice(13, 45));
        const key2 = bytes.slice(45, 78);
        switch (hexlify(bytes.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new _HDNode(_constructorGuard5, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key2[0] !== 0) {
              break;
            }
            return new _HDNode(_constructorGuard5, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger40.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
    };
  }
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/aes-js/index.js"(exports, module2) {
    "use strict";
    init_shim();
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i2 = 0; i2 < arrayish.length; i2++) {
          if (!checkInt(arrayish[i2]) || arrayish[i2] < 0 || arrayish[i2] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = /* @__PURE__ */ function() {
        function toBytes(text) {
          var result = [], i2 = 0;
          text = encodeURI(text);
          while (i2 < text.length) {
            var c = text.charCodeAt(i2++);
            if (c === 37) {
              result.push(parseInt(text.substr(i2, 2), 16));
              i2 += 2;
            } else {
              result.push(c);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i2 = 0;
          while (i2 < bytes.length) {
            var c = bytes[i2];
            if (c < 128) {
              result.push(String.fromCharCode(c));
              i2++;
            } else if (c > 191 && c < 224) {
              result.push(String.fromCharCode((c & 31) << 6 | bytes[i2 + 1] & 63));
              i2 += 2;
            } else {
              result.push(String.fromCharCode((c & 15) << 12 | (bytes[i2 + 1] & 63) << 6 | bytes[i2 + 2] & 63));
              i2 += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = /* @__PURE__ */ function() {
        function toBytes(text) {
          var result = [];
          for (var i2 = 0; i2 < text.length; i2 += 2) {
            result.push(parseInt(text.substr(i2, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i2 = 0; i2 < bytes.length; i2++) {
            var v = bytes[i2];
            result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i2 = 0; i2 < bytes.length; i2 += 4) {
          result.push(
            bytes[i2] << 24 | bytes[i2 + 1] << 16 | bytes[i2 + 2] << 8 | bytes[i2 + 3]
          );
        }
        return result;
      }
      var AES = function(key2) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key2, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i2 = 0; i2 <= rounds; i2++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i2 = 0; i2 < KC; i2++) {
          index = i2 >> 2;
          this._Ke[index][i2 % 4] = tk[i2];
          this._Kd[rounds - index][i2 % 4] = tk[i2];
        }
        var rconpointer = 0;
        var t2 = KC, tt;
        while (t2 < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i2 = 1; i2 < KC; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
          } else {
            for (var i2 = 1; i2 < KC / 2; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
            for (var i2 = KC / 2 + 1; i2 < KC; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
          }
          var i2 = 0, r3, c;
          while (i2 < KC && t2 < roundKeyCount) {
            r3 = t2 >> 2;
            c = t2 % 4;
            this._Ke[r3][c] = tk[i2];
            this._Kd[rounds - r3][c] = tk[i2++];
            t2++;
          }
        }
        for (var r3 = 1; r3 < rounds; r3++) {
          for (var c = 0; c < 4; c++) {
            tt = this._Kd[r3][c];
            this._Kd[r3][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a2 = [0, 0, 0, 0];
        var t2 = convertToInt32(plaintext);
        for (var i2 = 0; i2 < 4; i2++) {
          t2[i2] ^= this._Ke[0][i2];
        }
        for (var r3 = 1; r3 < rounds; r3++) {
          for (var i2 = 0; i2 < 4; i2++) {
            a2[i2] = T1[t2[i2] >> 24 & 255] ^ T2[t2[(i2 + 1) % 4] >> 16 & 255] ^ T3[t2[(i2 + 2) % 4] >> 8 & 255] ^ T4[t2[(i2 + 3) % 4] & 255] ^ this._Ke[r3][i2];
          }
          t2 = a2.slice();
        }
        var result = createArray(16), tt;
        for (var i2 = 0; i2 < 4; i2++) {
          tt = this._Ke[rounds][i2];
          result[4 * i2] = (S2[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i2 + 1] = (S2[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i2 + 2] = (S2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i2 + 3] = (S2[t2[(i2 + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a2 = [0, 0, 0, 0];
        var t2 = convertToInt32(ciphertext);
        for (var i2 = 0; i2 < 4; i2++) {
          t2[i2] ^= this._Kd[0][i2];
        }
        for (var r3 = 1; r3 < rounds; r3++) {
          for (var i2 = 0; i2 < 4; i2++) {
            a2[i2] = T5[t2[i2] >> 24 & 255] ^ T6[t2[(i2 + 3) % 4] >> 16 & 255] ^ T7[t2[(i2 + 2) % 4] >> 8 & 255] ^ T8[t2[(i2 + 1) % 4] & 255] ^ this._Kd[r3][i2];
          }
          t2 = a2.slice();
        }
        var result = createArray(16), tt;
        for (var i2 = 0; i2 < 4; i2++) {
          tt = this._Kd[rounds][i2];
          result[4 * i2] = (Si[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i2 + 1] = (Si[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i2 + 2] = (Si[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i2 + 3] = (Si[t2[(i2 + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key2) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key2);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
          copyArray(plaintext, block, 0, i2, i2 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i2);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
          copyArray(ciphertext, block, 0, i2, i2 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i2);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key2, iv2) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv2, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
          copyArray(plaintext, block, 0, i2, i2 + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i2);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
          copyArray(ciphertext, block, 0, i2, i2 + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i2 + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i2, i2 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key2, iv2, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv2, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i2 = 0; i2 < encrypted.length; i2 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i2 + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i2 = 0; i2 < plaintext.length; i2 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i2 + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key2, iv2) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv2, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i2 = 0; i2 < encrypted.length; i2++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i2] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i2 = 15; i2 >= 0; i2--) {
          if (this._counter[i2] === 255) {
            this._counter[i2] = 0;
          } else {
            this._counter[i2]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key2, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i2 = 0; i2 < encrypted.length; i2++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i2] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i2 = data.length; i2 < result.length; i2++) {
          result[i2] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data.length - padder;
        for (var i2 = 0; i2 < padder; i2++) {
          if (data[length + i2] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version23;
var init_version19 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/_version.js"() {
    init_shim();
    version23 = "json-wallets/5.7.0";
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i2 = 0; i2 < comps.length; i2++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i2]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes = arrayify(randomBytes2);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
var init_utils = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/utils.js"() {
    "use strict";
    init_shim();
    init_lib2();
    init_lib10();
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger41.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv2 = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv2);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
var import_aes_js, logger41, CrowdsaleAccount;
var init_crowdsale = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js"() {
    "use strict";
    init_shim();
    import_aes_js = __toESM(require_aes_js());
    init_lib13();
    init_lib2();
    init_lib9();
    init_lib22();
    init_lib10();
    init_lib4();
    init_lib();
    init_version19();
    init_utils();
    logger41 = new Logger(version23);
    CrowdsaleAccount = class extends Description {
      isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var init_inspect = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/inspect.js"() {
    "use strict";
    init_shim();
    init_lib13();
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module2) {
    "use strict";
    init_shim();
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA256(m) {
        const K2 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
        let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w = new Uint32Array(64);
        function blocks(p2) {
          let off = 0, len = p2.length;
          while (len >= 64) {
            let a2 = h0, b = h1, c = h2, d = h3, e2 = h4, f = h5, g = h6, h = h7, u, i3, j, t1, t2;
            for (i3 = 0; i3 < 16; i3++) {
              j = off + i3 * 4;
              w[i3] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
            }
            for (i3 = 16; i3 < 64; i3++) {
              u = w[i3 - 2];
              t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
              u = w[i3 - 15];
              t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
              w[i3] = (t1 + w[i3 - 7] | 0) + (t2 + w[i3 - 16] | 0) | 0;
            }
            for (i3 = 0; i3 < 64; i3++) {
              t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g) | 0) + (h + (K2[i3] + w[i3] | 0) | 0) | 0;
              t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b ^ a2 & c ^ b & c) | 0;
              h = g;
              g = f;
              f = e2;
              e2 = d + t1 | 0;
              d = c;
              c = b;
              b = a2;
              a2 = t1 + t2 | 0;
            }
            h0 = h0 + a2 | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e2 | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g | 0;
            h7 = h7 + h | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m);
        let i2, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(128);
        for (i2 = bytesLeft + 1; i2 < numZeros; i2++) {
          p.push(0);
        }
        p.push(bitLenHi >>> 24 & 255);
        p.push(bitLenHi >>> 16 & 255);
        p.push(bitLenHi >>> 8 & 255);
        p.push(bitLenHi >>> 0 & 255);
        p.push(bitLenLo >>> 24 & 255);
        p.push(bitLenLo >>> 16 & 255);
        p.push(bitLenLo >>> 8 & 255);
        p.push(bitLenLo >>> 0 & 255);
        blocks(p);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i2;
        let dk = [];
        for (i2 = 0; i2 < 64; i2++) {
          inner[i2] = 54;
        }
        for (i2 = 0; i2 < password.length; i2++) {
          inner[i2] ^= password[i2];
        }
        for (i2 = 0; i2 < salt.length; i2++) {
          inner[64 + i2] = salt[i2];
        }
        for (i2 = innerLen - 4; i2 < innerLen; i2++) {
          inner[i2] = 0;
        }
        for (i2 = 0; i2 < 64; i2++)
          outerKey[i2] = 92;
        for (i2 = 0; i2 < password.length; i2++)
          outerKey[i2] ^= password[i2];
        function incrementCounter() {
          for (let i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
            inner[i3]++;
            if (inner[i3] <= 255)
              return;
            inner[i3] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi, r3, x, _X) {
        let i2;
        arraycopy(BY, (2 * r3 - 1) * 16, _X, 0, 16);
        for (i2 = 0; i2 < 2 * r3; i2++) {
          blockxor(BY, i2 * 16, _X, 16);
          salsa20_8(_X, x);
          arraycopy(_X, 0, BY, Yi + i2 * 16, 16);
        }
        for (i2 = 0; i2 < r3; i2++) {
          arraycopy(BY, Yi + i2 * 2 * 16, BY, i2 * 16, 16);
        }
        for (i2 = 0; i2 < r3; i2++) {
          arraycopy(BY, Yi + (i2 * 2 + 1) * 16, BY, (i2 + r3) * 16, 16);
        }
      }
      function R2(a2, b) {
        return a2 << b | a2 >>> 32 - b;
      }
      function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for (let i2 = 8; i2 > 0; i2 -= 2) {
          x[4] ^= R2(x[0] + x[12], 7);
          x[8] ^= R2(x[4] + x[0], 9);
          x[12] ^= R2(x[8] + x[4], 13);
          x[0] ^= R2(x[12] + x[8], 18);
          x[9] ^= R2(x[5] + x[1], 7);
          x[13] ^= R2(x[9] + x[5], 9);
          x[1] ^= R2(x[13] + x[9], 13);
          x[5] ^= R2(x[1] + x[13], 18);
          x[14] ^= R2(x[10] + x[6], 7);
          x[2] ^= R2(x[14] + x[10], 9);
          x[6] ^= R2(x[2] + x[14], 13);
          x[10] ^= R2(x[6] + x[2], 18);
          x[3] ^= R2(x[15] + x[11], 7);
          x[7] ^= R2(x[3] + x[15], 9);
          x[11] ^= R2(x[7] + x[3], 13);
          x[15] ^= R2(x[11] + x[7], 18);
          x[1] ^= R2(x[0] + x[3], 7);
          x[2] ^= R2(x[1] + x[0], 9);
          x[3] ^= R2(x[2] + x[1], 13);
          x[0] ^= R2(x[3] + x[2], 18);
          x[6] ^= R2(x[5] + x[4], 7);
          x[7] ^= R2(x[6] + x[5], 9);
          x[4] ^= R2(x[7] + x[6], 13);
          x[5] ^= R2(x[4] + x[7], 18);
          x[11] ^= R2(x[10] + x[9], 7);
          x[8] ^= R2(x[11] + x[10], 9);
          x[9] ^= R2(x[8] + x[11], 13);
          x[10] ^= R2(x[9] + x[8], 18);
          x[12] ^= R2(x[15] + x[14], 7);
          x[13] ^= R2(x[12] + x[15], 9);
          x[14] ^= R2(x[13] + x[12], 13);
          x[15] ^= R2(x[14] + x[13], 18);
        }
        for (let i2 = 0; i2 < 16; ++i2) {
          B[i2] += x[i2];
        }
      }
      function blockxor(S2, Si, D3, len) {
        for (let i2 = 0; i2 < len; i2++) {
          D3[i2] ^= S2[Si + i2];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o2) {
        if (!o2 || typeof o2.length !== "number") {
          return false;
        }
        for (let i2 = 0; i2 < o2.length; i2++) {
          const v = o2[i2];
          if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name);
        }
        return value;
      }
      function _scrypt(password, salt, N2, r3, p, dkLen, callback) {
        N2 = ensureInteger(N2, "N");
        r3 = ensureInteger(r3, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N2 === 0 || (N2 & N2 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N2 > MAX_VALUE / 128 / r3) {
          throw new Error("N too large");
        }
        if (r3 > MAX_VALUE / 128 / p) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r3);
        const B = new Uint32Array(p * 32 * r3);
        for (let i2 = 0; i2 < B.length; i2++) {
          const j = i2 * 4;
          B[i2] = (b[j + 3] & 255) << 24 | (b[j + 2] & 255) << 16 | (b[j + 1] & 255) << 8 | (b[j + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r3);
        const V = new Uint32Array(32 * r3 * N2);
        const Yi = 32 * r3;
        const x = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p * N2 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r3) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r3;
              arraycopy(B, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N2 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i2 = 0; i2 < steps; i2++) {
                arraycopy(XY, 0, V, (i1 + i2) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r3, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N2) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N2 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i2 = 0; i2 < steps; i2++) {
                const offset = (2 * r3 - 1) * 16;
                const j = XY[offset] & N2 - 1;
                blockxor(V, j * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r3, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N2) {
                break;
              }
              arraycopy(XY, 0, B, Bi, Yi);
              i0++;
              if (i0 < p) {
                state = 0;
                break;
              }
              b = [];
              for (let i2 = 0; i2 < B.length; i2++) {
                b.push(B[i2] >> 0 & 255);
                b.push(B[i2] >> 8 & 255);
                b.push(B[i2] >> 16 & 255);
                b.push(B[i2] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N2, r3, p, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N2, r3, p, dkLen, function(error, progress, key2) {
              if (error) {
                reject(error);
              } else if (key2) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key2));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N2, r3, p, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N2, r3, p, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv2 = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv2);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger42.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name, value) {
      return logger42.throwArgumentError("invalid key-derivation function parameters", name, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r3 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r3 || !p) {
        throwError2("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError2("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r3, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger42.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter15(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key2 = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv2 = null;
  if (options.iv) {
    iv2 = arrayify(options.iv);
    if (iv2.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv2 = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N2 = 1 << 17, r3 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r3 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N2, r3, p, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv2);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv2).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N2,
          dklen: 32,
          p,
          r: r3
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = /* @__PURE__ */ new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
var import_aes_js2, import_scrypt_js, __awaiter15, logger42, KeystoreAccount;
var init_keystore = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"() {
    "use strict";
    init_shim();
    import_aes_js2 = __toESM(require_aes_js());
    import_scrypt_js = __toESM(require_scrypt());
    init_lib13();
    init_lib2();
    init_lib24();
    init_lib9();
    init_lib22();
    init_lib20();
    init_lib4();
    init_lib18();
    init_utils();
    init_lib();
    init_version19();
    __awaiter15 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger42 = new Logger(version23);
    KeystoreAccount = class extends Description {
      isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/index.js
var lib_exports20 = {};
__export(lib_exports20, {
  decryptCrowdsale: () => decrypt,
  decryptJsonWallet: () => decryptJsonWallet,
  decryptJsonWalletSync: () => decryptJsonWalletSync,
  decryptKeystore: () => decrypt2,
  decryptKeystoreSync: () => decryptSync,
  encryptKeystore: () => encrypt,
  getJsonWalletAddress: () => getJsonWalletAddress,
  isCrowdsaleWallet: () => isCrowdsaleWallet,
  isKeystoreWallet: () => isKeystoreWallet
});
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
var init_lib25 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_crowdsale();
    init_inspect();
    init_keystore();
  }
});

// node_modules/@ethersproject/solidity/lib.esm/_version.js
var version24;
var init_version20 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    init_shim();
    version24 = "solidity/5.7.0";
  }
});

// node_modules/@ethersproject/solidity/lib.esm/index.js
var lib_exports21 = {};
__export(lib_exports21, {
  keccak256: () => keccak2562,
  pack: () => pack2,
  sha256: () => sha2562
});
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger43.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger43.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger43.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger43.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger43.throwArgumentError("invalid type", "type", type);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger43.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
function sha2562(types, values) {
  return sha256(pack2(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros2, logger43;
var init_lib26 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib3();
    init_lib2();
    init_lib9();
    init_lib15();
    init_lib10();
    init_lib();
    init_version20();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
    logger43 = new Logger(version24);
  }
});

// node_modules/@ethersproject/units/lib.esm/_version.js
var version25;
var init_version21 = __esm({
  "node_modules/@ethersproject/units/lib.esm/_version.js"() {
    init_shim();
    version25 = "units/5.7.0";
  }
});

// node_modules/@ethersproject/units/lib.esm/index.js
var lib_exports22 = {};
__export(lib_exports22, {
  commify: () => commify,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits
});
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger44.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger44.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger44, names;
var init_lib27 = __esm({
  "node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib3();
    init_lib();
    init_version21();
    logger44 = new Logger(version25);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// node_modules/@ethersproject/wallet/lib.esm/_version.js
var version26;
var init_version22 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    init_shim();
    version26 = "wallet/5.7.0";
  }
});

// node_modules/@ethersproject/wallet/lib.esm/index.js
var lib_exports23 = {};
__export(lib_exports23, {
  Wallet: () => Wallet,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData
});
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature2);
}
var __awaiter16, logger45, Wallet;
var init_lib28 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_shim();
    init_lib13();
    init_lib5();
    init_lib19();
    init_lib2();
    init_lib14();
    init_lib24();
    init_lib9();
    init_lib4();
    init_lib20();
    init_lib17();
    init_lib25();
    init_lib18();
    init_lib();
    init_version22();
    __awaiter16 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger45 = new Logger(version26);
    Wallet = class _Wallet extends Signer {
      constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger45.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic2(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node.privateKey) !== this.address) {
              logger45.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger45.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger45.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new _Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger45.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature2);
        });
      }
      signMessage(message) {
        return __awaiter16(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter16(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            if (this.provider == null) {
              logger45.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name
              });
            }
            return this.provider.resolveName(name);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      /**
       *  Static methods to create Wallet instances.
       */
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return _Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new _Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new _Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist2) {
        if (!path) {
          path = defaultPath;
        }
        return new _Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
      }
    };
  }
});

// node_modules/ethers/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib21(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib13(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib6(), __toCommonJS(lib_exports4)));
    exports.base64 = base64;
    var basex_1 = (init_lib7(), __toCommonJS(lib_exports5));
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib14(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib24(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib25(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib9(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib15(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib26(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib20(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib4(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib12(), __toCommonJS(lib_exports9)));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib17(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib10(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib18(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib27(), __toCommonJS(lib_exports22));
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib28(), __toCommonJS(lib_exports23));
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib16(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib15(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib10(), __toCommonJS(lib_exports8));
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_ATOM.json
var require_LPACC_ATOM = __commonJS({
  "node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_ATOM.json"(exports, module2) {
    module2.exports = {
      $id: "https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_ATOM.ts",
      title: "LPACC_EVM_ATOM",
      description: "",
      type: "object",
      properties: {
        conditionType: {
          type: "string"
        },
        path: {
          type: "string"
        },
        chain: {
          enum: ["cosmos", "kyve", "evmosCosmos", "evmosCosmosTestnet"]
        },
        method: {
          type: "string"
        },
        parameters: {
          type: "array",
          items: {
            type: "string"
          }
        },
        returnValueTest: {
          type: "object",
          properties: {
            key: {
              type: "string"
            },
            comparator: {
              enum: ["contains", "=", ">", ">=", "<", "<="]
            },
            value: {
              type: "string"
            }
          },
          required: ["key", "comparator", "value"],
          additionalProperties: false
        }
      },
      required: ["path", "chain", "returnValueTest"],
      additionalProperties: false
    };
  }
});

// node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_EVM_BASIC.json
var require_LPACC_EVM_BASIC = __commonJS({
  "node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_EVM_BASIC.json"(exports, module2) {
    module2.exports = {
      $id: "https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_BASIC.json",
      title: "LPACC_EVM_BASIC",
      description: "",
      type: "object",
      properties: {
        conditionType: {
          type: "string"
        },
        contractAddress: {
          type: "string"
        },
        chain: {
          enum: [
            "ethereum",
            "polygon",
            "fantom",
            "xdai",
            "bsc",
            "arbitrum",
            "avalanche",
            "fuji",
            "harmony",
            "mumbai",
            "goerli",
            "cronos",
            "optimism",
            "celo",
            "aurora",
            "eluvio",
            "alfajores",
            "xdc",
            "evmos",
            "evmosTestnet",
            "bscTestnet",
            "baseGoerli",
            "baseSepolia",
            "moonbeam",
            "moonriver",
            "moonbaseAlpha",
            "filecoin",
            "hyperspace",
            "sepolia",
            "scrollAlphaTestnet",
            "scroll",
            "zksync",
            "base",
            "lukso",
            "luksoTestnet",
            "zora",
            "zoraGoerli",
            "zksyncTestnet",
            "lineaGoerli",
            "chronicleTestnet",
            "chiado",
            "zkEvm",
            "mantleTestnet",
            "mantle",
            "klaytn",
            "publicGoodsNetwork",
            "optimismGoerli",
            "waevEclipseTestnet",
            "waevEclipseDevnet",
            "verifyTestnet"
          ]
        },
        standardContractType: {
          enum: [
            "",
            "ERC20",
            "ERC721",
            "ERC721MetadataName",
            "ERC1155",
            "CASK",
            "Creaton",
            "POAP",
            "timestamp",
            "MolochDAOv2.1",
            "ProofOfHumanity",
            "SIWE",
            "PKPPermissions",
            "LitAction"
          ]
        },
        method: {
          type: "string"
        },
        parameters: {
          type: "array",
          items: {
            type: "string"
          }
        },
        returnValueTest: {
          type: "object",
          properties: {
            comparator: {
              enum: [
                "contains",
                "=",
                ">",
                ">=",
                "<",
                "<="
              ]
            },
            value: {
              type: "string"
            }
          },
          required: [
            "comparator",
            "value"
          ],
          additionalProperties: false
        }
      },
      required: [
        "contractAddress",
        "chain",
        "standardContractType",
        "method",
        "parameters",
        "returnValueTest"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_EVM_CONTRACT.json
var require_LPACC_EVM_CONTRACT = __commonJS({
  "node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_EVM_CONTRACT.json"(exports, module2) {
    module2.exports = {
      $id: "https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_CONTRACT.json",
      title: "LPACC_EVM_CONTRACT",
      description: "",
      type: "object",
      properties: {
        conditionType: {
          type: "string"
        },
        contractAddress: {
          type: "string"
        },
        chain: {
          enum: [
            "ethereum",
            "polygon",
            "fantom",
            "xdai",
            "bsc",
            "arbitrum",
            "avalanche",
            "fuji",
            "harmony",
            "mumbai",
            "goerli",
            "cronos",
            "optimism",
            "celo",
            "aurora",
            "eluvio",
            "alfajores",
            "xdc",
            "evmos",
            "evmosTestnet",
            "bscTestnet",
            "baseGoerli",
            "baseSepolia",
            "moonbeam",
            "moonriver",
            "moonbaseAlpha",
            "filecoin",
            "hyperspace",
            "sepolia",
            "scrollAlphaTestnet",
            "scroll",
            "zksync",
            "base",
            "lukso",
            "luksoTestnet",
            "zora",
            "zoraGoerli",
            "zksyncTestnet",
            "lineaGoerli",
            "chronicleTestnet",
            "chiado",
            "zkEvm",
            "mantleTestnet",
            "mantle",
            "klaytn",
            "publicGoodsNetwork",
            "optimismGoerli",
            "waevEclipseTestnet",
            "waevEclipseDevnet",
            "verifyTestnet"
          ]
        },
        functionName: {
          type: "string"
        },
        functionParams: {
          type: "array",
          items: {
            type: "string"
          }
        },
        functionAbi: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            type: {
              type: "string"
            },
            stateMutability: {
              type: "string"
            },
            constant: {
              type: "boolean"
            },
            inputs: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  type: {
                    type: "string"
                  },
                  internalType: {
                    type: "string"
                  }
                },
                required: [
                  "name",
                  "type"
                ],
                additionalProperties: false
              }
            },
            outputs: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  type: {
                    type: "string"
                  },
                  internalType: {
                    type: "string"
                  }
                },
                required: [
                  "name",
                  "type"
                ],
                additionalProperties: false
              }
            }
          },
          required: [
            "name",
            "stateMutability",
            "inputs",
            "outputs"
          ],
          additionalProperties: false
        },
        returnValueTest: {
          type: "object",
          properties: {
            key: {
              type: "string"
            },
            comparator: {
              enum: [
                "contains",
                "=",
                ">",
                ">=",
                "<",
                "<="
              ]
            },
            value: {
              type: "string"
            }
          },
          required: [
            "key",
            "comparator",
            "value"
          ],
          additionalProperties: false
        }
      },
      required: [
        "contractAddress",
        "chain",
        "functionName",
        "functionParams",
        "functionAbi",
        "returnValueTest"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_SOL.json
var require_LPACC_SOL = __commonJS({
  "node_modules/@lit-protocol/accs-schemas/esm/schemas/LPACC_SOL.json"(exports, module2) {
    module2.exports = {
      $id: "https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_SOL.json",
      title: "LPACC_SOL",
      description: "",
      type: "object",
      properties: {
        conditionType: {
          type: "string"
        },
        method: {
          type: "string"
        },
        params: {
          type: "array",
          items: {
            type: "string"
          }
        },
        pdaParams: {
          type: "array",
          items: {
            type: "string"
          }
        },
        pdaInterface: {
          type: "object",
          properties: {
            offset: {
              type: "number"
            },
            fields: {
              type: "object"
            }
          },
          required: ["offset", "fields"],
          additionalProperties: false
        },
        pdaKey: {
          type: "string"
        },
        chain: {
          enum: ["solana", "solanaDevnet", "solanaTestnet"]
        },
        returnValueTest: {
          type: "object",
          properties: {
            key: {
              type: "string"
            },
            comparator: {
              enum: ["contains", "=", ">", ">=", "<", "<="]
            },
            value: {
              type: "string"
            }
          },
          required: ["comparator", "value", "key"],
          additionalProperties: false
        }
      },
      required: [
        "method",
        "params",
        "chain",
        "pdaInterface",
        "pdaKey",
        "returnValueTest"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/pako/lib/utils/common.js
var require_common3 = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_shim();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l2, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common3();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits(s2, value, length) {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    }
    function send_code(s2, c, tree) {
      send_bits(
        s2,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base2 = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n2, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h = s2.heap_max + 1; h < HEAP_SIZE; h++) {
        n2 = s2.heap[h];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base2) {
          xbits = extra[n2 - base2];
        }
        f = tree[n2 * 2];
        s2.opt_len += f * (bits + xbits);
        if (has_stree) {
          s2.static_len += f * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m = s2.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n2--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n2;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        var len = tree[n2 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n2;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n2 = 0; n2 < D_CODES; n2++) {
        static_dtree[n2 * 2 + 1] = 5;
        static_dtree[n2 * 2] = bi_reverse(n2, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n2;
      for (n2 = 0; n2 < L_CODES; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n2, m, depth) {
      var _n2 = n2 * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
    }
    function pqdownheap(s2, tree, k) {
      var v = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller(tree, v, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n2, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n2 * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m] ? s2.depth[n2] : s2.depth[m]) + 1;
        tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n2;
      for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n2 = 32; n2 < LITERALS; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    init_shim();
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len !== 0) {
        n2 = len > 2e3 ? 2e3 : len;
        len -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    init_shim();
    function makeTable() {
      var c, table = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c = n2;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n2] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t2 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    init_shim();
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common3();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b) {
      s2.pending_buf[s2.pending++] = b;
    }
    function putShortMSB(s2, b) {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p, n2, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n2 = s2.hash_size;
          p = n2;
          do {
            m = s2.head[--p];
            s2.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          n2 = _w_size;
          p = n2;
          do {
            m = s2.prev[--p];
            s2.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n2;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n2 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n2);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common3();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i2 = 0, len = buf.length; i2 < len; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i2, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    init_shim();
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    init_shim();
    var zlib_deflate = require_deflate();
    var utils = require_common3();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    init_shim();
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    init_shim();
    var utils = require_common3();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base2 = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base2 = extra = work;
        end = 19;
      } else if (type === LENS) {
        base2 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base2 = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base2[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common3();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate4(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n2;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate4;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    init_shim();
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    init_shim();
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    init_shim();
    var zlib_inflate = require_inflate();
    var utils = require_common3();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate4(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate4(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate4;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate4;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module2) {
    "use strict";
    init_shim();
    var assign = require_common3().assign;
    var deflate = require_deflate2();
    var inflate4 = require_inflate2();
    var constants = require_constants();
    var pako4 = {};
    assign(pako4, deflate, inflate4, constants);
    module2.exports = pako4;
  }
});

// local-tests/test.ts
init_shim();

// local-tests/setup/env-setup.ts
init_shim();

// packages/lit-node-client/src/index.ts
init_shim();

// packages/misc/src/index.ts
init_shim();

// packages/misc/src/lib/misc.ts
init_shim();

// packages/constants/src/index.ts
init_shim();

// packages/constants/src/lib/version.ts
init_shim();
var version = "4.2.0";

// packages/constants/src/lib/constants/constants.ts
init_shim();

// packages/constants/src/lib/constants/autogen_internal.ts
init_shim();
var INTERNAL_DEV = [
  "https://167.114.17.201:443",
  "https://64.131.85.108:443",
  "https://167.114.17.202:443",
  "https://167.114.17.203:443",
  "https://167.114.17.204:443",
  "https://64.131.85.106:443"
];

// packages/constants/src/lib/enums.ts
init_shim();
var LIT_CURVE = /* @__PURE__ */ ((LIT_CURVE2) => {
  LIT_CURVE2["BLS"] = "BLS";
  LIT_CURVE2["EcdsaK256"] = "K256";
  LIT_CURVE2["EcdsaCaitSith"] = "ECDSA_CAIT_SITH";
  LIT_CURVE2["EcdsaCAITSITHP256"] = "EcdsaCaitSithP256";
  return LIT_CURVE2;
})(LIT_CURVE || {});
var LIT_ENDPOINT_VERSION = /* @__PURE__ */ ((LIT_ENDPOINT_VERSION2) => {
  LIT_ENDPOINT_VERSION2["LEGACY"] = "/";
  LIT_ENDPOINT_VERSION2["V1"] = "/v1";
  return LIT_ENDPOINT_VERSION2;
})(LIT_ENDPOINT_VERSION || {});

// packages/constants/src/lib/constants/constants.ts
var LIT_AUTH_SIG_CHAIN_KEYS = [
  "ethereum",
  "solana",
  "cosmos",
  "kyve"
];
var AUTH_SIGNATURE_BODY = "I am creating an account to use Lit Protocol at {{timestamp}}";
var LIT_CHAINS = {
  ethereum: {
    contractAddress: "0xA54F7579fFb3F98bd8649fF02813F575f9b3d353",
    chainId: 1,
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18,
    type: "ERC1155",
    rpcUrls: [
      "https://eth-mainnet.alchemyapi.io/v2/EuGnkVlzVoEkzdg0lpCarhm8YHOxWVxE"
    ],
    blockExplorerUrls: ["https://etherscan.io"],
    vmType: "EVM"
  },
  polygon: {
    contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
    chainId: 137,
    name: "Polygon",
    symbol: "MATIC",
    decimals: 18,
    rpcUrls: ["https://polygon-rpc.com"],
    blockExplorerUrls: ["https://explorer.matic.network"],
    type: "ERC1155",
    vmType: "EVM"
  },
  fantom: {
    contractAddress: "0x5bD3Fe8Ab542f0AaBF7552FAAf376Fd8Aa9b3869",
    chainId: 250,
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    rpcUrls: ["https://rpcapi.fantom.network"],
    blockExplorerUrls: ["https://ftmscan.com"],
    type: "ERC1155",
    vmType: "EVM"
  },
  xdai: {
    contractAddress: "0xDFc2Fd83dFfD0Dafb216F412aB3B18f2777406aF",
    chainId: 100,
    name: "xDai",
    symbol: "xDai",
    decimals: 18,
    rpcUrls: ["https://rpc.gnosischain.com"],
    blockExplorerUrls: [" https://blockscout.com/xdai/mainnet"],
    type: "ERC1155",
    vmType: "EVM"
  },
  bsc: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 56,
    name: "Binance Smart Chain",
    symbol: "BNB",
    decimals: 18,
    rpcUrls: ["https://bsc-dataseed.binance.org/"],
    blockExplorerUrls: [" https://bscscan.com/"],
    type: "ERC1155",
    vmType: "EVM"
  },
  arbitrum: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 42161,
    name: "Arbitrum",
    symbol: "AETH",
    decimals: 18,
    type: "ERC1155",
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorerUrls: ["https://arbiscan.io/"],
    vmType: "EVM"
  },
  avalanche: {
    contractAddress: "0xBB118507E802D17ECDD4343797066dDc13Cde7C6",
    chainId: 43114,
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    type: "ERC1155",
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorerUrls: ["https://snowtrace.io/"],
    vmType: "EVM"
  },
  fuji: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 43113,
    name: "Avalanche FUJI Testnet",
    symbol: "AVAX",
    decimals: 18,
    type: "ERC1155",
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorerUrls: ["https://testnet.snowtrace.io/"],
    vmType: "EVM"
  },
  harmony: {
    contractAddress: "0xBB118507E802D17ECDD4343797066dDc13Cde7C6",
    chainId: 16666e5,
    name: "Harmony",
    symbol: "ONE",
    decimals: 18,
    type: "ERC1155",
    rpcUrls: ["https://api.harmony.one"],
    blockExplorerUrls: ["https://explorer.harmony.one/"],
    vmType: "EVM"
  },
  mumbai: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 80001,
    name: "Mumbai",
    symbol: "MATIC",
    decimals: 18,
    rpcUrls: [
      "https://rpc-mumbai.maticvigil.com/v1/96bf5fa6e03d272fbd09de48d03927b95633726c"
    ],
    blockExplorerUrls: ["https://mumbai.polygonscan.com"],
    type: "ERC1155",
    vmType: "EVM"
  },
  goerli: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 5,
    name: "Goerli",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://goerli.infura.io/v3/96dffb3d8c084dec952c61bd6230af34"],
    blockExplorerUrls: ["https://goerli.etherscan.io"],
    type: "ERC1155",
    vmType: "EVM"
  },
  cronos: {
    contractAddress: "0xc716950e5DEae248160109F562e1C9bF8E0CA25B",
    chainId: 25,
    name: "Cronos",
    symbol: "CRO",
    decimals: 18,
    rpcUrls: ["https://evm-cronos.org"],
    blockExplorerUrls: ["https://cronos.org/explorer/"],
    type: "ERC1155",
    vmType: "EVM"
  },
  optimism: {
    contractAddress: "0xbF68B4c9aCbed79278465007f20a08Fa045281E0",
    chainId: 10,
    name: "Optimism",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorerUrls: ["https://optimistic.etherscan.io"],
    type: "ERC1155",
    vmType: "EVM"
  },
  celo: {
    contractAddress: "0xBB118507E802D17ECDD4343797066dDc13Cde7C6",
    chainId: 42220,
    name: "Celo",
    symbol: "CELO",
    decimals: 18,
    rpcUrls: ["https://forno.celo.org"],
    blockExplorerUrls: ["https://explorer.celo.org"],
    type: "ERC1155",
    vmType: "EVM"
  },
  aurora: {
    contractAddress: null,
    chainId: 1313161554,
    name: "Aurora",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://mainnet.aurora.dev"],
    blockExplorerUrls: ["https://aurorascan.dev"],
    type: null,
    vmType: "EVM"
  },
  eluvio: {
    contractAddress: null,
    chainId: 955305,
    name: "Eluvio",
    symbol: "ELV",
    decimals: 18,
    rpcUrls: ["https://host-76-74-28-226.contentfabric.io/eth"],
    blockExplorerUrls: ["https://explorer.eluv.io"],
    type: null,
    vmType: "EVM"
  },
  alfajores: {
    contractAddress: null,
    chainId: 44787,
    name: "Alfajores",
    symbol: "CELO",
    decimals: 18,
    rpcUrls: ["https://alfajores-forno.celo-testnet.org"],
    blockExplorerUrls: ["https://alfajores-blockscout.celo-testnet.org"],
    type: null,
    vmType: "EVM"
  },
  xdc: {
    contractAddress: null,
    chainId: 50,
    name: "XDC Blockchain",
    symbol: "XDC",
    decimals: 18,
    rpcUrls: ["https://rpc.xinfin.network"],
    blockExplorerUrls: ["https://explorer.xinfin.network"],
    type: null,
    vmType: "EVM"
  },
  evmos: {
    contractAddress: null,
    chainId: 9001,
    name: "EVMOS",
    symbol: "EVMOS",
    decimals: 18,
    rpcUrls: ["https://eth.bd.evmos.org:8545"],
    blockExplorerUrls: ["https://evm.evmos.org"],
    type: null,
    vmType: "EVM"
  },
  evmosTestnet: {
    contractAddress: null,
    chainId: 9e3,
    name: "EVMOS Testnet",
    symbol: "EVMOS",
    decimals: 18,
    rpcUrls: ["https://eth.bd.evmos.dev:8545"],
    blockExplorerUrls: ["https://evm.evmos.dev"],
    type: null,
    vmType: "EVM"
  },
  bscTestnet: {
    contractAddress: null,
    chainId: 97,
    name: "BSC Testnet",
    symbol: "BNB",
    decimals: 18,
    rpcUrls: ["https://data-seed-prebsc-1-s1.binance.org:8545"],
    blockExplorerUrls: ["https://testnet.bscscan.com/"],
    type: null,
    vmType: "EVM"
  },
  baseGoerli: {
    contractAddress: null,
    chainId: 84531,
    name: "Base Goerli",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://goerli.base.org"],
    blockExplorerUrls: ["https://goerli.basescan.org"],
    type: null,
    vmType: "EVM"
  },
  baseSepolia: {
    contractAddress: null,
    chainId: 84532,
    name: "Base Sepolia",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://sepolia.base.org"],
    blockExplorerUrls: ["https://sepolia.basescan.org"],
    type: null,
    vmType: "EVM"
  },
  moonbeam: {
    contractAddress: null,
    chainId: 1284,
    name: "Moonbeam",
    symbol: "GLMR",
    decimals: 18,
    rpcUrls: ["https://rpc.api.moonbeam.network"],
    blockExplorerUrls: ["https://moonscan.io"],
    type: null,
    vmType: "EVM"
  },
  moonriver: {
    contractAddress: null,
    chainId: 1285,
    name: "Moonriver",
    symbol: "MOVR",
    decimals: 18,
    rpcUrls: ["https://rpc.api.moonriver.moonbeam.network"],
    blockExplorerUrls: ["https://moonriver.moonscan.io"],
    type: null,
    vmType: "EVM"
  },
  moonbaseAlpha: {
    contractAddress: null,
    chainId: 1287,
    name: "Moonbase Alpha",
    symbol: "DEV",
    decimals: 18,
    rpcUrls: ["https://rpc.api.moonbase.moonbeam.network"],
    blockExplorerUrls: ["https://moonbase.moonscan.io/"],
    type: null,
    vmType: "EVM"
  },
  filecoin: {
    contractAddress: null,
    chainId: 314,
    name: "Filecoin",
    symbol: "FIL",
    decimals: 18,
    rpcUrls: ["https://api.node.glif.io/rpc/v1"],
    blockExplorerUrls: ["https://filfox.info/"],
    type: null,
    vmType: "EVM"
  },
  hyperspace: {
    contractAddress: null,
    chainId: 3141,
    name: "Filecoin Hyperspace testnet",
    symbol: "tFIL",
    decimals: 18,
    rpcUrls: ["https://api.hyperspace.node.glif.io/rpc/v1"],
    blockExplorerUrls: ["https://hyperspace.filscan.io/"],
    type: null,
    vmType: "EVM"
  },
  sepolia: {
    contractAddress: null,
    chainId: 11155111,
    name: "Sepolia Testnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://eth-sepolia.g.alchemy.com/v2/demo"],
    blockExplorerUrls: ["https://sepolia.etherscan.io/"],
    type: null,
    vmType: "EVM"
  },
  scrollAlphaTestnet: {
    contractAddress: null,
    chainId: 534353,
    name: "Scroll Alpha Testnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://alpha-rpc.scroll.io/l2"],
    blockExplorerUrls: ["https://blockscout.scroll.io/"],
    type: null,
    vmType: "EVM"
  },
  scroll: {
    contractAddress: null,
    chainId: 534352,
    name: "Scroll",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.scroll.io"],
    blockExplorerUrls: ["https://scrollscan.com/"],
    type: null,
    vmType: "EVM"
  },
  zksync: {
    contractAddress: null,
    chainId: 324,
    name: "zkSync Era Mainnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://mainnet.era.zksync.io"],
    blockExplorerUrls: ["https://explorer.zksync.io/"],
    type: null,
    vmType: "EVM"
  },
  base: {
    contractAddress: null,
    chainId: 8453,
    name: "Base Mainnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://mainnet.base.org"],
    blockExplorerUrls: ["https://basescan.org"],
    type: null,
    vmType: "EVM"
  },
  lukso: {
    contractAddress: null,
    chainId: 42,
    name: "Lukso",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.lukso.gateway.fm"],
    blockExplorerUrls: ["https://explorer.execution.mainnet.lukso.network/"],
    type: null,
    vmType: "EVM"
  },
  luksoTestnet: {
    contractAddress: null,
    chainId: 4201,
    name: "Lukso Testnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.testnet.lukso.network"],
    blockExplorerUrls: ["https://explorer.execution.testnet.lukso.network"],
    type: null,
    vmType: "EVM"
  },
  zora: {
    contractAddress: null,
    chainId: 7777777,
    name: "	Zora",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.zora.energy/"],
    blockExplorerUrls: ["https://explorer.zora.energy"],
    type: null,
    vmType: "EVM"
  },
  zoraGoerli: {
    contractAddress: null,
    chainId: 999,
    name: "Zora Goerli",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://testnet.rpc.zora.energy"],
    blockExplorerUrls: ["https://testnet.explorer.zora.energy"],
    type: null,
    vmType: "EVM"
  },
  zksyncTestnet: {
    contractAddress: null,
    chainId: 280,
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://testnet.era.zksync.dev"],
    blockExplorerUrls: ["https://goerli.explorer.zksync.io/"],
    type: null,
    vmType: "EVM"
  },
  lineaGoerli: {
    contractAddress: null,
    chainId: 59140,
    name: "Linea Testnet",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.goerli.linea.build"],
    blockExplorerUrls: ["https://explorer.goerli.linea.build"],
    type: null,
    vmType: "EVM"
  },
  chronicleTestnet: {
    contractAddress: null,
    chainId: 175177,
    name: "Chronicle - Lit Protocol Testnet",
    symbol: "testLPX",
    decimals: 18,
    rpcUrls: ["https://chain-rpc.litprotocol.com/http"],
    blockExplorerUrls: ["https://chain.litprotocol.com/"],
    type: null,
    vmType: "EVM"
  },
  chiado: {
    contractAddress: null,
    chainId: 10200,
    name: "Chiado",
    symbol: "XDAI",
    decimals: 18,
    rpcUrls: ["https://rpc.chiadochain.net"],
    blockExplorerUrls: ["https://blockscout.chiadochain.net"],
    type: null,
    vmType: "EVM"
  },
  zkEvm: {
    contractAddress: null,
    chainId: 1101,
    name: "zkEvm",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://zkevm-rpc.com"],
    blockExplorerUrls: ["https://zkevm.polygonscan.com/"],
    type: null,
    vmType: "EVM"
  },
  mantleTestnet: {
    contractAddress: null,
    chainId: 5001,
    name: "Mantle Testnet",
    symbol: "MNT",
    decimals: 18,
    rpcUrls: ["https://rpc.testnet.mantle.xyz"],
    blockExplorerUrls: ["https://explorer.testnet.mantle.xyz/"],
    type: null,
    vmType: "EVM"
  },
  mantle: {
    contractAddress: null,
    chainId: 5e3,
    name: "Mantle",
    symbol: "MNT",
    decimals: 18,
    rpcUrls: ["https://rpc.mantle.xyz"],
    blockExplorerUrls: ["http://explorer.mantle.xyz/"],
    type: null,
    vmType: "EVM"
  },
  klaytn: {
    contractAddress: null,
    chainId: 8217,
    name: "Klaytn",
    symbol: "KLAY",
    decimals: 18,
    rpcUrls: ["https://klaytn.blockpi.network/v1/rpc/public"],
    blockExplorerUrls: ["https://www.klaytnfinder.io/"],
    type: null,
    vmType: "EVM"
  },
  publicGoodsNetwork: {
    contractAddress: null,
    chainId: 424,
    name: "Public Goods Network",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://rpc.publicgoods.network"],
    blockExplorerUrls: ["https://explorer.publicgoods.network/"],
    type: null,
    vmType: "EVM"
  },
  optimismGoerli: {
    contractAddress: null,
    chainId: 420,
    name: "Optimism Goerli",
    symbol: "ETH",
    decimals: 18,
    rpcUrls: ["https://optimism-goerli.publicnode.com"],
    blockExplorerUrls: ["https://goerli-optimism.etherscan.io/"],
    type: null,
    vmType: "EVM"
  },
  waevEclipseTestnet: {
    contractAddress: null,
    chainId: 91006,
    name: "Waev Eclipse Testnet",
    symbol: "ecWAEV",
    decimals: 18,
    rpcUrls: ["https://api.evm.waev.eclipsenetwork.xyz"],
    blockExplorerUrls: ["http://waev.explorer.modular.cloud/"],
    type: null,
    vmType: "EVM"
  },
  waevEclipseDevnet: {
    contractAddress: null,
    chainId: 91006,
    name: "Waev Eclipse Devnet",
    symbol: "ecWAEV",
    decimals: 18,
    rpcUrls: ["https://api.evm.waev.dev.eclipsenetwork.xyz"],
    blockExplorerUrls: ["http://waev.explorer.modular.cloud/"],
    type: null,
    vmType: "EVM"
  },
  verifyTestnet: {
    contractAddress: null,
    chainId: 1833,
    name: "Verify Testnet",
    symbol: "MATIC",
    decimals: 18,
    rpcUrls: ["https://rpc.verify-testnet.gelato.digital"],
    blockExplorerUrls: ["https://verify-testnet.blockscout.com/"],
    type: null,
    vmType: "EVM"
  }
};
var LIT_SVM_CHAINS = {
  solana: {
    name: "Solana",
    symbol: "SOL",
    decimals: 9,
    rpcUrls: ["https://api.mainnet-beta.solana.com"],
    blockExplorerUrls: ["https://explorer.solana.com/"],
    vmType: "SVM"
  },
  solanaDevnet: {
    name: "Solana Devnet",
    symbol: "SOL",
    decimals: 9,
    rpcUrls: ["https://api.devnet.solana.com"],
    blockExplorerUrls: ["https://explorer.solana.com/"],
    vmType: "SVM"
  },
  solanaTestnet: {
    name: "Solana Testnet",
    symbol: "SOL",
    decimals: 9,
    rpcUrls: ["https://api.testnet.solana.com"],
    blockExplorerUrls: ["https://explorer.solana.com/"],
    vmType: "SVM"
  }
};
var LIT_COSMOS_CHAINS = {
  cosmos: {
    name: "Cosmos",
    symbol: "ATOM",
    decimals: 6,
    chainId: "cosmoshub-4",
    rpcUrls: ["https://lcd-cosmoshub.keplr.app"],
    blockExplorerUrls: ["https://atomscan.com/"],
    vmType: "CVM"
  },
  kyve: {
    name: "Kyve",
    symbol: "KYVE",
    decimals: 6,
    chainId: "korellia",
    rpcUrls: ["https://api.korellia.kyve.network"],
    blockExplorerUrls: ["https://explorer.kyve.network/"],
    vmType: "CVM"
  },
  evmosCosmos: {
    name: "EVMOS Cosmos",
    symbol: "EVMOS",
    decimals: 18,
    chainId: "evmos_9001-2",
    rpcUrls: ["https://rest.bd.evmos.org:1317"],
    blockExplorerUrls: ["https://evmos.bigdipper.live"],
    vmType: "CVM"
  },
  evmosCosmosTestnet: {
    name: "Evmos Cosmos Testnet",
    symbol: "EVMOS",
    decimals: 18,
    chainId: "evmos_9000-4",
    rpcUrls: ["https://rest.bd.evmos.dev:1317"],
    blockExplorerUrls: ["https://testnet.bigdipper.live"],
    vmType: "CVM"
  },
  cheqdMainnet: {
    name: "Cheqd Mainnet",
    symbol: "CHEQ",
    decimals: 9,
    chainId: "cheqd-mainnet-1",
    rpcUrls: ["https://api.cheqd.net"],
    blockExplorerUrls: ["https://explorer.cheqd.io"],
    vmType: "CVM"
  },
  cheqdTestnet: {
    name: "Cheqd Testnet",
    symbol: "CHEQ",
    decimals: 9,
    chainId: "cheqd-testnet-6",
    rpcUrls: ["https://api.cheqd.network"],
    blockExplorerUrls: ["https://testnet-explorer.cheqd.io"],
    vmType: "CVM"
  },
  juno: {
    name: "Juno",
    symbol: "JUNO",
    decimals: 6,
    chainId: "juno-1",
    rpcUrls: ["https://rest.cosmos.directory/juno"],
    blockExplorerUrls: ["https://www.mintscan.io/juno"],
    vmType: "CVM"
  }
};
var ALL_LIT_CHAINS = {
  ...LIT_CHAINS,
  ...LIT_SVM_CHAINS,
  ...LIT_COSMOS_CHAINS
};
var LOCAL_STORAGE_KEYS = {
  AUTH_COSMOS_SIGNATURE: "lit-auth-cosmos-signature",
  AUTH_SIGNATURE: "lit-auth-signature",
  AUTH_SOL_SIGNATURE: "lit-auth-sol-signature",
  WEB3_PROVIDER: "lit-web3-provider",
  KEY_PAIR: "lit-comms-keypair",
  SESSION_KEY: "lit-session-key",
  WALLET_SIGNATURE: "lit-wallet-sig"
};
var LIT_NETWORKS = {
  ["cayenne" /* Cayenne */]: [
    "https://cayenne.litgateway.com:7370",
    "https://cayenne.litgateway.com:7371",
    "https://cayenne.litgateway.com:7372"
  ],
  ["manzano" /* Manzano */]: [],
  ["habanero" /* Habanero */]: [],
  ["custom" /* Custom */]: [],
  // FIXME: Remove localhost and internalDev; replaced with 'custom' type networks
  localhost: [
    "http://localhost:7470",
    "http://localhost:7471",
    "http://localhost:7472",
    "http://localhost:7473",
    "http://localhost:7474",
    "http://localhost:7475",
    "http://localhost:7476",
    "http://localhost:7477",
    "http://localhost:7478",
    "http://localhost:7479"
  ],
  internalDev: INTERNAL_DEV
};
var AUTH_METHOD_TYPE_IDS = {
  WEBAUTHN: 3,
  DISCORD: 4,
  GOOGLE: 5,
  GOOGLE_JWT: 6
};
var RELAY_URL_CAYENNE = "https://relayer-server-staging-cayenne.getlit.dev";
var RELAY_URL_HABANERO = "https://habanero-relayer.getlit.dev";
var RELAY_URL_MANZANO = "https://manzano-relayer.getlit.dev";
var LIT_ACTION_IPFS_HASH = "QmUjX8MW6StQ7NKNdaS6g4RMkvN5hcgtKmEi8Mca6oX4t3";

// packages/constants/src/lib/interfaces/i-errors.ts
init_shim();

// packages/constants/src/lib/errors.ts
init_shim();
var LIT_ERROR = {
  INVALID_PARAM_TYPE: {
    name: "InvalidParamType",
    code: "invalid_param_type",
    kind: "Validation" /* Validation */
  },
  INVALID_ACCESS_CONTROL_CONDITIONS: {
    name: "InvalidAccessControlConditions",
    code: "invalid_access_control_conditions",
    kind: "Validation" /* Validation */
  },
  WRONG_NETWORK_EXCEPTION: {
    name: "WrongNetworkException",
    code: "wrong_network_exception",
    kind: "Validation" /* Validation */
  },
  MINTING_NOT_SUPPORTED: {
    name: "MintingNotSupported",
    code: "minting_not_supported",
    kind: "Validation" /* Validation */
  },
  UNSUPPORTED_CHAIN_EXCEPTION: {
    name: "UnsupportedChainException",
    code: "unsupported_chain_exception",
    kind: "Validation" /* Validation */
  },
  INVALID_UNIFIED_CONDITION_TYPE: {
    name: "InvalidUnifiedConditionType",
    code: "invalid_unified_condition_type",
    kind: "Validation" /* Validation */
  },
  LIT_NODE_CLIENT_NOT_READY_ERROR: {
    name: "LitNodeClientNotReadyError",
    code: "lit_node_client_not_ready_error",
    kind: "Unexpected" /* Unexpected */
  },
  UNAUTHROZIED_EXCEPTION: {
    name: "UnauthroziedException",
    code: "unauthrozied_exception",
    kind: "Validation" /* Validation */
  },
  INVALID_ARGUMENT_EXCEPTION: {
    name: "InvalidArgumentException",
    code: "invalid_argument_exception",
    kind: "Validation" /* Validation */
  },
  INVALID_BOOLEAN_EXCEPTION: {
    name: "InvalidBooleanException",
    code: "invalid_boolean_exception",
    kind: "Validation" /* Validation */
  },
  UNKNOWN_ERROR: {
    name: "UnknownError",
    code: "unknown_error",
    kind: "Unknown" /* Unknown */
  },
  NO_WALLET_EXCEPTION: {
    name: "NoWalletException",
    code: "no_wallet_exception",
    kind: "Validation" /* Validation */
  },
  WRONG_PARAM_FORMAT: {
    name: "WrongParamFormat",
    code: "wrong_param_format",
    kind: "Validation" /* Validation */
  },
  LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION: {
    name: "LocalStorageItemNotFoundException",
    code: "local_storage_item_not_found_exception",
    kind: "Unexpected" /* Unexpected */
  },
  LOCAL_STORAGE_ITEM_NOT_SET_EXCEPTION: {
    name: "LocalStorageItemNotSetException",
    code: "local_storage_item_not_set_exception",
    kind: "Unexpected" /* Unexpected */
  },
  LOCAL_STORAGE_ITEM_NOT_REMOVED_EXCEPTION: {
    name: "LocalStorageItemNotRemovedException",
    code: "local_storage_item_not_removed_exception",
    kind: "Unexpected" /* Unexpected */
  },
  REMOVED_FUNCTION_ERROR: {
    name: "RemovedFunctionError",
    code: "removed_function_error",
    kind: "Validation" /* Validation */
  },
  LIT_NODE_CLIENT_BAD_CONFIG_ERROR: {
    name: "LitNodeClientBadConfigError",
    code: "lit_node_client_bad_config_error",
    kind: "Config" /* Config */
  },
  PARAMS_MISSING_ERROR: {
    name: "ParamsMissingError",
    code: "params_missing_error",
    kind: "Validation" /* Validation */
  },
  UNKNOWN_SIGNATURE_TYPE: {
    name: "UnknownSignatureType",
    code: "unknown_signature_type",
    kind: "Validation" /* Validation */
  },
  UNKNOWN_SIGNATURE_ERROR: {
    name: "UnknownSignatureError",
    code: "unknown_signature_error",
    kind: "Validation" /* Validation */
  },
  SIGNATURE_VALIDATION_ERROR: {
    name: "InvalidSignatureError",
    code: "invalid_signature_error",
    kind: "Validation" /* Validation */
  },
  PARAM_NULL_ERROR: {
    name: "ParamNullError",
    code: "param_null_error",
    kind: "Validation" /* Validation */
  },
  UNKNOWN_DECRYPTION_ALGORITHM_TYPE_ERROR: {
    name: "UnknownDecryptionAlgorithmTypeError",
    code: "unknown_decryption_algorithm_type_error",
    kind: "Validation" /* Validation */
  },
  WASM_INIT_ERROR: {
    name: "WasmInitError",
    code: "wasm_init_error",
    kind: "Unexpected" /* Unexpected */
  },
  NODEJS_EXCEPTION: {
    name: "NodejsException",
    code: "nodejs_exception",
    kind: "Unexpected" /* Unexpected */
  },
  WALLET_SIGNATURE_NOT_FOUND_ERROR: {
    name: "WalletSignatureNotFoundError",
    code: "wallet_signature_not_found_error",
    kind: "Validation" /* Validation */
  },
  NO_VALID_SHARES: {
    name: "NoValidShares",
    code: "no_valid_shares",
    kind: "Unexpected" /* Unexpected */
  },
  INVALID_NODE_ATTESTATION: {
    name: "InvalidNodeAttestation",
    code: "invalid_node_attestation",
    kind: "Unexpected" /* Unexpected */
  },
  INVALID_ETH_BLOCKHASH: {
    name: "InvalidEthBlockhash",
    code: "invalid_eth_blockhash",
    kind: "Unexpected" /* Unexpected */
  },
  INIT_ERROR: {
    name: "InitError",
    code: "init_error",
    kind: "Unexpected" /* Unexpected */
  }
};
var LIT_ERROR_CODE = {
  NODE_NOT_AUTHORIZED: "NodeNotAuthorized"
};

// packages/constants/src/lib/utils/utils.ts
init_shim();
function ELeft(errorMsg) {
  return {
    type: "ERROR" /* ERROR */,
    result: errorMsg
  };
}
function ERight(result) {
  return {
    type: "SUCCESS" /* SUCCESS */,
    result
  };
}

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports17 = {};
__export(lib_exports17, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
init_shim();
init_lib5();

// node_modules/@ethersproject/networks/lib.esm/index.js
init_shim();
init_lib();

// node_modules/@ethersproject/networks/lib.esm/_version.js
init_shim();
var version7 = "networks/5.7.1";

// node_modules/@ethersproject/networks/lib.esm/index.js
var logger6 = new Logger(version7);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks) {
      const standard2 = networks[name];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger6.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger6.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
init_shim();
init_lib5();
init_lib6();
init_lib7();
init_lib3();
init_lib2();
init_lib8();
init_lib14();
init_lib4();
init_lib15();
init_lib10();
init_lib16();
var import_bech32 = __toESM(require_bech32());
init_lib();

// node_modules/@ethersproject/providers/lib.esm/_version.js
init_shim();
var version14 = "providers/5.7.2";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
init_shim();
init_lib13();
init_lib3();
init_lib2();
init_lib8();
init_lib4();
init_lib18();
init_lib();
var logger16 = new Logger(version14);
var Formatter = class _Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v) => {
      return this.data(v, true);
    };
    formats.transaction = {
      hash: hash3,
      type,
      accessList: _Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: _Formatter.allowNull(hash3, null),
      blockNumber: _Formatter.allowNull(number, null),
      transactionIndex: _Formatter.allowNull(number, null),
      confirmations: _Formatter.allowNull(number, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: _Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
      maxFeePerGas: _Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: _Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: _Formatter.allowNull(this.uint256),
      s: _Formatter.allowNull(this.uint256),
      v: _Formatter.allowNull(number),
      creates: _Formatter.allowNull(address, null),
      raw: _Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: _Formatter.allowNull(address),
      nonce: _Formatter.allowNull(number),
      gasLimit: _Formatter.allowNull(bigNumber),
      gasPrice: _Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
      maxFeePerGas: _Formatter.allowNull(bigNumber),
      to: _Formatter.allowNull(address),
      value: _Formatter.allowNull(bigNumber),
      data: _Formatter.allowNull(strictData),
      type: _Formatter.allowNull(number),
      accessList: _Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash3,
      address,
      topics: _Formatter.arrayOf(hash3),
      data,
      logIndex: number,
      blockHash: hash3
    };
    formats.receipt = {
      to: _Formatter.allowNull(this.address, null),
      from: _Formatter.allowNull(this.address, null),
      contractAddress: _Formatter.allowNull(address, null),
      transactionIndex: number,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: _Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: _Formatter.allowNull(data),
      blockHash: hash3,
      transactionHash: hash3,
      logs: _Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: _Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: _Formatter.allowNull(bigNumber),
      status: _Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: _Formatter.allowNull(hash3),
      parentHash: hash3,
      number,
      timestamp: number,
      nonce: _Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: _Formatter.allowNull(address),
      extraData: data,
      transactions: _Formatter.allowNull(_Formatter.arrayOf(hash3)),
      baseFeePerGas: _Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = _Formatter.allowNull(_Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: _Formatter.allowNull(blockTag, void 0),
      toBlock: _Formatter.allowNull(blockTag, void 0),
      blockHash: _Formatter.allowNull(hash3, void 0),
      address: _Formatter.allowNull(address, void 0),
      topics: _Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: _Formatter.allowNull(number),
      blockHash: _Formatter.allowNull(hash3),
      transactionIndex: number,
      removed: _Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: _Formatter.allowFalsish(data, "0x"),
      topics: _Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger16.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger16.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v = BigNumber.from(value);
    try {
      return v.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = _Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return _Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = _Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return _Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = _Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger16.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger16.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger16.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return _Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return _Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger17 = new Logger(version14);
var MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger17.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger17.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event2 = class {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger17.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data = arrayify(datas[i2]);
    result[i2] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
var Resolver = class {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter6(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger17.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter6(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger17.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version28 = bytes[0];
      if (version28 === 0) {
        if (length !== 20 && length !== 32) {
          version28 = -1;
        }
      } else {
        version28 = -1;
      }
      if (version28 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words2 = import_bech32.default.toWords(bytes.slice(2));
        words2.unshift(version28);
        return import_bech32.default.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger17.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter6(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match = avatar.match(matchers[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter6(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash3 = encode("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
          return "sia://" + hash3;
        }
      }
      return logger17.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter6(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger17.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger17.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i2 = 0; i2 < urls.length; i2++) {
        const url = urls[i2];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger17.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger17.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter6(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger17.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger17.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter = event.filter;
              filter.fromBlock = event._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter.fromBlock) {
                filter.fromBlock = minFromBlock;
              }
              if (filter.fromBlock < 0) {
                filter.fromBlock = 0;
              }
              const runner = this.getLogs(filter).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log3) => {
                  if (log3.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log3.blockNumber;
                  }
                  this._emitted["b:" + log3.blockHash] = log3.blockNumber;
                  this._emitted["t:" + log3.transactionHash] = log3.blockNumber;
                  this.emit(filter, log3);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter6(this, void 0, void 0, function* () {
      return logger17.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter6(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger17.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter6(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter6(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter6(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter6(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger17.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger17.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter6(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p) => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger17.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout) => __awaiter6(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger17.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter6(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v) => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v) => v ? BigNumber.from(v) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v) => v != null ? v : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v) => v ? hexlify(v) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter6(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = filter[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger17.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger17.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
              logger17.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger17.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger17.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger17.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter6(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger17.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger17.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger17.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter6(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log3) => {
        if (log3.removed == null) {
          log3.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter6(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger17.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name) {
    return __awaiter6(this, void 0, void 0, function* () {
      let currentName = name;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name);
          if (currentName !== name && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name, operation) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger17.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name) {
    return __awaiter6(this, void 0, void 0, function* () {
      name = yield name;
      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        if (isHexString(name)) {
          throw error;
        }
      }
      if (typeof name !== "string") {
        logger17.throwArgumentError("invalid ENS name", "name", name);
      }
      const resolver = yield this.getResolver(name);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter6(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name);
      if (addr != address) {
        return null;
      }
      return name;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter6(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger17.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event2(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_shim();
init_lib4();

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_shim();
init_lib3();
init_lib4();

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
init_shim();
init_lib19();
init_lib3();
init_lib2();
init_lib14();
init_lib4();
init_lib10();
init_lib18();
init_lib16();
init_lib();
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger19 = new Logger(version14);
var errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger19.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger19.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger19.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger19.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger19.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger19.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger19.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard3 = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard3) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger19.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger19.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard3, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger19.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter8(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger19.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger19.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger19.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger19.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter8(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter8(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter8(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger19.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter8(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger19.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter8(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
        return this.provider.resolveName(name);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger19.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter8(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter8(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger19.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger19.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard3, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger19.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys3);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ws.js
init_shim();
init_lib();
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger47 = new Logger(version14);
  WS = function() {
    logger47.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_lib();
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger20 = new Logger(version14);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger20.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger20.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger20.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter9(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger20.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter9(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e2) => e2.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e2) => e2.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter9(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_lib();

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
init_shim();
init_lib4();
init_lib();
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger21 = new Logger(version14);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter10(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger21.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class _UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger21.checkAbstract(new.target, _UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger21.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger21.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger21.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger22 = new Logger(version14);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger22.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger22.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
init_shim();
init_lib();
var logger23 = new Logger(version14);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger23.throwArgumentError("unsupported network", "name", name);
}
var AnkrProvider = class extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
};

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
init_shim();
init_lib();
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger24 = new Logger(version14);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger24.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger24.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter11(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
init_shim();
init_lib2();
init_lib4();
init_lib18();
init_lib16();
init_lib();
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger25 = new Logger(version14);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e2 = error.error;
    if (e2 && (e2.message.match(/reverted/i) || e2.message.match(/VM execution error/i))) {
      let data = e2.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger25.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger25.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger25.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger25.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger25.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    return logger25.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key2) => {
      const value = params[key2];
      if (value != null) {
        accum += `&${key2}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module2}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module2, params, post) {
    return __awaiter12(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module2, params);
      const payload = post ? this.getPostData(module2, params) : null;
      const procFunc = module2 === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key2) => {
          return `${key2}=${payload[key2]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter12(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter12(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger25.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger25.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i2 = 0; i2 < logs.length; i2++) {
            const log3 = logs[i2];
            if (log3.blockHash != null) {
              continue;
            }
            if (blocks[log3.blockNumber] == null) {
              const block = yield this.getBlock(log3.blockNumber);
              if (block) {
                blocks[log3.blockNumber] = block.hash;
              }
            }
            log3.blockHash = blocks[log3.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter12(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key2) {
          if (tx[key2] == "") {
            delete tx[key2];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
init_shim();
init_lib5();
init_lib3();
init_lib2();
init_lib4();
init_lib20();
init_lib16();
init_lib();
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger27 = new Logger(version14);
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i2 = 0; i2 < networks2.length; i2++) {
    const network = networks2[i2];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger27.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b = values[middle];
  if (maxDelta != null && Math.abs(a2 - b) > maxDelta) {
    return null;
  }
  return (a2 + b) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i2) => serialize2(i2)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key2) => {
      let v = value[key2];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize2(v);
      }
      return JSON.stringify(key2) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize2, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c) => {
      const value = normalize2(c.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const check = tally[keys[i2]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize2 = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c) => c.result);
        let blockNumber = median(configs.map((c) => c.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c) => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c) => c.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize2 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize2, provider.quorum);
}
function waitForSync(config, blockNumber) {
  return __awaiter13(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter13(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger27.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger27.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config = shallowCopy(configOrProvider);
      if (config.priority == null) {
        config.priority = 1;
      }
      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config.weight == null) {
        config.weight = 1;
      }
      const weight = config.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger27.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger27.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c) => c.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter13(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c) => {
          return c.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i3 = 0; i3 < results.length; i3++) {
          const result = results[i3];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a2, b) => a2.priority - b.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i2 = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c) => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
        while (inflightWeight < this.quorum && i2 < configs.length) {
          const config = configs[i2++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall2(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
            config.done = true;
            config.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config.done = true;
            config.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config.weight;
        }
        const waiting = [];
        configs.forEach((c) => {
          if (c.done || !c.runner) {
            return;
          }
          waiting.push(c.runner);
          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c) => c.done && c.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c) => {
              if (c.staller) {
                c.staller.cancel();
              }
              c.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall2(100).getPromise();
          }
          first = false;
        }
        const errors = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }
          const code = c.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c.error, weight: 0 };
            }
            accum[code].weight += c.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c) => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          const e2 = tally.error;
          const props = {};
          ForwardProperties.forEach((name) => {
            if (e2[name] == null) {
              return;
            }
            props[name] = e2[name];
          });
          logger27.throwError(e2.reason || e2.message, errorCode, props);
        });
        if (configs.filter((c) => !c.done).length === 0) {
          break;
        }
      }
      configs.forEach((c) => {
        if (c.staller) {
          c.staller.cancel();
        }
        c.cancelled = true;
      });
      return logger27.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map((c) => exposeDebugConfig(c)),
        provider: this
      });
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
init_shim();
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
init_shim();
init_lib4();
init_lib();
var logger28 = new Logger(version14);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger28.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger28.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger28.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger28.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
init_shim();
init_lib4();
init_lib16();
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
init_shim();
init_lib();
var logger29 = new Logger(version14);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger29.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger29.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger29.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
init_shim();
init_lib();
var logger30 = new Logger(version14);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
var PocketProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger30.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger30.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
init_shim();
init_lib4();
init_lib();
var logger31 = new Logger(version14);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger31.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger31.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@ethersproject/providers/lib.esm/index.js
init_lib();
var logger32 = new Logger(version14);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger32.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n2 = getNetwork(network);
  if (!n2 || !n2._defaultProvider) {
    logger32.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n2._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/@ethersproject/contracts/lib.esm/index.js
init_shim();
init_lib21();
init_lib5();
init_lib19();
init_lib13();
init_lib3();
init_lib2();
init_lib4();
init_lib18();
init_lib();

// node_modules/@ethersproject/contracts/lib.esm/_version.js
init_shim();
var version20 = "contracts/5.7.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger38 = new Logger(version20);
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter14(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger38.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger38.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger38.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter14(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger38.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter14(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger38.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter14(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger38.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        intrinsic += 4;
        if (bytes[i2]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger38.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger38.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger38.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log3) => {
        let event = deepCopy(log3);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log3);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter14(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger38.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag2(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i2) => i2.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger38.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag2(filter), filter);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger38.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name) => {
        const filters = uniqueFilters[name];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name, this.filters[filters[0]]);
        } else {
          logger38.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger38.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger38.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger38.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name = fragment.name;
        if (!uniqueNames[`%${name}`]) {
          uniqueNames[`%${name}`] = [];
        }
        uniqueNames[`%${name}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name) => {
      const signatures = uniqueNames[name];
      if (signatures.length > 1) {
        return;
      }
      name = name.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name] == null) {
          defineReadOnly(this, name, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name] == null) {
        defineReadOnly(this.functions, name, this.functions[signature2]);
      }
      if (this.callStatic[name] == null) {
        defineReadOnly(this.callStatic, name, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name] == null) {
        defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name] == null) {
        defineReadOnly(this.estimateGas, name, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger38.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger38.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger38.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag2(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log3, listener) {
    const event = deepCopy(log3);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log3.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log3.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log3.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger38.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log3) => {
        let event = this._wrapEvent(runningEvent, log3, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger38.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log3) => this._wrapEvent(runningEvent, log3, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger38.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger38.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys4[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger38.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger38.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger38.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter14(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger38.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger38.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// packages/logger/src/index.ts
init_shim();

// packages/logger/src/lib/logger.ts
init_shim();
var import_utils3 = __toESM(require_utils2());
var colours = {
  reset: "\x1B[0m",
  bright: "\x1B[1m",
  dim: "\x1B[2m",
  underscore: "\x1B[4m",
  blink: "\x1B[5m",
  reverse: "\x1B[7m",
  hidden: "\x1B[8m",
  fg: {
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
    gray: "\x1B[90m",
    crimson: "\x1B[38m"
    // Scarlet
  },
  bg: {
    black: "\x1B[40m",
    red: "\x1B[41m",
    green: "\x1B[42m",
    yellow: "\x1B[43m",
    blue: "\x1B[44m",
    magenta: "\x1B[45m",
    cyan: "\x1B[46m",
    white: "\x1B[47m",
    gray: "\x1B[100m",
    crimson: "\x1B[48m"
  }
};
function _convertLoggingLevel(level) {
  switch (level) {
    case 0 /* INFO */:
      return `${colours.fg.green}[INFO]${colours.reset}`;
    case 1 /* DEBUG */:
      return `${colours.fg.cyan}[DEBUG]${colours.reset}`;
    case 2 /* WARN */:
      return `${colours.fg.yellow}[WARN]${colours.reset}`;
    case 3 /* ERROR */:
      return `${colours.fg.red}[ERROR]${colours.reset}`;
    case 4 /* FATAL */:
      return `${colours.fg.red}[FATAL]${colours.reset}`;
    case 5 /* TIMING_START */:
      return `${colours.fg.green}[TIME_START]${colours.reset}`;
    case 6 /* TIMING_END */:
      return `${colours.fg.green}[TIME_END]${colours.reset}`;
  }
  return "[UNKNOWN]";
}
function _resolveLoggingHandler(level) {
  switch (level) {
    case 1 /* DEBUG */:
      return console.debug;
    case 0 /* INFO */:
      return console.info;
    case 3 /* ERROR */:
      return console.error;
    case 2 /* WARN */:
      return console.warn;
    case 4 /* FATAL */:
      return console.error;
    case 6 /* TIMING_END */:
      return console.timeLog;
    case 5 /* TIMING_START */:
      return console.time;
  }
}
function _safeStringify(obj, indent = 2) {
  let cache = [];
  const retVal = JSON.stringify(
    obj,
    (_key, value) => typeof value === "object" && value !== null ? cache?.includes(value) ? void 0 : cache?.push(value) && value : value,
    indent
  );
  cache = null;
  return retVal;
}
var Log = class {
  constructor(timestamp, message, args, id2, category, level) {
    this.timestamp = timestamp;
    this.message = message;
    this.args = args;
    this.id = id2;
    this.category = category;
    this.level = level;
  }
  toString() {
    var fmtStr = `[Lit-JS-SDK v${version}]${_convertLoggingLevel(
      this.level
    )} [${this.category}] [id: ${this.id}] ${this.message}`;
    for (var i2 = 0; i2 < this.args.length; i2++) {
      if (typeof this.args[i2] === "object") {
        fmtStr = `${fmtStr} ${_safeStringify(this.args[i2])}`;
      } else {
        fmtStr = `${fmtStr} ${this.args[i2]}`;
      }
    }
    return fmtStr;
  }
  toArray() {
    let args = [];
    args.push(`[Lit-JS-SDK v${version}]`);
    args.push(`[${this.timestamp}]`);
    args.push(_convertLoggingLevel(this.level));
    args.push(`[${this.category}]`);
    this.id && args.push(`${colours.fg.cyan}[id: ${this.id}]${colours.reset}`);
    this.message && args.push(this.message);
    for (var i2 = 0; i2 < this.args.length; i2++) {
      args.push(this.args[i2]);
    }
    return args;
  }
  toJSON() {
    return {
      timestamp: this.timestamp,
      message: this.message,
      args: this.args,
      id: this.id,
      category: this.category,
      level: this.level
    };
  }
};
var Logger2 = class _Logger {
  constructor(category, level, id2, isParent, config) {
    this._logs = [];
    this._logHashes = /* @__PURE__ */ new Map();
    this._category = category;
    this._level = level;
    this._id = id2;
    this._consoleHandler = _resolveLoggingHandler(this._level);
    this._config = config;
    this._children = /* @__PURE__ */ new Map();
    this._isParent = isParent;
  }
  static createLogger(category, level, id2, isParent, config) {
    return new _Logger(category, level, id2, isParent, config);
  }
  get id() {
    return this._id;
  }
  get category() {
    return this._category;
  }
  get Logs() {
    return this._logs;
  }
  set Config(value) {
    this._config = value;
  }
  get Config() {
    return this._config;
  }
  get Children() {
    return this._children;
  }
  setLevel(level) {
    this._level = level;
  }
  setHandler(handler) {
    this._handler = handler;
  }
  info(message = "", ...args) {
    this._log(0 /* INFO */, message, ...args);
  }
  debug(message = "", ...args) {
    this._log(1 /* DEBUG */, message, ...args);
  }
  warn(message = "", ...args) {
    this._log(2 /* WARN */, message, args);
  }
  error(message = "", ...args) {
    this._log(3 /* ERROR */, message, ...args);
  }
  fatal(message = "", ...args) {
    this._log(4 /* FATAL */, message, ...args);
  }
  trace(message = "", ...args) {
    this._log(4 /* FATAL */, message, ...args);
  }
  timeStart(message = "", ...args) {
    this._log(5 /* TIMING_START */, message, ...args);
  }
  timeEnd(message = "", ...args) {
    this._level < -1 /* OFF */ && this._log(6 /* TIMING_END */, message, ...args);
  }
  _log(level, message = "", ...args) {
    const log3 = new Log(
      (/* @__PURE__ */ new Date()).toISOString(),
      message,
      args,
      this._id,
      this._category,
      level
    );
    const arrayLog = log3.toArray();
    if (this._config?.["condenseLogs"] && !this._checkHash(log3)) {
      (this._level >= level || level === 3 /* ERROR */) && this._consoleHandler(...arrayLog);
      (this._level >= level || level === 3 /* ERROR */) && this._handler && this._handler(log3);
      (this._level >= level || level === 3 /* ERROR */) && this._addLog(log3);
    } else if (!this._config?.["condenseLogs"]) {
      (this._level >= level || level === 3 /* ERROR */) && this._consoleHandler(...arrayLog);
      (this._level >= level || level === 3 /* ERROR */) && this._handler && this._handler(log3);
      (this._level >= level || level === 3 /* ERROR */) && this._addLog(log3);
    }
  }
  _checkHash(log3) {
    const digest = (0, import_utils3.hashMessage)(log3.message);
    const hash3 = digest.toString();
    let item = this._logHashes.get(hash3);
    if (item) {
      return true;
    } else {
      this._logHashes.set(hash3, true);
      return false;
    }
  }
  _addLog(log3) {
    this._logs.push(log3);
  }
  _addToLocalStorage(log3) {
    if (globalThis.localStorage) {
      let bucket = globalThis.localStorage.getItem(log3.category);
      if (bucket) {
        bucket = JSON.parse(bucket);
        if (!bucket[log3.id]) {
          bucket[log3.id] = [];
        }
        bucket[log3.id].push(log3.toString());
        globalThis.localStorage.setItem(log3.category, _safeStringify(bucket));
      } else {
        const bucket2 = {};
        bucket2[log3.id] = [log3.toString()];
        globalThis.localStorage.setItem(log3.category, _safeStringify(bucket2));
      }
    }
  }
};
var LogManager = class _LogManager {
  constructor() {
    this._level = 1 /* DEBUG */;
    this._loggers = /* @__PURE__ */ new Map();
  }
  static get Instance() {
    if (!_LogManager._instance) {
      _LogManager._instance = new _LogManager();
    }
    return _LogManager._instance;
  }
  static clearInstance() {
    _LogManager._instance = void 0;
  }
  withConfig(config) {
    this._config = config;
    for (const logger47 of this._loggers) {
      logger47[1].Config = config;
    }
  }
  setLevel(level) {
    this._level = level;
    for (const logger47 of this._loggers) {
      logger47[1].setLevel(level);
    }
  }
  setHandler(handler) {
    for (const logger47 of this._loggers) {
      logger47[1].setHandler(handler);
    }
  }
  // if a logger is given an id it will persist logs under its logger instance
  get(category, id2) {
    let instance = this._loggers.get(category);
    if (!instance && !id2) {
      this._loggers.set(
        category,
        Logger2.createLogger(category, this._level ?? 0 /* INFO */, "", true)
      );
      instance = this._loggers.get(category);
      instance.Config = this._config;
      return instance;
    }
    if (id2) {
      if (!instance) {
        this._loggers.set(
          category,
          Logger2.createLogger(category, this._level ?? 0 /* INFO */, "", true)
        );
        instance = this._loggers.get(category);
        instance.Config = this._config;
      }
      let children = instance?.Children;
      let child = children?.get(id2);
      if (child) {
        return child;
      }
      children?.set(
        id2,
        Logger2.createLogger(
          category,
          this._level ?? 0 /* INFO */,
          id2 ?? "",
          true
        )
      );
      child = children?.get(id2);
      child.Config = this._config;
      return children?.get(id2);
    } else if (!instance) {
      this._loggers.set(
        category,
        Logger2.createLogger(category, this._level ?? 0 /* INFO */, "", true)
      );
      instance = this._loggers.get(category);
      instance.Config = this._config;
    }
    return instance;
  }
  getById(id2) {
    let logStrs = [];
    for (const category of this._loggers.entries()) {
      let logger47 = category[1].Children.get(id2);
      if (logger47) {
        let logStr = [];
        for (const log3 of logger47.Logs) {
          logStr.push(log3.toString());
        }
        logStrs = logStrs.concat(logStr);
      }
    }
    return logStrs;
  }
  getLogsForId(id2) {
    let logsForRequest = this.getById(id2);
    if (logsForRequest.length < 1 && globalThis.localStorage) {
      for (const category of this._loggers.keys()) {
        let bucketStr = globalThis.localStorage.getItem(category);
        let bucket = JSON.parse(
          bucketStr
        );
        if (bucket && bucket[id2]) {
          const logsForId = bucket[id2].filter(
            (log3) => log3.includes(id2)
          );
          logsForRequest = logsForId.concat(logsForRequest);
        }
      }
    }
    return logsForRequest;
  }
};

// packages/misc/src/lib/misc.ts
import Ajv from "ajv";
var logBuffer = [];
var ajv = new Ajv();
var mostCommonString = (arr) => {
  return arr.sort(
    (a2, b) => arr.filter((v) => v === a2).length - arr.filter((v) => v === b).length
  ).pop();
};
var throwError = (e2) => {
  if (isNodeClientErrorV1(e2)) {
    return throwErrorV1(e2);
  } else if (isNodeClientErrorV0(e2)) {
    return throwErrorV0(e2);
  }
  return throwGenericError(e2);
};
var throwErrorV0 = ({
  message,
  name,
  errorCode,
  error
}) => {
  const errConstructorFunc = function(message2, name2, errorCode2) {
    this.message = message2;
    this.name = name2;
    this.errorCode = oldErrorToNewErrorMap[errorCode2] ?? errorCode2;
  };
  throw new errConstructorFunc(
    message,
    name = error?.name ?? name,
    errorCode = error?.code ?? errorCode
  );
};
var oldErrorToNewErrorMap = {
  not_authorized: "NodeNotAuthorized",
  storage_error: "NodeStorageError"
};
var throwErrorV1 = ({
  errorKind,
  details,
  status,
  message,
  errorCode,
  requestId
}) => {
  const errConstructorFunc = function(errorKind2, status2, details2, message2, errorCode2, requestId2) {
    this.message = message2;
    this.errorCode = errorCode2;
    this.errorKind = errorKind2;
    this.status = status2;
    this.details = details2;
    this.requestId = requestId2;
  };
  throw new errConstructorFunc(
    errorKind,
    status,
    details,
    message,
    errorCode,
    requestId
  );
};
var throwGenericError = (e2) => {
  const errConstructorFunc = function(message) {
    this.message = message;
    this.errorKind = LIT_ERROR.UNKNOWN_ERROR.name;
    this.errorCode = LIT_ERROR.UNKNOWN_ERROR.code;
  };
  throw new errConstructorFunc(e2.message ?? "Generic Error");
};
var isNodeClientErrorV1 = (nodeError) => {
  return nodeError.hasOwnProperty("errorCode") && nodeError.hasOwnProperty("errorKind");
};
var isNodeClientErrorV0 = (nodeError) => {
  return nodeError.hasOwnProperty("errorCode");
};
var bootstrapLogManager = (id2, level = 1 /* DEBUG */) => {
  if (!globalThis.logManager) {
    globalThis.logManager = LogManager.Instance;
    globalThis.logManager.withConfig({
      condenseLogs: true
    });
    globalThis.logManager.setLevel(level);
  }
  globalThis.logger = globalThis.logManager.get(id2);
};
var getLoggerbyId = (id2) => {
  return globalThis.logManager.get(id2);
};
var log = (...args) => {
  if (isNode()) {
    if (process.env["DEBUG"] === "false") {
      return;
    }
  }
  if (!globalThis) {
    console.log(...args);
    return;
  }
  if (!globalThis?.litConfig) {
    logBuffer.push(args);
    return;
  }
  if (globalThis?.litConfig?.debug !== true) {
    return;
  }
  while (logBuffer.length > 0) {
    const log3 = logBuffer.shift() ?? "";
    globalThis?.logger && globalThis?.logger.debug(...log3);
  }
  globalThis?.logger && globalThis?.logger.debug(...args);
  if (isNode()) {
    try {
      const fs = __require("fs");
      const message = args.map(
        (arg) => typeof arg === "object" ? JSON.stringify(arg) : arg
      ).join(" ");
      if (!fs.existsSync("./logs")) {
        fs.mkdirSync("./logs");
      }
      const processArgs = process.argv.slice(2);
      const processArgsString = processArgs.map((arg) => arg.split("=")[1]).join("_");
      const date = /* @__PURE__ */ new Date();
      const currentDate = date.toISOString().split("T")[0].replaceAll("-", "_");
      const filename = `${currentDate}_${processArgsString}.log`;
      fs.appendFileSync(
        process.env["LOG_FILE" /* LOG_FILE */] ? `./logs/${process.env["LOG_FILE" /* LOG_FILE */]}` : `./logs/${filename}`,
        `${(/* @__PURE__ */ new Date()).toISOString()} ${message}
`
      );
    } catch (e2) {
      console.log("[misc][log] all cool, just logging to console.");
    }
  }
};
var logWithRequestId = (id2, ...args) => {
  if (!globalThis) {
    console.log(...args);
    return;
  }
  if (!globalThis?.litConfig) {
    logBuffer.push(args);
    return;
  }
  if (globalThis?.litConfig?.debug !== true) {
    return;
  }
  while (logBuffer.length > 0) {
    const log3 = logBuffer.shift() ?? "";
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id2).debug(...log3);
  }
  globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id2).debug(...args);
};
var logErrorWithRequestId = (id2, ...args) => {
  if (!globalThis) {
    console.log(...args);
    return;
  }
  if (!globalThis?.litConfig) {
    logBuffer.push(args);
    return;
  }
  if (globalThis?.litConfig?.debug !== true) {
    return;
  }
  while (logBuffer.length > 0) {
    const log3 = logBuffer.shift() ?? "";
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id2).error(...log3);
  }
  globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id2).error(...args);
};
var logError = (...args) => {
  if (!globalThis) {
    console.log(...args);
    return;
  }
  if (!globalThis?.litConfig) {
    logBuffer.push(args);
    return;
  }
  if (globalThis?.litConfig?.debug !== true) {
    return;
  }
  while (logBuffer.length > 0) {
    const log3 = logBuffer.shift() ?? "";
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category).error(...log3);
  }
  globalThis?.logger && globalThis.logManager.get(globalThis.logger.category).error(...args);
};
var getVarType = (value) => {
  return Object.prototype.toString.call(value).slice(8, -1);
};
var checkType = ({
  value,
  allowedTypes,
  paramName,
  functionName,
  throwOnError = true
}) => {
  if (!allowedTypes.includes(getVarType(value))) {
    const message = `Expecting ${allowedTypes.join(
      " or "
    )} type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${getVarType(
      value
    )}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
    if (throwOnError) {
      throwError({
        message,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    }
    return false;
  }
  return true;
};
var checkSchema = (value, schema, paramName, functionName, throwOnError = true) => {
  let validate5 = schema.$id ? ajv.getSchema(schema.$id) : void 0;
  if (!validate5) {
    validate5 = ajv.compile(schema);
  }
  const validates = validate5(value);
  const message = `FAILED schema validation for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(). Value: ${value instanceof Object ? JSON.stringify(value) : value}. Errors: ${JSON.stringify(validate5.errors)}`;
  if (!validates) {
    if (throwOnError) {
      throwError({
        message,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    }
    return false;
  }
  return true;
};
var checkIfAuthSigRequiresChainParam = (authSig, chain, functionName) => {
  log("checkIfAuthSigRequiresChainParam");
  for (const key2 of LIT_AUTH_SIG_CHAIN_KEYS) {
    if (key2 in authSig) {
      return true;
    }
  }
  if (!checkType({
    value: chain,
    allowedTypes: ["String"],
    paramName: "chain",
    functionName
  })) {
    return false;
  }
  return true;
};
var sortedObject = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(sortedObject);
  }
  const sortedKeys = Object.keys(obj).sort();
  const result = {};
  sortedKeys.forEach((key2) => {
    result[key2] = sortedObject(obj[key2]);
  });
  return result;
};
var numberToHex = (v) => {
  return "0x" + v.toString(16);
};
var is = (value, type, paramName, functionName, throwOnError = true) => {
  if (getVarType(value) !== type) {
    let message = `Expecting "${type}" type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${getVarType(
      value
    )}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
    if (throwOnError) {
      throwError({
        message,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    }
    return false;
  }
  return true;
};
var convertLitActionsParams = (jsParams) => {
  const convertedParams = {};
  for (const [key2, value] of Object.entries(jsParams)) {
    const _key = key2;
    const _value = value;
    const varType = getVarType(_value);
    if (varType === "Uint8Array") {
      convertedParams[_key] = Array.from(_value);
    } else if (varType === "Object") {
      convertedParams[_key] = convertLitActionsParams(_value);
    } else {
      convertedParams[_key] = _value;
    }
  }
  return convertedParams;
};
var isNode = () => {
  var isNode3 = false;
  if (typeof process === "object") {
    if (typeof process.versions === "object") {
      if (typeof process.versions.node !== "undefined") {
        isNode3 = true;
      }
    }
  }
  return isNode3;
};
var isBrowser = () => {
  return isNode() === false;
};
var defaultMintClaimCallback = async (params, network = "cayenne") => {
  try {
    let relayUrl = "";
    switch (network) {
      case "cayenne" /* Cayenne */:
        relayUrl = RELAY_URL_CAYENNE + "/auth/claim";
        break;
      case "habanero" /* Habanero */:
        relayUrl = RELAY_URL_HABANERO + "auth/claim";
        break;
      case "manzano" /* Manzano */:
        relayUrl = RELAY_URL_MANZANO + "auth/claim";
    }
    const url = params.relayUrl ? params.relayUrl : relayUrl;
    const response = await fetch(url, {
      method: "POST",
      body: JSON.stringify(params),
      headers: {
        "api-key": params.relayApiKey ? params.relayApiKey : "67e55044-10b1-426f-9247-bb680e5fe0c8_relayer",
        "Content-Type": "application/json"
      }
    });
    if (response.status < 200 || response.status >= 400) {
      let errResp = await response.json() ?? "";
      let errStmt = `An error occured requesting "/auth/claim" endpoint ${JSON.stringify(
        errResp
      )}`;
      console.warn(errStmt);
      throw new Error(errStmt);
    }
    let body = await response.json();
    return body.requestId;
  } catch (e2) {
    console.error(e2.message);
    throw e2;
  }
};
var hexPrefixed = (str) => {
  if (str.startsWith("0x")) {
    return str;
  }
  return "0x" + str;
};
function sendRequest(url, req, requestId) {
  return fetch(url, req).then(async (response) => {
    const isJson = response.headers.get("content-type")?.includes("application/json");
    const data = isJson ? await response.json() : null;
    if (!response.ok) {
      const error = data || response.status;
      return Promise.reject(error);
    }
    return data;
  }).catch((error) => {
    logErrorWithRequestId(
      requestId,
      `Something went wrong, internal id for request: lit_${requestId}. Please provide this identifier with any support requests. ${error?.message || error?.details ? `Error is ${error.message} - ${error.details}` : ""}`
    );
    return Promise.reject(error);
  });
}
async function executeWithRetry(execCallback, errorCallback, opts) {
  let timer2;
  let counter = 0;
  let isTimeout = false;
  if (!opts) {
    opts = {};
  }
  opts.timeout = opts.timeout ?? 31e3;
  opts.interval = opts.interval ?? 100;
  opts.maxRetryCount = opts.maxRetryCount ?? 3;
  let requestId = "";
  while (!isTimeout) {
    requestId = Math.random().toString(16).slice(2);
    try {
      timer2 = setTimeout(() => {
        isTimeout = true;
      }, opts.timeout);
      const response = await execCallback(requestId);
      clearTimeout(timer2);
      response.requestId = requestId;
      if ("error" in response) {
        counter += 1;
        errorCallback && errorCallback(
          response,
          requestId,
          counter >= opts.maxRetryCount ? true : false
        );
      } else {
        clearTimeout(timer2);
        return response;
      }
      if (counter >= opts.maxRetryCount) {
        return response;
      }
    } catch (err) {
      errorCallback && errorCallback(
        `Error is ${err.message}-${err.details}`,
        requestId,
        counter >= opts.maxRetryCount ? true : false
      );
      counter += 1;
    }
    await new Promise((resolve) => setTimeout(resolve, opts?.interval));
  }
  return {
    success: false,
    error: {
      errorKind: "Timeout",
      status: 500,
      details: [`timeout limit reached timeout limit: ${opts.timeout}ms`]
    },
    requestId
  };
}
function normalizeAndStringify(input) {
  try {
    if (!input.startsWith("{") && !input.startsWith("[")) {
      return input;
    }
    const parsed = JSON.parse(input);
    return JSON.stringify(parsed);
  } catch (error) {
    const unescaped = input.replace(/\\(.)/g, "$1");
    if (input === unescaped) {
      return input;
    }
    return normalizeAndStringify(unescaped);
  }
}

// packages/lit-node-client/src/lib/lit-node-client.ts
init_shim();

// packages/lit-node-client-nodejs/src/index.ts
init_shim();

// packages/lit-node-client-nodejs/src/lib/lit-node-client-nodejs.ts
init_shim();
init_lib18();

// node_modules/ethers/lib.esm/index.js
init_shim();

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports6,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports17,
  utils: () => utils_exports,
  version: () => version27,
  wordlists: () => wordlists
});
init_shim();
init_lib3();
init_lib19();
init_lib28();
init_lib8();
init_lib23();

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports9,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports4,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
init_shim();
init_lib21();
init_lib13();
init_lib6();
init_lib7();
init_lib2();
init_lib14();
init_lib24();
init_lib25();
init_lib9();
init_lib();
init_lib15();
init_lib26();
init_lib20();
init_lib4();
init_lib12();
init_lib17();
init_lib10();
init_lib18();
init_lib27();
init_lib28();
init_lib16();
init_lib15();
init_lib10();

// node_modules/ethers/lib.esm/ethers.js
init_lib();

// node_modules/ethers/lib.esm/_version.js
init_shim();
var version27 = "ethers/5.7.2";

// node_modules/ethers/lib.esm/ethers.js
var logger46 = new Logger(version27);

// node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers_exports;
  }
} catch (error) {
}

// packages/lit-node-client-nodejs/src/lib/lit-node-client-nodejs.ts
var import_utils10 = __toESM(require_utils2());
import * as siwe2 from "siwe";

// packages/access-control-conditions/src/index.ts
init_shim();

// packages/access-control-conditions/src/lib/canonicalFormatter.ts
init_shim();
var getOperatorParam = (cond) => {
  const _cond = cond;
  return {
    operator: _cond.operator
  };
};
var canonicalAbiParamss = (params) => {
  return params.map((param) => ({
    name: param.name,
    type: param.type
  }));
};
var canonicalUnifiedAccessControlConditionFormatter = (cond) => {
  if (Array.isArray(cond)) {
    return cond.map((c) => canonicalUnifiedAccessControlConditionFormatter(c));
  }
  if ("operator" in cond) {
    return getOperatorParam(cond);
  }
  if ("returnValueTest" in cond) {
    const _cond = cond;
    const _conditionType = _cond.conditionType;
    switch (_conditionType) {
      case "solRpc":
        return canonicalSolRpcConditionFormatter(cond, true);
      case "evmBasic":
        return canonicalAccessControlConditionFormatter(
          cond
        );
      case "evmContract":
        return canonicalEVMContractConditionFormatter(cond);
      case "cosmos":
        return canonicalCosmosConditionFormatter(cond);
      default:
        throwError({
          message: `You passed an invalid access control condition that is missing or has a wrong "conditionType": ${JSON.stringify(
            cond
          )}`,
          errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
          errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
        });
    }
  }
  throwError({
    message: `You passed an invalid access control condition: ${cond}`,
    errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
    errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
  });
};
var canonicalSolRpcConditionFormatter = (cond, requireV2Conditions = false) => {
  if (Array.isArray(cond)) {
    return cond.map(
      (c) => canonicalSolRpcConditionFormatter(c, requireV2Conditions)
    );
  }
  if ("operator" in cond) {
    return getOperatorParam(cond);
  }
  if ("returnValueTest" in cond) {
    const { returnValueTest } = cond;
    const canonicalReturnValueTest = {
      // @ts-ignore
      key: returnValueTest.key,
      comparator: returnValueTest.comparator,
      value: returnValueTest.value
    };
    if ("pdaParams" in cond || requireV2Conditions) {
      const _assumedV2Cond = cond;
      if (!("pdaInterface" in _assumedV2Cond) || !("pdaKey" in _assumedV2Cond) || !("offset" in _assumedV2Cond.pdaInterface) || !("fields" in _assumedV2Cond.pdaInterface)) {
        throwError({
          message: `Solana RPC Conditions have changed and there are some new fields you must include in your condition.  Check the docs here: https://developer.litprotocol.com/AccessControlConditions/solRpcConditions`,
          errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
          errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
        });
      }
      const canonicalPdaInterface = {
        offset: _assumedV2Cond.pdaInterface.offset,
        fields: _assumedV2Cond.pdaInterface.fields
      };
      const _solV2Cond = cond;
      const _requiredParams = {
        method: _solV2Cond.method,
        params: _solV2Cond.params,
        pdaParams: _solV2Cond.pdaParams,
        pdaInterface: canonicalPdaInterface,
        pdaKey: _solV2Cond.pdaKey,
        chain: _solV2Cond.chain,
        returnValueTest: canonicalReturnValueTest
      };
      return _requiredParams;
    } else {
      const _solV1Cond = cond;
      const _requiredParams = {
        // @ts-ignore
        method: _solV1Cond.method,
        // @ts-ignore
        params: _solV1Cond.params,
        chain: _solV1Cond.chain,
        returnValueTest: canonicalReturnValueTest
      };
      return _requiredParams;
    }
  }
  throwError({
    message: `You passed an invalid access control condition: ${cond}`,
    errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
    errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
  });
};
var canonicalAccessControlConditionFormatter = (cond) => {
  if (Array.isArray(cond)) {
    return cond.map((c) => canonicalAccessControlConditionFormatter(c));
  }
  if ("operator" in cond) {
    return getOperatorParam(cond);
  }
  if ("returnValueTest" in cond) {
    const _cond = cond;
    const _return = {
      contractAddress: _cond.contractAddress,
      chain: _cond.chain,
      standardContractType: _cond.standardContractType,
      method: _cond.method,
      parameters: _cond.parameters,
      returnValueTest: {
        comparator: _cond.returnValueTest.comparator,
        value: _cond.returnValueTest.value
      }
    };
    return _return;
  }
  throwError({
    message: `You passed an invalid access control condition: ${cond}`,
    errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
    errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
  });
};
var canonicalEVMContractConditionFormatter = (cond) => {
  if (Array.isArray(cond)) {
    return cond.map((c) => canonicalEVMContractConditionFormatter(c));
  }
  if ("operator" in cond) {
    const _cond = cond;
    return {
      operator: _cond.operator
    };
  }
  if ("returnValueTest" in cond) {
    const evmCond = cond;
    const { functionAbi, returnValueTest } = evmCond;
    const canonicalAbi = {
      name: functionAbi.name,
      inputs: canonicalAbiParamss(functionAbi.inputs),
      outputs: canonicalAbiParamss(functionAbi.outputs),
      constant: typeof functionAbi.constant === "undefined" ? false : functionAbi.constant,
      stateMutability: functionAbi.stateMutability
    };
    const canonicalReturnValueTest = {
      key: returnValueTest.key,
      comparator: returnValueTest.comparator,
      value: returnValueTest.value
    };
    const _return = {
      contractAddress: evmCond.contractAddress,
      functionName: evmCond.functionName,
      functionParams: evmCond.functionParams,
      functionAbi: canonicalAbi,
      chain: evmCond.chain,
      returnValueTest: canonicalReturnValueTest
    };
    return _return;
  }
  throwError({
    message: `You passed an invalid access control condition: ${cond}`,
    errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
    errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
  });
};
var canonicalCosmosConditionFormatter = (cond) => {
  if (Array.isArray(cond)) {
    return cond.map((c) => canonicalCosmosConditionFormatter(c));
  }
  if ("operator" in cond) {
    const _cond = cond;
    return {
      operator: _cond.operator
    };
  }
  if ("returnValueTest" in cond) {
    const _cosmosCond = cond;
    const { returnValueTest } = _cosmosCond;
    const canonicalReturnValueTest = {
      key: returnValueTest.key,
      comparator: returnValueTest.comparator,
      value: returnValueTest.value
    };
    return {
      path: _cosmosCond.path,
      chain: _cosmosCond.chain,
      method: _cosmosCond?.method,
      parameters: _cosmosCond?.parameters,
      returnValueTest: canonicalReturnValueTest
    };
  }
  throwError({
    message: `You passed an invalid access control condition: ${cond}`,
    errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
    errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
  });
};

// packages/access-control-conditions/src/lib/hashing.ts
init_shim();

// packages/uint8arrays/src/index.ts
init_shim();

// packages/uint8arrays/src/lib/uint8arrays.ts
init_shim();
function utf8Encode(str) {
  let utf8Array = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    let charCode = str.charCodeAt(i2);
    if (charCode < 128) {
      utf8Array.push(charCode);
    } else if (charCode < 2048) {
      utf8Array.push(192 | charCode >> 6, 128 | charCode & 63);
    } else if (
      // Check if the character is a high surrogate (UTF-16)
      (charCode & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320
    ) {
      charCode = 65536 + ((charCode & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
      utf8Array.push(
        240 | charCode >> 18,
        128 | charCode >> 12 & 63,
        128 | charCode >> 6 & 63,
        128 | charCode & 63
      );
    } else {
      utf8Array.push(
        224 | charCode >> 12,
        128 | charCode >> 6 & 63,
        128 | charCode & 63
      );
    }
  }
  return new Uint8Array(utf8Array);
}
function utf8Decode(utf8Array) {
  let str = "";
  let i2 = 0;
  while (i2 < utf8Array.length) {
    let charCode = utf8Array[i2++];
    if (charCode < 128) {
      str += String.fromCharCode(charCode);
    } else if (charCode > 191 && charCode < 224) {
      str += String.fromCharCode(
        (charCode & 31) << 6 | utf8Array[i2++] & 63
      );
    } else if (charCode > 239 && charCode < 365) {
      charCode = (charCode & 7) << 18 | (utf8Array[i2++] & 63) << 12 | (utf8Array[i2++] & 63) << 6 | utf8Array[i2++] & 63;
      charCode -= 65536;
      str += String.fromCharCode(
        55296 + (charCode >> 10),
        56320 + (charCode & 1023)
      );
    } else {
      str += String.fromCharCode(
        (charCode & 15) << 12 | (utf8Array[i2++] & 63) << 6 | utf8Array[i2++] & 63
      );
    }
  }
  return str;
}
function base64ToUint8Array(base64Str) {
  const binaryStr = atob(base64Str);
  const len = binaryStr.length;
  const bytes = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    bytes[i2] = binaryStr.charCodeAt(i2);
  }
  return bytes;
}
function uint8ArrayToBase64(uint8Array) {
  let binaryStr = "";
  for (let i2 = 0; i2 < uint8Array.length; i2++) {
    binaryStr += String.fromCharCode(uint8Array[i2]);
  }
  return btoa(binaryStr);
}
function base64UrlPadToBase64(base64UrlPadStr) {
  return base64UrlPadStr.replace("-", "+").replace("_", "/") + "=".repeat((4 - base64UrlPadStr.length % 4) % 4);
}
function base64ToBase64UrlPad(base64Str) {
  return base64Str.replace("+", "-").replace("/", "_").replace(/=+$/, "");
}
function uint8arrayFromString(str, encoding = "utf8") {
  switch (encoding) {
    case "utf8":
      return utf8Encode(str);
    case "base16":
      const arr = [];
      for (let i2 = 0; i2 < str.length; i2 += 2) {
        arr.push(parseInt(str.slice(i2, i2 + 2), 16));
      }
      return new Uint8Array(arr);
    case "base64":
      return base64ToUint8Array(str);
    case "base64url":
    case "base64urlpad":
      return base64ToUint8Array(base64UrlPadToBase64(str));
    default:
      throw new Error(`Unsupported encoding "${encoding}"`);
  }
}
function uint8arrayToString(uint8array, encoding = "utf8") {
  let _uint8array = new Uint8Array(uint8array);
  switch (encoding) {
    case "utf8":
      return utf8Decode(_uint8array);
    case "base16":
      return Array.from(_uint8array).map((byte) => byte.toString(16).padStart(2, "0")).join("");
    case "base64":
      return uint8ArrayToBase64(_uint8array);
    case "base64url":
    case "base64urlpad":
      return base64ToBase64UrlPad(uint8ArrayToBase64(_uint8array));
    default:
      throw new Error(`Unsupported encoding "${encoding}"`);
  }
}

// packages/access-control-conditions/src/lib/hashing.ts
var hashUnifiedAccessControlConditions = (unifiedAccessControlConditions) => {
  log("unifiedAccessControlConditions:", unifiedAccessControlConditions);
  const conditions = unifiedAccessControlConditions.map((condition) => {
    return canonicalUnifiedAccessControlConditionFormatter(condition);
  });
  log("conditions:", conditions);
  const hasUndefined = conditions.some((c) => c === void 0);
  if (hasUndefined) {
    throwError({
      message: "Invalid access control conditions",
      errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
      errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
    });
  }
  if (conditions.length === 0) {
    throwError({
      message: "No conditions provided",
      errorKind: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
      errorCode: LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name
    });
  }
  const toHash = JSON.stringify(conditions);
  log("Hashing unified access control conditions: ", toHash);
  const encoder = new TextEncoder();
  const data = encoder.encode(toHash);
  return crypto.subtle.digest("SHA-256", data);
};
var hashAccessControlConditions = (accessControlConditions) => {
  const conds = accessControlConditions.map(
    (c) => canonicalAccessControlConditionFormatter(c)
  );
  const toHash = JSON.stringify(conds);
  log("Hashing access control conditions: ", toHash);
  const encoder = new TextEncoder();
  const data = encoder.encode(toHash);
  return crypto.subtle.digest("SHA-256", data);
};
var hashEVMContractConditions = (evmContractConditions) => {
  const conds = evmContractConditions.map(
    (c) => canonicalEVMContractConditionFormatter(c)
  );
  const toHash = JSON.stringify(conds);
  log("Hashing evm contract conditions: ", toHash);
  const encoder = new TextEncoder();
  const data = encoder.encode(toHash);
  return crypto.subtle.digest("SHA-256", data);
};
var hashSolRpcConditions = (solRpcConditions) => {
  const conds = solRpcConditions.map(
    (c) => canonicalSolRpcConditionFormatter(c)
  );
  const toHash = JSON.stringify(conds);
  log("Hashing sol rpc conditions: ", toHash);
  const encoder = new TextEncoder();
  const data = encoder.encode(toHash);
  return crypto.subtle.digest("SHA-256", data);
};

// packages/access-control-conditions/src/lib/humanizer.ts
init_shim();

// packages/access-control-conditions/src/lib/validator.ts
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/index.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/generated/index.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/generated/LPACC_EVM_ATOM.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/generated/LPACC_EVM_BASIC.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/generated/LPACC_EVM_CONTRACT.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/generated/LPACC_SOL.js
init_shim();

// node_modules/@lit-protocol/accs-schemas/esm/schemas/index.js
init_shim();
async function loadSchema(schemaName) {
  switch (schemaName) {
    case "LPACC_ATOM":
      return Promise.resolve().then(() => __toESM(require_LPACC_ATOM()));
    case "LPACC_EVM_BASIC":
      return Promise.resolve().then(() => __toESM(require_LPACC_EVM_BASIC()));
    case "LPACC_EVM_CONTRACT":
      return Promise.resolve().then(() => __toESM(require_LPACC_EVM_CONTRACT()));
    case "LPACC_SOL":
      return Promise.resolve().then(() => __toESM(require_LPACC_SOL()));
    default:
      throw new Error(`Unknown schema: ${schemaName}`);
  }
}

// packages/access-control-conditions/src/lib/validator.ts
var SCHEMA_NAME_MAP = {
  cosmos: "LPACC_ATOM",
  evmBasic: "LPACC_EVM_BASIC",
  evmContract: "LPACC_EVM_CONTRACT",
  solRpc: "LPACC_SOL"
};
async function getSchema(accType) {
  try {
    const schemaName = SCHEMA_NAME_MAP[accType];
    return loadSchema(schemaName);
  } catch (err) {
    return throwError({
      message: `No schema found for condition type ${accType}`,
      errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
      errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
    });
  }
}
var validateAccessControlConditionsSchema = async (accs) => {
  for (const acc of accs) {
    if (Array.isArray(acc)) {
      await validateAccessControlConditionsSchema(acc);
      continue;
    }
    if ("operator" in acc) {
      continue;
    }
    checkSchema(
      acc,
      await getSchema("evmBasic"),
      "accessControlConditions",
      "validateAccessControlConditionsSchema"
    );
  }
  return true;
};
var validateEVMContractConditionsSchema = async (accs) => {
  for (const acc of accs) {
    if (Array.isArray(acc)) {
      await validateEVMContractConditionsSchema(acc);
      continue;
    }
    if ("operator" in acc) {
      continue;
    }
    checkSchema(
      acc,
      await getSchema("evmContract"),
      "evmContractConditions",
      "validateEVMContractConditionsSchema"
    );
  }
  return true;
};
var validateSolRpcConditionsSchema = async (accs) => {
  for (const acc of accs) {
    if (Array.isArray(acc)) {
      await validateSolRpcConditionsSchema(acc);
      continue;
    }
    if ("operator" in acc) {
      continue;
    }
    checkSchema(
      acc,
      await getSchema("solRpc"),
      "solRpcConditions",
      "validateSolRpcConditionsSchema"
    );
  }
  return true;
};
var validateUnifiedAccessControlConditionsSchema = async (accs) => {
  for (const acc of accs) {
    if (Array.isArray(acc)) {
      await validateUnifiedAccessControlConditionsSchema(acc);
      continue;
    }
    if ("operator" in acc) {
      continue;
    }
    let schema;
    switch (acc.conditionType) {
      case "evmBasic":
        schema = await getSchema("evmBasic");
        break;
      case "evmContract":
        schema = await getSchema("evmContract");
        break;
      case "solRpc":
        schema = await getSchema("solRpc");
        break;
      case "cosmos":
        schema = await getSchema("cosmos");
        break;
    }
    if (schema) {
      checkSchema(
        acc,
        schema,
        "accessControlConditions",
        "validateUnifiedAccessControlConditionsSchema"
      );
    } else {
      throwError({
        message: `Missing schema to validate condition type ${acc.conditionType}`,
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    }
  }
  return true;
};

// packages/auth-helpers/src/index.ts
init_shim();

// packages/auth-helpers/src/lib/session-capability-object.ts
init_shim();

// packages/auth-helpers/src/lib/recap/recap-session-capability-object.ts
init_shim();
import { Recap } from "siwe-recap";

// packages/auth-helpers/src/lib/recap/utils.ts
init_shim();

// packages/types/src/index.ts
init_shim();

// packages/types/src/lib/types.ts
init_shim();

// packages/types/src/lib/interfaces.ts
init_shim();

// packages/types/src/lib/ILitNodeClient.ts
init_shim();

// packages/types/src/lib/models.ts
init_shim();

// packages/auth-helpers/src/lib/recap/utils.ts
function getRecapNamespaceAndAbility(litAbility) {
  switch (litAbility) {
    case "access-control-condition-decryption" /* AccessControlConditionDecryption */:
      return {
        recapNamespace: "Threshold" /* Threshold */,
        recapAbility: "Decryption" /* Decryption */
      };
    case "access-control-condition-signing" /* AccessControlConditionSigning */:
      return {
        recapNamespace: "Threshold" /* Threshold */,
        recapAbility: "Signing" /* Signing */
      };
    case "pkp-signing" /* PKPSigning */:
      return {
        recapNamespace: "Threshold" /* Threshold */,
        recapAbility: "Signing" /* Signing */
      };
    case "rate-limit-increase-auth" /* RateLimitIncreaseAuth */:
      return {
        recapNamespace: "Auth" /* Auth */,
        recapAbility: "Auth" /* Auth */
      };
    case "lit-action-execution" /* LitActionExecution */:
      return {
        recapNamespace: "Threshold" /* Threshold */,
        recapAbility: "Execution" /* Execution */
      };
    default:
      throw new Error(`Unknown LitAbility: ${litAbility}`);
  }
}

// packages/auth-helpers/src/lib/siwe.ts
init_shim();
function sanitizeSiweMessage(message) {
  let sanitizedMessage = message.replace(/\\\\n/g, "\\n");
  sanitizedMessage = sanitizedMessage.replace(/\\"/g, "'");
  return sanitizedMessage;
}

// packages/auth-helpers/src/lib/recap/recap-session-capability-object.ts
var RecapSessionCapabilityObject = class {
  #inner;
  constructor(att = {}, prf = []) {
    this.#inner = new Recap(att, prf);
  }
  // static async sha256(data: Buffer): Promise<ArrayBuffer> {
  //   const digest = await crypto.subtle.digest('SHA-256', data);
  //   return digest;
  // }
  // This should ideally be placed in the IPFSBundledSDK package, but for some reasons
  // there seems to be bundling issues where the jest test would fail, but somehow
  // works here.
  // public static async strToCID(
  //   data: string | Uint8Array | object
  // ): Promise<string> {
  //   let content: Uint8Array;
  //   // Check the type of data and convert accordingly
  //   if (typeof data === 'string') {
  //     // console.log("Type A");
  //     // Encode the string directly if data is a string
  //     content = new TextEncoder().encode(data);
  //   } else if (data instanceof Uint8Array) {
  //     // console.log("Type B");
  //     // Use the Uint8Array directly
  //     content = data;
  //   } else if (typeof data === 'object') {
  //     // console.log("Type C");
  //     // Stringify and encode if data is an object
  //     const contentStr = JSON.stringify(data);
  //     content = new TextEncoder().encode(contentStr);
  //   } else {
  //     // console.log("Type D");
  //     throw new Error('Invalid content type');
  //   }
  //   // Create the CID
  //   let ipfsId;
  //   for await (const { cid } of IPFSBundledSDK.importer(
  //     [{ content }],
  //     new IPFSBundledSDK.MemoryBlockstore(),
  //     { onlyHash: true }
  //   )) {
  //     ipfsId = cid;
  //   }
  //   // Validate the IPFS ID
  //   if (!ipfsId) {
  //     throw new Error('Could not create IPFS ID');
  //   }
  //   // Return the IPFS ID as a string
  //   return ipfsId.toString();
  // }
  /**
   * Adds a Rate Limit Authorization Signature (AuthSig) as an proof to the Recap object.
   * This method serializes the AuthSig object into a JSON string and adds it to the proof
   * of the Recap object. The AuthSig typically contains authentication details like signature,
   * method of derivation, the signed message, and the address of the signer. This proof is
   * used to verify that the user has the necessary authorization, such as a Rate Limit Increase NFT.
   *
   * @param authSig The AuthSig object containing the rate limit authorization details.
   */
  async addRateLimitAuthSig(authSig) {
    throw new Error("Not implemented yet. ");
  }
  static decode(encoded) {
    const recap = Recap.decode_urn(encoded);
    return new this(
      recap.attenuations,
      recap.proofs.map((cid) => cid.toString())
    );
  }
  static extract(siwe3) {
    const recap = Recap.extract_and_verify(siwe3);
    return new this(
      recap.attenuations,
      recap.proofs.map((cid) => cid.toString())
    );
  }
  get attenuations() {
    return this.#inner.attenuations;
  }
  get proofs() {
    return this.#inner.proofs.map((cid) => cid.toString());
  }
  get statement() {
    return sanitizeSiweMessage(this.#inner.statement);
  }
  addProof(proof) {
    return this.#inner.addProof(proof);
  }
  addAttenuation(resource, namespace = "*", name = "*", restriction = {}) {
    return this.#inner.addAttenuation(resource, namespace, name, restriction);
  }
  addToSiweMessage(siwe3) {
    return this.#inner.add_to_siwe_message(siwe3);
  }
  encodeAsSiweResource() {
    return this.#inner.encode();
  }
  /** LIT specific methods */
  addCapabilityForResource(litResource, ability, data = {}) {
    if (!litResource.isValidLitAbility(ability)) {
      throw new Error(
        `The specified Lit resource does not support the specified ability.`
      );
    }
    const { recapNamespace, recapAbility } = getRecapNamespaceAndAbility(ability);
    if (!data) {
      return this.addAttenuation(
        litResource.getResourceKey(),
        recapNamespace,
        recapAbility
      );
    }
    return this.addAttenuation(
      litResource.getResourceKey(),
      recapNamespace,
      recapAbility,
      data
    );
  }
  verifyCapabilitiesForResource(litResource, ability) {
    if (!litResource.isValidLitAbility(ability)) {
      return false;
    }
    const attenuations = this.attenuations;
    const { recapNamespace, recapAbility } = getRecapNamespaceAndAbility(ability);
    const recapAbilityToCheckFor = `${recapNamespace}/${recapAbility}`;
    const attenuatedResourceKey = this.#getResourceKeyToMatchAgainst(litResource);
    if (!attenuations[attenuatedResourceKey]) {
      return false;
    }
    const attenuatedRecapAbilities = Object.keys(
      attenuations[attenuatedResourceKey]
    );
    for (const attenuatedRecapAbility of attenuatedRecapAbilities) {
      if (attenuatedRecapAbility === "*/*") {
        return true;
      }
      if (attenuatedRecapAbility === recapAbilityToCheckFor) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the attenuated resource key to match against. This supports matching
   * against a wildcard resource key too.
   *
   * @example If the attenuations object contains the following:
   *
   * ```
   * {
   *   'lit-acc://*': {
   *    '*\/*': {}
   *   }
   * }
   * ```
   *
   * Then, if the provided litResource is 'lit-acc://123', the method will return 'lit-acc://*'.
   */
  #getResourceKeyToMatchAgainst(litResource) {
    const attenuatedResourceKeysToMatchAgainst = [
      `${litResource.resourcePrefix}://*`,
      litResource.getResourceKey()
    ];
    for (const attenuatedResourceKeyToMatchAgainst of attenuatedResourceKeysToMatchAgainst) {
      if (this.attenuations[attenuatedResourceKeyToMatchAgainst]) {
        return attenuatedResourceKeyToMatchAgainst;
      }
    }
    return "";
  }
  addAllCapabilitiesForResource(litResource) {
    return this.addAttenuation(litResource.getResourceKey(), "*", "*");
  }
};

// packages/auth-helpers/src/lib/session-capability-object.ts
function decode3(encoded) {
  return RecapSessionCapabilityObject.decode(encoded);
}

// packages/auth-helpers/src/lib/resources.ts
init_shim();
var LitResourceBase = class {
  constructor(resource) {
    this.resource = resource;
  }
  getResourceKey() {
    return `${this.resourcePrefix}://${this.resource}`;
  }
  toString() {
    return this.getResourceKey();
  }
};
var LitAccessControlConditionResource = class extends LitResourceBase {
  /**
   * Creates a new LitAccessControlConditionResource.
   * @param resource The identifier for the resource. This should be the
   * hashed key value of the access control condition.
   */
  constructor(resource) {
    super(resource);
    this.resourcePrefix = "lit-accesscontrolcondition" /* AccessControlCondition */;
  }
  isValidLitAbility(litAbility) {
    return litAbility === "access-control-condition-decryption" /* AccessControlConditionDecryption */ || litAbility === "access-control-condition-signing" /* AccessControlConditionSigning */;
  }
};
var LitPKPResource = class extends LitResourceBase {
  /**
   * Creates a new LitPKPResource.
   * @param resource The identifier for the resource. This should be the
   * PKP token ID.
   */
  constructor(resource) {
    super(resource);
    this.resourcePrefix = "lit-pkp" /* PKP */;
  }
  isValidLitAbility(litAbility) {
    return litAbility === "pkp-signing" /* PKPSigning */;
  }
};
var LitRLIResource = class extends LitResourceBase {
  /**
   * Creates a new LitRLIResource.
   * @param resource The identifier for the resource. This should be the
   * RLI token ID.
   */
  constructor(resource) {
    super(resource);
    this.resourcePrefix = "lit-ratelimitincrease" /* RLI */;
  }
  isValidLitAbility(litAbility) {
    return litAbility === "rate-limit-increase-auth" /* RateLimitIncreaseAuth */;
  }
};
var LitActionResource = class extends LitResourceBase {
  /**
   * Creates a new LitActionResource.
   * @param resource The identifier for the resource. This should be the
   * Lit Action IPFS CID.
   */
  constructor(resource) {
    super(resource);
    this.resourcePrefix = "lit-litaction" /* LitAction */;
  }
  isValidLitAbility(litAbility) {
    return litAbility === "lit-action-execution" /* LitActionExecution */;
  }
};

// packages/auth-helpers/src/lib/auth-needed-callback/craft-auth-sig.ts
init_shim();
var craftAuthSig = async ({
  signer,
  toSign,
  address,
  algo
}) => {
  if (!signer?.signMessage) {
    throw new Error("signer does not have a signMessage method");
  }
  const signature2 = await signer.signMessage(toSign);
  if (!address) {
    address = await signer.getAddress();
  }
  if (!address) {
    throw new Error("address is required");
  }
  return {
    sig: signature2,
    derivedVia: "web3.eth.personal.sign",
    signedMessage: toSign,
    address,
    ...algo && { algo }
  };
};

// packages/auth-helpers/src/lib/auth-needed-callback/create-siwe-message/create-siwe-message.ts
init_shim();
import * as siwe from "siwe";
var createSiweMessage = async (params) => {
  if (!params.walletAddress) {
    throw new Error("walletAddress is required");
  }
  const ONE_WEEK_FROM_NOW = new Date(
    Date.now() + 1e3 * 60 * 60 * 24 * 7
  ).toISOString();
  let siweParams = {
    domain: params?.domain ?? "localhost",
    address: params.walletAddress,
    statement: params?.statement ?? "This is a test statement.  You can put anything you want here.",
    uri: params?.uri ?? "https://localhost/login",
    version: params?.version ?? "1",
    chainId: params?.chainId ?? 1,
    nonce: params.nonce,
    expirationTime: params?.expiration ?? ONE_WEEK_FROM_NOW
  };
  let siweMessage = new siwe.SiweMessage(siweParams);
  if ("uses" in params || "delegateeAddresses" in params || "capacityTokenId" in params) {
    const ccParams = params;
    const capabilities = createCapacityCreditsResourceData(ccParams);
    params.resources = [
      {
        resource: new LitRLIResource(ccParams.capacityTokenId ?? "*"),
        ability: "rate-limit-increase-auth" /* RateLimitIncreaseAuth */,
        data: capabilities
      }
    ];
  }
  if (params.resources) {
    siweMessage = await addRecapToSiweMessage({
      siweMessage,
      resources: params.resources,
      litNodeClient: params.litNodeClient
    });
  }
  return siweMessage.prepareMessage();
};
var createCapacityCreditsResourceData = (params) => {
  return {
    ...params.capacityTokenId ? { nft_id: [params.capacityTokenId] } : {},
    // Conditionally include nft_id
    ...params.delegateeAddresses ? {
      delegate_to: params.delegateeAddresses.map(
        (address) => address.startsWith("0x") ? address.slice(2) : address
      )
    } : {},
    uses: params.uses.toString() || "1"
  };
};
var addRecapToSiweMessage = async ({
  siweMessage,
  resources,
  litNodeClient
}) => {
  if (!resources || resources.length < 1) {
    throw new Error("resources is required");
  }
  if (!litNodeClient) {
    throw new Error("litNodeClient is required");
  }
  for (const request of resources) {
    const recapObject = await litNodeClient.generateSessionCapabilityObjectWithWildcards([
      request.resource
    ]);
    recapObject.addCapabilityForResource(
      request.resource,
      request.ability,
      request.data || null
    );
    const verified = recapObject.verifyCapabilitiesForResource(
      request.resource,
      request.ability
    );
    if (!verified) {
      throw new Error(
        `Failed to verify capabilities for resource: "${request.resource}" and ability: "${request.ability}`
      );
    }
    siweMessage = recapObject.addToSiweMessage(siweMessage);
  }
  return siweMessage;
};
var createSiweMessageWithRecaps = async (params) => {
  return createSiweMessage({
    ...params
  });
};
var createSiweMessageWithCapacityDelegation = async (params) => {
  if (!params.litNodeClient) {
    throw new Error("litNodeClient is required");
  }
  return createSiweMessage({
    ...params
  });
};

// packages/core/src/index.ts
init_shim();

// packages/core/src/lib/lit-core.ts
init_shim();

// packages/contracts-sdk/src/index.ts
init_shim();

// packages/contracts-sdk/src/lib/contracts-sdk.ts
init_shim();

// packages/contracts-sdk/src/lib/hex2dec.ts
init_shim();
function add3(x, y, base2) {
  var z = [];
  var n2 = Math.max(x.length, y.length);
  var carry = 0;
  var i2 = 0;
  while (i2 < n2 || carry) {
    var xi = i2 < x.length ? x[i2] : 0;
    var yi = i2 < y.length ? y[i2] : 0;
    var zi = carry + xi + yi;
    z.push(zi % base2);
    carry = Math.floor(zi / base2);
    i2++;
  }
  return z;
}
function multiplyByNumber(num, x, base2) {
  if (num < 0)
    return null;
  if (num == 0)
    return [];
  var result = [];
  var power = x;
  while (true) {
    if (num & 1) {
      result = add3(result, power, base2);
    }
    num = num >> 1;
    if (num === 0)
      break;
    power = add3(power, power, base2);
  }
  return result;
}
function parseToDigitsArray(str, base2) {
  var digits = str.split("");
  var ary = [];
  for (var i2 = digits.length - 1; i2 >= 0; i2--) {
    var n2 = parseInt(digits[i2], base2);
    if (isNaN(n2))
      return null;
    ary.push(n2);
  }
  return ary;
}
function convertBase(str, fromBase, toBase) {
  var digits = parseToDigitsArray(str, fromBase);
  if (digits === null)
    return null;
  var outArray = [];
  var power = [1];
  for (var i2 = 0; i2 < digits.length; i2++) {
    if (digits[i2]) {
      outArray = add3(
        outArray,
        multiplyByNumber(digits[i2], power, toBase),
        toBase
      );
    }
    power = multiplyByNumber(fromBase, power, toBase);
  }
  var out = "";
  for (var i2 = outArray.length - 1; i2 >= 0; i2--) {
    out += outArray[i2].toString(toBase);
  }
  if (out === "") {
    out = "0";
  }
  return out;
}
function decToHex(decStr, opts) {
  var hidePrefix = opts && opts.prefix === false;
  var hex = convertBase(decStr, 10, 16);
  return hex ? hidePrefix ? hex : "0x" + hex : null;
}
function hexToDec(hexStr) {
  if (hexStr.substring(0, 2) === "0x")
    hexStr = hexStr.substring(2);
  hexStr = hexStr.toLowerCase();
  return convertBase(hexStr, 16, 10);
}
var intToIP = (ip) => {
  const binaryString = ip.toString(2).padStart(32, "0");
  const ipArray = [];
  for (let i2 = 0; i2 < 32; i2 += 8) {
    ipArray.push(parseInt(binaryString.substring(i2, i2 + 8), 2));
  }
  return ipArray.join(".");
};

// packages/contracts-sdk/src/lib/contracts-sdk.ts
import bs58 from "bs58";

// packages/contracts-sdk/src/abis/Allowlist.sol/AllowlistData.ts
init_shim();
var AllowlistData = {
  date: "2023-11-14T15:45:41Z",
  address: "0xfc7Bebd150b36921549595A776D7723fBC4Bb2D9",
  contractName: "Allowlist",
  abi: [
    {
      inputs: [],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "AdminAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "AdminRemoved",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "key",
          type: "bytes32"
        }
      ],
      name: "ItemAllowed",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "key",
          type: "bytes32"
        }
      ],
      name: "ItemNotAllowed",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "addAdmin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "allowAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      name: "allowedItems",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "key",
          type: "bytes32"
        }
      ],
      name: "isAllowed",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "removeAdmin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "_allowAll",
          type: "bool"
        }
      ],
      name: "setAllowAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "key",
          type: "bytes32"
        }
      ],
      name: "setAllowed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "key",
          type: "bytes32"
        }
      ],
      name: "setNotAllowed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/LITToken.sol/LITTokenData.ts
init_shim();
var LITTokenData = {
  date: "2023-10-02T18:22:38.000Z",
  address: "0x53695556f8a1a064EdFf91767f15652BbfaFaD04",
  contractName: "LITToken",
  abi: [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [],
      name: "InvalidShortString",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "str",
          type: "string"
        }
      ],
      name: "StringTooLong",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "delegator",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "fromDelegate",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "toDelegate",
          type: "address"
        }
      ],
      name: "DelegateChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "delegate",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "previousBalance",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newBalance",
          type: "uint256"
        }
      ],
      name: "DelegateVotesChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [],
      name: "EIP712DomainChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "Paused",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "Unpaused",
      type: "event"
    },
    {
      inputs: [],
      name: "ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "CLOCK_MODE",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "MINTER_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "PAUSER_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "spender",
          type: "address"
        }
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "burnFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "cap",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "uint32",
          name: "pos",
          type: "uint32"
        }
      ],
      name: "checkpoints",
      outputs: [
        {
          components: [
            {
              internalType: "uint32",
              name: "fromBlock",
              type: "uint32"
            },
            {
              internalType: "uint224",
              name: "votes",
              type: "uint224"
            }
          ],
          internalType: "struct ERC20Votes.Checkpoint",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "clock",
      outputs: [
        {
          internalType: "uint48",
          name: "",
          type: "uint48"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "subtractedValue",
          type: "uint256"
        }
      ],
      name: "decreaseAllowance",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "delegatee",
          type: "address"
        }
      ],
      name: "delegate",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "delegatee",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "nonce",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "expiry",
          type: "uint256"
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "s",
          type: "bytes32"
        }
      ],
      name: "delegateBySig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "delegates",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "eip712Domain",
      outputs: [
        {
          internalType: "bytes1",
          name: "fields",
          type: "bytes1"
        },
        {
          internalType: "string",
          name: "name",
          type: "string"
        },
        {
          internalType: "string",
          name: "version",
          type: "string"
        },
        {
          internalType: "uint256",
          name: "chainId",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "verifyingContract",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "salt",
          type: "bytes32"
        },
        {
          internalType: "uint256[]",
          name: "extensions",
          type: "uint256[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "timepoint",
          type: "uint256"
        }
      ],
      name: "getPastTotalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "timepoint",
          type: "uint256"
        }
      ],
      name: "getPastVotes",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getVotes",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "addedValue",
          type: "uint256"
        }
      ],
      name: "increaseAllowance",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_recipient",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "_amount",
          type: "uint256"
        }
      ],
      name: "mint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "nonces",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "numCheckpoints",
      outputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "paused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "deadline",
          type: "uint256"
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "s",
          type: "bytes32"
        }
      ],
      name: "permit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "unpause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/Multisender.sol/MultisenderData.ts
init_shim();
var MultisenderData = {
  date: "2023-11-14T15:45:41Z",
  address: "0xD4e3D27d21D6D6d596b6524610C486F8A9c70958",
  contractName: "Multisender",
  abi: [
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "_recipients",
          type: "address[]"
        }
      ],
      name: "sendEth",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "_recipients",
          type: "address[]"
        },
        {
          internalType: "address",
          name: "tokenContract",
          type: "address"
        }
      ],
      name: "sendTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenContract",
          type: "address"
        }
      ],
      name: "withdrawTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/PKPHelper.sol/PKPHelperData.ts
init_shim();
var PKPHelperData = {
  date: "2023-11-14T15:45:41Z",
  address: "0xF02b6D6b0970DB3810963300a6Ad38D8429c4cdb",
  contractName: "PKPHelper",
  abi: [
    {
      inputs: [
        {
          internalType: "address",
          name: "_resolver",
          type: "address"
        },
        {
          internalType: "enum ContractResolver.Env",
          name: "_env",
          type: "uint8"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "ContractResolverAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "derivedKeyId",
              type: "bytes32"
            },
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "r",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "s",
                  type: "bytes32"
                },
                {
                  internalType: "uint8",
                  name: "v",
                  type: "uint8"
                }
              ],
              internalType: "struct IPubkeyRouter.Signature[]",
              name: "signatures",
              type: "tuple[]"
            }
          ],
          internalType: "struct LibPKPNFTStorage.ClaimMaterial",
          name: "claimMaterial",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes[]",
              name: "permittedIpfsCIDs",
              type: "bytes[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedIpfsCIDScopes",
              type: "uint256[][]"
            },
            {
              internalType: "address[]",
              name: "permittedAddresses",
              type: "address[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedAddressScopes",
              type: "uint256[][]"
            },
            {
              internalType: "uint256[]",
              name: "permittedAuthMethodTypes",
              type: "uint256[]"
            },
            {
              internalType: "bytes[]",
              name: "permittedAuthMethodIds",
              type: "bytes[]"
            },
            {
              internalType: "bytes[]",
              name: "permittedAuthMethodPubkeys",
              type: "bytes[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedAuthMethodScopes",
              type: "uint256[][]"
            },
            {
              internalType: "bool",
              name: "addPkpEthAddressAsPermittedAddress",
              type: "bool"
            },
            {
              internalType: "bool",
              name: "sendPkpToItself",
              type: "bool"
            }
          ],
          internalType: "struct PKPHelper.AuthMethodData",
          name: "authMethodData",
          type: "tuple"
        }
      ],
      name: "claimAndMintNextAndAddAuthMethods",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "derivedKeyId",
              type: "bytes32"
            },
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "r",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "s",
                  type: "bytes32"
                },
                {
                  internalType: "uint8",
                  name: "v",
                  type: "uint8"
                }
              ],
              internalType: "struct IPubkeyRouter.Signature[]",
              name: "signatures",
              type: "tuple[]"
            }
          ],
          internalType: "struct LibPKPNFTStorage.ClaimMaterial",
          name: "claimMaterial",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes[]",
              name: "permittedIpfsCIDs",
              type: "bytes[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedIpfsCIDScopes",
              type: "uint256[][]"
            },
            {
              internalType: "address[]",
              name: "permittedAddresses",
              type: "address[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedAddressScopes",
              type: "uint256[][]"
            },
            {
              internalType: "uint256[]",
              name: "permittedAuthMethodTypes",
              type: "uint256[]"
            },
            {
              internalType: "bytes[]",
              name: "permittedAuthMethodIds",
              type: "bytes[]"
            },
            {
              internalType: "bytes[]",
              name: "permittedAuthMethodPubkeys",
              type: "bytes[]"
            },
            {
              internalType: "uint256[][]",
              name: "permittedAuthMethodScopes",
              type: "uint256[][]"
            },
            {
              internalType: "bool",
              name: "addPkpEthAddressAsPermittedAddress",
              type: "bool"
            },
            {
              internalType: "bool",
              name: "sendPkpToItself",
              type: "bool"
            }
          ],
          internalType: "struct PKPHelper.AuthMethodData",
          name: "authMethodData",
          type: "tuple"
        }
      ],
      name: "claimAndMintNextAndAddAuthMethodsWithTypes",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [],
      name: "contractResolver",
      outputs: [
        {
          internalType: "contract ContractResolver",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "env",
      outputs: [
        {
          internalType: "enum ContractResolver.Env",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getDomainWalletRegistry",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPKPNftMetdataAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpNftAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpPermissionsAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "uint256[]",
          name: "permittedAuthMethodTypes",
          type: "uint256[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodIds",
          type: "bytes[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodPubkeys",
          type: "bytes[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedAuthMethodScopes",
          type: "uint256[][]"
        },
        {
          internalType: "bool",
          name: "addPkpEthAddressAsPermittedAddress",
          type: "bool"
        },
        {
          internalType: "bool",
          name: "sendPkpToItself",
          type: "bool"
        }
      ],
      name: "mintNextAndAddAuthMethods",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "bytes[]",
          name: "permittedIpfsCIDs",
          type: "bytes[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedIpfsCIDScopes",
          type: "uint256[][]"
        },
        {
          internalType: "address[]",
          name: "permittedAddresses",
          type: "address[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedAddressScopes",
          type: "uint256[][]"
        },
        {
          internalType: "uint256[]",
          name: "permittedAuthMethodTypes",
          type: "uint256[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodIds",
          type: "bytes[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodPubkeys",
          type: "bytes[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedAuthMethodScopes",
          type: "uint256[][]"
        },
        {
          internalType: "bool",
          name: "addPkpEthAddressAsPermittedAddress",
          type: "bool"
        },
        {
          internalType: "bool",
          name: "sendPkpToItself",
          type: "bool"
        }
      ],
      name: "mintNextAndAddAuthMethodsWithTypes",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "uint256[]",
          name: "permittedAuthMethodTypes",
          type: "uint256[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodIds",
          type: "bytes[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodPubkeys",
          type: "bytes[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedAuthMethodScopes",
          type: "uint256[][]"
        },
        {
          internalType: "string[]",
          name: "nftMetadata",
          type: "string[]"
        },
        {
          internalType: "bool",
          name: "addPkpEthAddressAsPermittedAddress",
          type: "bool"
        },
        {
          internalType: "bool",
          name: "sendPkpToItself",
          type: "bool"
        }
      ],
      name: "mintNextAndAddDomainWalletMetadata",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      name: "onERC721Received",
      outputs: [
        {
          internalType: "bytes4",
          name: "",
          type: "bytes4"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "removePkpMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "string[]",
          name: "nftMetadata",
          type: "string[]"
        }
      ],
      name: "setPkpMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/PKPNFT.sol/PKPNFTData.ts
init_shim();
var PKPNFTData = {
  date: "2023-11-14T15:45:41Z",
  address: "0x58582b93d978F30b4c4E812A16a7b31C035A69f7",
  contractName: "PKPNFT",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool"
        }
      ],
      name: "ApprovalForAll",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "ContractResolverAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newFreeMintSigner",
          type: "address"
        }
      ],
      name: "FreeMintSignerSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newMintCost",
          type: "uint256"
        }
      ],
      name: "MintCostSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "pubkey",
          type: "bytes"
        }
      ],
      name: "PKPMinted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Withdrew",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "derivedKeyId",
          type: "bytes32"
        },
        {
          components: [
            {
              internalType: "bytes32",
              name: "r",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "s",
              type: "bytes32"
            },
            {
              internalType: "uint8",
              name: "v",
              type: "uint8"
            }
          ],
          internalType: "struct IPubkeyRouter.Signature[]",
          name: "signatures",
          type: "tuple[]"
        }
      ],
      name: "claimAndMint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "exists",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "freeMintSigner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getApproved",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getEthAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getNextDerivedKeyId",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpNftMetadataAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpPermissionsAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPubkey",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getRouterAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getStakingAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "operator",
          type: "address"
        }
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "mintCost",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "ipfsCID",
          type: "bytes"
        }
      ],
      name: "mintGrantAndBurnNext",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        }
      ],
      name: "mintNext",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "hash",
          type: "bytes32"
        }
      ],
      name: "prefixed",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "redeemedFreeMintIds",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address"
        },
        {
          internalType: "bool",
          name: "approved",
          type: "bool"
        }
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newFreeMintSigner",
          type: "address"
        }
      ],
      name: "setFreeMintSigner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMintCost",
          type: "uint256"
        }
      ],
      name: "setMintCost",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "index",
          type: "uint256"
        }
      ],
      name: "tokenByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256"
        }
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "tokenURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/PKPNFTMetadata.sol/PKPNFTMetadataData.ts
init_shim();
var PKPNFTMetadataData = {
  date: "2023-11-14T15:45:41Z",
  address: "0xeD46dDcbFF662ad89b0987E0DFE2949901498Da6",
  contractName: "PKPNFTMetadata",
  abi: [
    {
      inputs: [
        {
          internalType: "address",
          name: "_resolver",
          type: "address"
        },
        {
          internalType: "enum ContractResolver.Env",
          name: "_env",
          type: "uint8"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      inputs: [],
      name: "ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "WRITER_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "buffer",
          type: "bytes"
        }
      ],
      name: "bytesToHex",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [],
      name: "contractResolver",
      outputs: [
        {
          internalType: "contract ContractResolver",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "env",
      outputs: [
        {
          internalType: "enum ContractResolver.Env",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "removeProfileForPkp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "removeUrlForPKP",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "pkpHelperWriterAddress",
          type: "address"
        }
      ],
      name: "setPKPHelperWriterAddress",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "string",
          name: "imgUrl",
          type: "string"
        }
      ],
      name: "setProfileForPKP",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "string",
          name: "url",
          type: "string"
        }
      ],
      name: "setUrlForPKP",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "pubKey",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "ethAddress",
          type: "address"
        }
      ],
      name: "tokenURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/PKPPermissions.sol/PKPPermissionsData.ts
init_shim();
var PKPPermissionsData = {
  date: "2023-11-14T15:45:41Z",
  address: "0xD01c9C30f8F6fa443721629775e1CC7DD9c9e209",
  contractName: "PKPPermissions",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "ContractResolverAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "userPubkey",
          type: "bytes"
        }
      ],
      name: "PermittedAuthMethodAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "PermittedAuthMethodRemoved",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "scopeId",
          type: "uint256"
        }
      ],
      name: "PermittedAuthMethodScopeAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "scopeId",
          type: "uint256"
        }
      ],
      name: "PermittedAuthMethodScopeRemoved",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "group",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "root",
          type: "bytes32"
        }
      ],
      name: "RootHashUpdated",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "ipfsCID",
          type: "bytes"
        },
        {
          internalType: "uint256[]",
          name: "scopes",
          type: "uint256[]"
        }
      ],
      name: "addPermittedAction",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "user",
          type: "address"
        },
        {
          internalType: "uint256[]",
          name: "scopes",
          type: "uint256[]"
        }
      ],
      name: "addPermittedAddress",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "authMethodType",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "id",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "userPubkey",
              type: "bytes"
            }
          ],
          internalType: "struct LibPKPPermissionsStorage.AuthMethod",
          name: "authMethod",
          type: "tuple"
        },
        {
          internalType: "uint256[]",
          name: "scopes",
          type: "uint256[]"
        }
      ],
      name: "addPermittedAuthMethod",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          internalType: "uint256",
          name: "scopeId",
          type: "uint256"
        }
      ],
      name: "addPermittedAuthMethodScope",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256[]",
          name: "permittedAuthMethodTypesToAdd",
          type: "uint256[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodIdsToAdd",
          type: "bytes[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodPubkeysToAdd",
          type: "bytes[]"
        },
        {
          internalType: "uint256[][]",
          name: "permittedAuthMethodScopesToAdd",
          type: "uint256[][]"
        },
        {
          internalType: "uint256[]",
          name: "permittedAuthMethodTypesToRemove",
          type: "uint256[]"
        },
        {
          internalType: "bytes[]",
          name: "permittedAuthMethodIdsToRemove",
          type: "bytes[]"
        }
      ],
      name: "batchAddRemoveAuthMethods",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "getAuthMethodId",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getEthAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPermittedActions",
      outputs: [
        {
          internalType: "bytes[]",
          name: "",
          type: "bytes[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPermittedAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          internalType: "uint256",
          name: "maxScopeId",
          type: "uint256"
        }
      ],
      name: "getPermittedAuthMethodScopes",
      outputs: [
        {
          internalType: "bool[]",
          name: "",
          type: "bool[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPermittedAuthMethods",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "authMethodType",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "id",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "userPubkey",
              type: "bytes"
            }
          ],
          internalType: "struct LibPKPPermissionsStorage.AuthMethod[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpNftAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPubkey",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getRouterAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "getTokenIdsForAuthMethod",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "getUserPubkeyForAuthMethod",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "ipfsCID",
          type: "bytes"
        }
      ],
      name: "isPermittedAction",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "user",
          type: "address"
        }
      ],
      name: "isPermittedAddress",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "isPermittedAuthMethod",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          internalType: "uint256",
          name: "scopeId",
          type: "uint256"
        }
      ],
      name: "isPermittedAuthMethodScopePresent",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "ipfsCID",
          type: "bytes"
        }
      ],
      name: "removePermittedAction",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "user",
          type: "address"
        }
      ],
      name: "removePermittedAddress",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        }
      ],
      name: "removePermittedAuthMethod",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "authMethodType",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "id",
          type: "bytes"
        },
        {
          internalType: "uint256",
          name: "scopeId",
          type: "uint256"
        }
      ],
      name: "removePermittedAuthMethodScope",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "group",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "root",
          type: "bytes32"
        }
      ],
      name: "setRootHash",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "group",
          type: "uint256"
        },
        {
          internalType: "bytes32[]",
          name: "proof",
          type: "bytes32[]"
        },
        {
          internalType: "bytes32",
          name: "leaf",
          type: "bytes32"
        }
      ],
      name: "verifyState",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "group",
          type: "uint256"
        },
        {
          internalType: "bytes32[]",
          name: "proof",
          type: "bytes32[]"
        },
        {
          internalType: "bool[]",
          name: "proofFlags",
          type: "bool[]"
        },
        {
          internalType: "bytes32[]",
          name: "leaves",
          type: "bytes32[]"
        }
      ],
      name: "verifyStates",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/PubkeyRouter.sol/PubkeyRouterData.ts
init_shim();
var PubkeyRouterData = {
  date: "2023-11-14T15:45:41Z",
  address: "0x4B5E97F2D811520e031A8F924e698B329ad83E29",
  contractName: "PubkeyRouter",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "ContractResolverAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "pubkey",
          type: "bytes"
        },
        {
          indexed: false,
          internalType: "address",
          name: "stakingContract",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes32",
          name: "derivedKeyId",
          type: "bytes32"
        }
      ],
      name: "PubkeyRoutingDataSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "stakingContract",
          type: "address"
        },
        {
          components: [
            {
              internalType: "bytes",
              name: "pubkey",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            }
          ],
          indexed: false,
          internalType: "struct IPubkeyRouter.RootKey",
          name: "rootKey",
          type: "tuple"
        }
      ],
      name: "RootKeySet",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "bytes32",
              name: "r",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "s",
              type: "bytes32"
            },
            {
              internalType: "uint8",
              name: "v",
              type: "uint8"
            }
          ],
          internalType: "struct IPubkeyRouter.Signature[]",
          name: "signatures",
          type: "tuple[]"
        },
        {
          internalType: "bytes",
          name: "signedMessage",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "stakingContractAddress",
          type: "address"
        }
      ],
      name: "checkNodeSignatures",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "pubkey",
          type: "bytes"
        }
      ],
      name: "deriveEthAddressFromPubkey",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "ethAddress",
          type: "address"
        }
      ],
      name: "ethAddressToPkpId",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakingContract",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "derivedKeyId",
          type: "bytes32"
        }
      ],
      name: "getDerivedPubkey",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getEthAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getPkpNftAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getPubkey",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakingContract",
          type: "address"
        }
      ],
      name: "getRootKeys",
      outputs: [
        {
          components: [
            {
              internalType: "bytes",
              name: "pubkey",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            }
          ],
          internalType: "struct IPubkeyRouter.RootKey[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getRoutingData",
      outputs: [
        {
          components: [
            {
              internalType: "bytes",
              name: "pubkey",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "derivedKeyId",
              type: "bytes32"
            }
          ],
          internalType: "struct LibPubkeyRouterStorage.PubkeyRoutingData",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "isRouted",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "pubkeys",
      outputs: [
        {
          components: [
            {
              internalType: "bytes",
              name: "pubkey",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "derivedKeyId",
              type: "bytes32"
            }
          ],
          internalType: "struct LibPubkeyRouterStorage.PubkeyRoutingData",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "pubkey",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "stakingContractAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "derivedKeyId",
          type: "bytes32"
        }
      ],
      name: "setRoutingData",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "pubkey",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "stakingContract",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "keyType",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "derivedKeyId",
          type: "bytes32"
        }
      ],
      name: "setRoutingDataAsAdmin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakingContractAddress",
          type: "address"
        },
        {
          components: [
            {
              internalType: "bytes",
              name: "pubkey",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "keyType",
              type: "uint256"
            }
          ],
          internalType: "struct IPubkeyRouter.RootKey[]",
          name: "newRootKeys",
          type: "tuple[]"
        }
      ],
      name: "voteForRootKeys",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/RateLimitNFT.sol/RateLimitNFTData.ts
init_shim();
var RateLimitNFTData = {
  date: "2023-11-14T15:45:41Z",
  address: "0x19593CbBC56Ddd339Fde26278A544a25166C2388",
  contractName: "RateLimitNFT",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newAdditionalRequestsPerKilosecondCost",
          type: "uint256"
        }
      ],
      name: "AdditionalRequestsPerKilosecondCostSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "approved",
          type: "address"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "operator",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bool",
          name: "approved",
          type: "bool"
        }
      ],
      name: "ApprovalForAll",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "newFreeMintSigner",
          type: "address"
        }
      ],
      name: "FreeMintSignerSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newFreeRequestsPerRateLimitWindow",
          type: "uint256"
        }
      ],
      name: "FreeRequestsPerRateLimitWindowSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newRLIHolderRateLimitWindowSeconds",
          type: "uint256"
        }
      ],
      name: "RLIHolderRateLimitWindowSecondsSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newRateLimitWindowSeconds",
          type: "uint256"
        }
      ],
      name: "RateLimitWindowSecondsSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Withdrew",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "requestsPerKilosecond",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "msgHash",
          type: "bytes32"
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "sVal",
          type: "bytes32"
        }
      ],
      name: "freeMint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "getApproved",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "operator",
          type: "address"
        }
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        }
      ],
      name: "mint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newAdditionalRequestsPerKilosecondCost",
          type: "uint256"
        }
      ],
      name: "setAdditionalRequestsPerKilosecondCost",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address"
        },
        {
          internalType: "bool",
          name: "approved",
          type: "bool"
        }
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newFreeMintSigner",
          type: "address"
        }
      ],
      name: "setFreeMintSigner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newFreeRequestsPerRateLimitWindow",
          type: "uint256"
        }
      ],
      name: "setFreeRequestsPerRateLimitWindow",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMaxExpirationSeconds",
          type: "uint256"
        }
      ],
      name: "setMaxExpirationSeconds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMaxRequestsPerKilosecond",
          type: "uint256"
        }
      ],
      name: "setMaxRequestsPerKilosecond",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newRLIHolderRateLimitWindowSeconds",
          type: "uint256"
        }
      ],
      name: "setRLIHolderRateLimitWindowSeconds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newRateLimitWindowSeconds",
          type: "uint256"
        }
      ],
      name: "setRateLimitWindowSeconds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "index",
          type: "uint256"
        }
      ],
      name: "tokenByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256"
        }
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "tokenURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "RLIHolderRateLimitWindowSeconds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "additionalRequestsPerKilosecondCost",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "requestsPerKilosecond",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        }
      ],
      name: "calculateCost",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "payingAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        }
      ],
      name: "calculateRequestsPerKilosecond",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "capacity",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "requestsPerKilosecond",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "expiresAt",
              type: "uint256"
            }
          ],
          internalType: "struct LibRateLimitNFTStorage.RateLimit",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "requestedRequestsPerKilosecond",
          type: "uint256"
        }
      ],
      name: "checkBelowMaxRequestsPerKilosecond",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "currentSoldRequestsPerKilosecond",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "defaultRateLimitWindowSeconds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "requestsPerKilosecond",
          type: "uint256"
        },
        {
          internalType: "bytes32",
          name: "msgHash",
          type: "bytes32"
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "sVal",
          type: "bytes32"
        }
      ],
      name: "freeMintSigTest",
      outputs: [],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "freeMintSigner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "freeRequestsPerRateLimitWindow",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "isExpired",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "maxExpirationSeconds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "maxRequestsPerKilosecond",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "hash",
          type: "bytes32"
        }
      ],
      name: "prefixed",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "msgHash",
          type: "bytes32"
        }
      ],
      name: "redeemedFreeMints",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "tokenIdCounter",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256"
        }
      ],
      name: "tokenSVG",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expiresAt",
          type: "uint256"
        }
      ],
      name: "totalSoldRequestsPerKilosecondByExpirationTime",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/Staking.sol/StakingData.ts
init_shim();
var StakingData = {
  date: "2023-11-14T15:45:41Z",
  address: "0x5bFa704aF947b3b0f966e4248DED7bfa6edeF952",
  contractName: "Staking",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "ActiveValidatorsCannotLeave",
      type: "error"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakingAddress",
          type: "address"
        }
      ],
      name: "CannotRejoinUntilNextEpochBecauseKicked",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "senderPubKey",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "receiverPubKey",
          type: "uint256"
        }
      ],
      name: "CannotReuseCommsKeys",
      type: "error"
    },
    {
      inputs: [],
      name: "CannotStakeZero",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "CannotVoteTwice",
      type: "error"
    },
    {
      inputs: [],
      name: "CannotWithdrawZero",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "nodeAddress",
          type: "address"
        }
      ],
      name: "CouldNotMapNodeAddressToStakerAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "state",
          type: "uint8"
        }
      ],
      name: "MustBeInActiveOrUnlockedOrPausedState",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "state",
          type: "uint8"
        }
      ],
      name: "MustBeInActiveOrUnlockedState",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "state",
          type: "uint8"
        }
      ],
      name: "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "state",
          type: "uint8"
        }
      ],
      name: "MustBeInNextValidatorSetLockedState",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "state",
          type: "uint8"
        }
      ],
      name: "MustBeInReadyForNextEpochState",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "MustBeValidatorInNextEpochToKick",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "currentTimestamp",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "epochEndTime",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "timeout",
          type: "uint256"
        }
      ],
      name: "NotEnoughTimeElapsedForTimeoutSinceLastEpoch",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "currentTimestamp",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "epochEndTime",
          type: "uint256"
        }
      ],
      name: "NotEnoughTimeElapsedSinceLastEpoch",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "validatorCount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "minimumValidatorCount",
          type: "uint256"
        }
      ],
      name: "NotEnoughValidatorsInNextEpoch",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "currentReadyValidatorCount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "nextReadyValidatorCount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "minimumValidatorCountToBeReady",
          type: "uint256"
        }
      ],
      name: "NotEnoughValidatorsReadyForNextEpoch",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "currentEpochNumber",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "receivedEpochNumber",
          type: "uint256"
        }
      ],
      name: "SignaledReadyForWrongEpochNumber",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "StakerNotPermitted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "yourBalance",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "requestedWithdrawlAmount",
          type: "uint256"
        }
      ],
      name: "TryingToWithdrawMoreThanStaked",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "validator",
          type: "address"
        },
        {
          internalType: "address[]",
          name: "validatorsInNextEpoch",
          type: "address[]"
        }
      ],
      name: "ValidatorIsNotInNextEpoch",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newTokenRewardPerTokenPerEpoch",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newComplaintTolerance",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newComplaintIntervalSecs",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256[]",
          name: "newKeyTypes",
          type: "uint256[]"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newMinimumValidatorCount",
          type: "uint256"
        }
      ],
      name: "ConfigSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newEpochEndTime",
          type: "uint256"
        }
      ],
      name: "EpochEndTimeSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newEpochLength",
          type: "uint256"
        }
      ],
      name: "EpochLengthSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newEpochTimeout",
          type: "uint256"
        }
      ],
      name: "EpochTimeoutSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "reason",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newKickPenaltyPercent",
          type: "uint256"
        }
      ],
      name: "KickPenaltyPercentSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "epochNumber",
          type: "uint256"
        }
      ],
      name: "ReadyForNextEpoch",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Recovered",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "RequestToJoin",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "RequestToLeave",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverContractAddress",
          type: "address"
        }
      ],
      name: "ResolverContractAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newDuration",
          type: "uint256"
        }
      ],
      name: "RewardsDurationUpdated",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newStakingTokenAddress",
          type: "address"
        }
      ],
      name: "StakingTokenSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "enum LibStakingStorage.States",
          name: "newState",
          type: "uint8"
        }
      ],
      name: "StateChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amountBurned",
          type: "uint256"
        }
      ],
      name: "ValidatorKickedFromNextEpoch",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "ValidatorRejoinedNextEpoch",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "reporter",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "validatorStakerAddress",
          type: "address"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "reason",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "VotedToKickValidatorInNextEpoch",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "validatorStakerAddress",
          type: "address"
        }
      ],
      name: "adminKickValidatorInNextEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "adminRejoinValidator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "validatorStakerAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amountToPenalize",
          type: "uint256"
        }
      ],
      name: "adminSlashValidator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "advanceEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "exit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "getReward",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "validatorStakerAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "reason",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "kickValidatorInNextEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "lockValidatorsForNextEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "ip",
          type: "uint32"
        },
        {
          internalType: "uint128",
          name: "ipv6",
          type: "uint128"
        },
        {
          internalType: "uint32",
          name: "port",
          type: "uint32"
        },
        {
          internalType: "address",
          name: "nodeAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "senderPubKey",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "receiverPubKey",
          type: "uint256"
        }
      ],
      name: "requestToJoin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "requestToLeave",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newTokenRewardPerTokenPerEpoch",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "newComplaintTolerance",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "newComplaintIntervalSecs",
          type: "uint256"
        },
        {
          internalType: "uint256[]",
          name: "newKeyTypes",
          type: "uint256[]"
        },
        {
          internalType: "uint256",
          name: "newMinimumValidatorCount",
          type: "uint256"
        }
      ],
      name: "setConfig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newEpochEndTime",
          type: "uint256"
        }
      ],
      name: "setEpochEndTime",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newEpochLength",
          type: "uint256"
        }
      ],
      name: "setEpochLength",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "newState",
          type: "uint8"
        }
      ],
      name: "setEpochState",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newEpochTimeout",
          type: "uint256"
        }
      ],
      name: "setEpochTimeout",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "ip",
          type: "uint32"
        },
        {
          internalType: "uint128",
          name: "ipv6",
          type: "uint128"
        },
        {
          internalType: "uint32",
          name: "port",
          type: "uint32"
        },
        {
          internalType: "address",
          name: "nodeAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "senderPubKey",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "receiverPubKey",
          type: "uint256"
        }
      ],
      name: "setIpPortNodeAddressAndCommunicationPubKeys",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "reason",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "newKickPenaltyPercent",
          type: "uint256"
        }
      ],
      name: "setKickPenaltyPercent",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "epochNumber",
          type: "uint256"
        }
      ],
      name: "signalReadyForNextEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "stake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint32",
          name: "ip",
          type: "uint32"
        },
        {
          internalType: "uint128",
          name: "ipv6",
          type: "uint128"
        },
        {
          internalType: "uint32",
          name: "port",
          type: "uint32"
        },
        {
          internalType: "address",
          name: "nodeAddress",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "senderPubKey",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "receiverPubKey",
          type: "uint256"
        }
      ],
      name: "stakeAndJoin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "unlockValidatorsForNextEpoch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "major",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "minor",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "patch",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Version",
          name: "version",
          type: "tuple"
        }
      ],
      name: "checkVersion",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getMaxVersion",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "major",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "minor",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "patch",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Version",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getMaxVersionString",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getMinVersion",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "major",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "minor",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "patch",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Version",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getMinVersionString",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "major",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "minor",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "patch",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Version",
          name: "version",
          type: "tuple"
        }
      ],
      name: "setMaxVersion",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "major",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "minor",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "patch",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Version",
          name: "version",
          type: "tuple"
        }
      ],
      name: "setMinVersion",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "config",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "tokenRewardPerTokenPerEpoch",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "complaintTolerance",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "complaintIntervalSecs",
              type: "uint256"
            },
            {
              internalType: "uint256[]",
              name: "keyTypes",
              type: "uint256[]"
            },
            {
              internalType: "uint256",
              name: "minimumValidatorCount",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Config",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "contractResolver",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "countOfCurrentValidatorsReadyForNextEpoch",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "countOfNextValidatorsReadyForNextEpoch",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "currentValidatorCountForConsensus",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "epoch",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "epochLength",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "number",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "endTime",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "retries",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "timeout",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Epoch",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getKeyTypes",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getKickedValidators",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "addresses",
          type: "address[]"
        }
      ],
      name: "getNodeStakerAddressMappings",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "nodeAddress",
              type: "address"
            },
            {
              internalType: "address",
              name: "stakerAddress",
              type: "address"
            }
          ],
          internalType: "struct LibStakingStorage.AddressMapping[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getStakingBalancesAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getTokenAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getValidatorsInCurrentEpoch",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getValidatorsInCurrentEpochLength",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getValidatorsInNextEpoch",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "addresses",
          type: "address[]"
        }
      ],
      name: "getValidatorsStructs",
      outputs: [
        {
          components: [
            {
              internalType: "uint32",
              name: "ip",
              type: "uint32"
            },
            {
              internalType: "uint128",
              name: "ipv6",
              type: "uint128"
            },
            {
              internalType: "uint32",
              name: "port",
              type: "uint32"
            },
            {
              internalType: "address",
              name: "nodeAddress",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "reward",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "senderPubKey",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "receiverPubKey",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Validator[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getValidatorsStructsInCurrentEpoch",
      outputs: [
        {
          components: [
            {
              internalType: "uint32",
              name: "ip",
              type: "uint32"
            },
            {
              internalType: "uint128",
              name: "ipv6",
              type: "uint128"
            },
            {
              internalType: "uint32",
              name: "port",
              type: "uint32"
            },
            {
              internalType: "address",
              name: "nodeAddress",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "reward",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "senderPubKey",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "receiverPubKey",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Validator[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getValidatorsStructsInNextEpoch",
      outputs: [
        {
          components: [
            {
              internalType: "uint32",
              name: "ip",
              type: "uint32"
            },
            {
              internalType: "uint128",
              name: "ipv6",
              type: "uint128"
            },
            {
              internalType: "uint32",
              name: "port",
              type: "uint32"
            },
            {
              internalType: "address",
              name: "nodeAddress",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "reward",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "senderPubKey",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "receiverPubKey",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Validator[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "epochNumber",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "validatorStakerAddress",
          type: "address"
        },
        {
          internalType: "address",
          name: "voterStakerAddress",
          type: "address"
        }
      ],
      name: "getVotingStatusToKickValidator",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "isActiveValidator",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "isActiveValidatorByNodeAddress",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isReadyForNextEpoch",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "reason",
          type: "uint256"
        }
      ],
      name: "kickPenaltyPercentByReason",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "nextValidatorCountForConsensus",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "nodeAddress",
          type: "address"
        }
      ],
      name: "nodeAddressToStakerAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "readyForNextEpoch",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "shouldKickValidator",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "state",
      outputs: [
        {
          internalType: "enum LibStakingStorage.States",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "validators",
      outputs: [
        {
          components: [
            {
              internalType: "uint32",
              name: "ip",
              type: "uint32"
            },
            {
              internalType: "uint128",
              name: "ipv6",
              type: "uint128"
            },
            {
              internalType: "uint32",
              name: "port",
              type: "uint32"
            },
            {
              internalType: "address",
              name: "nodeAddress",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "reward",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "senderPubKey",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "receiverPubKey",
              type: "uint256"
            }
          ],
          internalType: "struct LibStakingStorage.Validator",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/abis/StakingBalances.sol/StakingBalancesData.ts
init_shim();
var StakingBalancesData = {
  date: "2023-11-14T15:45:41Z",
  address: "0x095251de2aD2A78aDe96F2a11F7feAA7CF93e6B5",
  contractName: "StakingBalances",
  abi: [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotAddFunctionToDiamondThatAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotAddSelectorsToZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveFunctionThatDoesNotExist",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotRemoveImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionThatDoesNotExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4[]",
          name: "_selectors",
          type: "bytes4[]"
        }
      ],
      name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4"
        }
      ],
      name: "CannotReplaceImmutableFunction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_action",
          type: "uint8"
        }
      ],
      name: "IncorrectFacetCutAction",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_initializationContractAddress",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "InitializationFunctionReverted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_contractAddress",
          type: "address"
        },
        {
          internalType: "string",
          name: "_message",
          type: "string"
        }
      ],
      name: "NoBytecodeAtAddress",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "NoSelectorsProvidedForFacetForCut",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_user",
          type: "address"
        },
        {
          internalType: "address",
          name: "_contractOwner",
          type: "address"
        }
      ],
      name: "NotContractOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facetAddress",
          type: "address"
        }
      ],
      name: "RemoveFacetAddressMustBeZeroAddress",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          indexed: false,
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          indexed: false,
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "DiamondCut",
      type: "event"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "enum IDiamond.FacetCutAction",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamond.FacetCut[]",
          name: "_diamondCut",
          type: "tuple[]"
        },
        {
          internalType: "address",
          name: "_init",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "_calldata",
          type: "bytes"
        }
      ],
      name: "diamondCut",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_functionSelector",
          type: "bytes4"
        }
      ],
      name: "facetAddress",
      outputs: [
        {
          internalType: "address",
          name: "facetAddress_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facetAddresses",
      outputs: [
        {
          internalType: "address[]",
          name: "facetAddresses_",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_facet",
          type: "address"
        }
      ],
      name: "facetFunctionSelectors",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "_facetFunctionSelectors",
          type: "bytes4[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "facets",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "facetAddress",
              type: "address"
            },
            {
              internalType: "bytes4[]",
              name: "functionSelectors",
              type: "bytes4[]"
            }
          ],
          internalType: "struct IDiamondLoupe.Facet[]",
          name: "facets_",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "owner_",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "ActiveValidatorsCannotLeave",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        },
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "AliasNotOwnedBySender",
      type: "error"
    },
    {
      inputs: [],
      name: "CallerNotOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "CannotRemoveAliasOfActiveValidator",
      type: "error"
    },
    {
      inputs: [],
      name: "CannotStakeZero",
      type: "error"
    },
    {
      inputs: [],
      name: "CannotWithdrawZero",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "aliasCount",
          type: "uint256"
        }
      ],
      name: "MaxAliasCountReached",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "OnlyStakingContract",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amountStaked",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "minimumStake",
          type: "uint256"
        }
      ],
      name: "StakeMustBeGreaterThanMinimumStake",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amountStaked",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "maximumStake",
          type: "uint256"
        }
      ],
      name: "StakeMustBeLessThanMaximumStake",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "stakerAddress",
          type: "address"
        }
      ],
      name: "StakerNotPermitted",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "yourBalance",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "requestedWithdrawlAmount",
          type: "uint256"
        }
      ],
      name: "TryingToWithdrawMoreThanStaked",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "AliasAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "AliasRemoved",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newMaxAliasCount",
          type: "uint256"
        }
      ],
      name: "MaxAliasCountSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newMaximumStake",
          type: "uint256"
        }
      ],
      name: "MaximumStakeSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newMinimumStake",
          type: "uint256"
        }
      ],
      name: "MinimumStakeSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "PermittedStakerAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "PermittedStakerRemoved",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bool",
          name: "permittedStakersOn",
          type: "bool"
        }
      ],
      name: "PermittedStakersOnChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "ResolverContractAddressSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "reward",
          type: "uint256"
        }
      ],
      name: "RewardPaid",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Staked",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "newTokenRewardPerTokenPerEpoch",
          type: "uint256"
        }
      ],
      name: "TokenRewardPerTokenPerEpochSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "ValidatorNotRewardedBecauseAlias",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "ValidatorRewarded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "ValidatorTokensPenalized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Withdrawn",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "addAlias",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "addPermittedStaker",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "stakers",
          type: "address[]"
        }
      ],
      name: "addPermittedStakers",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "checkStakingAmounts",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getReward",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "getStakingAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getTokenAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "isPermittedStaker",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "maximumStake",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "minimumStake",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "penalizeTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "permittedStakersOn",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "aliasAccount",
          type: "address"
        }
      ],
      name: "removeAlias",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "staker",
          type: "address"
        }
      ],
      name: "removePermittedStaker",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "staker",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "balance",
          type: "uint256"
        }
      ],
      name: "restakePenaltyTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "rewardOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "rewardValidator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newResolverAddress",
          type: "address"
        }
      ],
      name: "setContractResolver",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMaxAliasCount",
          type: "uint256"
        }
      ],
      name: "setMaxAliasCount",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMaximumStake",
          type: "uint256"
        }
      ],
      name: "setMaximumStake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newMinimumStake",
          type: "uint256"
        }
      ],
      name: "setMinimumStake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "permitted",
          type: "bool"
        }
      ],
      name: "setPermittedStakersOn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "stake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "totalStaked",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "balance",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "recipient",
          type: "address"
        }
      ],
      name: "transferPenaltyTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "balance",
          type: "uint256"
        }
      ],
      name: "withdrawPenaltyTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

// packages/contracts-sdk/src/lib/addresses.ts
init_shim();
import * as bitcoinjs from "bitcoinjs-lib";
var import_utils5 = __toESM(require_utils2());
import { toBech32 } from "@cosmjs/encoding";
import { Secp256k1 } from "@cosmjs/crypto";
import { rawSecp256k1PubkeyToRawAddress } from "@cosmjs/amino";
var derivedAddresses = async ({
  publicKey,
  pkpTokenId,
  pkpContractAddress,
  defaultRPCUrl,
  options = {
    cacheContractCall: false
  }
}) => {
  let pubkeyBuffer;
  if (!publicKey && !pkpTokenId) {
    throw new Error("publicKey or pkpTokenId must be provided");
  }
  if (!pkpContractAddress) {
    pkpContractAddress = PKPNFTData.address;
  }
  if (!defaultRPCUrl) {
    defaultRPCUrl = "https://chain-rpc.litprotocol.com/http";
  }
  let isNewPKP = false;
  if (pkpTokenId) {
    const CACHE_KEY = "lit-cached-pkps";
    try {
      const cachedPkp = localStorage.getItem(CACHE_KEY);
      if (cachedPkp) {
        const cachedPkpJSON = JSON.parse(cachedPkp);
        if (cachedPkpJSON[pkpTokenId]) {
          publicKey = cachedPkpJSON[pkpTokenId];
        } else {
          const provider = new ethers_exports.providers.JsonRpcProvider(defaultRPCUrl);
          const contract = new Contract(
            pkpContractAddress,
            ["function getPubkey(uint256 tokenId) view returns (bytes memory)"],
            provider
          );
          publicKey = await contract["getPubkey"](pkpTokenId);
          isNewPKP = true;
        }
      }
    } catch (e2) {
      console.error(e2);
    }
    if (options.cacheContractCall) {
      try {
        const cachedPkp = localStorage.getItem(CACHE_KEY);
        if (cachedPkp) {
          const cachedPkpJSON = JSON.parse(cachedPkp);
          cachedPkpJSON[pkpTokenId] = publicKey;
          localStorage.setItem(CACHE_KEY, JSON.stringify(cachedPkpJSON));
        } else {
          const cachedPkpJSON = {};
          cachedPkpJSON[pkpTokenId] = publicKey;
          localStorage.setItem(CACHE_KEY, JSON.stringify(cachedPkpJSON));
        }
      } catch (e2) {
        console.error(e2);
      }
    }
  }
  if (publicKey === void 0) {
    console.warn("publicKey is undefined");
  }
  if (!publicKey) {
    console.warn("publicKey or pubkeyBuffer is undefined");
    return;
  }
  if (publicKey.startsWith("0x")) {
    publicKey = publicKey.slice(2);
  }
  pubkeyBuffer = Buffer.from(publicKey, "hex");
  const ethAddress = (0, import_utils5.computeAddress)(pubkeyBuffer);
  const btcAddress = bitcoinjs.payments.p2pkh({
    pubkey: pubkeyBuffer
  }).address;
  if (!btcAddress || !ethAddress) {
    const errors = [];
    if (!btcAddress) {
      errors.push("btcAddress is undefined");
    }
    if (!ethAddress) {
      errors.push("ethAddress is undefined");
    }
    throw new Error(errors.join(", "));
  }
  function getCosmosAddress(pubkeyBuffer2) {
    return toBech32(
      "cosmos",
      rawSecp256k1PubkeyToRawAddress(Secp256k1.compressPubkey(pubkeyBuffer2))
    );
  }
  const cosmosAddress = getCosmosAddress(pubkeyBuffer);
  return {
    tokenId: pkpTokenId,
    publicKey: `0x${publicKey}`,
    publicKeyBuffer: pubkeyBuffer,
    ethAddress,
    btcAddress,
    cosmosAddress,
    isNewPKP
  };
};

// packages/contracts-sdk/src/lib/contracts-sdk.ts
var import_utils6 = __toESM(require_utils2());

// packages/contracts-sdk/src/lib/auth-utils.ts
init_shim();
import * as jose from "jose";
async function getAuthIdByAuthMethod(authMethod) {
  let authId;
  switch (authMethod.authMethodType) {
    case 1:
      authId = getEthAuthMethodId(authMethod);
      break;
    case 4:
      authId = await getDiscordAuthId(authMethod);
      break;
    case 3:
      authId = await getWebauthnAuthId(authMethod);
      break;
    case 6:
      authId = await getGoogleJwtAuthId(authMethod);
      break;
    case 9:
      authId = await getStytchAuthId(authMethod);
      break;
    case 10:
    case 11:
    case 12:
    case 13:
      authId = await getStytchFactorAuthMethodId(authMethod);
      break;
    default:
      throw new Error(
        `Unsupported auth method type: ${authMethod.authMethodType}`
      );
  }
  return authId;
}
function getEthAuthMethodId(authMethod) {
  let address;
  let accessToken;
  try {
    accessToken = JSON.parse(authMethod.accessToken);
  } catch (err) {
    throw new Error("Unable to parse access token as JSON object");
  }
  address = accessToken.address;
  if (!address) {
    throw new Error("No address found in access token");
  }
  return ethers_exports.utils.keccak256(ethers_exports.utils.toUtf8Bytes(`${address}:lit`));
}
async function getDiscordAuthId(authMethod) {
  const _clientId = "1052874239658692668";
  let userId;
  const meResponse = await fetch("https://discord.com/api/users/@me", {
    method: "GET",
    headers: {
      authorization: `Bearer ${authMethod.accessToken}`
    }
  });
  if (meResponse.ok) {
    const user = await meResponse.json();
    userId = user.id;
  } else {
    throw new Error("Unable to verify Discord account");
  }
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(`${userId}:${_clientId}`)
  );
  return authMethodId;
}
async function getWebauthnAuthId(authMethod) {
  let credentialId;
  const rpNameToUse = "lit";
  try {
    credentialId = JSON.parse(authMethod.accessToken).rawId;
  } catch (err) {
    throw new Error(
      `Error when parsing auth method to generate auth method ID for WebAuthn: ${err}`
    );
  }
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(`${credentialId}:${rpNameToUse}`)
  );
  return authMethodId;
}
async function getStytchAuthId(authMethod) {
  try {
    let tokenBody = _parseJWT(authMethod.accessToken);
    const userId = tokenBody["sub"];
    const orgId = tokenBody["aud"][0];
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId.toLowerCase()}:${orgId.toLowerCase()}`)
    );
    return authMethodId;
  } catch (err) {
    throw new Error(
      `Error while parsing auth method to generate auth method id for Stytch OTP: ${err}`
    );
  }
}
function getStytchFactorAuthMethodId(authMethod) {
  return new Promise((resolve, reject) => {
    const accessToken = authMethod.accessToken;
    const parsedToken = _parseJWT(accessToken);
    let factor = "email";
    switch (authMethod.authMethodType) {
      case 10:
        factor = "email";
        break;
      case 11:
        factor = "sms";
        break;
      case 12:
        factor = "whatsApp";
        break;
      case 13:
        factor = "totp";
        break;
      default:
        throw new Error("Unsupport stytch auth type");
    }
    const factorParser = _resolveAuthFactor(factor).parser;
    try {
      resolve(factorParser(parsedToken, "https://stytch.com/session"));
    } catch (e2) {
      reject(e2);
    }
  });
}
async function getGoogleJwtAuthId(authMethod) {
  const tokenPayload = jose.decodeJwt(authMethod.accessToken);
  const userId = tokenPayload["sub"];
  const audience = tokenPayload["aud"];
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(`${userId}:${audience}`)
  );
  return authMethodId;
}
function _parseJWT(jwt) {
  const parts = jwt.split(".");
  if (parts.length !== 3) {
    throw new Error("Invalid token length");
  }
  const body = Buffer.from(parts[1], "base64");
  const parsedBody = JSON.parse(body.toString("ascii"));
  console.log("JWT body: ", parsedBody);
  return parsedBody;
}
var emailOtpAuthFactorParser = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.email_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.email_factor.email_address;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var smsOtpAuthFactorParser = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.phone_number_factor.phone_number;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var whatsAppOtpAuthFactorParser = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.phone_number_factor.phone_number;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var totpAuthFactorParser = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.authenticator_app_factor.totp_id;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
function _resolveAuthFactor(factor) {
  switch (factor) {
    case "email":
      return {
        parser: emailOtpAuthFactorParser,
        authMethodType: 10
      };
    case "sms":
      return {
        parser: smsOtpAuthFactorParser,
        authMethodType: 11
      };
    case "whatsApp":
      return {
        parser: whatsAppOtpAuthFactorParser,
        authMethodType: 12
      };
    case "totp":
      return {
        parser: totpAuthFactorParser,
        authMethodType: 13
      };
  }
  throw new Error(`Error could not find auth with factor ${factor}`);
}

// packages/contracts-sdk/src/lib/utils.ts
init_shim();
function calculateUTCMidnightExpiration(daysFromNow) {
  const now2 = /* @__PURE__ */ new Date();
  const utcNow = Date.UTC(
    now2.getUTCFullYear(),
    now2.getUTCMonth(),
    now2.getUTCDate()
  );
  const futureDate = new Date(utcNow);
  futureDate.setUTCDate(futureDate.getUTCDate() + daysFromNow);
  futureDate.setUTCHours(0, 0, 0, 0);
  return Math.floor(futureDate.getTime() / 1e3);
}
function requestsToKilosecond({
  period,
  requests
}) {
  const secondsPerDay = 86400;
  const kilosecondsPerDay = secondsPerDay / 1e3;
  switch (period) {
    case "day":
      return Math.round(requests / kilosecondsPerDay);
    case "second":
      return Math.round(requests * 1e3);
    default:
      throw new Error("Invalid period");
  }
}

// packages/contracts-sdk/src/lib/contracts-sdk.ts
var DEFAULT_RPC = "https://chain-rpc.litprotocol.com/http";
var BLOCK_EXPLORER = "https://chain.litprotocol.com/";
var CID;
try {
  CID = __require("multiformats/cid");
} catch (e2) {
  console.log("CID not found");
}
var asyncForEachReturn = async (array, callback) => {
  const list = [];
  for (let index = 0; index < array.length; index++) {
    const item = await callback(array[index], index, array);
    list.push(item);
  }
  return list;
};
var LitContracts = class _LitContracts {
  // ----- autogen:declares:end  -----
  // make the constructor args optional
  constructor(args) {
    this.randomPrivateKey = false;
    this.connected = false;
    this.isPKP = false;
    this.debug = false;
    /**
     * Logs a message to the console.
     *
     * @param {any} [args] An optional value to log with the message.
     */
    this.log = (...args) => {
      if (this.debug) {
        _LitContracts.logger.debug(...args);
      }
    };
    this.connect = async () => {
      let wallet;
      let SETUP_DONE = false;
      if (isBrowser() && !this.signer) {
        this.log("----- We're in the browser! -----");
        const web3Provider = window.ethereum;
        if (!web3Provider) {
          const msg = "No web3 provider found. Please install Brave, MetaMask or another web3 provider.";
          alert(msg);
          throw new Error(msg);
        }
        const chainInfo = {
          chainId: "0x2AC49",
          chainName: "Chronicle - Lit Protocol Testnet",
          nativeCurrency: { name: "LIT", symbol: "LIT", decimals: 18 },
          rpcUrls: this.rpcs,
          blockExplorerUrls: [BLOCK_EXPLORER],
          iconUrls: ["future"]
        };
        try {
          await web3Provider.send("wallet_switchEthereumChain", [
            { chainId: chainInfo.chainId }
          ]);
        } catch (e2) {
          await web3Provider.request({
            method: "wallet_addEthereumChain",
            params: [chainInfo]
          });
        }
        wallet = new ethers_exports.providers.Web3Provider(web3Provider);
        await wallet.send("eth_requestAccounts", []);
        this.provider = wallet;
      }
      if (isNode()) {
        this.log("----- We're in node! -----");
        this.provider = new ethers_exports.providers.JsonRpcProvider(this.rpc);
      }
      if (this.privateKey) {
        this.log("Using your own private key");
        this.signer = new ethers_exports.Wallet(this.privateKey, this.provider);
        this.provider = this.signer.provider;
        SETUP_DONE = true;
      }
      if (!this.privateKey && this.randomPrivateKey || this.options?.storeOrUseStorageKey) {
        console.warn("THIS.SIGNER:", this.signer);
        let STORAGE_KEY = "lit-contracts-sdk-private-key";
        this.log("Let's see if you have a private key in your local storage!");
        let storagePrivateKey;
        try {
          storagePrivateKey = localStorage.getItem(STORAGE_KEY);
        } catch (e2) {
        }
        if (!storagePrivateKey) {
          this.log("Not a problem, we will generate a random private key");
          storagePrivateKey = ethers_exports.utils.hexlify(ethers_exports.utils.randomBytes(32));
        } else {
          this.log("Found your private key in local storage. Let's use it!");
        }
        this.signer = new ethers_exports.Wallet(storagePrivateKey, this.provider);
        this.log("- Your private key:", storagePrivateKey);
        this.log("- Your address:", await this.signer.getAddress());
        this.log("- this.signer:", this.signer);
        this.log("- this.provider.getSigner():", this.provider.getSigner());
        if (this.options?.storeOrUseStorageKey) {
          console.warn(
            "You've set the option to store your private key in local storage."
          );
          localStorage.setItem(STORAGE_KEY, storagePrivateKey);
        }
      } else {
        if (isBrowser() && wallet && !SETUP_DONE) {
          this.log("this.signer:", this.signer);
          this.signer = wallet.getSigner();
        }
      }
      if (this.signer !== void 0 && this.signer !== null) {
        if ("litNodeClient" in this.signer && "rpcProvider" in this.signer) {
          this.log(`
  // ***********************************************************************************************
  //          THIS IS A PKP WALLET, USING IT AS A SIGNER AND ITS RPC PROVIDER AS PROVIDER                                    
  // ***********************************************************************************************
        `);
          this.provider = this.signer.rpcProvider;
          this.isPKP = true;
        }
      }
      if (!this.provider) {
        this.log("No provide found. Will try to use the one from the signer.");
        this.provider = this.signer.provider;
        this.log("Your Provider(from signer):", this.provider);
      }
      let addresses = await _LitContracts.getContractAddresses(
        this.network,
        this.customContext?.provider ?? this.provider,
        this.customContext
      );
      this.litTokenContract = {
        read: new ethers_exports.Contract(
          addresses.LITToken.address,
          addresses.LITToken.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.LITToken.address,
          addresses.LITToken.abi,
          this.signer
        )
      };
      this.multisenderContract = {
        read: new ethers_exports.Contract(
          addresses.Multisender.address,
          addresses.Multisender.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.Multisender.address,
          addresses.Multisender.abi,
          this.signer
        )
      };
      this.pkpHelperContract = {
        read: new ethers_exports.Contract(
          addresses.PKPHelper.address,
          addresses.PKPHelper.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.PKPHelper.address,
          addresses.PKPHelper.abi,
          this.signer
        )
      };
      this.pkpNftContract = {
        read: new ethers_exports.Contract(
          addresses.PKPNFT.address,
          addresses.PKPNFT.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.PKPNFT.address,
          addresses.PKPNFT.abi,
          this.signer
        )
      };
      this.pkpNftMetadataContract = {
        read: new ethers_exports.Contract(
          addresses.PKPNFTMetadata.address,
          addresses.PKPNFTMetadata.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.PKPNFTMetadata.address,
          addresses.PKPNFTMetadata.abi,
          this.signer
        )
      };
      this.pkpPermissionsContract = {
        read: new ethers_exports.Contract(
          addresses.PKPPermissions.address,
          addresses.PKPPermissions.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.PKPPermissions.address,
          addresses.PKPPermissions.abi,
          this.signer
        )
      };
      this.pubkeyRouterContract = {
        read: new ethers_exports.Contract(
          addresses.PubkeyRouter.address,
          addresses.PubkeyRouter.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.PubkeyRouter.address,
          addresses.PubkeyRouter.abi,
          this.signer
        )
      };
      this.rateLimitNftContract = {
        read: new ethers_exports.Contract(
          addresses.RateLimitNFT.address,
          addresses.RateLimitNFT.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.RateLimitNFT.address,
          addresses.RateLimitNFT.abi,
          this.signer
        )
      };
      this.stakingContract = {
        read: new ethers_exports.Contract(
          addresses.Staking.address,
          addresses.Staking.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.Staking.address,
          addresses.Staking.abi,
          this.signer
        )
      };
      this.stakingBalancesContract = {
        read: new ethers_exports.Contract(
          addresses.StakingBalances.address,
          addresses.StakingBalances.abi,
          this.provider
        ),
        write: new ethers_exports.Contract(
          addresses.StakingBalances.address,
          addresses.StakingBalances.abi,
          this.signer
        )
      };
      this.connected = true;
    };
    this.mintWithAuth = async ({
      authMethod,
      scopes,
      pubkey
    }) => {
      if (!this.connected) {
        throw new Error(
          "Contracts are not connected. Please call connect() first"
        );
      }
      if (!this.pkpNftContract) {
        throw new Error("Contract is not available");
      }
      if (authMethod && !authMethod?.authMethodType) {
        throw new Error("authMethodType is required");
      }
      if (authMethod && !authMethod?.accessToken) {
        throw new Error("accessToken is required");
      }
      if (scopes.length <= 0) {
        throw new Error(`\u274C Permission scopes are required!
[0] No Permissions
[1] Sign Anything	
[2] Only Sign Messages
Read more here:
https://developer.litprotocol.com/v3/sdk/wallets/auth-methods/#auth-method-scopes
      `);
      }
      const _pubkey = pubkey ?? "0x";
      scopes = scopes.map((scope) => {
        if (typeof scope === "string") {
          return ethers_exports.BigNumber.from(scope);
        }
        if (typeof scope === "number") {
          return ethers_exports.BigNumber.from(scope.toString());
        }
        return scope;
      });
      const authId = await getAuthIdByAuthMethod(authMethod);
      const mintCost = await this.pkpNftContract.read.mintCost();
      const tx = await this.pkpHelperContract.write.mintNextAndAddAuthMethods(
        2,
        // key type
        [authMethod.authMethodType],
        [authId],
        [_pubkey],
        [[...scopes]],
        true,
        true,
        {
          value: mintCost
        }
      );
      const receipt = await tx.wait();
      let events = "events" in receipt ? receipt.events : receipt.logs;
      if (!events || events.length <= 0) {
        throw new Error("No events found in receipt");
      }
      let tokenId;
      tokenId = events[0].topics[1];
      let publicKey = await this.pkpNftContract.read.getPubkey(tokenId);
      if (publicKey.startsWith("0x")) {
        publicKey = publicKey.slice(2);
      }
      const pubkeyBuffer = Buffer.from(publicKey, "hex");
      const ethAddress = (0, import_utils6.computeAddress)(pubkeyBuffer);
      return {
        pkp: {
          tokenId,
          publicKey,
          ethAddress
        },
        tx: receipt
      };
    };
    // Mints a Capacity Credits NFT (RLI) token with the specified daily request rate and expiration period.
    // The expiration date is calculated to be at midnight UTC, a specific number of days from now.
    this.mintCapacityCreditsNFT = async ({
      requestsPerDay,
      requestsPerSecond,
      requestsPerKilosecond,
      daysUntilUTCMidnightExpiration
    }) => {
      this.log("Minting Capacity Credits NFT...");
      if ((requestsPerDay === null || requestsPerDay === void 0 || requestsPerDay <= 0) && (requestsPerSecond === null || requestsPerSecond === void 0 || requestsPerSecond <= 0) && (requestsPerKilosecond === null || requestsPerKilosecond === void 0 || requestsPerKilosecond <= 0)) {
        throw new Error(
          "At least one of requestsPerDay, requestsPerSecond, or requestsPerKilosecond is required and must be more than 0"
        );
      }
      let effectiveRequestsPerKilosecond;
      if (requestsPerDay !== void 0) {
        effectiveRequestsPerKilosecond = requestsToKilosecond({
          period: "day",
          requests: requestsPerDay
        });
      } else if (requestsPerSecond !== void 0) {
        effectiveRequestsPerKilosecond = requestsToKilosecond({
          period: "second",
          requests: requestsPerSecond
        });
      } else if (requestsPerKilosecond !== void 0) {
        effectiveRequestsPerKilosecond = requestsPerKilosecond;
      }
      if (effectiveRequestsPerKilosecond === void 0 || effectiveRequestsPerKilosecond <= 0) {
        throw new Error(
          "Effective requests per kilosecond is required and must be more than 0"
        );
      }
      const expiresAt = calculateUTCMidnightExpiration(
        daysUntilUTCMidnightExpiration
      );
      let mintCost;
      try {
        mintCost = await this.rateLimitNftContract.read.calculateCost(
          effectiveRequestsPerKilosecond,
          expiresAt
        );
      } catch (e2) {
        this.log("Error calculating mint cost:", e2);
        throw e2;
      }
      this.log("Capacity Credits NFT mint cost:", mintCost.toString());
      if (requestsPerDay)
        this.log("Requests per day:", requestsPerDay);
      if (requestsPerSecond)
        this.log("Requests per second:", requestsPerSecond);
      this.log(
        "Effective requests per kilosecond:",
        effectiveRequestsPerKilosecond
      );
      this.log(`Expires at (Unix Timestamp): ${expiresAt}`);
      const expirationDate = new Date(expiresAt * 1e3);
      this.log("Expiration Date (UTC):", expirationDate.toUTCString());
      try {
        const res = await this.rateLimitNftContract.write.mint(expiresAt, {
          value: mintCost
        });
        const txHash = res.hash;
        let tx = await res.wait();
        const tokenId = ethers_exports.BigNumber.from(tx.logs[0].topics[3]);
        return {
          rliTxHash: txHash,
          capacityTokenId: tokenId,
          capacityTokenIdStr: tokenId.toString()
        };
      } catch (e2) {
        throw new Error(e2);
      }
    };
    // getRandomPrivateKeySignerProvider = () => {
    //   const privateKey = ethers.utils.hexlify(ethers.utils.randomBytes(32));
    //   let provider;
    //   if (isBrowser()) {
    //     provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
    //   } else {
    //     provider = new ethers.providers.JsonRpcProvider(this.rpc);
    //   }
    //   const signer = new ethers.Wallet(privateKey, provider);
    //   return { privateKey, signer, provider };
    // };
    // getPrivateKeySignerProvider = (privateKey: string) => {
    //   let provider;
    //   if (isBrowser()) {
    //     provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
    //   } else {
    //     provider = new ethers.providers.JsonRpcProvider(this.rpc);
    //   }
    //   const signer = new ethers.Wallet(privateKey, provider);
    //   return { privateKey, signer, provider };
    // };
    this.utils = {
      hexToDec,
      decToHex,
      /**
       * Partition multihash string into object representing multihash
       *
       * @param {string} multihash A base58 encoded multihash string
       * @returns {Multihash}
       */
      getBytesFromMultihash: (multihash) => {
        const decoded = bs58.decode(multihash);
        return `0x${Buffer.from(decoded).toString("hex")}`;
      },
      /**
       *
       * Convert bytes32 to IPFS ID
       * @param { string } byte32 0x1220baa0d1e91f2a22fef53659418ddc3ac92da2a76d994041b86ed62c0c999de477
       * @returns { string } QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
       */
      getMultihashFromBytes: (byte32) => {
        const text = byte32.replace("0x", "");
        const hashFunction = parseInt(text.slice(0, 2), 16);
        const digestSize = parseInt(text.slice(2, 4), 16);
        const digest = text.slice(4, 4 + digestSize * 2);
        const multihash = bs58.encode(Buffer.from(`1220${digest}`, "hex"));
        return multihash;
      },
      /**
       * Partition multihash string into object representing multihash
       *
       * @param {string} multihash A base58 encoded multihash string
       * @returns {Multihash}
       */
      getBytes32FromMultihash: async (ipfsId) => {
        const cid = CID.parse(ipfsId);
        const hashFunction = cid.multihash.code;
        const size = cid.multihash.size;
        const digest = "0x" + Buffer.from(cid.multihash.digest).toString("hex");
        let ipfsHash = {
          digest,
          hashFunction,
          size
        };
        return ipfsHash;
      },
      // convert timestamp to YYYY/MM/DD format
      timestamp2Date: (timestamp) => {
        const date = __require("date-and-time");
        const format = "YYYY/MM/DD HH:mm:ss";
        let timestampFormatted = new Date(parseInt(timestamp) * 1e3);
        return date.format(timestampFormatted, format);
      }
    };
    this.pkpNftContractUtils = {
      read: {
        /**
         * (IERC721Enumerable)
         *
         * Get all PKPs by a given address
         *
         * @param { string } ownerAddress
         * @retu
         * */
        getTokensByAddress: async (ownerAddress) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpNftContract) {
            throw new Error("Contract is not available");
          }
          if (!ethers_exports.utils.isAddress(ownerAddress)) {
            throw new Error(
              `Given string is not a valid address "${ownerAddress}"`
            );
          }
          let tokens = [];
          for (let i2 = 0; ; i2++) {
            let token;
            try {
              token = await this.pkpNftContract.read.tokenOfOwnerByIndex(
                ownerAddress,
                i2
              );
              token = this.utils.hexToDec(token.toHexString());
              tokens.push(token);
            } catch (e2) {
              this.log(`[getTokensByAddress] Ended search on index: ${i2}`);
              break;
            }
          }
          return tokens;
        },
        /**
         * (IERC721Enumerable)
         *
         * Get the x latest number of tokens
         *
         * @param { number } latestNumberOfTokens
         *
         * @returns { Array<string> } a list of PKP NFTs
         *
         */
        getTokens: async (latestNumberOfTokens) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpNftContract) {
            throw new Error("Contract is not available");
          }
          let tokens = [];
          for (let i2 = 0; ; i2++) {
            if (i2 >= latestNumberOfTokens) {
              break;
            }
            let token;
            try {
              token = await this.pkpNftContract.read.tokenByIndex(i2);
              token = this.utils.hexToDec(token.toHexString());
              tokens.push(token);
            } catch (e2) {
              this.log(`[getTokensByAddress] Ended search on index: ${i2}`);
              break;
            }
          }
          return tokens;
        },
        /**
         * Get info of all PKPs by a given address
         */
        getTokensInfoByAddress: async (ownerAddress) => {
          const tokenIds = await this.pkpNftContractUtils.read.getTokensByAddress(
            ownerAddress
          );
          const arr = [];
          for (let i2 = 0; i2 < tokenIds.length; i2++) {
            const tokenId = tokenIds[i2];
            const pubKey = await this.pkpNftContract.read.getPubkey(tokenId);
            const addrs = await derivedAddresses({
              pkpTokenId: tokenId,
              publicKey: pubKey
            });
            arr.push(addrs);
          }
          return arr;
        }
      },
      write: {
        mint: async () => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpNftContract) {
            throw new Error("Contract is not available");
          }
          let mintCost;
          try {
            mintCost = await this.pkpNftContract.read.mintCost();
          } catch (e2) {
            throw new Error("Could not get mint cost");
          }
          let sentTx;
          if (this.isPKP) {
            this.log(
              "This is a PKP wallet, so we'll use the PKP wallet to sign the tx"
            );
            this.log("...populating tx");
            let tx = await this.pkpNftContract.write.populateTransaction.mintNext(
              2,
              { value: mintCost }
            );
            this.log("tx:", tx);
            this.log("...signing tx");
            let signedTx = await this.signer.signTransaction(tx);
            this.log("signedTx:", signedTx);
            this.log("sending signed tx...");
            sentTx = await this.signer.sendTransaction(
              signedTx
            );
          } else {
            sentTx = await this.pkpNftContract.write.mintNext(2, {
              value: mintCost
            });
          }
          const res = await sentTx.wait();
          let events = "events" in res ? res.events : res.logs;
          let tokenIdFromEvent;
          tokenIdFromEvent = events[0].topics[1];
          let publicKey = await this.pkpNftContract.read.getPubkey(
            tokenIdFromEvent
          );
          if (publicKey.startsWith("0x")) {
            publicKey = publicKey.slice(2);
          }
          const pubkeyBuffer = Buffer.from(publicKey, "hex");
          const ethAddress = (0, import_utils6.computeAddress)(pubkeyBuffer);
          return {
            pkp: {
              tokenId: tokenIdFromEvent,
              publicKey,
              ethAddress
            },
            tx: sentTx,
            tokenId: tokenIdFromEvent,
            res
          };
        },
        claimAndMint: async (derivedKeyId, signatures, txOpts) => {
          let cost = await this.pkpNftContract.read.mintCost();
          const tx = await this.pkpNftContract.write.claimAndMint(
            2,
            derivedKeyId,
            signatures,
            txOpts ?? { value: cost }
          );
          let txRec = await tx.wait();
          let events = "events" in txRec ? txRec.events : txRec.logs;
          let tokenId = events[1].topics[1];
          return { tx, res: txRec, tokenId };
        }
      }
    };
    this.pkpPermissionsContractUtils = {
      read: {
        /**
         *
         * Check if an address is permitted
         *
         * @param { string } tokenId
         * @param { string } address
         *
         * @returns { Promise<boolean> }
         */
        isPermittedAddress: async (tokenId, address) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          const pkpIdHex = this.utils.decToHex(tokenId, null);
          const bool = await this.pkpPermissionsContract.read.isPermittedAddress(
            pkpIdHex,
            address
          );
          return bool;
        },
        getPermittedAddresses: async (tokenId) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          this.log("[getPermittedAddresses] input<tokenId>:", tokenId);
          let addresses = [];
          const maxTries = 5;
          let tries = 0;
          while (tries < maxTries) {
            try {
              addresses = await this.pkpPermissionsContract.read.getPermittedAddresses(
                tokenId
              );
              if (addresses.length <= 0) {
                await new Promise((resolve) => setTimeout(resolve, 1e3));
                tries++;
                continue;
              } else {
                break;
              }
            } catch (e2) {
              this.log(
                `[getPermittedAddresses] error<e.message | ${tries}>:`,
                e2.message
              );
              tries++;
            }
          }
          return addresses;
        },
        /**
         *
         * Get permitted action
         *
         * @param { any } id
         *
         * @returns { Promise<Array<any>> }
         *
         */
        getPermittedActions: async (tokenId) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          let actions = [];
          const maxTries = 5;
          let tries = 0;
          while (tries < maxTries) {
            try {
              actions = await this.pkpPermissionsContract.read.getPermittedActions(
                tokenId
              );
              if (actions.length <= 0) {
                await new Promise((resolve) => setTimeout(resolve, 1e3));
                tries++;
                continue;
              } else {
                break;
              }
            } catch (e2) {
              this.log(
                `[getPermittedActions] error<e.message | ${tries}>:`,
                e2.message
              );
              tries++;
            }
          }
          return actions;
        },
        /**
         *
         * Check if an action is permitted given the pkpid and ipfsId
         *
         * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
         * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         *
         * @return { object } transaction
         */
        isPermittedAction: async (pkpId, ipfsId) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          this.log("[isPermittedAction] input<pkpId>:", pkpId);
          this.log("[isPermittedAction] input<ipfsId>:", ipfsId);
          const ipfsHash = this.utils.getBytesFromMultihash(ipfsId);
          this.log("[isPermittedAction] converted<ipfsHash>:", ipfsHash);
          const bool = await this.pkpPermissionsContract.read.isPermittedAction(
            pkpId,
            ipfsHash
          );
          return bool;
        }
      },
      write: {
        /**
         *
         * Add permitted action to a given PKP id & ipfsId
         *
         * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
         * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         *
         * @return { object } transaction
         */
        addPermittedAction: async (pkpId, ipfsId) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract || !this.pubkeyRouterContract) {
            throw new Error("Contract is not available");
          }
          this.log("[addPermittedAction] input<pkpId>:", pkpId);
          const pubKey = await this.pubkeyRouterContract.read.getPubkey(pkpId);
          this.log("[addPermittedAction] converted<pubKey>:", pubKey);
          const pubKeyHash = ethers_exports.utils.keccak256(pubKey);
          this.log("[addPermittedAction] converted<pubKeyHash>:", pubKeyHash);
          const tokenId = ethers_exports.BigNumber.from(pubKeyHash);
          this.log("[addPermittedAction] converted<tokenId>:", tokenId);
          this.log("[addPermittedAction] input<ipfsId>:", ipfsId);
          const ipfsIdBytes = this.utils.getBytesFromMultihash(ipfsId);
          this.log("[addPermittedAction] converted<ipfsIdBytes>:", ipfsIdBytes);
          const tx = await this.pkpPermissionsContract.write.addPermittedAction(
            tokenId,
            ipfsIdBytes,
            [1]
          );
          this.log("[addPermittedAction] output<tx>:", tx);
          return tx;
        },
        /**
         * TODO: add transaction type
         * Add permitted action to a given PKP id & ipfsId
         *
         * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
         * @param { string } ownerAddress  0x3B5dD2605.....22aDC499A1
         *
         * @return { object } transaction
         */
        addPermittedAddress: async (pkpId, ownerAddress) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          this.log("[addPermittedAddress] input<pkpId>:", pkpId);
          this.log("[addPermittedAddress] input<ownerAddress>:", ownerAddress);
          this.log("[addPermittedAddress] input<pkpId>:", pkpId);
          const tx = await this.pkpPermissionsContract.write.addPermittedAddress(
            pkpId,
            ownerAddress,
            [1]
          );
          this.log("[addPermittedAddress] output<tx>:", tx);
          return tx;
        },
        /**
         * Revoke permitted action of a given PKP id & ipfsId
         *
         * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
         * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         *
         * @return { object } transaction
         */
        revokePermittedAction: async (pkpId, ipfsId) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.pkpPermissionsContract) {
            throw new Error("Contract is not available");
          }
          this.log("[revokePermittedAction] input<pkpId>:", pkpId);
          this.log("[revokePermittedAction] input<ipfsId>:", ipfsId);
          const ipfsHash = this.utils.getBytesFromMultihash(ipfsId);
          this.log("[revokePermittedAction] converted<ipfsHash>:", ipfsHash);
          const tx = await this.pkpPermissionsContract.write.removePermittedAction(
            pkpId,
            ipfsHash
          );
          this.log("[revokePermittedAction] output<tx>:", tx);
          return tx;
        }
      }
    };
    this.rateLimitNftContractUtils = {
      read: {
        /**
         * getCapacityByIndex: async (index: number): Promise<any> => {
         *
         *  This function takes a token index as a parameter and returns the capacity of the token
         *  with the given index. The capacity is an object that contains the number of requests
         *  per millisecond that the token allows, and an object with the expiration timestamp and
         *  formatted expiration date of the token.
         *
         *  @param {number} index - The index of the token.
         *  @returns {Promise<any>} - A promise that resolves to the capacity of the token.
         *
         *  Example:
         *
         *  const capacity = await getCapacityByIndex(1);
         *  this.log(capacity);
         *  // Output: {
         *  //   requestsPerMillisecond: 100,
         *  //   expiresAt: {
         *  //     timestamp: 1623472800,
         *  //     formatted: '2022-12-31',
         *  //   },
         *  // }
         *
         * }
         */
        getCapacityByIndex: async (index) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          const capacity = await this.rateLimitNftContract.read.capacity(index);
          return {
            requestsPerMillisecond: parseInt(capacity[0].toString()),
            expiresAt: {
              timestamp: parseInt(capacity[1].toString()),
              formatted: this.utils.timestamp2Date(capacity[1].toString())
            }
          };
        },
        /**
         * getTokenURIByIndex: async (index: number): Promise<string> => {
         *
         *  This function takes a token index as a parameter and returns the URI of the token
         *  with the given index.
         *
         *  @param {number} index - The index of the token.
         *  @returns {Promise<string>} - A promise that resolves to the URI of the token.
         *
         *  Example:
         *
         *  const URI = await getTokenURIByIndex(1);
         *  this.log(URI);
         *  // Output: 'https://tokens.com/1'
         *
         * }
         */
        getTokenURIByIndex: async (index) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          const base64 = await this.rateLimitNftContract.read.tokenURI(index);
          const data = base64.split("data:application/json;base64,")[1];
          const dataToString = Buffer.from(data, "base64").toString("binary");
          return JSON.parse(dataToString);
        },
        /**
         * getTokensByOwnerAddress: async (ownerAddress: string): Promise<any> => {
         *
         *  This function takes an owner address as a parameter and returns an array of tokens
         *  that are owned by the given address.
         *
         *  @param {string} ownerAddress - The address of the owner.
         *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
         *
         *  Example:
         *
         *  const tokens = await getTokensByOwnerAddress('0x1234...5678');
         *  this.log(tokens);
         *  // Output: [
         *  //   {
         *  //     tokenId: 1,
         *  //     URI: 'https://tokens.com/1',
         *  //     capacity: 100,
         *  //     isExpired: false,
         *  //   },
         *  //   {
         *  //     tokenId: 2,
         *  //     URI: 'https://tokens.com/2',
         *  //     capacity: 200,
         *  //     isExpired: true,
         *  //   },
         *  //   ...
         *  // ]
         *
         * }
         */
        getTokensByOwnerAddress: async (ownerAddress) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          if (!ethers_exports.utils.isAddress(ownerAddress)) {
            throw Error(`Given string is not a valid address "${ownerAddress}"`);
          }
          let total = await this.rateLimitNftContract.read.balanceOf(
            ownerAddress
          );
          total = parseInt(total.toString());
          const tokens = await asyncForEachReturn(
            [...new Array(total)],
            async (_, i2) => {
              if (!this.rateLimitNftContract) {
                throw new Error("Contract is not available");
              }
              const token = await this.rateLimitNftContract.read.tokenOfOwnerByIndex(
                ownerAddress,
                i2
              );
              const tokenIndex = parseInt(token.toString());
              const URI = await this.rateLimitNftContractUtils.read.getTokenURIByIndex(
                tokenIndex
              );
              const capacity = await this.rateLimitNftContractUtils.read.getCapacityByIndex(
                tokenIndex
              );
              const isExpired = await this.rateLimitNftContract.read.isExpired(
                tokenIndex
              );
              return {
                tokenId: parseInt(token.toString()),
                URI,
                capacity,
                isExpired
              };
            }
          );
          return tokens;
        },
        /**
         * getTokens: async (): Promise<any> => {
         *
         *  This function returns an array of all tokens that have been minted.
         *
         *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
         *
         *  Example:
         *
         *  const tokens = await getTokens();
         *  this.log(tokens);
         *  // Output: [
         *  //   {
         *  //     tokenId: 1,
         *  //     URI: 'https://tokens.com/1',
         *  //     capacity: 100,
         *  //     isExpired: false,
         *  //   },
         *  //   {
         *  //     tokenId: 2,
         *  //     URI: 'https://tokens.com/2',
         *  //     capacity: 200,
         *  //     isExpired: true,
         *  //   },
         *  //   ...
         *  // ]
         *
         * }
         */
        getTokens: async () => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          let total = await this.rateLimitNftContract.read.totalSupply();
          total = parseInt(total.toString());
          const tokens = await asyncForEachReturn(
            [...new Array(total)],
            async (_, i2) => {
              if (!this.rateLimitNftContract) {
                throw new Error("Contract is not available");
              }
              const token = await this.rateLimitNftContract.read.tokenByIndex(i2);
              const tokenIndex = parseInt(token.toString());
              const URI = await this.rateLimitNftContractUtils.read.getTokenURIByIndex(
                tokenIndex
              );
              const capacity = await this.rateLimitNftContractUtils.read.getCapacityByIndex(
                tokenIndex
              );
              const isExpired = await this.rateLimitNftContract.read.isExpired(
                tokenIndex
              );
              return {
                tokenId: parseInt(token.toString()),
                URI,
                capacity,
                isExpired
              };
            }
          );
          return tokens;
        }
      },
      write: {
        mint: async ({
          mintCost,
          timestamp
        }) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          const tx = await this.rateLimitNftContract.write.mint(
            timestamp,
            mintCost
          );
          const res = await tx.wait();
          const tokenIdFromEvent = res.events[0].topics[1];
          return { tx, tokenId: tokenIdFromEvent };
        },
        /**
         * Transfer RLI token from one address to another
         *
         * @property { string } fromAddress
         * @property { string } toAddress
         * @property  { stsring } RLITokenAddress
         *
         * @return { <Promise<void>> } void
         */
        transfer: async ({
          fromAddress,
          toAddress,
          RLITokenAddress
        }) => {
          if (!this.connected) {
            throw new Error(
              "Contracts are not connected. Please call connect() first"
            );
          }
          if (!this.rateLimitNftContract) {
            throw new Error("Contract is not available");
          }
          const tx = await this.rateLimitNftContract.write.transferFrom(
            fromAddress,
            toAddress,
            RLITokenAddress
          );
          this.log("tx:", tx);
          return tx;
        }
      }
    };
    this.routerContractUtils = {
      read: {
        /**
         *
         * Convert IPFS response from Solidity to IPFS ID
         * From: "0xb4200a696794b8742fab705a8c065ea6788a76bc6d270c0bc9ad900b6ed74ebc"
         * To: "QmUnwHVcaymJWiYGQ6uAHvebGtmZ8S1r9E6BVmJMtuK5WY"
         *
         * @param { string } solidityIpfsId
         *
         * @return { Promise<string> }
         */
        // getIpfsIds: async (solidityIpfsId: string): Promise<string> => {
        //   this.log('[getIpfsIds] input<solidityIpfsId>:', solidityIpfsId);
        //   const ipfsId = this.utils.getMultihashFromBytes(solidityIpfsId);
        //   this.log('[getIpfsIds] output<ipfsId>:', ipfsId);
        //   return ipfsId;
        // },
      },
      write: {}
    };
    this.pkpHelperContractUtil = {
      read: {},
      write: {
        /**
         *
         * @param param0
         * @returns
         */
        mintNextAndAddAuthMethods: async ({
          keyType,
          permittedAuthMethodTypes,
          permittedAuthMethodIds,
          permittedAuthMethodPubkeys,
          permittedAuthMethodScopes,
          addPkpEthAddressAsPermittedAddress,
          sendPkpToItself
        }) => {
          const mintCost = await this.pkpNftContract.read.mintCost();
          const tx = await this.pkpHelperContract.write.mintNextAndAddAuthMethods(
            keyType,
            permittedAuthMethodTypes,
            permittedAuthMethodIds,
            permittedAuthMethodPubkeys,
            permittedAuthMethodScopes,
            addPkpEthAddressAsPermittedAddress,
            sendPkpToItself,
            { value: mintCost }
          );
          return tx;
        }
        // claimAndMintNextAndAddAuthMethods: async (
        //   keyType: number,
        //   derivedKeyId: string,
        //   signatures: pkpHelperContract.IPubkeyRouter.SignatureStruct[],
        //   permittedAuthMethodTypes: string[],
        //   permittedAuthMethodIds: string[],
        //   permittedAuthMethodPubkeys: string[],
        //   permittedAuthMethodScopes: string[][],
        //   addPkpEthAddressAsPermittedAddress: boolean,
        //   sendPkpToItself: boolean
        // ): Promise<any> => {
        //   const mintCost = await this.pkpNftContract.read.mintCost();
        //   this.pkpHelperContract.write.claimAndMintNextAndAddAuthMethods(
        //     keyType,
        //     `0x${derivedKeyId}` as BytesLike,
        //     signatures,
        //     permittedAuthMethodTypes,
        //     permittedAuthMethodIds as BytesLike[],
        //     permittedAuthMethodPubkeys as BytesLike[],
        //     permittedAuthMethodScopes,
        //     addPkpEthAddressAsPermittedAddress,
        //     sendPkpToItself,
        //     { value: mintCost }
        //   );
        // },
      }
    };
    this.customContext = args?.customContext;
    this.rpc = args?.rpc;
    this.rpcs = args?.rpcs;
    this.signer = args?.signer;
    this.privateKey = args?.privateKey;
    this.provider = args?.provider;
    this.randomPrivateKey = args?.randomPrivatekey ?? false;
    this.options = args?.options;
    this.debug = args?.debug ?? false;
    this.network = args?.network || "cayenne";
    if (!this.rpc) {
      this.rpc = DEFAULT_RPC;
    }
    if (!this.rpcs) {
      this.rpcs = [this.rpc];
    }
    this.allowlistContract = {};
    this.litTokenContract = {};
    this.multisenderContract = {};
    this.pkpHelperContract = {};
    this.pkpNftContract = {};
    this.pkpNftMetadataContract = {};
    this.pkpPermissionsContract = {};
    this.pubkeyRouterContract = {};
    this.rateLimitNftContract = {};
    this.stakingContract = {};
    this.stakingBalancesContract = {};
  }
  static {
    this.logger = LogManager.Instance.get("contract-sdk");
  }
  static async getStakingContract(network, context, rpcUrl) {
    let provider;
    rpcUrl = rpcUrl ?? DEFAULT_RPC;
    if (context && "provider" in context) {
      provider = context.provider;
    } else {
      provider = new ethers_exports.providers.JsonRpcProvider(rpcUrl);
    }
    if (!context) {
      let contractData = await _LitContracts._resolveContractContext(
        network,
        context
      );
      const stakingContract = contractData.find(
        (item) => item.name === "Staking"
      );
      const { address, abi } = stakingContract;
      if (!address || !abi) {
        throw new Error("\u274C Required contract data is missing");
      }
      return new ethers_exports.Contract(address, abi, provider);
    } else {
      if (!context.resolverAddress) {
        let stakingContract = context.Staking;
        if (!stakingContract.address) {
          throw new Error(
            "\u274C Could not get staking contract address from contract context"
          );
        }
        return new ethers_exports.Contract(
          stakingContract.address,
          stakingContract.abi ?? StakingData.abi,
          provider
        );
      } else {
        let contractContext = await _LitContracts._getContractsFromResolver(
          context,
          provider,
          ["Staking"]
        );
        if (!contractContext.Staking.address) {
          throw new Error(
            "\u274C Could not get Staking Contract from contract resolver instance"
          );
        }
        return new ethers_exports.Contract(
          contractContext.Staking.address,
          contractContext.Staking.abi ?? StakingData.abi,
          provider
        );
      }
    }
  }
  static async _getContractsFromResolver(context, provider, contractNames) {
    const rpcUrl = DEFAULT_RPC;
    let resolverContract = new ethers_exports.Contract(
      context.resolverAddress,
      context.abi,
      provider
    );
    let getContract = async function(contract, environment) {
      let address = "";
      switch (contract) {
        case "Allowlist":
          address = await resolverContract["getContract"](
            await resolverContract["ALLOWLIST_CONTRACT"](),
            environment
          );
          break;
        case "LITToken":
          address = await resolverContract["getContract"](
            await resolverContract["LIT_TOKEN_CONTRACT"](),
            environment
          );
          break;
        case "Multisender":
          address = await resolverContract["getContract"](
            await resolverContract["MULTI_SENDER_CONTRACT"](),
            environment
          );
          break;
        case "PKPNFT":
          address = await resolverContract["getContract"](
            await resolverContract["PKP_NFT_CONTRACT"](),
            environment
          );
          break;
        case "PKPNFTMetadata":
          address = await resolverContract["getContract"](
            await resolverContract["PKP_NFT_METADATA_CONTRACT"](),
            environment
          );
          break;
        case "PKPPermissions":
          address = await resolverContract["getContract"](
            await resolverContract["PKP_PERMISSIONS_CONTRACT"](),
            environment
          );
          break;
        case "PKPHelper":
          address = await resolverContract["getContract"](
            await resolverContract["PKP_HELPER_CONTRACT"](),
            environment
          );
          break;
        case "PubkeyRouter":
          address = await resolverContract["getContract"](
            await resolverContract["PUB_KEY_ROUTER_CONTRACT"](),
            environment
          );
          break;
        case "RateLimitNFT":
          address = await resolverContract["getContract"](
            await resolverContract["RATE_LIMIT_NFT_CONTRACT"](),
            environment
          );
          break;
        case "Staking":
          address = await resolverContract["getContract"](
            await resolverContract["STAKING_CONTRACT"](),
            environment
          );
          break;
        case "StakingBalances":
          address = await resolverContract["getContract"](
            await resolverContract["STAKING_BALANCES_CONTRACT"](),
            environment
          );
          break;
      }
      return address;
    };
    if (!contractNames) {
      contractNames = [
        "Allowlist",
        "Staking",
        "RateLimitNFT",
        "PubkeyRouter",
        "PKPHelper",
        "PKPPermissions",
        "PKPNFTMetadata",
        "PKPNFT",
        "Multisender",
        "LITToken",
        "StakingBalances"
      ];
    }
    let addresses = {};
    for (const contract of contractNames) {
      let contracts = context?.contractContext;
      addresses[contract] = {
        address: await getContract(contract, context.environment),
        abi: contracts?.[contract]?.abi ?? void 0
      };
    }
    return addresses;
  }
  static async getContractAddresses(network, provider, context) {
    let contractData;
    if (context) {
      if (context?.resolverAddress) {
        context = await _LitContracts._getContractsFromResolver(
          context,
          provider
        );
      }
      let flatten2 = [];
      let keys = Object.keys(context);
      for (const key2 of keys) {
        context[key2].name = key2;
        flatten2.push(context[key2]);
      }
      contractData = flatten2;
    } else {
      contractData = await _LitContracts._resolveContractContext(network);
    }
    const addresses = {};
    for (const contract of contractData) {
      switch (contract.name) {
        case "AllowList":
          addresses.Allowlist = {};
          addresses.Allowlist.address = contract.address;
          addresses.Allowlist.abi = contract.abi ?? AllowlistData.abi;
          break;
        case "PKPHelper":
          addresses.PKPHelper = {};
          addresses.PKPHelper.address = contract.address;
          addresses.PKPHelper.abi = contract?.abi ?? PKPHelperData.abi;
          break;
        case "PKPNFT":
          addresses.PKPNFT = {};
          addresses.PKPNFT.address = contract.address;
          addresses.PKPNFT.abi = contract?.abi ?? PKPNFTData.abi;
          break;
        case "Staking":
          addresses.Staking = {};
          addresses.Staking.address = contract.address;
          addresses.Staking.abi = contract.abi ?? StakingData.abi;
          break;
        case "RateLimitNFT":
          addresses.RateLimitNFT = {};
          addresses.RateLimitNFT.address = contract.address;
          addresses.RateLimitNFT.abi = contract.abi ?? RateLimitNFTData.abi;
          break;
        case "PKPPermissions":
          addresses.PKPPermissions = {};
          addresses.PKPPermissions.address = contract.address;
          addresses.PKPPermissions.abi = contract.abi ?? PKPPermissionsData.abi;
          break;
        case "PKPNFTMetadata":
          addresses.PKPNFTMetadata = {};
          addresses.PKPNFTMetadata.address = contract.address;
          addresses.PKPNFTMetadata.abi = contract.abi ?? PKPNFTMetadataData.abi;
          break;
        case "PubkeyRouter":
          addresses.PubkeyRouter = {};
          addresses.PubkeyRouter.address = contract.address;
          addresses.PubkeyRouter.abi = contract?.abi ?? PubkeyRouterData.abi;
          break;
        case "LITToken":
          addresses.LITToken = {};
          addresses.LITToken.address = contract.address;
          addresses.LITToken.abi = contract?.abi ?? LITTokenData.abi;
          break;
        case "StakingBalances":
          addresses.StakingBalances = {};
          addresses.StakingBalances.address = contract.address;
          addresses.StakingBalances.abi = contract.abi ?? StakingBalancesData.abi;
          break;
        case "Multisender":
          addresses.Multisender = {};
          addresses.Multisender.address = contract.address;
          addresses.Multisender.abi = contract?.abi ?? MultisenderData.abi;
          break;
      }
    }
    if (Object.keys(addresses).length < 5) {
      throw new Error("\u274C Required contract data is missing");
    }
    return addresses;
  }
  static {
    this.getMinNodeCount = async (network, context, rpcUrl) => {
      const contract = await _LitContracts.getStakingContract(
        network,
        context,
        rpcUrl
      );
      const minNodeCount = await contract["currentValidatorCountForConsensus"]();
      if (!minNodeCount) {
        throw new Error("\u274C Minimum validator count is not set");
      }
      return minNodeCount;
    };
  }
  static {
    this.getValidators = async (network, context, rpcUrl) => {
      const contract = await _LitContracts.getStakingContract(
        network,
        context,
        rpcUrl
      );
      const [activeValidators, currentValidatorsCount, kickedValidators] = await Promise.all([
        contract["getValidatorsInCurrentEpoch"](),
        contract["currentValidatorCountForConsensus"](),
        contract["getKickedValidators"]()
      ]);
      const validators = [];
      if (activeValidators.length - kickedValidators.length >= currentValidatorsCount) {
        for (const validator of activeValidators) {
          validators.push(validator);
        }
      } else {
        _LitContracts.logger.error(
          "\u274C Active validator set does not meet the threshold"
        );
      }
      const cleanedActiveValidators = activeValidators.filter(
        (av) => !kickedValidators.some((kv) => kv === av)
      );
      const activeValidatorStructs = await contract["getValidatorsStructs"](
        cleanedActiveValidators
      );
      const networks2 = activeValidatorStructs.map((item) => {
        let proto = "https://";
        if (item.port !== 443) {
          proto = "http://";
        }
        return `${proto}${intToIP(item.ip)}:${item.port}`;
      });
      return networks2;
    };
  }
  static async _resolveContractContext(network, context) {
    let data;
    const CAYENNE_API = "https://lit-general-worker.getlit.dev/contract-addresses";
    const MANZANO_API = "https://lit-general-worker.getlit.dev/manzano-contract-addresses";
    const HABANERO_API = "https://lit-general-worker.getlit.dev/habanero-contract-addresses";
    if (network === "cayenne") {
      try {
        data = await fetch(CAYENNE_API).then((res) => res.json());
      } catch (e2) {
        throw new Error(
          `Error fetching data from ${CAYENNE_API}: ${e2.toString()}`
        );
      }
    } else if (network === "manzano") {
      try {
        data = await fetch(MANZANO_API).then((res) => res.json());
      } catch (e2) {
        throw new Error(
          `Error fetching data from ${MANZANO_API}: ${e2.toString()}`
        );
      }
    } else if (network === "habanero") {
      try {
        data = await fetch(HABANERO_API).then((res) => res.json());
      } catch (e2) {
        throw new Error(
          `Error fetching data from ${HABANERO_API}: ${e2.toString()}`
        );
      }
    } else if (network === "custom" || network === "localhost") {
      try {
        data = await fetch(CAYENNE_API).then((res) => res.json());
      } catch (e2) {
        throw new Error(
          `Error fetching data from ${CAYENNE_API}: ${e2.toString()}`
        );
      }
    }
    data = data.data.map((c) => {
      return {
        address: c.contracts[0].address_hash,
        abi: c.contracts[0].ABI,
        name: c.name
      };
    });
    return data;
  }
};

// packages/crypto/src/index.ts
init_shim();

// packages/crypto/src/lib/crypto.ts
init_shim();

// packages/bls-sdk/src/index.ts
init_shim();

// packages/bls-sdk/src/lib/bls-sdk.ts
init_shim();
var pako = __toESM(require_pako());
var base64codes = [
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  62,
  255,
  255,
  255,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  255,
  255,
  255,
  0,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  255,
  255,
  255,
  255,
  255,
  255,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new Error("Unable to parse base64 string.");
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new Error("Unable to parse base64 string.");
  }
  return code;
}
function base64ToUint8Array2(str) {
  if (str.length % 4 !== 0) {
    throw new Error("Unable to parse base64 string.");
  }
  const index = str.indexOf("=");
  if (index !== -1 && index < str.length - 2) {
    throw new Error("Unable to parse base64 string.");
  }
  let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n2 = str.length, result = new Uint8Array(3 * (n2 / 4)), buffer;
  for (let i2 = 0, j = 0; i2 < n2; i2 += 4, j += 3) {
    buffer = getBase64Code(str.charCodeAt(i2)) << 18 | getBase64Code(str.charCodeAt(i2 + 1)) << 12 | getBase64Code(str.charCodeAt(i2 + 2)) << 6 | getBase64Code(str.charCodeAt(i2 + 3));
    result[j] = buffer >> 16;
    result[j + 1] = buffer >> 8 & 255;
    result[j + 2] = buffer & 255;
  }
  return result.subarray(0, result.length - missingOctets);
}
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: () => {
    throw Error("TextEncoder not available");
  }
};
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var cachedFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i2 = 1; i2 < length; i2++) {
      debug += ", " + debugString(val[i2]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function encrypt2(public_key, message, identity) {
  let deferred5_0;
  let deferred5_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(
      public_key,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(
      message,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passStringToWasm0(
      identity,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len2 = WASM_VECTOR_LEN;
    wasm.encrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r22 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr4 = r0;
    var len4 = r1;
    if (r3) {
      ptr4 = 0;
      len4 = 0;
      throw takeObject(r22);
    }
    deferred5_0 = ptr4;
    deferred5_1 = len4;
    return getStringFromWasm0(ptr4, len4);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred5_0, deferred5_1);
  }
}
function verify_and_decrypt_with_signature_shares(public_key, identity, ciphertext, shares) {
  let deferred5_0;
  let deferred5_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(
      public_key,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(
      identity,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passStringToWasm0(
      ciphertext,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len2 = WASM_VECTOR_LEN;
    wasm.verify_and_decrypt_with_signature_shares(
      retptr,
      ptr0,
      len0,
      ptr1,
      len1,
      ptr2,
      len2,
      addHeapObject(shares)
    );
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r22 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr4 = r0;
    var len4 = r1;
    if (r3) {
      ptr4 = 0;
      len4 = 0;
      throw takeObject(r22);
    }
    deferred5_0 = ptr4;
    deferred5_1 = len4;
    return getStringFromWasm0(ptr4, len4);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred5_0, deferred5_1);
  }
}
function combine_signature_shares(shares) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.combine_signature_shares(retptr, addHeapObject(shares));
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r22 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r22);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred2_0, deferred2_1);
  }
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e2) {
    wasm.__wbindgen_exn_store(addHeapObject(e2));
  }
}
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e2
          );
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(deferred0_0, deferred0_1);
    }
  };
  imports.wbg.__wbg_crypto_c48a774b022d20ac = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_process_298734cf255a885d = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_e2e78e134e3e5d01 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_node_1cd7a5d853dbea79 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_require_8f08ceecec0f4fee = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_bcb970640f50a1e8 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getRandomValues_37fa2ca9e4e07fab = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_randomFillSync_dc1e9a60c158336d = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_newnoargs_c9e6043b8ad84109 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_f4bc0e96ea67da68 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_value_2f4ef2036bfad28e = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_iterator_7c7e58f62eb84700 = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_self_742dd6eab3e9211e = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_c409e731db53a0e2 = function() {
    return handleError(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_b70c095388441f2d = function() {
    return handleError(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_1c72617491ed7194 = function() {
    return handleError(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_get_7303ed2ef026b2f5 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_isArray_04e59fb73f78ab5b = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_length_820c786973abdd8a = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_ef2632aa0d4bfff8 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_call_557a2f2deacc4912 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_587b30eea3e09332 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_ec061e48a0e72a96 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_b6abb27d42b63867 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_buffer_55ba7a6b1b92e2ac = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_09938a7d020f049b = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_instanceof_Uint8Array_1349640af2da2e88 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_newwithlength_89eeca401d8918c2 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_subarray_d82be056deb4ad27 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_0aab7ffd65ad19ed = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_set_3698e3ca519b3c3c = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_f53c921291c381bd = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedFloat64Memory0 = null;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  const imports = __wbg_get_imports();
  __wbg_init_memory(imports);
  const { instance, module: module2 } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module2);
}
async function initWasmBlsSdk() {
  var b = "";
  b += "eNrsvQt0VUd2IHrP794r6Uq6AgECCVTnILCwsa3vlWRjmcv/50+77ba7290gIclY0GAE/nSGC0p";
  b += "anWheSJ7eekyGzjAZ0qEDSXC3kjATukPe0AmTKB2yoqzHS5Q8sp7eWkyG94bMaCakH2uFSb/9qV";
  b += "On7j1Hum4b3OmOkF2n9t51Prdq165du3btivUc+YIRi8WMPzOW7zFPnDBOYBrbY53wU8AYnMT22";
  b += "CcI7ZzgawzQ8RMndCRg7BPqruM+GUCkH8ebYnsSJ/ybSjhz/PjxAAtlrePqSUBInlDlLXqEg0+i";
  b += "zzku33yMwWMSzDGIF/Pvy1utd3vfWLZ797u9bx7se6P/4O5DvYP9e4/u7hs69Nbuof6BmIMFFmk";
  b += "FjhwdevPgG7sP9r8bi81Ce6P/aMwopB18+wu9/UMBrVqjvXlEvjdmI2mpRho88k7Pgd0HDh060r";
  b += "+7/zC/crFG7z106EB/z0F6rl343P6hoUNDwafS76RP393T29fTkenv7Gzt7ensaR+IJbFAHRc4c";
  b += "rRn7/7dmfbOlo6ugf62tva25r0DGf5sWYSfPNDZ3pzJdPQMdDT37h3YK4ss5yJ7h7741tFDu/e2";
  b += "dfZ0dLT1NrW09LU09ezlr1zBZd4aOrS3/8iR3S1dnR2tbXsHWtrbezo72/u4UD0Xeqd/6Mibhw4";
  b += "e2d3f0t/R2d/c2tbf2t/e19TMpWrlrzrU17+7eW9fR097X2d7a19vf09HV7hKoKq5lfK+Y6j/8N";
  b += "tvDvXv7hxo6tzb37+3f2/TQNtAfz9Xi/yOLxzZyD+pd29vV0dTpq1poL2pp7m/kx+1mktBQ7zUc";
  b += "7Dv0Bc+1XPg7f4ju1s7Bnpa9vZ09bf1N0G2l+tolXwvldzy5oEDn/ziwb27+/Y293f1ZJr2Nrd3";
  b += "trZm+risUM128FDP0BtHdu/t6s80tbX2dvb0dbY1N3Vx6/r10P/e0d0Dbb17m/q7Mv09mY6+noz";
  b += "8wsX59TDw9sG9R6FimSgb9h386t0tA239Ay1NrZnegZ6+ls7+vPZ482j/UM9RaP6OvR397Z0DmZ";
  b += "b+3s62jqYmri35HUf6Dwzs7mhr6euDr+ht7e9qaW6W9SkZ5F34lEPvAoM0dfV3tDb39ba39jT1t";
  b += "3AZV9bmgUO9PQde3gef29vRtLepq721s7OtrXmgpS/vWVwO2r+jJdPc0dbV3N/X0dzVxmWW5P/u";
  b += "tw/29Q+8ebBfctky1W67O1qbWvv7WvoHmloyvS0D7VyxkkfePJIdGur54u6mtv72roHejtaBjs6";
  b += "e3vZefor8jgP9B984um93Z0vT3o7OTFdHK3S0vs4eLvO4fNBB6GAH9/YfGthNT9zw9sAASAao8E";
  b += "xrS09PU19b78DAQGced+/tOXBgd3t7R08L/PL+nr174Se25LU7l+js6G1t6u/vae1v6mptbYlZh";
  b += "ZwBnJ1p7oc+2dTf0dLTlcl7S9+hg/27ezM9vb0tHX1tLb2Z1s5MR97v6+VvbW/v7enoyfQ293a1";
  b += "9Lf4nbpZMeq7bx7d1/vFo/ATB470w4/t8+uls6+5r7MXeu9AV1tvVy9/nyaXmrq6WkFe9DW1NA0";
  b += "0tXXJyl0bqrhX3jx4tJPbA+RBF/TFHqiYnhaQaHxLQ963+K/vgr7d09YE39DV3Lm3JY+tj7zd20";
  b += "MP7Ots6e1vas/09fe2Afd38EfmN3BTT09vx8BAX6a9p6+5q4CV4Cfvbs10dfa37u1pb+7qbd3bu";
  b += "jdmqnrOH2n2HsBKx6GmkBsH2lv3Qq9p6Wre29rZ3NvHza0zM3zh22/48oxkRVqjHt03dOhdRldp";
  b += "6C/0f+HQ0BehZ/y+fc0247ZtGqZhxE3TjtsJsyQBkG2UGSXlgIxD3oklzJhlwv+WGaeyJpDgBoA";
  b += "Rb1oG/GfEDdN0bKMiZhgxx4xVxUpiJSUl5oLSWDwWM834QtOsgIzlGDETrjHDjCUTcSNhmgkzHo";
  b += "N7jGrDSGMZ+BR4Wynck4gvApwVixv4DMOwrAQ83TKS8P4YFoKrZdjwKfGEY9qANMw4fB/8g69OJ";
  b += "Kx4HG7Ef/B5kIVvNAhcbMM1DkUNLA0k+MmGHUsYJYZjGPAzDMuEt1lOiVlCX+OYibgD/8WtmAMP";
  b += "Tpj8llL4KrihEp9jw21QQaYDv96ht1BlJeJxm1+En2c7QHb4V0P1leOvipUlSpcsrY0ZSIuZcbj";
  b += "Zwjp0YvBAQMG3xeC1NvwKxzSpIsrw91v4gwFrwX1wQwJvxu+KOQ5+FNYpoOCdMRtfC/9iNjzAsG";
  b += "0bcHAfgDEs6MB9Dv3MWKwSE7gBylhQBP7F5D+D6oh+qW3HkljIqEylUo6dMN4y3oc//IqqeAkod";
  b += "9nh4avws75ipuLMbtCebx588+ibPQfe/LH+2H+3E/0HST+I/ZnRCOP7mwNf3A1SAhiasLuxz+4+";
  b += "8uYbB3uOvg3D8pF9PUP9R2L/u7F87gL/q1mz99AXgNH7w7S/MdPyRYoU+10jr2OABD20N/YP5gI";
  b += "NOdTP2G9Y9Rq2p69vNygCrCi9dQiEUf9Q7NftSq3IwBCoD//dylPH3kMV8RC8+H+xS/4KWDFrlF";
  b += "00vmv/B+OnjZ+1f8P+/6xfNb5mfte+aX3XnrK/a/+lfdP+P+1TkPsz+2eMn7T+CnL/jf6+Drmfs";
  b += "n8f7v2u/Rf2n9v/w8K7fwugb9t/bXzmsv331kXjl00kf9P+W4thhH7Xvg7X37N/y/obeMk/h///";
  b += "q3XeeN/8qsEQ/t22fx1yP2v9P5D/aes71u9b36S/37GuWL9t/Z75Letb1m9YYzbf+3XTf/qENW7";
  b += "/pvW35jeMn7J/1v59oP+O+UfwpL+1xwD+OeMcfM//bUzYP2deN//Q/hfmn5hfMf6l+Qf2/2b9lP";
  b += "2L1h9Y/8L+S+s/mJPmrxgXzP9knDbOm3fh3gvWVeO2ccf8Ofvv7El42p+aF+3T5vvwk0/bf239n";
  b += "fVd62fguUCz371i/Ir5DftbxlfMP7VLx39r0TX79hfNZ44fP7Eylj2b3O+tb4gJI3vGHGw0Y+5P";
  b += "GJA/TXnInPIzY37mpJ8Z9TMjfmbYz9w3ZOaen7nrZ2aMQa+Xs3d83G0/c8vPTPuZm35mys/c8DO";
  b += "Tfua6n5nwM9dkptG8aoj12bPOoNcD6Kvw7r2iN/064KatQW+TQOggQDP2oJdFKDs+8u1Y9n9870";
  b += "g2lX5OZPGPil+FAhtEj9iUXwCeEx/0NosNYm+6W2yGPzM7HRuEvOnX588bkOf6dP8V5rlK3TOY5";
  b += "1p1/zXmuWLdX8A81637bzDP1euexTzXsPuLmOdKdr+Kea5n95cwz1XtnsM81nYfQl9DiCvc/WXM";
  b += "c5275zHP1e5ewDzXvPsrmOfKd38V81z/7q9hnpvAvYh5bgX3fcxzQ7hfxzy3hfsNzHNzuOOQxxZ";
  b += "xfx0bZRga4DUgYqP0iz6q5bPmoPeKQAgbZYwaBaDoRtkkXhOv5JNeAWQ/VP4r8GfIhlgPTzqZGP";
  b += "Q+3Q4csb4d+lgOMKOA+YzETBBmBDCflZhrhBkGzOsSc5Uw96Gxt0jMFcLcA8xWiblMmLuA2SYxl";
  b += "wgzA5jtEjNOmDuA2SExFwlzGzA7JeYCYW4BZpfEnENMuzkdx/SsmfOsDeKnjnlpSlOUllNaQWkp";
  b += "pWWUOpQmKS2hNEFpfEP9T2549qc8e8Ov/R//8L3KLwlrw/fgX+WXjnlWN75pl7AB8/d/UvYlkfZ";
  b += "JUEiMUoGY2En0P/mfgJ6Kou8A+j987xt/Z3xJlEfRtwP93J3f+7fw6ooo+jagn/3a730z/iVRGk";
  b += "XfCvR//7VTZ+D+sij6FqCP/Mu/+iW434mivw70P/+Lr/+8/SWRjKJ/Fuj/7k/+yxTQS6LonwH6z";
  b += "//x9/7I+pJIRNE/DfT/95dGJuH3xyUB0euzV4CtPic+R02bvQ8c/xsG5LHJLwPl84y/B/jf9PGX";
  b += "AL+b8XcBf8nHjwN+D+NnAP9vffxFwD/H+DuA/3c+/gLgn2f8bcD/lo8/B/gXGH8L8Jd9/FnAv8j";
  b += "4acB/08efAfwnGH8T8N/y8acB/xLjpwD/2z7+FOA/yfgbgL/i48cAv1Gy+CRw9UfjZ0wtxdWy6q";
  b += "1jQTPFVTOplk1oKMkMJRpK8k9SQ0mWczSU5NIyDSUZu1RDyb5QoaFk9ynPQ1GPS2ko2T9VJ8QKG";
  b += "qUKGqUKGqUKGqUKGqUKGqUKGqUKGqUKGqUKQtb0+fDzgrh0t4jjZY9I4OU5UYKX50USLy8IBy8v";
  b += "ijK8fEKU4uUlUYGXT4pyvGwUKbzgwLcZRPJG/IPra8IQm1D2knQfEKbYwJK43bxjkNCzSKDdJuA";
  b += "CA7cIOMfANAFnGbhJwBkGpgg4zcANAk4xMEnAGAPXCTjJwAQBowxcI2CEgasEDFsPX6Tim+YUqd";
  b += "f8ArPJ1AkuMLtQvc4FZpeqk1xgdrF6gwvMLlenuMDsgvUmF5hdsk5zgdlF6y0uMLtsvc0FQsIVW";
  b += "QulE4iYfVI6WYO+aALkm1I0KSRoYt6glEsKCSqZt5+RkwoJupl3gJHXFRKUNO9TjJxQSNDWvFcZ";
  b += "eU0hQW3zNjDyqkKC/ua9zMgrCgmKnLeJkZcVEjQ6L8vISz6y3Zwh1h3/GFgX3pQtog1sKqINvFx";
  b += "EG9hQRBt4tYg28Kki2sCBItrA/iLawGARbeDNItrAvtm0AVBSYWIxIAZIAR7D5sfhHFucpx5QNZ";
  b += "voiuIMFecrhmKBUYQvB/AIwpcCeBjh8QA+hspBAL6HOkEAHkVVIADfQg0gAA9g1wrAfdipArAPu";
  b += "1MA7iFJbHwMrJkoIlXvJopI1XuJIlL1fqKIVB1OFpGqI8kiUnU0WUSqnkwWkapjySJS9VSyiFQ9";
  b += "nYyWqmeS0Lk3FE58N+EfsOUGErkzoMi9UTAzBp7eIKdi60kVGIYJzY8boBsg+g3QGDYSW9O87HP";
  b += "EODQh+zxlaSa2m7I0BdtDWZp7PUdZmnQ9T1mabb1AWZpmvUhZml99grI0sXqJsjSj+qTPpjDNQf";
  b += "3zYxj8i7HptWJsOlGMTa8XY9PJRLHBP1Fs8E8UG/wTxQb/RLHBP1Fs8E/MMvgncMB2UGwCZ0VbD";
  b += "HqA7WAEBmb9HaPQjnMRuPMV4AV3DQpFAF5D4FEUiQD0IPAYCkQAvoDAWhSHABxE4HEUhgAcQuAJ";
  b += "FIUAvIXAkyjUATiMQBNqEgAMIdCMygIARxBoQXUCgKMItJLojrtVpMc6bgNe17qrSJN13NV4bXQ";
  b += "fIV3WcRvx2uC2kTbruO14FW6GTBSO24HXOreT7BOO24XXGvcpMk447tN4rXbXkSLhuM/gNe12k4";
  b += "buuM/iNeUuIB3dcZfiNekuI8XccWvxGnPrSGl33OV4td1Kkgf3nUAFiynVxglUMIW86wQqmELOO";
  b += "IEKppB3nEAFU8jbTqCCKeQtJ1DBFHLaUSrY+v0Sd9NRGtg6v9yUoxSwTh93w1H6V5sa4iYdTJvm";
  b += "Z60f16xVPgnbDXrK29AO3oqcErPYdIB+B9H1OVVr2HqAfhfRIqdqDjkL0O8h2s2p2kPeAvQXEe3";
  b += "lVA0idwH6xxC9MqdqEfkL0P8M0dU5VZMoYgB9DNGLcqo2UXMDdA7Ri3OqRlGBA/RxRC/JqVpFPQ";
  b += "7QJxBdk1M1i+ocoIfRguLZD5L3Fmq8tzDMewvDvLcwzHsLw7y3MMx7C8O8tzDMewvDvLcwzHsLw";
  b += "7y38CHyns5wOpfprKXzk85EOufo7KLziM4YS7Rml00tagIOeVDNHqqsdDfKtmxU1aapRlI84Yto";
  b += "DVnPPOGLaEDZAjzhi2hz2TY84YtgE9lqPOGL4CzZnjzhi2BG2dI84YvgX8kDPOGLYHnJHTzhi+g";
  b += "lkm94wqf3qHgwE4Q52QrFRDlRr27PCaFelROu+qyc8NRPyImV6ufmRLWqmpxYpKoxJxarKs+JJa";
  b += "p5cqJGNWVO2KrFfe33gzPPIkoXU7qE0hrJTtWR2m9MnBDVPjdFTt+PE524KXL6Dr/V56bI6fsxo";
  b += "Etuipy+/zOgS26KnL7/GNAlN0VO378IdMlN8QK6TfN40SBW5cRq8UhONIq2nGgXmZzoEJ050SWe";
  b += "yomnxbqceEZ058SzYkFOLBXLcmK5qMyJWlH3IKV4pcZzlWH+rAyzdGW4F1SGO05luK9VhrtnZbh";
  b += "HV4aFQGVYblSGRU3lQ5TiazQp/qgmxR/TpPhaTYo/rknxJzQp/qQmxZs0Kd6sSfFWbUxv0SR61X";
  b += "yz/4g3e2FTY/M/2MG7MnLwPgsTk6iqVYP3Ob/AbKP3BS4w+/B9kQvMPn6Pc4HZB/BLXGD2EfwyF";
  b += "5h9CL/CBWYfw69ygdkH8WtcYPZRfIILRAzj15GyRhvGH9WG8ce0YXytNow/rg3jT2jD+JPaMN6k";
  b += "DePN2jDeqg3jLdowXhUaxuMfyZRVwFh5w/hwXBwJGCseNU6+B+OkbJFF2mRQaUVHA76LXEZ4F+6";
  b += "XDbZY0ePB/UMBW0YuM7wD98v2XBJ1/+GAayOXId6G+2Vz18gbEf1WwMuRqxOHAlaOVG8OBpwcqd";
  b += "58IWDkSPWmJ+DjSPXmtYCNI9WbVwIuTmirDz9u4H+b0UqLppw2QTavdkHWrowgO1eHIAtXpyDbV";
  b += "pcgq9ZTguxZTwuyZK0TZLZ6RpApq5udbNwV7Frj1rNDjSvYjcZ12XnG9dhlxl3JjjJuNbvHsLXr";
  b += "osnmrgsmm7vOmmzvGo6zVeqc6TaiJo1WAEH+Ex6oVTj5F+Q14S3NCZzzC/KV8EDbwqm+IA8JrzY";
  b += "ncIYvyC/Cq8sJnNgL8obwlucEzucF+UB4oKDhNF6Q5wNO5nH2LsjfAefwOGkX5OWAU3ecqwvybc";
  b += "AZO03R2bHhwU7UqzR5VBUWXlVhgVcVFpJVYcFaFRbGVWEBXhUW+lXhgaIqPLhUhQekqoc41i/Qx";
  b += "vql2li/TBvra7Wxvk4b65drY33l9z9Rt0ITdW7ApZQuo7SW0jpKl1NaWWRmVTXrzKpqNoksZyZt";
  b += "aLVoR3NFBu0UHWig6ETLRBeaJJ5CW8TToiEn1uEM5hmxOie6RSNOVB55kGy7QGPbBWG2XRBm2wV";
  b += "htl0QZtsFYbZdEGbbBWG2XRBm2wVhtl0QZtsFP2T2pQaNbVdpbLtaY9tHJNs2htn2o2kSC2bXJB";
  b += "bMqUkcD4TI0mhNYsGcmkQukEvLojWJBXNqEpqoq43WJBbMqUn8s0B61kXd/1bAphXRFgklkJdH3";
  b += "X8o4PzSaIuFkvGVUfcfDDpTWbQmVxXW5LT7vxD0Tydak6uaU5PrCbp8MlqTq5pTk3stkCIl0Zpc";
  b += "VZQm94pYEKUJbRZ7RT85sPWSK/L88vT88vSDXp7eGF6Y9v0lNwPDFS5JIyu4CVKebTfO/j/sAH4";
  b += "VlQzpo50QcRwyaKRlr2zfi3zCziPsEL7D+fV8wnbh+6ZP5hO2Cd+N/UY+YavwPd6n8glbhO8cfz";
  b += "Of4H+874N/x5a9CX1Abdmd0AXUlv0Ji6tHzM7NjuTmwGedOpAjObnAX32nT0MmLvBV38E05t8CP";
  b += "/XtTGPWLfBR38Y05toC//StTGOGLfBN38I05tUCv3SniF+6U8Qv3Snil+5EeaJtFL4n9gyzF/r4";
  b += "Sqftuzavemst+pKQjt73wrRPCOkcfj9Me1FIh/JhJ0R7QUgn9JEw7XkhHddHw7TnhHR2PxmmyZ8";
  b += "lve3PyALSyf60BKVv/SkJSpf6sbynfUAmVLUWyYOy1iJ5UNZaJA/KWovkQVlrkTwoay2SB2WtRf";
  b += "LgniI8uLsID36+CA9+LpoHNRk3beXy+zRKB2sWUXfbmkXU3bFmEXUz1iyi7q41i6i7Z80i6u5bc";
  b += "4q6k5qoG9VE3Ygm6obnRd0PRtSNhUTdqTlE3ek5RN2ZOUTdWXt2UXfOnl3UXbBnF3UX7SKi7oqd";
  b += "J+ou23mi7pKdJ+rG7XlR9/GKOtwxM5DuHor8J37eEP/KEGcM8a8N8QuG+DeGOGuIXzTEVw3xS4Y";
  b += "4Z4ivGeKXDXHeEBcM8SuG+FVD/JohLhrifUN83RDfMMS4IX7diH76kPupbMx91VrPO2PFq+iAvk";
  b += "EYmHlZfKq20Yxl0EEjS9svs+JlyOjopI9O5qFTPjqloV/Npge9V7Nnza3lsTLxE8aQ+zK8ewO8G";
  b += "25hV3f8hA14r4kXQ7zs37sJ35vFxMBEwycRn0R8UsPTJ2zw3wUPTg42xMp+4hNm94nVx1fGslcT";
  b += "+z27ISZs3JQEP9cAxdtGT3t4TtOg5wiHELjTNw5khnBHahlBBwFC9/xShPJV9VL8o+LozV8p4qI";
  b += "sv0ClqEzvokK7hM07U716UU+3wKtrcX+14X+C2jnsqo3Datew2jKs9gurzcJqp7DaJqz2CKsNwm";
  b += "p3sNwa7HD2jo+77Wdu+ZlpP3PTz0z5mRt+ZtLPXPczE35G7vzt4I2/okzu962TtYsbAJeIOlm7u";
  b += "Ak7hVB+5aXwD4pDrYol+SSbnMqF3Nq9XNSlu4ON7J1qH7vbpXayu0+pvezu02o3u7tO7Wd3n1E7";
  b += "2t1utafdfVbtanfXq33tbrna2e6m5d72EgRq1O52d6na3+6uUDvc3WVqj7tbpXa5uwvUPnd3odr";
  b += "p7larve7uIrXbHWaE/n53N6l2vMN8kfa8u45YIpaLEubJOPYuhLCSJ4GhKxDKr8kK/IPiUMXQt/";
  b += "JIlr1eNRV3iBIqagsbF3oAd9/k4cPGBR+A7wXwNYTvBvBVhGcC+ArCdwL4MsK3A/gSwrcCeBzh6";
  b += "QC+iPDNAL6A8FQAn0P4RgCfNTHFzaYbaGR7ntJNlG6mdAulWyndRul2SndQupPSXZQ+J0fFjb5N";
  b += "ZYOyqWwgHc0WG32byvNqbNhAYwMUuOUXIJvKpnCB21xA2lQ2hwvc4QLSprIlXGCGC0ibytZwgbt";
  b += "cQNpUtoUL3OMC0qayPVzgPheQQ+iOcIHhBBWQY+jOcIERLiAH0V3hAqNcQI6iz0lKt3kygfzsoI";
  b += "AGjsxn2jL8YwnuIMMu4Y6QX6gE/iwQGSCeqa+gHIebykTHLOOyO+QuRocu9OdCdy7xLOj75SIta";
  b += "sRSsUIsE1VigVgoqsUikFZJ4YjELA/qHAIZwd9WLupJbpXDH48+pQDZFB8hzeEkxHLApOFPdj+k";
  b += "Q/4ilFiGio2dvS7nqnb2AiCrGDmhkOcAuYCR1xTyLCAXMvKqQp4BZDUjryjkaUAuYuRlhTwFyDg";
  b += "jLynkGCCTjBxXyJOATDDyokKOAtJh5AWFHAGkxchzjuqzwxb1XOfh91l4kzVnnwUlcs4uGxOJOX";
  b += "tsDLhirg4bA76Zq7/GgLPm6q4x4L25emsMuHOuzhoD/p2rr8aAw+fqqjHoAxE9FRv0JratkK17X";
  b += "zX5VMCv9xTyRsCvdxVyMuDXGYW8HvDrHYWcCPj1tkJeC/j1lkJeDfh1WiGvBPx6UyEvB/w6pZCX";
  b += "An69oZDjgFzKyElGfkSOxXSD4ltZuRuOBQ3xnGoI1Xa7NJRs7p0aSnLIDg0lmWq7hpJ8uE1DSdb";
  b += "dqqEkt2/RULKDbM5DUZ/apKFkD1TdDCtolCpolCpolCpolCpolCpolCpolCpolCpolCoImc/ntC";
  b += "oh+fg5Zvdd3Ct2cufZwX1sO3fFbdxjt3LH3oIXS2zGy1KxCS84IhggbnGkMEksY9ygFQCxvj8GE";
  b += "5MK0k6VNsTWbakKsXlb6kFs35ZKEBu4pQbEBnOp/rBZXeo+bHyXig+b6KXWw4Z8qfKwuV/qO7hi";
  b += "oCk7uFzwsAUnvmlOwXnOLKLsXDCLKDsXzSLKzrhZRNm5ZBZRdi6bRZSdK2YRZeeqWUTZuWYWUXY";
  b += "mzGhlB1mLVW1/zD+jJA4Gi5Ey9LRCYqQYKUNPKSSGiZEydEwhMUaMlKEnFRIDxEgZOqqQGB1Gyt";
  b += "ARhcTQMFKGDiskxoWRMtRfBSC93Jeh9xQSI8JIGeqvM5CGjunMx8C68Kb5Mf9hjPlZmKTC/5a1n";
  b += "vVWAfNQJ1tNlgEnm5bXlLwm5dXmKyaWNFdZIp6tAcaDST6ZdqyssR+SE0cOZ+vfdpP4HnoH6M74";
  b += "joRIwN2gaxj0RsgfEcnDwjqCRqIEWrVADeES8nV59GQePVlAj6ORKS6NTOrN8tepN9sP+80C//F";
  b += "swKJhCafnDjByRf5QdN/UhqJ7pjYU3TW1oWjG1IaiO6Y2FN02taHolqkNRdOmNhTdNLWhaMrUhq";
  b += "Ib5vy8+0dv3l2LrJY/ma7FP+I+Rxqd4oVGUFvNtstpwmvLCa/FE1qxAq4OTHOX+kx8kWZ+Ny1mL";
  b += "gKmGDhHwA0GzhIwycAZAq4zcJqACQZOEXCNgTECrjJwkoArDIwScJmBEQIuWdpEFCPuzDPxjwAT";
  b += "p5DVom3NIIBFAfvarNpjujbHmj2mjTlW7DFtyLFej6nIsVqPaV2OtXpMa3Ks1GNazaoO5dM5Vuk";
  b += "xTbHQpnySZTbl5eyB8g90VvlCeC72Uje9SLwQnrm9RHX7yW76KipQMNv7JBV4uZt+AhQIzRBfpg";
  b += "KvdNPvhQKhWeUrVOBT3VQ5UCA0E/0UFXi1m2oSCoRmr69Sgde6qdqhQGjG+xoV+HQ3tREUCM2SP";
  b += "00FPtNNDQoFQjPrz1CBz3ZT60OB0Gz8s1RgYzexChTQp+5+L0QZyDEy3M+hiszZz6NizNndaEfg";
  b += "7B40eHC2B80cnO1F4wZn90KWolu4fZCjmBZuP+QokoU7ADmKX+G+QYLScV8kGem4r5N4dNznSTI";
  b += "67iYSio67meSh424hUei4W0kKOu420i1sdzupFba7g5V1dydem9xdpGDYruw01x0l3JixWZ9W8D";
  b += "UHakqDrzpQtRp8xYG20ODLDjSeBl9yoLU1eNwB9tDgiw7wkwZfcIABNficAxyrwWcdYHF/UxVL+";
  b += "hcofYnST1L6MqWvUPopSl+l9DVKP03pZyj9rOxknwhL+o20W88WL4rP5cTr4vM58bzYnRObxJ6c";
  b += "2Cx6cmKL6M2JrWJvTmwTfTmxXfTnxA4xkBPPiTdyYqfY9SClwIthKfA6DAPIuy+GpcDrxMLPwzD";
  b += "gFyiQAs9TgU0wDHCBkBSQ5h4YBrhASApISxAMA1RJYSkgjUQwDHCBkBSQ9iMYBrhASApI0xKMB1";
  b += "wgJAWk1akbugUVCEkBaZDqhv5DBUJSQNqquqGjUYFACkj7VTd0RaB8wq/jFzQbmW8+8QtQHb8UY";
  b += "T7hArKOPxlhPuECso5fjjCfcAFZx69EmE+4gKzjT0WYT7iArONXI8wnXEDW8WsR5hMuIOv40xHm";
  b += "Ey4g6/gzEeYTLiDr+LOB+cRhWXTfUS1Dff2eo5qS4LuOanuCZxzFLATfcRR3sRLgKHZkRcBR/Mv";
  b += "KgKMYnhUCR/UQVgoc1aVYMXBU72PlwIGOli+LHqIpxCmidd5wimidU04RrfOmU0TrnHaKaJ23nC";
  b += "Ja522niNZ5xymidc44RbTOu04RrfOeE611AvvhOl+aJzw0NNrZk0awfI7waAAjv2dHAhg7SHY4g";
  b += "LFHZe/HguVzhO8FMPbZ7N0Axk6enQlglArZOwGMYiR7O4BR7mRvBTCOVu3mno/BoFyMFc8VY8UL";
  b += "xVjxYjFWHC/GipeKseLlYqx4pRgrXi3GiteKseLELKyoSURbxRRliWirmKIsEW0VU5Qloq1iirJ";
  b += "EtFVQUZaItooqyhLRVmFFWSLaKq4oS0RbBRZliWiryKIsEW0VWpQlos2xRefF4Q+/OIww3kq7rV";
  b += "jsO/b5llMymuropI9O5qFTPjqloePoiagZbhPkg0hWU355Au8y8WKIGv8ueqOlfBA1fBLxvg9iT";
  b += "d7LE76R1sZYkw2xsj9fZ244UUs+iPH9ntEQE7FGc9h0Tbh7/X4RS//Ptrke3m00mpu2l+MBJp2D";
  b += "hEXMOhs+NHvBHPTWo2m44X28+aLprXp/g/jJEWB8C+YR593VwH8m8P559xHIGdAjzrs2KZDnXYc";
  b += "U5fOuSyr3ebcRHjhqDrpZ9DdzBskFbQKu6H92Ga4L2RuOPM/uGYPkdnYbrovZP81dwr5n5OYGgx";
  b += "X5uMGgQ15tMHi46M8IE1m3Lnv3Oz/+F3F3TfY3/nL0jxLuo9n/MvHjX7Hcx7L/cebbPx1312ZL3";
  b += "cdl/glJe1KWbZL3Nku4RdJbZfk2SW+XcEbSO2T5Tknvgt86bg6usWJQI57pPsV14Fnu08J0y4Xl";
  b += "VsC1DK4lUBLDhG+gsjDXjaF9HYGNMKPdBJPgjTDx3QST3o0w4YVGGDW9uLsOcydNL+E+AzewZ6G";
  b += "XdLsRfcr0St1nRdxdLhLuCpF0U6LUrQTYA3glwPUAC2DEx210KoRZvpcWLchHhijJoKHeEGUZtN";
  b += "Ebwsmged4QqzNomTdERQaN8oYoz6A93hBuBk3xhngkg1Z4QzydQQO8IZ7KoO3dEI0Z8wxe7Yx5G";
  b += "q9WBj4PrmbGHMPrqgz8Crg2ZOB3wXVHhzWM1+0d1j0Drts6rBm8bumwbuN1V4c1jdetHdYUXjd2";
  b += "WJN43dRhTeBVZDCgvSHqM+j4aYiV8P149eD78VoJ34/XFHw/XlfA9+N1OXw/Xp+F78drN3w/Xp+";
  b += "B78frOvh+vJbC9+M1Cd+P10QGo2OD6MhgVGxDdGUwGrYhOjMYBdsQHRnzGFwyGfM9uLRnzKNwac";
  b += "qYb8HlyYx5AC5PZMx9cFmTMfvg8mjG3AOXxzLm63BZmzHxUIPmjPkyXFoz5i64tGXMbdBuF8jDb";
  b += "Gn2aix9w8Y+gI6sJiBAPpWuMWMdFjboUsrdRvffMZJnaWAtJhlrLKjeUSRNAA+42K2gCMK34eqk";
  b += "/7MJ0mEhPi+unrfQf54l6pBSrih1lIPH1aExnm9egEUSqsiC4OZapFQoSq1/c21wcxUWSaoiVcH";
  b += "Ny5BSpijL/JuX+Tfzj8Nk1Pwy9MBs+l3JYIB6DZPTgN/I+NMSvw+TC4DfwvgLEv8eJpcBv43x1B";
  b += "GwGhE/BvjtjB+T5fdgchbwOxh/VuLfwmQc8JsZPy7xw5ReBcJWJlDPI3lBIHWQjQqk/rRFgdT9t";
  b += "imQeut2BVJn26FA6pubFUhdeasCoeeXiGqfoUzIQjWXqGquDhqgBinLFaXGb4CaoPUiWWYJ3rdC";
  b += "UZb49y0J7ovklsV4X0pRFvv3LQ7ui2SURXhfpaIs8u9blMcoE5SOGsQpqXdlVwbUFKWnDWIVJJy";
  b += "WhNuUXjCIV5BwQRLuUXrZIGZBwmVJmKR0zCBuQcKYJExTetYgdkHCWUmYoXTcIH5BwrgkoIAEfj";
  b += "GIX5BAko75BUESSBsVSPJriwJJ3G1TIEnH7Qok4bZDgSQLNyuQROdWBaKkRTEUCCFTREieSJnjF";
  b += "uGUueVKJJPMLU0i+eP7kiHJWWRIchYZkpxFhiRnkSHJWWRIchYZkpxNhiTzZUgyX4Yk82VIMl+G";
  b += "JPNlSDJfhiTzZUgyX4YkWYYwT2hyJFKEfAjp8SEEx4eQGXOKC+AI0MqQAdyd1E7uc9Ts7vPUOu4";
  b += "L1Njui9wm7ie407svsYBxP8l93X2Z5Yr7Cndx91MsTtxXuWe7r7EUcT/NosPdxGLK3cgSA5RCkk";
  b += "7uNhYUoBySUAIFkeSDu5llEWiTBuqDoPkRG7ufQXgMo1/B9RxGySI2dj+L8FmMlgXXSxgNi9jYf";
  b += "R3hcYyKBddrGBWL2Nj9HG34wOhYaa1zPyKVx8915CuNqySXvN7BnNYg+4WQzPTZDmbIetmPVkqe";
  b += "+0wH860n+91WqRxulsrhDqkcbpfK4TapHG6ZRTncKj5N/SMhZZfYLF77ssesnPDl6GbOXwlEXcI";
  b += "X4zvEq9QhE74o3C4+9WVvuypEAno75y8GgjThjw/bxCskABK+ZN0iXv6yt0UVIsm/hfNnAjGd8A";
  b += "eejeKTJHASvqDeJF76srdJFaIhZRPntUEg4Y9on+ggOSFe7EB5JF7oQHEinu9AqSWe60ChI3Z2o";
  b += "GxDPXvbPynhPq8gfjAF8UdZuM/rgvO64LwuOK8LfjBx8XjW2O8+zp3Q2+53Q1IfUI/C/u/t8CXA";
  b += "TkKv5L7sbfF783OErmQx4m3zBcnzhF7BIsHb6guFFwj9LEsjb5cvj14k9DMsWbxNvmz5BKFLWah";
  b += "5G32x9hKhE8JXe0A33Oln68VzfnY5OVJQNiVe8LPrxIt+tlt8ws/GyTeLskmRbqSDhUA/3Oa24W";
  b += "WX24qXl91mvLzmrsXL6+5jeNnjPoqXPncNXva5T+DlgPskXt5ym/By1G3Hy3tuBi/H3A68gGrdi";
  b += "dcRAzdZo03UtfB6klRXUnFXSdWX7Nug4j6N1zOma0tVt1GqwE/hFVTdCrxeRJWWVV5XqsLleAWV";
  b += "twSvV0gFJtXXkSpxWcpwRIy05c14hVt3SkOgJQ2BFhsC75tsCbxnsinwrsm2wBmTjYF3TLYG3jb";
  b += "ZHHjLZHvgtMkGwZsmWwSnTDYJ3sBrSwa3EpBt8LrJxsEJqVtfs6Qh1JKGUEsaQi1pCLWkIdSShl";
  b += "BLGkItaQi1pCHUkoZQSxpCLWkItaQh1JKGUEsaQi1pyLWlIdeShlxLGnItaci1pCHXkrq6JXV1S";
  b += "xqibWmItqUh2pZzClsaom1piLalIdqWhmhbGqJtaYi2pSHaloZoWxqibWmItqUh2paGaLSATtq4";
  b += "sx/jPajxKku5CYqkYON2rA06dQPlppCKsSV2Eha3u/jZ4SA7Yw+K9cHN6+EKU7wY9En7mIeSmfY";
  b += "dxcTGbh40NtNqC7nyGLgBR3CZGJFMIo0i6WQBySDSPfym+7ZO2iRNwk24koR7Ys30f7OkTZm2+J";
  b += "uDvDBEXbAt/W2U5I1YeMIa5KJoMgbZjHTqSmvTf48qgBhkMzIWivMzaFLZkP4WPqNmkK3LSJZ31";
  b += "2BSl/4md1TDo458yvDM/V48izvj4i/Ucu88iae620cHua+/x08fNuA7CEtRCPoYe8BHJhl+bRAg";
  b += "j7LbBlEoNpovCnPQLc/SghgvB1bQesg4be0uxeaRwp/OEEuJch2Fx6ZViqSOwqPYPFofVCg80W0";
  b += "lrdipgYSVogsO8i5lZzDLo88wRgDhsWsMsxZlz0J2Ay4v/cHXvzL2nwHxIsC4/PTXP/OVsVaeqI";
  b += "3LgBTYgL5BH0epLG7zMbPp7V59bfbWL8Iw/H9ZXgmNSvGOWFJQdhyyMbkSVAKDsaagTdj4/DIYO";
  b += "zXkjEM/QMiRUL6jcidWuIeNDi/cL+prPXpxqjZ7V764PnhxffDiEhjMtadPyVdW6sjh+Ad5ZSp4";
  b += "5chX+ZWVwSsrg1eWCU9/+hg/vUSs1LFn4/gh0a8s014Zx1eatdlTX52reuO4FrxfmLXAbmWQ5wf";
  b += "B2FmBekQFMEkaGbsUL6XAa3ApB/5KIwsn8JJIGWVl0Eppf5GW1oEbzTQm1ek/s0QsG4PRxkxZZT";
  b += "H4y967eDWWbc+Ov4/KlxnDeDJ0I60Cc1+wPesFG9eAreyNX4Nio1SMg6iYR2lPFGaNQXwuxjuJz";
  b += "y8szy8szy8szy8szy8sz9sN5xeW542J88bEeWPivDFxfmF5fmF5fmF5fmF5XkGcX1ie1wXndcF5";
  b += "XXBeF5xfWJ5fWJ5fWJ5fWJ5fWJ5fWP4RX1i+/A0Yhqd/AAvLE/LFH+PC8pR85ce4sHx7zur9+Be";
  b += "WJ79FC8ujv/2BFpYvfPMDLyz/pzaz7cRSXFietvZ7VgPyzkk+YmIVr83ijQaGpuDMsJ+5H5OZe3";
  b += "7mrp+Z8TN3/MxtP3OLMqwV7IFPxcCWjjwopVJUFhxIQSG2Mc5gZShEG/yUpoIo/6b/5U14Vgpnm";
  b += "/G0FM624HkpnG3FE1P4S9rwzBTOtuOpKZzN4LkpnE3huSkxeQqIKX+Ji/wjf0sSzzzZAyLLonNB";
  b += "SjmUv5cW6cJfg0e/lIjSQgLGnDZCv8aCG276MdOtdpjR5QAz5QdMB8xlwtzwo6UD5hJhJv1Q6YA";
  b += "ZJ8x1P046YC4SBiOnL5aYC4TBsOlLJOYcYTBmeo3EnCXMFT/iOWDOEOayfzQBYE4TBkOl10rMKc";
  b += "RgIEVMMZJDhxbD4SlKn6Z0HaXPUNpN6bOUrqc0K6NXYbpRRnLo9CM5dKhIDh3d+KZa0RmOYdVBA";
  b += "Qo6OIZtpx/I4ako+lKgyzgOT0fRa4Auwzisi6IvAbqM4vBMFH0x0GUQh+4o+iKgyxgOz0bRq4Eu";
  b += "Qzisj6IvBLqM4JCNoi8AugzgsCGKXgV0Gb9hoyRQXH/8w4CJdAJPBY5+heyNXA/cX3isDzU+jPe";
  b += "Q3mF+GCXgNgMjBNxiYJiAaQaOYXKT8+9hMsX5o5jc4PxbmExy/gAm1zm/D5MJzvdhco3zezC5+j";
  b += "FwIrxoTkbsk/TZGHEf0WdnxANEn50R3yL67Ix4lOizM+J7RJ+dEY8RfXZGxJackxNHuMDsrDjKB";
  b += "UK8iKzE53jxYVwO/hWyXGkhio6AKeRYPHqlQVSEbsfDkyhobZiRYeZnUWBQC+MsY9pI+buUb6D8";
  b += "DOUF5e9Qvo7ytylfQ/lblK+m/DTl05S/SfkU5acon6T8DcrblJ+kfCz3EdkX0w7FxLKeO44FjbJ";
  b += "RNYpqyA0aSjZ+VkNJflmvoSSLPauhJFd2ayjJyM9oKMn76zSU7C5P56Gohz2loWR3VJ0OK2iUKm";
  b += "iUKmiUKmiUKmiUKmiUKmiUKsg/YsLjmHzEdPJJwBgX5ekg3uac6u+ocQG6BNFbcqrWAI3H8VQge";
  b += "mtO1RwqPYCuQ/S2nKo9QOORPMsRvT2nahDQeCjPCkTvyKlaBDQey1OP6J05VZOoYwBaIHpXTtUm";
  b += "oPFoHhfRz+VUjQIa54seop/PqVoFNB7PsxLRL+RUzZJ4trzOB8l1XRrXdYW5rivMdV1hrusKc11";
  b += "XmOu6wlzXFea6rjDXdYW5rivMdV0Pket0VtP5S2cqnZN09tF5RmcUnTt0lnhea3DZ1OKFgDceVL";
  b += "OHKmuTPJ8homo5euhT3SQCo5pDVnQ3ycuoJpRt0E3CNarZZfN0kySOYhXZct0ktqPYSzZqN8n4K";
  b += "JaU7d1NA0IUG0tW6KbRI4r1syoKFxcIdZcNfhTie1wg6Fsb/TEVRy+xWbETxp0NIvRu1aL3blNf";
  b += "hsFo16v8DvWbMSptt8rvUrWJIWvXqfzzqp1y4gXVqDnRGUTDfOiq2LAlVhaZFHhFJgVukUmBKDI";
  b += "pqC8yKVhRZFKwvMikoK7IpKCiyKSgpMikwImeFDTAX0hJctSEFQfJEjVZxbGxQk1UcUisU5NUHA";
  b += "mXqwkqDoAr1OQUx716NTHF4U6oSSmOcq6akOLg5qnJKI5pK9VEFIcyGsF4Kjo/jv2TGsc6QuPYv";
  b += "Lj54RM3tqgUaT4yJCx2fDvZdTMnfAvZBOR929g1yPtWsauQ9+1hVyDvW8IuQ963gV2CvG/9Goe8";
  b += "b/e6CHnf4nUB8r6t65yp2brOmvOTs499cgZDgKnPymAQMPXpGAwDpj4Pg3HA1Cdg7eZJU595tZu";
  b += "jpj7lajdHTH2uBaOJqU+y2s37hj67ajfvGfq0qt28a+TPp2bmTaI/5CbRAiPok9rRv02iWbSIVt";
  b += "Em2kVGpES5iIuESGqnA7upbMwtt9ZLg1M5Ln/hWiFkkiIVBLS1OVxuEiPTauikj07moVM+OqWhc";
  b += "RHKK8+O8cFqq4bUaWoxjMFbJr+A4vKaeDFE0r+1DF+bUKFxNXxykJZIefkqmfcFcf9VFh6k2RAr";
  b += "+81VRuWJlbHscHy/ZzbgStRpZ5BWouVyqkkL7LjqrBCjhKgJEMOESAeIeza/3UcIg9dhbVrTw11";
  b += "U5fDTC1aJhmlRyQwT0LJt0J0FhCZsGTuM5zPSjcLByKR1qwS2ZegVNhrPS8IEXBuyMCZyIWGSVs";
  b += "gqIggOLplZYQKeXFoqnAhCDJu6MuLlNnJcaYhAi1CFv9nBta1k+CG4+JUSZmFlYIXGC58Lf+nPP";
  b += "dRr5YN7pfP9P+oB/OCSB/cDkh/+UUbxW+2P/qHWP4pHJD74I+wH1zgf4sMfwG91Pvoj0h/8EeUP";
  b += "vv9b/yi6R8U/CsZNff+PSDz4Fkn9QBj5ATRisWvpQ5WBD1DOP8Bh9gHwx0dokdSHv7X0B3Lrx8D";
  b += "gZQ+PwT/CYGD9QMbMD/Hh9j+qvvEQh+UHwCfGQ9UXH+CtP1jue4A98oemxj8Eg5b8o6im1A9LDf";
  b += "9TutX6gYi7AjUpFmXxGSbv6O+sMetOrDouzVboHW2RBaecbmka9NgjEg1KJShj0gfRAwcKLAhLn";
  b += "AX4R8XRPlMjygs7Rrm00FRLa9AiKowmpgpRLRbRs9GulEQo/9Yk/kHxEnhIwZSkQtq1FksLzRLl";
  b += "wxkXi8USeirayRYilH/rQvyD4vDMwjqLw6uSdHy2RYe3k6syHdxm0fnt5Kjsw+csdlP24bMWOyn";
  b += "78BmLXZR9+LTFDso+fMpi92QfHrPYOdmHT1rsmuzDoxY7JvvwiMVuyT7Ma8B4uns92c89SldS2k";
  b += "DpKkpXU/oIpY2UrqH0UUofo3SttL0L3/Zer2zv9ewEKnzTu6dMy/VkWq5nJ1Dhm95Xhun7iC5N7";
  b += "w1h+gGiS9P7qjD9LaJL0/vqMP0o0aXp/ZEw/T2iS9N7Y5h+jOjS9L4mTCcnUOHb3h8NFxjhAtL4";
  b += "/li4wCgXkNb3tZIinUDRNJpGTsxnzjT+AXMC1/peyYXcC6MS9QPsEXhuPPJyKdrnfZ6+g88/Y7K";
  b += "zHztvIgaju5X5mFuIOWWyiz47ciJmDDApH3MTMScBU+ljphAzarIjPbt2ImbEZEd6dvBEzLDJjv";
  b += "Q5dmsGzH2D/QZz7NwMmHsGuwzm2MUZMHcN9hbMsaOzv8r0sDk9VoTT7SKcnizC6akinJ4uwunVR";
  b += "Ti9pgin1xXhdFGE0RuK8HljNJuvFbiKUDDhwNUdZNQ4sGzBCIrc6tajOLTp/HdPILe6uG/tMmMa";
  b += "aKHcXYUikTGrBXKr+wg+izGNArnVXYP+rox5lJa/3cfQ1ZUxa2kR3O1EL1fGdNFSuPsUDlqMeZo";
  b += "8fNx12JUY8wx5+bjd2JUY8yx5+ri4BnaKMVnmWXcDyXrb3Rj0SJD1tuqMIOht1Q9BytuqC4KIt1";
  b += "XvazfvW6rjtZv3LNXn2s27lupu8EpL9TR4m6U6GbzNUv0L3mZpXWsaBhGXusfjlD5B6ZOUNlHaT";
  b += "GkLpa2UtlHaTmkmb51faOv8ilkyilkUf7VrKMmSbRpKcnGrhpKM36KhZF9p1lCyezVpKNkjn9RQ";
  b += "shM/kYeifv+4hpJCwlVCQhCru5Q+TukTlD5JaROlzZS2UNpKaRul7QXr/Ojj0a7B6OfRpsHo69G";
  b += "qwejv0aLB6PPRrMHo99Gkwej78aQGo//HExqMPiCPazD6gbgajL4gQoPRHeRBskmoct1uYsiopu";
  b += "AahwLXDF0GPxEuMGHoQvjJcIHrhi6Fm8IFJg1dDDeHC9wwdDncEi4wZeiCuDVc4KahS+K2cIHpP";
  b += "J2jPVzgVp7OkQkXuJ2nc3RISjdJIFEvvJxYKRpyYpVYnROPiMacWCMezYnHxFp0a+3KiafE0zmx";
  b += "TjyTE93i2ZxYL7I5YP6ND3YQDoaKiGElYiSKGLwixruIITJiVI0YiCPG7ojhPkJDiFAnWFLw0Oh";
  b += "RupLSBkpXUbqa0kcobaR0DaWP5m/XuG+y1v9ogLonUWsC1F2JagxQMxL1SIC6I1GrA9RtiVoVoG";
  b += "5JVEOAmpaolQHqpkR5AWpKouoD1A2J0kXJpPnwlbkZQ6yYU5tDD8G5tDn0EJxLm4uJ2jm1OXRJm";
  b += "kubQ5ekubS5mKicU5uLidSc2hy6/MylzeGu87m0OfRgjNDmaOe4iIPq5qtwpaImvUvuDHbEAspP";
  b += "UoSCUuH4cxGa6/gHt8vtk+rgdrmDUh3cLjdRqoPbeR+lOredt1KqY9t5N6U6tZ03VKpD23lPpTq";
  b += "znbdVqiPbeWelOrHd31w59jHMNs46RaYb55wi840LTpEJx0WnyIxj3Cky5bjkFJlzXHaKTDquOE";
  b += "VmHVedItOOa06ReceEEz3xuO7wJsuy8E7KMvwj3kwhr6AXUqFBrVSYUCCGDzChK6CVDMfOePogb";
  b += "XT3quARCQQwygxcq+CPYDJMOaJaLMZbaHqOYZrQaJWSD6qk60EM5VBoYvP3KDtQuOCbcJNoCd2F";
  b += "k/2DBJdLeCFcK0RF1kr3oOWArhyRwEYXLvquMXINS4gqeU9pupuuFfJXpOGaQlMifSFeDwqTAi5";
  b += "EmCehasJfiOEZauguEwTBQYItCZfBtUSUZE34sqRI0hXpJZKOvyiGXww1Xw5fFsN6pF+IMy22ZV";
  b += "58zKw+UYO2zLGE74J3lmPEcKNY8F2+c5zBryZbJsY0scK16VBxtGU6UEt2lC8d3PVL3wZZCF8Rh";
  b += "+ZnAySKPfhmmtCZaGIh6WHSnM5EA4sP30L4VABPIzwWwDcRPhnAUwiPBvANhEcCeBLh4QC+jvB9";
  b += "Q8ETCN8L4GsI3w1gULBNNqYsJhFVQ+lSSpdRWktpHaXLKV1BKYtDQakrRSOLtyW+eFusxNvibow";
  b += "KZ4olvnirUb12MfVaKHDOL0DibWm4wAUuIMXbsnCBi1xAirfacIFxLiDFW124wCUuIMXb8nCBy1";
  b += "xAircV4QJXuIAUb/XhAle5gBRvIlzgGheQ4s0NF5jgAlK8eZLSjfG12EkTxV8imrltChJz1hwMC";
  b += "xlLbjtPUFe2s9NQwBd4CZCXY19mGE+O+GXIduNALmJ+z/SqspNfhY5hE+KMycFZkPc5c8rPjPmZ";
  b += "k35m1M+M+JlhP3PfkJl7fuaun5nxM3f8zG0/c8vPTPuZm35mys/c8DOTfua6n5nwM9dkphH6yVD";
  b += "0P9fKxlybfI5t9BDGmsCVCzs7+bVvg+yyAg/ia4p0o5A0oUhThaTrBntQ29mb+SQbvZ+hmWLkks";
  b += "xyLwljDtWMFHy40GIDzqLRoWp2kYcS0qIPKBDteC/K25lf/HaMskn4pQnipBgNb7yuE0eo0CDNa";
  b += "iEvACXCD0d90SKTX5y+AmFiK+IvGFK6Q0WS/hpV3Be4awG+GVPyrBHAqQBsAPBGAAr0MA7AOgCv";
  b += "B2ANgBMBiEtW1wIwDeD6/T6EAXTWKRp8VrZTQehT3aagGCZND1++TseLyNdb8SLy9Xa8iHy9Ey8";
  b += "iX2fiReTr3XgR+XovXkS+3o8Xka/DiSLydSRRRL6OJqLl68mE8lwPrbcG8hV5YTqOoqBgL1eCOJ";
  b += "olLeoOdoSHfRx7YSjyB3K/VGTipJmkRw2Xe+vYOZLEtC0AvmkGwAjvfHjg2a8VUFBsCYwaZu3HH";
  b += "9RoztjwbrhOx48cFtaRDHMUIO5Kwq34EeEw6ZYk3ZOk2wHptiTdl6Q7AemOJA07TJoJSDOSNCJJ";
  b += "dwPSXUkalaR7AemeJJ2UpPsB6b4kjUnScEKRiEMAdUqSRgLSiCSdlqTRgDQqSWck6WRAOilJV+V";
  b += "PHg4+Y1h+xjVJGglII5I0IUmjAWlUkq5L0smAdFKSJiVpLCCNSdINSToVkE5J0pQknQ5IpyXppi";
  b += "SdCUhnJGlaks4GpLOSdEuSzgWkc5J0W5IuBKQLknRHki4GpIu4b4cGMUHHAFl4YFSChzAaWQGmw";
  b += "okjOPhZcv8Ql8LdRIX0pHqKRduKfLp1hAfPVN7giT0Wo+lwF6su6EPt0MTuEtKvHXcxXkcTbg3p";
  b += "1467FK8jCXcZ6deOW4vX4YRbR/q14y7H6/24uwKvVxy3Hq/34q7A62XHdfF6F0+/guslx11JGnn";
  b += "cbcDruOOuonlF3F2N14uO+wjNK+JuI14vOO4amkfE3UfxetZxH6N5Rtxdi9dzjvs4/SzUDkppgd";
  b += "jkMWJDjDu7h1GGl+TEUlGTE7ViWU4sF3U5US9W5AR8I9qFPbQLN6BdeDXahRtz4nG0Cz8mHn3Yw";
  b += "9p57mkYQRE7IzIE9lcvyV0awxxir8ctOigY0IcFZYdXweLFq2QJ5KVZSHkLcMMTSjJvoabDeXat";
  b += "tyhrHPasWrFwjjH0vLBr3z8mFr3PXwo1aNXSb0dr7nlvYbb+qKg5nzXeGZLCc8Ec4y09jKn8IME";
  b += "G4Zrz3gJ80EJ+Dkna9BzDMj+HqPI5Nf5z0vicBfwcEsuVc4ze/ByiFj6nEp+T5ueQDK+YY5Dn5x";
  b += "C18DkV+JxKfg4J/PI5dAF+DlELn1OOz6ng59DokJpDZeDnELXwOSl8Tjk/h4aSsjk0C34OUQufU";
  b += "4bPSfFzaNxJzqGA8HOIWvicJD6njJ9Dg1RiDj2Fn0PUwuck8DlJfg6NaPGwOsO3EzLv9iXnQSzC";
  b += "7Qm+XepCGD0bkDYjYbwjwwxI1hJQRZbhpA4nMLgBkSy9cRLL72dxTmAc3u/xzACQh9+HN/A200T";
  b += "2ko8TcVSa8S3HiGwT+bJOTmrkJJGv6OSURk4R+apOTmvkNJGv6eRqRYa2zACIJSb0EjVaiVTGrK";
  b += "ES1/USdVqJ8oxZRyUm9RJCK1GRMQWVuKGXaNBKVGYAxBJTeolGrUQ6YzZmbzLVXYDUtS7Gi7cxb";
  b += "Gqcmgso3GIxxidZRsUZaTMyxYWlvMHKTWv9FD+iUutv+NkVWr/BH1qu8T9WTUrjY6pMsQA+f7H2";
  b += "7QlNojQKO+AwyXZrAVcmf0Lak0huueD7U+QiaIXi2RX6IFr0V5reuYwy1WE3wzAqa6QPU2maGoO";
  b += "GXUr5aZkvFUa6O2/iz9ZBzJJOUiKUwlJyRG14LqEtx0iHodinlx5RO5/jtPVY6jT5Ck2ewpJvcp";
  b += "imsMhKd0rM8vxbsSIfcDv2wb+A6sZIZ2Fekj2CQyfWF1YlXtGKWyXtQybNTsYSaK39idVmvfQ8t";
  b += "XxrLVukpbWWbBEYTJ3sCjMGG3Kd2ewKVyn0bHgLszR0l0kTNxlnaeKWlCZ6f2dyWaHNgliFpnGh";
  b += "rT5JaSIjqwNF+r6CgXH9af4oYi4bvpecSStYJq5geeU+Zhgx4waHzyPMMUBcNHxHOhPXsUxcx/L";
  b += "SPuIoIM4ZvjueiWtZJq5lUcBcQhxAi7PB8XIJsQ9NzgaHyyVEH9qcDY6WS4g9mOCalvsh17F0rw";
  b += "/W3rxI/w0y+nq+QtUQdks45xcgJWlVuMAFLiC1n9XhAhe5gFRrHgkXGOcCUl9pDBe4xAWkIrImX";
  b += "OAyF5AaxqPhAle4gFQdHgsXuMoFpE6wNsKPhQvIwT7C0WWCC8hR/Anlv3FdGsTQ4dOKdqkzySaB";
  b += "psDFYauvwQuy0rqWz+I6c+tsrTO0xsoaE2vsqzGuxrIas2psOs+gP5IMaoV5MxC0SVHAlch1OCl";
  b += "WnsowE06xeyctpVFAb5gNl7ODJy2nUUhvmBFXsIsnLamRLzLMiivZyZOW1cgbGWbGyJ8wMaalNf";
  b += "JHdp9gF9KneHmNPJLdp4lj3XW8xEY+ye4zxLpuNy+zkVey+yzxsLuel9oogKmbJWaGOqDlNope6";
  b += "m5krnY38ZqbuzkYTDiMtBxHOIy0HEI4jLQcPTiMNA8cHEaaxwwOI83DBYeR5pGCw0jzIMFhpHl8";
  b += "4DDSPDRwGGm/02EY6ZUf0pMP005Ku1Snk/zQdSxgnk7FPIrhOjSUZNKMhpKM3a6hZGdo01CyA7V";
  b += "qKNnpWjSU7KjNGkp27qY8FAmEJzWUFB/K7yLPjesDO3xiZRUGeTIp9nKHBjbm1O+nZQzNM9SkIM";
  b += "xtGlin+YWaFIq5RQOrNa9QkwIyN2lgSvMJNSks80oNtDVnLpOCMz9I1ghV6ErcXGJG1T5X8spuO";
  b += "j4losEUfZ8ujJvD9AO6LG4J09/SRXFrmH5Ul8RtYfp7uiBuD9OP6XI4E6ZjJ4/qFqrAiKHL4c5w";
  b += "gVFDl8NdkkKbS0zhzubj+bh4YnYfT7FJbH6wQ3EwSkQMKRHDUMTQFTHcRQyREcNqxFAcMXxHDPk";
  b += "RakKEUuFpLuEf2LkTK2uUKkuTCmpdc22A8tc2HwtQ/vrmowHKX+NcE6D8dc7GAOWvdT4SoPz1zt";
  b += "UBSq55rgow6wqcQdXapxtg2gpcQXkN9GFrc2OGWDSnNodh1eZS5jCs2ly6HIZVm0uVQx/LuTS5m";
  b += "EjPqcihj+dcehxGoZxLjYuJ8jm1OHTRmkuJQy+3CB1OOylD6m0loiS9iybiuwQeIxTXHKAczflp";
  b += "ieb4VKM5PS3VHJ6Wac5OtZqjU53m5LRcc3BaoTk31WuOTSLs1DQ/ffgRmD7E+GCMktnW3GPhOQR";
  b += "aoGzpEWlJv8M8WG4WZt9MPnKD/Gakf6ZB82K0NJWh/QoEGvpPwnSarmz8NtAFhp6FxqQYzaHZb7";
  b += "IE7sGrKd/MJqdhChk42WAK9lgct/Z7dgN5WsUGBb/R5qh8RuG+c+5ofCKex56q6mCoCnUwlDoWS";
  b += "h0KpY6EUgdCqeOg1GFQ6igodRBUcAzUYjoGCj4LV2F9R54Cm5lNzkOuNLo5hWR19Fa5OnrLXaIO";
  b += "33Jr1PFb7lJ1AJe7TB3B5daqQ7jcOnUMl7tcHcSFx5D6B1jVB4dxCT6+00MfCXIbLTwOxV6PPlp";
  b += "kFKQi3kqxMmwZtsK2x2T69TKxWIuJWTEEbbBE1IilYpmoFXViuVgh6oUQnlaofMitVC8M2R3Z9w";
  b += "tNNKnCykUGLSMbT5TPMn96eciug05xHp6nAll/v4iNDnJegpH3FPKWwdNsyN5VyGlp24TsjELeN";
  b += "PhAEHy8Qk5JayU+XiFvSIslPl4hJ6XVEh+vkNel5RIfr5AT0nqJj1fIa9KCiY/3kSTrbd5A0vAh";
  b += "5bs+oWFZv8qX9Uqgew20F20RSXCS9YGkZiWvgZWLVb6ofySKvhDoUtI3RtEXAF0K+jVR9CqgSzn";
  b += "/aBQ9DXQp5h+LopcAXUr5tVH0UqBLIf94FN0BupTxT0TRE0CXIv7JKLoFdCnhmySBdZJUocArp8";
  b += "gRBV1hhkI+lIsUh8vGaPyY4sZJG4PxYzrBwCUCrjEwTsBVBi4ScIWBCwRcZuAcAZcYOEvAOANnC";
  b += "LjIwGkCLjBwioBzDIwRcPYB82KIoSJ4MIpj9VkHrVrih4vVtDyJny0azntL6Gx3O4oteaYCZWro";
  b += "WHZ7DtY87y2lo+DtOdjzvLeMjmi352DR814tnU5vz8Gm5706OhfenoNVz3vL6QR6ew52Pe+toDP";
  b += "i7TlY9rxXnyG2CrPteU/QefToYEReSMLBpBQTXFijY6ZFFSYLMFmISTUmizCx0aMY3R+GRGpI1A";
  b += "yJpUNi2ZCoHRJ1Q2L5kFgxJOqHhMjzNPasrLEfBqQTRw5n6992E9mYa1nr5dhMXt8OrzwaCJXS4";
  b += "l3CX350ePmxhEuU+v5SGj2pnuDQ4bI+3ZH+VCnc+sDxj9WbcWTV32zh+uPDfLNw4Y/HPKtwzLPC";
  b += "g7UdOX6H1/V46LXCqyOLC63WZYWxeWyWQJiuzbEAwrQxx/IH0wYeqCgvcix9MK1jsUX5GpZalK9";
  b += "moUX5NMssyqdYZFE+yRKL8jYLLMrHHv44iC+afRxcTXMeO2oglLKoW/6EKdNtxusN023hMdxtnU";
  b += "sUNXbLerhpum3R8kjaVbpl5U2bbnu0UJKml25Z47dMNxMtmaR1pls2023T7YgWT9KA0y3b9o7pd";
  b += "kbLqLUcLKBbMsSM6XZFCyoZT6BbctFdPAo+UlrJkAPdkvXu4Vny+SKLrdOraDZFDHvfVHPRnHha";
  b += "PQtNgE+ofJf6atwDvlblO1T95ERGVWpOtKuWyIk21Xw50ax4ICdaFMPkRKviq4fPtJNzMm0DncN";
  b += "lz6m9TZnRzKkK3DTnHCTpHC57TgXuljnn8EjncNlzqnB3zDkHRjqHy55Tibtrzjkk0jlcdpQad9";
  b += "+kWUyUeLyPccN8YyZxKCr2AYzvVGZM6hM4Wwhg/FXKgEm9EOcIAYz1pkyX1O8BlnZLkhcArlNUb";
  b += "EjfYkniB8A2BU5SH2qa58gfBY4sVJH4JAoKN1cRfRJFRfRJFBX550CQFpHS0Hg4uq4eGeSdRT5G";
  b += "/HLpykSz/8rgLtq0gedPYKLhk4P0AfxyhTfw5YavCtm4168hVvaXrll3ogktSjO2H88Pd7CWkwW";
  b += "qW4byq5D2Gf8k7zKioNpTKa1gaelRRZ5bVAZjMaUppNgYHYPA7lTLpI2slszBZaKKSjRRfEAqUC";
  b += "d9t5arqHwLaQNLt4qo57oyEFm1H8iJI+u5DTIcme2Hc+IIe+5qGZRskR/UiSPtuY0yNJnjh3bii";
  b += "HvuozJA2WI/wBNH3nPXyjBlaARxhYrA5z4ug5UtYVcAPxKf+6QMWZZspxPY/Yh8oLhw4DJyO2hR";
  b += "kflAgeHwZWglASXFj9AHaggHMSOXhAxH6gNNQsWECmJBXbS0WFAXLC0W1DlLiwV11tJiQZ3RY0G";
  b += "d1mNBndJjQY3psaBO6rGgRvVYUCN6LKhhK6fWbT/MYT4b81z86zUv5PrwmU/14QNt6sNn4NSHj8";
  b += "2pD5+0Ux8+nKc+fJ5PffgIoPrwqUH1vpTu0lBSpncGIRxIHnVS2sXHe35/p0DlxYLyNuaf4jRhe";
  b += "tn8c5yumd76/JOcrpres/lnOV0xve7805wum94z+ec5XTK9dfknOo2b3tP5ZzpdNL2ncurnc3Qo";
  b += "ryunfj3Hh/I69UgvbAnxtJOgNlO6hdKtlG6jdDulOyjdSekuSp+j9HnFPLLKvWCtVUaIqg+fBMX";
  b += "LsJ6MEKUadXO4wAQXkIywJVzgOheQzLM1XGCSC0iG2xYucIMLSCbdHi4wxQUkY+8IF7jJBWRn2B";
  b += "kuMM0FZAfaFS5wiwvITvdcuMBtLiB76POSIiNErRRuaBMQ7v8RAr0HnhCP50STeBL1+2ZU/ltxZ";
  b += "tCO3gMd/iLcyo+wFCcK5YfQ5MfasPx4LCw/Hg3LjzVh+dEYlh+PhOXH6rD8WBWWHw1h+bEyLD/c";
  b += "AvnhfpjYUOw+UBghylur+Qn4MaK8x/ICR7HF33s0L3QUW/y9NXnBo9ji7zXmhY9ii7/3SF4AKbb";
  b += "4e6vzQkixxd9blRdEii3+XkNeGCm2+Hsr9ehz0uLvufkCBs3+4oGFoFNtIoKoXRQ3amnQgno0QK";
  b += "x4wWb1+qgAgopeE/DJk1H0ZMBaTVH0JQE3NkfREwEDt0TRFwc83xpFd4Ju0hZFXxT0rPYouh10x";
  b += "kwUvToQKx2SQKsBtDV5oYxYuwK0xWqO9GmzdraINTOHdbLFrI8lWBNbwlpYkvWvGta9pNa1VGpc";
  b += "qFKxsnXbYGXrlgzAOW24HqtP7ibWnNzNrDS5W1hfcreyquRuYy3J3S6VtR2sG7k7WWFyd0HrW2u";
  b += "sCRuPasP1wkl7cI1FB7clkJkVhLGHphWElsnbCrLwEVfhETMoazOiHo0sAsUnyFUPXbM2oXDdLJ";
  b += "rwcOtmPNW6BY+zbsVzrNvwoOp2PLl6x8PvDfnDbURvyB9uI7pD/nAb0R/yh9uIDpE/3Eb0iPzhN";
  b += "qJL5A+3EX0if7iN6BT5w21Er8gfbiO6Rf5wG/QLGG5xplhK0aFovT8pltFUy6R1/wXs718i6shn";
  b += "wY/oZMnYAuXKI4F8HSjYUULGd6rwPSAoSkwpRXeqlCGnOfjVRhzNs+IxdP6DMeFZsQZ9AUHmPyM";
  b += "eQdfA1WgtXIVmwga0D65Ew6DL8c9NXyA/yOE+yudmj86BK8OeJH06A0a45OzT+S/CI+eAzn4RDj";
  b += "lv6dwX4Y9zVGe+CHec93Tei/DGOaazXoQzznAe60U444zksV6EM85oHusJ5Wtz0iA2ictAQClyg";
  b += "THIBIB77WolF1YRF5aI5cSAfL4kMyA6vTADokSnY2WkS0ylFvQL4Qr2F2PHGxgDymWkIbGCw5Vj";
  b += "PIuGWNkfLzdrjpfiEZtjxn6vtgFjLBrSlCgMjP5iSEMiQo0A3VBQA0CTChIAXVcQepJMKAh9UK4";
  b += "pqBogMh4ikAZgnU/B/tjpA3hYZJsP2JhQrumYZ/E2R5svDl/ifEnwJcmXEr6U8qWMLym+lPOlQj";
  b += "Yf7fTEd5T7iCmJSPmIGxJR5iMmJaLUR1yXiBIfMSERSR9xTSISPuKqRMR9xBWJcHzEZYmwfcQli";
  b += "bB8xDgjcl4l/KYNxpeO5by0ylWp3AKVW6hy1Sq3SOUWq9wSlatRuaUqtww3lYoKTNEoZZ8/LOqy";
  b += "J454y0X6/OGhDAgKdNZxAF11XixHzD7CxAGzQGIOECYBmIUS8xZhkoCplpijhLEAUykxewCziFa";
  b += "Y3yNaCdCWixVIYkQFIJbJwtDrEFUOqKUSNcqoFKBqJGqEUWWAWiJRw4wqBdRiiToGGN9v2I+ONK";
  b += "WgRuUt7MdGmlSQUD7CfmSkCQXVKM9gPy4S9w8ZFWmdT0n5rsB+TKQ2H7CDSEjz/eOHpX+0hfpHZ";
  b += "6h/rAv1j/Wh3tAEmGrqDZtU35G9YVOoN7we6gyvhfrCy6Gu8GKoJ+xSHW+RxGwTtag41QG6ltSm";
  b += "uvylqjphFLoc1ZICRgpXoX9pLe6XIm9lz8LJDGH6MAHVXlWxhcEMiLQPk2Q+KcmkA5ik8kkpJr2";
  b += "FSTqflGbSUUyq80nVTHoPk5p8Ug2TjmFSl0+qY9IweV+LfJpg2gjRGvJpDUwbJVpjPq2RaSeJtj";
  b += "afthadYrkDsJ5n+T0AFDybKzOG9UgSAo3oOtVmalJRL+vUJFNTinpFp6aYmlbUqzo1zdRqRb2mU";
  b += "6uZWqOoEzq1hql1inpdp9YxVSjqpE4VTG1Q1Bs6tYGpjYo6pVMbmbpWUW/6VK5nqP0m4lWq+SbQ";
  b += "sdpQXQNMGzNsXstgzMNOVNyA1MlcG6Kvwy4EpHXMuiH6+v0gQIC0nvk3RIeBxFuBtE3MxaECMO5";
  b += "49UjbxrwcKgDDlCeQtos5OlQARjXPRdqLkq9DJWAU9Dwkviy5O1QCRk1vJRJfkzweKgGjrNeAxN";
  b += "clpxeWwIZpmo3Jm1AN5mEhgsljvJkiFs3kGIm8Tqdeyacup+0S0UweAw17hU69lk+tpy0V0UweE";
  b += "4I2WUQzeQyds3TqZD7VE55OvZFPXSlW6tSpfGqDaNCpGpOrelayWNVsWBarag3LYlWnYVmsKjQs";
  b += "i1VthmWxqsqwLFb1GJbFqhLDoljVYFgSq+oLC2JVd2E5PM+iHxeL1qJBBqaz912z8oSBS/Xp/V5";
  b += "ZQ8xcX/gHcuXvjBfs9dlkNpn+j5Ybz1ZzxsmmOWNkYzKbNY/u98zs8PAxDJIi4oOD+7PvHs5a+z";
  b += "3afLKzVsSeKy+BJ9qDfKudvfuHv4vhgjaXJ7PwqftdyzyBmeywub08tixbD1lQSRM7AYAsBp1Nv";
  b += "vOGF9v/TtY4DA8yju7Pdg+WeXF4dXbq93+Xtlp4Rjl8kxuD/52UWZZN8xvlNzr7RWxnrXw//8bs";
  b += "DH8F7qDJWu94sXfgV1iHN9OOjHtMe668TJjwXPnBHnxymYilL9j78l+d/o5Nv0MY6T+1vJi9Hh0";
  b += "vGOmZZK2wtntmLRSIYZ3UugaQsWR5rKwMMHb6b2zXgbu/ZsgvFtbOcosov2rTbqG/sPyPgrvMVE";
  b += "mZiRv9TxyhKkGvD+uoF8vO/IH8JEfGz8F9S7cR6cW2wi8DMEP6h5kxkymjjCoB1Mvjwnr3cMaMl";
  b += "ZFdzjqa/ve4j+i/2q6VKoM3ZeF7s/WHvdjR9F38NbGjh7ESsMLy3mrJtxr5bzX8txraW/36h3eb";
  b += "8t0W/1yL6gPDgcLjqQrzfv3m8jg8/r3D/AY3kR3+DlHcOLCRalT6ZOsd+LzD8AWJRu3nwndQMKp";
  b += "EmYvm8XiG9LU4fmJcJPgSwy+NlxV/kTnni8wP/CKD3Jah3hFA69eUdZS8q4mjLeyUyGbQoDZ0Ej";
  b += "wDk1jrBcgbwDqmZ5VjSeAZN5ayMOhQtc8AFMwokV3+TtY+DD2CW2hrLRJqXQqOBm8SBvEizBiHo";
  b += "AvgO+GHxbG9fe4/LKu+kP1daDmgGGXkbeQQ42OnegHZlz5y+2HPqMWPxGhN1AsC5nc2l1tBh/Ni";
  b += "6N6MQuGFw+UWHUcAPQOjLn/NADb0+8ZzUNMOM0uc+gY5yIDAIvCXDRAAgFEtZxYwhhW0lxnFGCa";
  b += "2l1nQXqbWXgb1E26vMuoongW/I2WXEY8IB55CPwnvwoDV1JOsENUitjfofqjAAiGs1cpOaJL7Pi";
  b += "DsneWmFM3wDVI2+7JuEESxDVfol+l31sdA1JRl8aPxgjHNh48dBuY4scWL1WLwNcSC0DkqEIyJM";
  b += "nxDkkSplUqWKZY3/brHtvEM/B4k4ZNj/me6nCMcCgkUIib/9GQZneEKbSl/uYH3UW1QaUBgK5rc";
  b += "pvKmRBl+TtJNZUexYBlGlCulPLwM5g/4iJP4ESe/49eMgU/aib9ECvkRJsHnTgEruDESzL9mi+S";
  b += "WchMjqieJDXHAOOU/ZDNu5dw5VO7gB8TS123oYrH0H9sitbWcorBjp5fP9Yzn7BOCnmQPwpudbK";
  b += "wMGpIeFjyRopUnt1MFJ0XpIIye/DX4iRbJRyiHklJ+ETJwwbu34GPlW90SdT/cXUJ3I/PTLysB5";
  b += "igLflqW+mcJ0Tx/HPcq92eXQDMi48Vku+4XtH/UH9ZFyeD2Wq8cW6JClItKbjupD1ghfYBrhM7K";
  b += "hWca/AgDXwGSPIEthexLGytIDDiD6I2437NIPkKPxJ5n+893/OebSt+gEOx/gzHa8KTs5P7BQSw";
  b += "/hvU8PDyMvEBf+as2Vc0aqKS0qIC3ZacZ7KBd62m4ZG8BRqTwm25irhRzeJNIYg7LiwrIIatkkW";
  b += "fhAr8AawodJbeXU32WbylP0KHAJfu9GNXv39jpcYtODcC2QAwIomTeEGLOPkLNJYhKWBCVoAQqY";
  b += "UFUwoIoQS0dI8UiyR0JWRF4DPs2tYUja5KkkGwZN0Yx7J396F1J3RLPwpSDL7x8P3ICyNbB/aCt";
  b += "SaYTzKC+RNgC4hlfBSpT1tha7pis8cDr+PfHQGKjnIxlU0oRkcoBqwT0M8zZVAIHakZqBaD/DLp";
  b += "ob3GIB1MO9wOhuMqXjLjtJ8b8FGN+gmHUlyR6xagbqCuOqG4ay+sPHjYpsDoxroEIEtz0bmJb4O";
  b += "J8tjV9tvW1OJf3YyMLkVkvim3x99znRkfJ6r9CfRbLTc8Xk/KH5UtKR44sCV8a+yJZrxIUsLI+b";
  b += "JZQxDLYSAnaRD5ukQ6OrQcI4F6/uIVuvrMysf3BmDjBTExqT4JbP0FM7L8FZPBp/OHfq88U7aR3";
  b += "IUefQzyAwIwEZnTKyARWhQTu6cVOImV4goFhvdgpBEYlZVQvdgaBMQmM6cXOIXBaAqf1YhcROCu";
  b += "Bs3qxSwhckMAFvdi4TrmCwLgELuvANQQuS+CqDlxH4KoEJnTgBgITEpjUgZsITEpgSgduITAlgW";
  b += "kduIPAtARu68BdBG5L4D4CMxKY0SkjxKoSuKcXO4mU4T+U7aMXO4XAqKSM6sXOIDAmgTG92DkET";
  b += "kvgtF7sIgJnJXBWL3YJgQsSuKAXu4LAuATG9WLXELgsgct6sesIXJXAVb3YDQQmJDChF7uJwKQE";
  b += "JvVitxCYksCUXuwOAtMSmNaL3dYps4+zeeN4viykwVobx2kohnE8Nsii8QEJRNrYqWu7z5XHPqq";
  b += "ExA2T6UHclFD2E4vM6hPlaP2YjvuhL64GsXMpygH6DZRTIAw+hKuMDzST5wcClL8OgzvHaTc4xb";
  b += "dfgKfEFG74tMSCdDd7X4HquoQCeqB3A2I5dEUa5xj0lnHaKGHTYRq46ENIjhSSJpcF2s50EaU1b";
  b += "2TgHZkITwXwOYRvBPBZhCcD+AzC1wP4NMITAXwK4WsBPIbw1QA+ifCVAB5F+HIAjyB8KYCHLdpP";
  b += "auVkmP7vP0C/7tDDpsKlvmuOCpLv1aBrjk2B7sk1J4hULwOTo2sO08k1pzZM30d06ZpTF6YfILp";
  b += "0zVkepr9FdOmasyJMP0p06ZpTH6a/R3TpmiPC9GNEl645bpg+bFAB6ZrjhQuMcAHpmrMyXGCUC0";
  b += "jXnAZJYdccGTwEtetQ8JAkdwKT99rYvNWnsCssFAupGHaySnmTH025Ev/o8E7oDnSEFwd7ceR+o";
  b += "RLNr8xGrzLe7ANYP8xscASOSU+w6TibaqASlg7WWESQPDAR49s70UcJGqJaLCqII0NOcexFxDvA";
  b += "q6Qvka2w8NDFBUiEMV43xeSREWps7fzDErGYOj+ffMaioZRPJqRzEQth3iuFRwWk1WmOuJMfpUM";
  b += "1atVwXUTXgySmjfCvMMj3KfQD/TMSsUhKfv1CCeNZiHGaiGH08SX+SUK0aQglgsH7IgkYZeAWAS";
  b += "MMTBMwzMBNAo7xZkjKv8c7ISl/lLdBUv4tyl+n/AHe3U75fby7nfJ9WhiWPQ9fxFw1isiYa0YRI";
  b += "TNhFJEy140iYmbSKCJnbhhFBM2UUUTS3DSKiJrpYqLmVjFRc3sWUXOHvABpex6v/qhjem3amyej";
  b += "Cl1WyFOmiip0SSHH5K45FAMKedJUoYYuKiTuxytj5AWFxM14KUaeU0jciSfjD51VyPsywjp+skL";
  b += "ek0HW8ZMV8m4QlMg/3xc3GxscuuXhsy68qWpO1kU7yVyci4aWuRgXrSFz8S1G2pmLbfEE6Lm4Fm";
  b += "3MczEtaq9z8SxOhudiWVRR5+JY1FwjGBZ1Tx7EyIOUxzE+LRbHrvQNGxezpunA2F+oNpedWHRcO";
  b += "pQaDTF/oc4V/oKe2+Av/Lkr/QVCd5W/kOiu9hcc3Uf8hUm30V/AdNf4C53uo/6CqPuYv3DqrkVT";
  b += "SJ1L9psatKw0mtWug5e0G8dLyk34a7Du49mUC/N21yQ7JTnRrcV5fswrwTHjwPte7XFR8r6oFY8";
  b += "fP8bOcHWoghnsfVcrHjsOTOLj+3AlAgs/qmP34VnFiF0TYM+j1fAALikioVERlp/34uj+CP0FCY";
  b += "8cBxYjworzOAk5igspSFh9HHiLCPXnPRs9Hg12MKwVq47zUczQd87jnOYYkxqAtPI4eyHTVrRhg";
  b += "wmNQGg4zhvRKBTGiCSsxbPWj3Pki2Md1qjBY7uLpzZAuybRUkiL133K2w6APYGnXa1aCBfoUkRl";
  b += "9ylXPaFTk0CtK/TuC0rUoVuRobqbcgis00ukocSKQh/CvBLVUKK+0O0wr0QNlKilGsWpVgzj250";
  b += "0POd95fkIiFHDi7+vPB8BMWLgOTy+56NX6PnoFno+Bm8MaijALVe5FSpXT0e34OFZuOKEQfcO0+";
  b += "4WaAbrMJmhSA1qNPsOYwqkwzRLlNh9hE0yNuljDxA2xdiUj32LsGnGpn3sUcJWM7bax75H2BrG1";
  b += "vjYY3ioS+3/z977R8lxXeeBVa+qu6u7umdqBgNggBkA1UVYGlqgCTEiwVAKzeIRSSEUTW1WOUd/";
  b += "6GS5uz5ntT08igZAEG2WxIwiSEIsOsbatE3btA3blAHbhA1JtINN4HjIpY9gm04QhzmCbDoLyZS";
  b += "NtWgacZgEtuBw7/fd915V9/QAoPUjtk+Iw+l6P+rV+3nffffd+11qN84jvBL2rWAbCTuYsIsRTU";
  b += "RsZ8QCI1qI2MaInYyIETHPiJyUp2+oPmWlwtBCwmOsGkt4bKh2Ey8yVRMKjy0qTeEpoXqVXjO85";
  b += "EnQeU+CXvQk6JwnQS94EnTWk6DnPQk640mQI0a7PDG6yVOab/Pka15oTlDRm5uU3nQqetPBCv82";
  b += "R2+2Kb3hst/l6cE2pTYkTW+pYrniQXASJMzXyUdbCY6jTxX5SJTgOBJVEY+WEhxHohzpIIn6cI1";
  b += "EWdKRk0TVyI0QqVyTdnJJ1SmOUKmdmnbzMMURGnXzWooTYKoHpDhQrotGyI4siKJ7chzluYE7Gh";
  b += "Tu4op8OBJ0Q7XoNNs7cHLZPkqHto1mu2uxaFY2kjY5n1cSEqihgxzr+lclRoGaR8hhs7gqSQr89";
  b += "Nvmp+R2P013KAHCnZmN6SuN6nf89C6UjPVTJW49aAtHQtzSk3mBydbHNNpR2Yxu93wH3BT+xYmV";
  b += "wd2REiWD8TNEclvap9diFJKRNsWEQ5V4kt2Gxgt1arh4it+aGi/0qenim1b2bylUy8W39CoysDQ";
  b += "qcfGJUkph0ZbgGE9iuugLGq1o7keQANqFXgos9ZpQcxjJkSIZFAwuzAK1i5HoDqJBx4qORr/I6D";
  b += "aiQc2w9gK1lJHoCUSDpsFDGa6G/3HYD3haxxNJaNCfJB3vZyTc/SlS6v40SXN/A2lxf4bEt78RP";
  b += "/P9TfjJgfq6YHYC8XXBLADtdcHsItIrlaPkw1vhhFJOt5vkBD2Tb8inhV+ezLM6Bl4IDLxQMfAO";
  b += "FpNLvNLs7svjfXljX97cl7f25QnQVvOJfXl7X97Zl6cjb8nzUkl55dy+UrpenibLcLAk02Jf+l+";
  b += "nzdxyBP4wXyzSfjdPdwaEWTUHio3l5KD80FLRoO6WxMpDUjR2Yl7E0MeZrDL0iuZOzAt5nKoeZ1";
  b += "TlK4/ju3LM+I3kTXEhqE+TvRAiTgpapZ/LsD+LS6LJ0hyUNjSX+k2JhkwhhE+9Fu6LemU2gAJTe";
  b += "VlWRbTUbwv1bpTZouoCNMquf0r8U+yfXMTAZ/JPXf+U4wNwMJYMCnMfdUea+LLEmAMDqMjUS5K8";
  b += "TdSvyYzamLxWeVvvqZF6h9+geodD9Z68R6Zf854eoFSvo/YxFHQ2WZWQ5oFis7xZhvnmcvsHiy3";
  b += "5ljJ8YE4mcFe+2Z+Tn2TQn5efeF9/m5TaLWcHsj67aGhGfF+ZQy1pThFaFiCBN7bFosEgVIVSPk";
  b += "GZL7UMQwx1vmlOl5b0SdEe9OFJXX4w0ABVlCXXUhhk4WJklWOqdyxIJNB+crhzNvul/A42zP3AV";
  b += "ew3+GUpqo2fNmSD+0Eqmvv7sPjbzkC4X6oyjd6YZm9MUEflNh5TMXIfKgP9ZljKEN5fNGAuEdy3";
  b += "WH5YNVsO4ntzSA2ROCgfYXzi4yc1+hCjYx/NooDEbTSqDA8uymAWYfZnITjHjFTzNuLdwreljS/";
  b += "/F+nmLshOAz/z6Hs9WHVBkoTMQ3eSml1tee5EuGwVBkKmJW5PlqSZSyfVfDWfOAlhnATVnwP4B+";
  b += "nmvLN/qWjt54N07fQSepCA3/vzDUtFuJ+PRZspYBEnEK+dL/OKAfZwB/OqI50vP23Z0WCF6bfkj";
  b += "ykIxHEASH/suOz60n5pSwOeD/v0LisNzEogNoHp6OKGFvcg1FXo4po3huXwbTS8T2m5uS2Ps3cC";
  b += "nA3WN8LIIKQ0aEYpDx566CcsjC649E3Zd2yVZ0YmGtnVyNl7uPhn5JjNN3egKjvyrQSl2iyrYvv";
  b += "DRXgvtOPyzYsyJKnOZCgRSWMTO/URwpB0ZDgmgJglzy0ZkonhIUn8kLQxJMnQkEzKSEzIkEzs54";
  b += "OwNYl0/AQnemd/PrlUdPbzsQiZgtXQRnxtSCbtkDhdPPyE1zUk7fWGBPfwtkHQfgAO15RUUDqvn";
  b += "4CSgPwIZVkiVQEllw69GwIIIQIg93F5SOg47tyUQrk0Odvu+AdSuagPX9kgbU11DJoTI+ERh+YA";
  b += "QDN0gfWKLRk67sjq8uC5nxNjDDp++FESbxyphCIJDjkD1KEI6f1SnjBDUA1+Nax9VUtM2Tq0XuZ";
  b += "ZLj0FB/PCa7X3KS1b6oPmRQ9S1feRJY4+GtMUgkd93eag6BFNd4kKDND76WkzfFSCqGQoqouobi";
  b += "2qCaIL+LIQnREq8U/kqxHIygGhwKRz6YDSFaNsm3s1RiI+XRcnaMtkycoQGA4fng/2mzKKLdXbD";
  b += "P3gJeyBVDcXyyvul2l9sj5ETcssSkINKyPXuV2NCuyMjW1DjoRUmQc7LqGWIR2nKjvUSrYzJzDL";
  b += "rm4yDr52kZ9QKc6htpZNzpG1Mylmj1Bsel2zKKrNIqlv2o/QbwGnT0FFN7vP5RSDBQOteFco/M4";
  b += "g/eEps13dIxxtOTA7oIQAyu5/5OjpvbDeGMcKVRfhGifkXS50qRzkHUYfN2ItG3ehOSBIsDCzsD";
  b += "BXK1kAgVgTWaLSqX0sMenUOJaYdGoZS0Q6NYslIp3axBKPjgaxhKOjNSyx6G73UHS0gwUOHXz07";
  b += "sLPAiDn5CgKsLlbhTe+GT/zgJi7VTawt+JnBsByt8oG9jfw0wWc3K3CbxPYZLfimgQKaxL3b1fc";
  b += "HMCIXGwSUQSAOzCjlwWVOpQRwPUACEjiuj7uEuNWWrLwfNxlxh2RuIk6QskFKfocVukuuIS/Ccg";
  b += "P3wYMiJuBBrEbuBBvBULELcCK+BtAjXgb8CNuBZLE7cCU2JPf9vWAh7jpWi5Zosolyw1jXbJElU";
  b += "uWnWNdskSVS5ZvGeuSJapcsrxprEuWqHLJ8uaxLlmiyiXLwliXLFHlkuXGsS5Zosoly7eOdckSV";
  b += "S5Z3jLWJUtUuWTZNdYlS1S5ZLlp2KOjlawXVKvQO2J1EERQcGP/XgoHlMVjGVIXniHcY6svExw8";
  b += "jWbBim2pUMXK8k9F6qLlKN2ySEgBTwjfyWtY9f5CiJOGXsUidzyw2BKRUAz+goJYCBQCSxST9to";
  b += "6otpIxsvVJlZ8Q2+V1fMHLqynK8gUCW2w17IKnDnjy0SDjC2z40tD/WNbWtuXg9ricljpUVsdsJ";
  b += "ZnYk+MHostPiXI0WlsFI4gHYktEiVI0jOxJ0mHY4uACaJ0Kq7BZK7EFgMTlOnp2JOmK5HFugR1O";
  b += "hFbIEsAZV6OLEoloDKfij065muRdZ4JdMxjsfWaCXzMS5F1lwnJzZOxx8d8JbIuM4GP+URsfWUC";
  b += "IfNiZJ1kvo0sBNExH9cXbwN+WGT9ZZK4XYiEuoWO/MA2zBO5udyRttncEbSNuSNjzbwiXn0QrJ2";
  b += "gVW8CmVoAhfpWEKddoEvj4OtAq4Rq3fqNJ1gXIrCVVyFYsHi7Gr2CNd3VyBVs8a5GrYJ861WJVZ";
  b += "BvuSqtAkDZ1UgVAMiuRqkgP7kaoYK87Gp0CnK2MWQKTIcyD+3qajB0oElydpxR6iFUY4pKJ3plO";
  b += "F1zBrXBkTS6L/9yasyh7vINPJsIMYApjgp85EzfyxMcPSgvn8bRu5tP78+7i32coRpgx/JGvCzH";
  b += "6R16chC2EoxcAwzZZN4TvliPpIn6kOgKV9gWdrHJ5oMNtp4TmEKwDE3DY9E8jpMV+K+ECoJy0pm";
  b += "U84hQpYxsGNJTnqh4dMvAilGNMLFF5m3lwhpg0Tv51Ml+S/jatIz28mgCyU2btjdg2iddDKrNKv";
  b += "Oiv3Uob9YqXFjjUURX1UUl10vprpOCRxwZwdMn0rA2PUooT99hg9pkd9evi7xmC4F4pOioDOs4b";
  b += "EbkfDy1tHib+uSAWjWHLtSho+SngfPuhI5hGfj82h0hTHowpMiIsieV3840WQYXMocsn5AqRF/X";
  b += "AQ7XDDCrmSmbTZjrq43t5PixjfzYTvw3GNtozdhO/MXG1g6X9Es1vhtgKadLN8Tpe5kjK21N9Ww";
  b += "UurMR2i9FSF+5+c3zc5Off2S4Gzr2bBTeahvzyHDD7GDZoYtkSUHbxY5Z2k9wNuoh9kAR6TF7Qs";
  b += "/YPNjZsxFOxFKjBukF5Qbycy/rzpHraTdwukUcvIBTrUNpS4Gjonxi+0HexnYc3jiS8GFpuE8ar";
  b += "mwblW1X4oC2nVsoC0hfg1op+1hTkL/+NEzOpiWXLKVofx7p6tKrFBfmupK2p1w87HBp032OIhpp";
  b += "gR1yfWtksbiDb3SNtWKGO9xRQT2RpjxCq2EZKqbrJP1UajrL4SE577PREWBvaDYH9IzgjmBCfj5";
  b += "i3h46Y948uJtcBu5uVZAMkA3aH06mZdjvqZwH4xX2aaQRyhRTaVern6p0GVqGwtzdTxFFc3BTEA";
  b += "gzHAl9xlNT7Stb9/YgMcN0CQeUYzbkBN+BkQgExpjYwn4u9nvWEpsy51M//1yQHaFut8598Ki9e";
  b += "4vmHIXA0mdzEIO0UEaL52eYWbkqqjUqh6Je1bYcIEer2tWqPlCvajJc1fZwVduLFJSwqt31qppc";
  b += "q6p5p99IzbKrGf6H/LhIeTsifSDPLYiX5CXKnfLGg6x6JIXkafZvVRAa5+li0bxfpj/FVC2K5kg";
  b += "jhW43uo1UBVag4o3orrvDvPHWIPh4PnkYj1JZhPTZ1J4jfZYd3l4uJBD4Q54ES6CQM7/Bzg76PX";
  b += "gqyJtFJ29o9zpjVFRZZfp2hjTkMYdkDHe98YO90M+UxA+JnTMJrMU6GISm/VRbOqwnX8+7JRXbe";
  b += "4taC4wNJsyqGwXqEZ8bHRMeZuyYJDomHSkclkxCKcJ0tFVJvVUT67SqW29VUmuVTqpu1SqdXt2x";
  b += "rUrQqgltVVJrVffarYJZX9e2qjuuVVJbO3t6PM/19s4tUnrZruR/LRp0UciJyDJ2k4fRMnmaX+P";
  b += "kaWLy6M0UNo6hkpgr1ClWiSwxbzGVj6HB36UoA3F51IeggM3QJxHCHF+p0gCmMPYLLUqt+QX0Z2";
  b += "dOF/myjILQo3I5habLMOGE6fWCWlLuVLoJnZngNkIjtW4jflLnNoIspbcRiWlyD0irXh+CtObxE";
  b += "GlNH+uGWwEMecw4W5JLocq9w1G/gdDzNuWpTz6LLW6Me80mPbyucRTGM4F0+gVJ4KMcFh6TPGu0";
  b += "tkeiVHW+Xa7gg83RtMfoFSRS0Iaff/I8DT/hGLVoOWvNw9Cypzk45CKwjEFA9hu4R6V8vMAmdFk";
  b += "CkwgAceM1CUzx8IGziwTgca6Q/oSb1AJO54pNwIaADQwC0uFwlVpsQWAr9sCHirkhb3NzqsFgyh";
  b += "d+68w/fTTXMKbXn/2Ln/psaMMgI7/0R7/w6diGe7IAf+BTf/gfjQ3jGPITf/Tqd7v0KTkB/fBXf";
  b += "ui3XXhDPlP+5z/7ic9FNrwx31Re+eSXP/F/2vDmfLb88mu/96Pue1vyreWxH/3Rr7ZsGNgql3/y";
  b += "V5//Rww/JKPWFjZlZIyJobvGfXCzPPddawdITScMR3vNQFsv16NJTc6LUcdy7gW6L8albTI6xcx";
  b += "oFDa85pqo7EjYj8alCU0qL3xydEaCsnbWRoWjE1FW6CL80yyYo2FBQ/qAN8XarRL9uI2OhWfThF";
  b += "gTnrAJiU9INOFJm9D1CV1NOGYTMp+QacJTNmHGJ8xowgmbMOsTZjXhaZsw7xPmNeGUTch9Qq4Jz";
  b += "9iEnT5hpyactgkLPmFBE87YhF0+YVduD4iM3+3jLaKaQSKBU+i8MHLOCy2cWgxMgDGJ77CJ3XGJ";
  b += "dy1qYjYu8fnAvjozLvWsS50dl/qCS50fl3rOpebjUl90qTvHpZ53qQvjUl8K9I5P0nfJxDM64aL";
  b += "9SmdaeZj9XZnsfxfAOtkSHWe31y6PZHS5HjOQzbzeMXNj7o3oDdNkf8tKbN2NUCxUDb8NpNBYSF";
  b += "0YDcukVbQd2r8r0cCLt4dl0vRxZCXSvJ9SAGPnTNzLpFUMTm3TmhjcKMJkXQxuba7UZ3hNFO6k6";
  b += "nVReEuvwvCGjYWAOVHZO97gp6GkEElj1Tt5XRSeesE0ROHdIVF4z4vJIQqf8IJxiMInrWVSZ0gI";
  b += "7n2sazuGROFNXxrqbXxpwwJxMywQ31EXiG+3AvHEeW+CQDxzovJnKhE6BOJTTmoOgfi0k5pDIL7";
  b += "Byc2tQPxNViA+46TmJ5wIfcEKxDc5ubkViH+rFYhvdlLzY06EvssKxLc4ubkViH+bFYhvdVLzJ5";
  b += "wIfbcViM+r3Dx0EnMrEP8bViC+zXqUokD81rpAfK4SiM/qjZ8XhfOuz4am9ZbPhhK93/MC8u3wO";
  b += "dCHz4EbICof5+nlJmDD3wxnBG+FHwJKyW/Nb3nUWsasbxNzPSLzEcB3b5xSbKeAfFuF+F7ZnVBN";
  b += "GBkg4PaI7/1x6VsrxPdiXPqWCvH9hnHpNQ8cO8elb6oQ379lXPpMhfj+pnHpGyrE9zePS5+qAN8";
  b += "XxqVnFd77jePSWxXc+7faBBWQt63kW2hQWhOOd60QHPSmR/KowvEJS7pAWybJ3Tjh+OWO2aQEGF";
  b += "7oDPQ53ZWevZpvZ8v22j6xZLhjrSkbSLHWmbG94k8lLuCm8EHloCIlfLwRpGU2IVcISS//lD9X7";
  b += "HicFr1vhAiHWm+7GlsTc3utCKpj3wYNi+3biQ03PcB9RKLtgO2VaLs7x3UKMTaMDjO8hjDWqZ56";
  b += "ydN4Na3rb5FHHgwQANz26dA6wdsqAR4OEAC4t5rY9YHQjXMCaeE29E2oFnNQBOShoaf001hTuz4";
  b += "QvnF+mFCCaWBtV0wqyTQ8TGRKMo01uesDIZznCiWYBlZ3SkrfhH4MLCl9swTU9K4PhHGcN2aUYB";
  b += "pY3ykp/VYJ4PBhPfI1lFgaa4knpNLwOGId8JlbzUNCJmUjVL8oIGbGeVmBB4zKy8okIM59CBDkd";
  b += "S8rpuZlxQh93PKo0Mutj0J5/NF8R779WkSPV4M3C+X7JtjOb76GceCmaxgHzlzDOHDDNYwDp65h";
  b += "HJhdwzhw4hrGgb1rGAcm1zAObF3DODBaxzhQnXtDUFFjuxoVmzdm8TZri1d5skg5LFn0bc+Rxcp";
  b += "fkZpYVnBMWY0hanLBlqVsaOo5tkB5QBIV5dnqdM3RudiGlXioj4xzqbC+BBW9FDjKK+Q8sOd/HD";
  b += "2y8szvCdPczu6pgdwJ/70bIm7jbZZM+bcgZQNeIBYjIjvI9lAfXOadTOtCs7kXSQkQuUaQ50m9O";
  b += "ipS7dzbC7vdlKLVXUFQ/sryu3upBgvIUyHCC1eLdhl8B7EHIbqxcRPlXd8BdKpyx5KiHkEJG2nx";
  b += "ahFqWlxOLvWJMBiW375EPW3JULaWyuaBfap91yhfD5d6DSA5TiBPiKS0L0yvD/V9Nmw5KyvPA1D";
  b += "LLJfLCIWEQT2Ex4yPj5aPMFe8d07aMehHZdhvdINU7zo+UGxU1wgU1gz60LUlAUS4udjfxN4DLs";
  b += "lif7McuJPF/gbJQv+xe+eKWYop1UWDKn4bZx8Wq3MGNy52NCbVgcOC7hg3Rrf35/WSREEC7p/Lt";
  b += "wBfcGpOukbGbAPdt0zNQf1V0wf9CXkhKnpSI5mGkw9iJAHXn09D2Agrmfeoeu9mCvr6oZsuMAqT";
  b += "spm2aSBVnYDGaD/Nu7xqagCfNb2nB61UKbXJy1AI/fEDU4fpgWxlHRkvldti6w9RzFaJuhdi/J7";
  b += "iuE71ZL+WwWxDsth6oMeTywBlQn+oMWBhGwe0geiHKC+tSkgApYdyUU5TIjYMXAQkoVCJffpLz1";
  b += "pBMPogBx9TnvFxs5LjBR+SppQv+dAU5cBNqRuHPyrbspfCboF4sAu00ikPf1my/4TR5bVLgbkWM";
  b += "Et3L2LOlZ29uIQ0Za7ZH9fspawr5MyheAobmRiSZYUJblG2mRAbDJdabV4nMdwuE8hk2gDKxBVm";
  b += "Cfn9pfPPqgC3/FWs+YTAqPjTzU5HuABrKR5P+54eeK1EViY1QE05izo1yqfqTZjXJsyuaUIjlwU";
  b += "CXiaj3ZCU9Aze+73QHmhhpyl/ZrKfl5ibgt09tuxt/VQ1eLE3N8rnR15J8Kc7+grE/9n9PdxaU5";
  b += "dUQkpuMpCbBujLDMnNXe/qxalKngnQp+JqHS6dbl1cULwiQ1ruLp+U7sleVNSjLv6kKWmhg8uzW";
  b += "JpAMIx2U0IsbOfnKbeIsVQVd3OmjLOPxEXMu4Eu5FoxJNhd2JBhcGK9EowJt6dcEwZ0Mi3jcib7";
  b += "VzGF8B0I48qnUaH/GgXplzqmoUBJMFJXim5541ExnlHWOFR+dA2aCtRdh6KwiYRuc1kjrwSWvVE";
  b += "4EQPke6NoIgY4+UbBRAxQ9Y1iiRhA8BtCiRjA9RsiiRhA+xsCiRi4ATDEETHwGGAII2LgXMAQRc";
  b += "TAD4EhiAh8w5DvexROYD5B5y+foO+XT9D1yyfo+eUTdPzyCfh9wd9J/s34d4p/p/l3g2W1EscQb";
  b += "HgkTxzzMO2Zh8TxG1O1KMuiZLUoy9VM1qIsIzRRi7K8U68WZdmtbi3KcmhpLcoydZ2hKPKB7VqU";
  b += "ZRpbnmmkkxz1mKOectRRjvrJUTc56iUHnXWEnXWEnXWEnVU5DIV566O+D2gG+6hvPy1mH/Vtpyn";
  b += "/o77ddBb0qG8zvQU96ttLd0GP+rbSYdCjvp10GfSobyNhCx717aMF8qPe8w6x5r++U2NNh7aAeW";
  b += "/G9b52sqS/zaaPDJhPv53pa8bYp7+D6WumhU+/i+lrZpJPfyfT10w+n/4upq+Zrz793UxfM8V9+";
  b += "nuYvmZV+PT3Mn3NQvLp72N6tehayoUPccbZu0n+41GXOoBr/mD1a0/LKhZQ1KTmWoA30OUo+59V";
  b += "RoAr48ABQK0FXoLM0Vgo/p/rhPnw9SElEZbOF4kFskoIAXfUXhImay8JmwpWR9F2Y/SjMbWQP6h";
  b += "XUG1KQner48V4wbxfNjb5eV+/h5/39ifw8x7h8eTn3f0MP+/qT+Hnnf1p/NwlzKP8vKM/g5/b+x";
  b += "vx8zZhMuVnd38z5er9WYrfhT2EjF5YLgjy+3OU9vfneSXQ38Z7g/52Xi7A3Srsd3NeUvT7vMjoF";
  b += "7zs6N8gvY3bT4+iwva8HxwHD1NoBdvAFrD+rD3rzpqz3qw168was76sLevKmrKerCXryBqyfqwd";
  b += "68aasV77xv9HbRLY88QqEVcFEhnw488GgzyZs3t6q4zVOaYpHx9NSVzKE6MpXVfak8MpYIAKbM9";
  b += "UMYp1LljEsKbO+L9cndQa7SRt8CU2q+WaRdMfXO+b8rXRlMSlXB5N6brSrgynrNdJ77ed9MG/bJ";
  b += "0UjXYS9QHKcyfQrMg1q1nNpBdHU/xMOj+a0nWlvTScMtxJAUmYfJ1IerzkIqiK/Fnev0QVDPmDR";
  b += "+h7yB88dnH/jjt33LPjbh336bhDx705HaJtg6Qflo15kd+wTusLIFoIQZUSJVTuOJj+XMMkywYM";
  b += "6W4Ynu/GqbUFi+V+RPO5huozCL99YJ+324usdqDU7wBMJQ/uc/Z7gMTGTwRTwoO0DIQ0pATMOxj";
  b += "xRA6Wqo+Be+9+zG/Q+ozYY82TjzxadO5034mtCmZkfzse7YF5OhbygTZ99W/H+ImlCkAq02/DDE";
  b += "62A2l5vwHLRPl4hLqwAhFRnZfI+OeNJd9QKF1Z1d3YAjrYVPsh+9kmPtT0jWywB9v0G6EtZONSN";
  b += "hTeDu+sd6TClumv9YPIDHi2Z6o1LYM2kYyJ+yBM/eq9qt4thnq28Rfr2cb479cbnKfHAYAADAZ+";
  b += "Wbs2qHdtaLs2rnVt4LsWZo211PW7Nv0viYkP9WRvh84ZNFYnyg3Q0oeO/gTwMaGHT81tsJTU1VJ";
  b += "1Wq+yDX38jgxLSh1aYtMlldIxFWhT2yXJOG1mq0eb4ieV5dhF9bpOj7aH8IGiAx3tzmCkcC3Bqv";
  b += "x2rI66b3Cm9Zth9WX/p8b5FKI25VOImlCrQGmTOSSVJy5eAn2Qh08WLaL2SPV6ZrmkrhklXCFVb";
  b += "819VGHr5hnVntHylI3kDQHavOh1r21VJ9lAhe7r1DW7x3bGplovUPUQx+1GPnEPXA1ZDegUmKXx";
  b += "opYW5elg9JO2yIZq7lZ5m3l7KAu18QFdMCimIbJqQNbBPjMQ48Dk/G74arHa/dD5xuAbeUUKRg+";
  b += "2rB54N5/CkNWmAz+Yjtasw67K2Vlubly1P+zkmKlPjnyjqoN3XWfox8J1e8LPkw3sgnoPQNJRGS";
  b += "BMQCM8j+SDvX4X0CJsStc3ZRILv5rdXUdp7G/TL3z/BS78yZHWEAIDcF0TaNQEx3ryJKyMDXWpJ";
  b += "7xxQk/LpXAP9G5Nyanqh3Odto/nk4tFRtohQzal6pYTfr0atlBmrdd7h8Jcni2pqYUlGR3VG08t";
  b += "QcmWVIXcptoW2PaYWgtS1RafqNkv91wJNZKUpucS06SzapIdaxo0tVhM51MwA1Jrg0kQ6x3/QOa";
  b += "K2W+pEPbAnrMfmbmnRogm8mnusl1SScIzTO4/mfecKrxxg+VSmu4cFvDkBV34niOSdnAmRuxGeq";
  b += "BJ02o3YmhoPah/B2VZ25EuRmHjSVLMGapGO6N3mo5soNH7tCXpxhK2dq2qxUQ+sZZoEp9lnZTuO";
  b += "ik6x8kyScs2DJn5d9ke2sdfpS7YNbSQLrq9a/FeODKxHZnYjczMeKOeKWx5b3Rw/LY9bnDCcYMz";
  b += "tcaox30n5eC07l6R/5KP0gTEjdPEyX7Hj9PdCntSjVXsYtCGqo86h/JWfbwiZQs6a8drnZTuOin";
  b += "s6pYbr3jNeE2tHa+RurjxatXHC6MEzXk7RI6ON7wlDzgMaWJXpmWow2TJTs2Sx9QpXlijeCOEe2";
  b += "Sk8AN5Qw8D1tPN/RDgPvxYTXkaNz2ofQ/FCZ8pDFH7eImL7eQ9c8LL43lCJoaOpUQNBumfJmabC";
  b += "oIhpoAgOAQuL/khYPHqw+Pu4ah7eMw9HHEPh93Dinu4EtqHy+7hNfdwyT284h4uuoeX3cMF9/CS";
  b += "ezjvHl50D+fcwwvu4ax7eN4+LADQ2ViscWqDZP8xtEoa2/T0Lk/bVe+WXlaNhyOmdFp1JVz4cOg";
  b += "1JB5VKbVqRrjwI14dgsEPqxaECx7wqg8Mfkg1HlzwYa/mwOAHVLvBBb/T6zIw+BD+AFR4x9ekFq";
  b += "WWxCqwzJ3A0l++FzuIh2143U6JZXWvTqhEZHjeZaDIslib4axmsDLLG9ZmeEEzWKHlzrUZzmkGK";
  b += "7X8lrUZXtQMVmz5prUZzmsGK7d889oML2kGK7hcWJvhgmawkssb12Z4WTNY0eW3rs1wUTNY2eVb";
  b += "bArxsO0tSyvfvvY2JeLc3KaqTaMizZBI7dAEbzlMfatQKvHrCR9wPoro0g/6BpRAROW5j0JYgA1";
  b += "ADjqIiiuxy/PM8SJyLFDEYFdXrCr7WHXAB6nSz9bTI1JtJ3cwVqH2lxITLSdr76AiIlaWSfbzkX";
  b += "YLVD9XL68G2R8bXEnvJgQM7qM0DzVD68lNJi/Uki/Uk1tMzmvJl+rJCZNna8krf1pLbjM5qyUfr";
  b += "Sd3mJzUko/Vk1NNdmmn6mnwmNW5+/aPy5+V/xp99O6Fjx/G48qV1kfvnmXsysrlyY/enXz8MBKS";
  b += "IzZCnmePaD7ELxzh6yjqyOHDhwkkavI2Cm5XBbergttDBbdrBbdrBbd9wW1XMEhfnqDgpCo4qQp";
  b += "OhgpOagUntYITX3DiCv4wZjPKbVXltqpyW0Pltmrltmrltny5LVfuh2AvgXKbVbnNqtzmULnNWr";
  b += "nNWrlNX27TlfsBCKhQbqMqt1GV2xgqt1Ert1Ert+HLbbhyHyIQyIX/IpPkSKQadGoISvU793jEP";
  b += "+IHbeyiLt2qLt2qLt2hunRrdenW6tL1denW25ii3LQqN63KTYfKTWvlprVyU19uWrWRa+iytpEr";
  b += "nhcBlS5SZGPcvcrhTtheLvN+UyjHSs/drXB/z47w0gfituzJWH3mqLpRDBOwC22VDMMM90JEH5I";
  b += "nQgiNWmVOt6NUAYKOuNAHoaf/HjBcrzQtlmK8YC42hSGT35ebMN9cMBeaQg9i4qAmLKq8+FPSkO";
  b += "+PvKAZ8udWeRmxJ+mkB1mzw7G6H/JS6Pdmvxiq9siJ8INSnRPhw0VjQNjExiLt8o6H0FTRt4By8";
  b += "4sWC+yuRffp0+7T0DBwoux3lrkm/GzkhdrvQPPKs7ZOimKphZ2tGnLkKf/Su1RODkyJJ57iS3Tc";
  b += "d0dwPrLdpd0PJVwHhd+mkUNog6fSAV0xnxLC+DMuknYQ8q34puB8V14+8ZSr//kuLKt59dTUqye";
  b += "IEZu04AzuCAIqZhEPLNSqo+6ScL6rt3IwxR2UO5AzRvGf78p62XeH/GI8uwNywCvhHmpNJLeZi1";
  b += "16hrjNvAylioZMjq4bn/JCd2DbI1nSQfa4cdpK2sFXooJTYiWGu96YWiC3SaxkXxi48cr+n8jar";
  b += "BCZb8G8FtmiG7xb4H5wU3ChS42xSGHXboR66Y3BF7sfk8VtGyn10M+dSLN/H+sDpdsXLBrZWd/l";
  b += "DWg4Pxlrg05A2NyiicaPYlKfp7ErJq9M6rb28oV2n4I8bb7W7zZzCgpJjTyBhlvM9dKG9+/m/T1";
  b += "jBx/aZnIO+JSM3u/WFkxjZMF0dMFIhhya4O3yCbzxg1He8fcpO8sTn3LzS5chTD24JPD34fLET4";
  b += "18JNSP6KDbDzSyH5beu8fVr2hkv2VsBpkwSIzVwxnKLE/ji38AzS93b9Mtz2otgL8rWdihYb8FJ";
  b += "4Yf/enVoHwL3H90B+UqAqeOS94rIYHxZrVhF5/ShsXQXGr6O6J5TZBvJRrL+6KZ8rKuKcjXaHou";
  b += "pEqmcpPgiNAtb2b/LNShz36TXhx731wq+MU3TgXPfHocFXzh09ekgr/0BqngL62hgo99eh0qyIQ";
  b += "1VPDJT1+VCr706XFU8JVPf+Oo4JVP/3cq+FeXCr70GRm9C2+ECr7ymbVU8MpnrkoFr5wa+ch4Kv";
  b += "gjV6OCPzJMBR/77Foq+ORn16OCn/9sjQo+/owEDv/iGip45jPrUEEmrKGCL3zmL0IF/3ViJtQm6";
  b += "ELkjDIVpFPPxZGF53R+2ayWI1OcndAqjfotgCfM6mm6BvFQSuujJw3va2Dd9oT1GdWfgvmcxm8A";
  b += "+2qsMcwMjAk1HrZxcDxFY5hNMBnU+M30Z2/tYmBOd8UZ6ER0KpWpTU4EYZla5ERwwtafx+/FsL8";
  b += "Nvy+HMFWE1zXYL8LhGqwV4WwNhopwtAYrRThZg4EiHKzBNhHO1WCWCJdUsEmEUzWYI8LRWn8hz2";
  b += "Dm9wG1eImgRmqtWiZQMx/qof5hZQ0T4QBSx/B8aE90CWLL+XwaVjBTj+bb8w0whZl5NM/zjbCH2";
  b += "fRoXuSbYRQzC9C8LbCM2QrQvDk1j7HqdBv4d4Z/N/LvJv7dzL9qLrNlXaMZlWlNO5mWVzUrpijT";
  b += "iqhcRpnWBi+qmVLVRcq0NANlWjNrM5zVDFamtXFthhc0g5VpbVqb4ZxmsDKtzWszvKgZrExrdm2";
  b += "G85rByrS2rM3wkmawMq2tazNc0AxWpjW3NsPLmsHKtObXZrioGaxMa5tNoUwLltGNmkXzbmvWTO";
  b += "VgU5lEW/vkoxbJU5Xx2vRECJ26Zs22LraWvg2rgtdaYxus1nSh0FNj3285e8IitIbYAemJN0rUO";
  b += "sreIQTlYmJmDrWXqYfS3+SdiFQORjre+UjqHZJ0vZOSnveRM+F95Ex63zeZ95Yz5b3lTHtvORvU";
  b += "lcVmdWwxq24utqjTi63qAmPOO9SZKbu0zNiEi4Y457tBsc260TGH8m0AM59xbnQite4K4bbL5NO";
  b += "H8sjHxxI/h8xT9dhEYrciNqtijxdzUDvflG9BwqRPiI8XW6GWvimfRcLEoTzWhMbxYgvgFjblm5";
  b += "HQO5Q37KXH8WIWcAusUQ6Jhb/Ibh0vNgNwgUk7IXQ4pCqejxTJnZKX8QsQlR3KE43feKdkZPwuS";
  b += "LoOyWpUFzoL+SbZG+dxmzOvGk+wDawc5Ri1UJXI2HvTMf4i2txJNApJTbzPnKFUQFJEo+5yhnIQ";
  b += "m2LUbddQDoBUNEY95QzlAFpFc9RHzlAOwFa0Rt1s1XKwswFhkYw65xrKtEXhLDYBeWFr5dFrKM+";
  b += "cIltsAhc3X7kBG8qzjSAXJXPtKrZX3sNquZyTnM3gojYBQj7fjGHazPtuvS+HbFuSYt6Bx/lmde";
  b += "plYxPGJhqbuNguY7sa23WxeoueaWzmYmcYO6OxMy52lrGzGjvrYueXoOKmPr02Qd11E1O2I9pYl";
  b += "16IYL5t6tEL4a0Iz6lDLxaF8Bb680o/n5hkeYasSzDsJzD1xGbKE5tpT2w2eGIz44nNRk9sNnli";
  b += "s9kTm1lPbLZ4YrNV/QQqAIq6C5xRd4GZugvs9pue2MwJsWnRZ1cAYrNVLf8SS2ywEE8KvZ1zxKY";
  b += "NJXfmTSR6y6G87ePfpq62OvlsPfZ29bPVyTdXsfSz9Q71s9XJN/mELv1s3aU+wTr5xkN5VxN69L";
  b += "L1TjB+SJg5lPc0YYJuwd6lNcolacOhfEKTJo8X5jY51DFppyQJZZzUpAya6oxfkHihjZl3afhej";
  b += "d8FLRDnu3BP9D7ucP2gwq5Sn39vq/sH3F0Rn0rVLfX+AW/3hCatp8K0rj1KaKocbfUP2B0lNO16";
  b += "Djiz640SmqEccGw3MUpohnLAyV3nuDqwsv4B31/EQ+4B3wd3gTXvgO+Ft0BHSrJR+jM5SrWqz1X";
  b += "dU8V1/VPPP02M+tvavUQpMq6UnHNAxr/NOgc0zjkgY2+3zgGNcw7I2HdY54DGOQdk7F3WOaBxzg";
  b += "EZ+07rHNA454CMfZd1Dmicc0DGvhvepDqVc8D3QDczV53PfML7BoR6J/ZL7xswgLNA2SW9b8CA6";
  b += "EB52/oGhBctPeMIC/MLrbCxnAfZpRjIk9mvx0WY/VHctyd2ifmNuKeQlP2I4Z8hDiUu/vosOXtV";
  b += "3ixXfv055LmvR0M0QBaW0X09U17+tecC9f2il4+nosmUL0PzIoDtLM43MJ8Lsk9RPBOo44widnZ";
  b += "vRYMwnMBbs6IGglZekpL5R7KUwl2U0cF/CIcZUKIz2Q/GVPDST0p2bU55WKuZQ70Q9yK+1nyEhV";
  b += "zAKvMPFQIGWPP0F5F9QerOEjTfFeS7sjZfGerW40qHUaC006BvZQAHsGH1rTa21ca32thWaxVdq";
  b += "821Wo3GSg3z2lDUer8bpdou1hw5+ITvHtXsD0gfJGWSfTmiESEfTJnpQ1QG9rE0B6A1u7LyCExb";
  b += "cjMYLJb/cAlOoTjC98/dI+XYXr7nakVCY0kmlOvAQt1eypAvDgaF1IZO7xbhyGmAry0VMayeF6U";
  b += "AW7qUcP5zzwX9QG2BOUV1Hv2clHV/T7qctuaBahujh7IX7Fzubu0GaXYqJOYYRt/Wot4ZeCyXCZ";
  b += "pKNZW9PS7L7KfD8gkkPaFZ6WyRI98LpMStkynzf3ipvCi1G8hCWnbjVUQl1l108EBB4GsYmLoxx";
  b += "ZpQNeMUasSYYbhaDpQxMfoDO9L0WBK2YOoelq+3H6CFeuNgv+GWK6HNaPwJcR9t2g/kwQBetaDn";
  b += "1BhUYUiAFu6nrnfcA+pfY1C0ygUYNtPQ1ZkULKr3mUXqU8OLarmsilJhme/txQqbCBK/GjwoUz2";
  b += "GRe9CefaXHcAl0+NS5VLhA3OFKc29PaPxMEGNfAhoGbEPCe0sGz4kNLNs+hAwSVo+BPCRxIcALN";
  b += "L2IYCGdHwIgCCpDwHwo+tDuyXU86G3SWjCh26X0KQPvQOaYz4ESjLlQ++U0LQPvUtCG3zo3RKa8";
  b += "aH3SGijD71XQpt86H0S2uxDAFeY9aGHJLTFh6Dos9WHoAU050NQEZr3IegPbfMhKBdt9yFoHu3w";
  b += "Iagl5T5EpaW+D1KnqfBBqjzd4IPUiNrpg0cR/BYffBzBN/ngEwi+2QefRHABUL0LQzMoqofKP5G";
  b += "ncptGvMgJhkkPU3xDuAb6r9JFI9GyfDlAnLhvxoIx4FzzyHqPKuDbC663DxbRPT3W5wF9nYDdka";
  b += "r+C9WOScTXrxdNJRWS9n4LHEEABV1vyaKappRmUZcY7AiAKHBATVWaeXjQGhIQdiCxTMlerjTV4";
  b += "PUo060DFhPRtbBcrtfkEy3Tpc9Irn7V+10ccvW1WHSgktgF9sFSHwiyHao7TqgJwoY89O78ikYe";
  b += "Cds+DT64cZIa+1PAnLAEpzNhTKj2I9Z1ViNPoHlOUObMai8apS0aEK556hFKg+DoUnpBdgTVJ7e";
  b += "/yKDsM/NM8ZvOnVPXGleoRiovM9K8p6rZ5kCBr0MNH593Xx79qBYIUHYGE8DEYtzSPFZ7sJpDtI";
  b += "6qcU5ht/IOq1JemaDDmi5NSrHOtW4lck1TFSynvNuqVt661Zpo3WrrML6B1nsVZhdgYpyVRqIzt";
  b += "vBfgCRNvaHVPuWaVjXhEJsA1dq7K49b9AeXE1gFYPc0L2ux+mrQxNGACv60q7+3uXENmPY8NfNM";
  b += "O0X51kg7rGFMWvca1jqZ9qeVP/PKqXboqe+tCvgj5dYalU8dz1uyOKCAH9lBGvJ3FqvHt7o3MfV";
  b += "rq77PrB9wOy7WLR1SW7XUYS9ica3+VgE/rCngJ66EoCohTU8mJlbnrdV9Qz7Izjrm2pTPkmWhUL";
  b += "xoZD8Sq+y8PPI7q0HlEEsiVuoRFyXi8m9XEVDkERotOV3kQ0RTEAZfCIQiKxyL5BkyZOjaEcaG3";
  b += "53lbVr55PnVIPsBogDP4s88d/M8hu3Z0+f1qiWC+ixvg56hPHaRHkLjQZ/c67cvqePy8q4l9Vb3";
  b += "7fcr24sWA0wNlodfYEkae46jLlv6QSmPMNBEwj7jvpbHdwSQmiNjYbQ10hWq7VOumkH256F6FeP";
  b += "DjdGlELp65WnDWzo6CJS9ivgSJ4vk7rdDE6z9cdzX3B19/HBxPUporbvDj1fKYpM1ZbEdo9ptR3";
  b += "A00ysZ4bFWQtyjos8Oo9+fxFM2IMZTOChfcL2NK7WIDuQBTPIq+78r/RjB8llVz+N7iWgUlrcvl";
  b += "bffxzE7ZWQ7wZwRzjgpX/HD82QEB1Qfi7EKGCpChnX0C5PBfxZu92tvv2TfxjnpYzHeC+4I4Our";
  b += "fDwa3H1M2r4a7OGuhK1dp9IKmnSElT0csaM5DLLX24mmpRMbRGb7ZUWkkdxncO0rv6vRg0RN0Wv";
  b += "fM36CCnP9qxaJ2hBXBZbf0N6Uh2fUUeJA/UfMwkmEDMBSmRzYRxeuDEET8+C+fawdjUDZyrh86b";
  b += "d14uE+mHOnzLXOZV6e+LzrvxOs+Vnjr6dwd6B3BT7mNGPOm6ErrFWzJ8Iyg5Zork2Rgi/qbMctI";
  b += "u/fyUTAnyb3c2ZeddNZbxNeTsJQ7xKg3wo8q2v/ywMg4YSLE1OhieJGs5W0O2m3NzGZTeF0h2SZ";
  b += "i+Amdg7u5u29sCDKMB+7+KxlpH9f2WuaQ5B95iFUpRaA4cl+2HSnWNqNUbInGlvaYV/aH1xHadl";
  b += "1l3bxOkqbZGlviZK/Ob60i3/gSvv/rqO0CZYmc09PJ2tKO+tL+8PrKK2nLTXxaEtDLe0ZX9pXrq";
  b += "O0bqplBENlPOXLePHLz/IAVL2Rjn3j6FXe6Ix948rvr/9Ge+wbF6/yRjL2jXNXeaM19o3Vq7zRH";
  b += "PvGM1d5ozH2jRNXeSMe+8bjV3kjGt+7X17/DTP2jZev8gbVongNYkVo2e/ws7tBZf5jM0yWnbAA";
  b += "NsmUkkT7FDnvHvpJNlCjsoI4+lJQm3CcIGCrrU6CScNxzjbLebQrgLl98B3UN3qdNtiRvMm9SEg";
  b += "Q+ANYg+1Yoh34//RArB7M82QfcxqXE5xEnhAXD/k/tJesb1x2D2jGaKBM3vSBcmXlUrCEdyL/zj";
  b += "6pg0XQI8OawltsHi0qI4eU+8iVpFrzQOst3OJ3SJEP7d0nfz+0d989rBygxdZ8xdYQNbfNQs327";
  b += "bNfVTmjOnQ3OZyD8GwgjyoEZCjMmw4dDAPVj1JC70dzELCAi5gDS9WBMg7GkB59hSY8SKmryf5e";
  b += "nzu8UZ5Xn2Fl12C2WK0gY5SrSY8s0bIutuAIMdtc/sry3x7gKfRPxj9FfAIfAju3SJ3Cq3uNBt1";
  b += "81AthNiLc0Vy0oXaLeXOvbXuTXCQa4barHNuVCUKjIACxO1iFBymvAj7eQZgS22IDmdSKQBiUM1";
  b += "ZLihdPKvhTkRRO7g2FxJeNL7iHLoPo7YgSUQ6OoYtqxbefioKesWYtUsd7rSWsa8lwSYpz0dw7m";
  b += "XZVqDhjZZWsmJaGUYRoe3xq+nTLzB6Kl4lshSmAHx62FzAw+JkkrpW0DRfZ/YywVn0aBuZyNgSq";
  b += "FVYhfqYJagUHffjZQEwrWa4hfmYIaQXrcPxsJKIVjqv42URAK5gK4mcz8azk7A+NgD7vLnlextm";
  b += "rcMoh1f3TVr387gG6w96guTzuwmqrPxHO6l14N9/sbtX8bZO7sZr1mTfr1XgKi3wLJDF6ebXZZ9";
  b += "6kt+SdfKNDneiM3mNt8pk36oV5O58hNATuCUevtDb6zDN6d57kG9zdYTJ6uzXjM2+w1+hyXrVaB";
  b += "Wtu1DdU52NehONGvQm/61anYfRyqzpPTx0v5vVyvZFnTtHB3/q727Epnz/jJTpdSOSTTmfC6xGc";
  b += "97dpLv/k8WK7XjlH+YRTvvCaCS/5y7ahOzNqbxzHkWLLcfDZy/uti47q9r133N69m+ruvXvc3ry";
  b += "b6uY9PW7v3U117945bm/dTXXr3j5u79xNdeceSdzEcY3RS/T4OK62tle36A1GbKuu0ZuMmNe7L0";
  b += "S0GDGn92o8vR+39/h6/5b+cstsOWS4WoNCV+shVSSJDqmiif7m9nfe/s7a3xn7m9nfrv1N7G9sf";
  b += "2UEDhWxWiXXsPOSN4ag1294XYDsm6ELULvoj6lV1OAEyWQo7B2/tC6ighB1hyA5jHDDHuH+PcLt";
  b += "fIS7+wjX+hFu/KN8K/7MHfLqL9QN8Iosj2gn1ZDx2F1eQ8V2XIWPp11Y4eFpZ1b4d9qtFd6ddnC";
  b += "Fb6ddXeHZaadX+HXa/V4VB8sTq6O/LZ8vd+OUTn2q+cE3Yf5UXWY7qTnSSa2RTkpGOqk90kmdkU";
  b += "5KRzqpO9JJvZFOmli3k1RXQra4efAV8zyOB/k2XcmNO7l+J+7kqu3dybXavZMrNFVy21ES3Vayn";
  b += "uhW0NLto6lbTgwAgn9dcbjCLwoDBFK1WPBWkCRjsWiW8NWXN+laD8JCQ5H/vRQwSlxEaT4gpwbq";
  b += "cy/g0d353FOcINnmPStlPCtlPCtlPCsVOsgA724vJas9XAizhQN/z2ZF//JiQKdulDo2pQaDwr2";
  b += "jzs9Q7UZVBUYaH2lsJMTl5iDFdI2BGvRCF1z4zHI1pPL6avjgXEHIhial6RaL6Eqodyql7YQQxR";
  b += "8Y0KEd+iHgvYkeJyCTLVsHKdjbV37kHx9OlgBgq8hb6yQmV0vsrpsIdSRAlAW59c8KB35sXgLFG";
  b += "gOp0OsfudICogl/B+VHVuKHy+wggbPJpadmGdc/BP2xzSqoGxnYDwbVBwvaUNyLrFTPiMdlGjCX";
  b += "qXIlY3OlEsvqzcvOs7Z2uEJ26CwhxsNQBgjmXj3DyiwMyboGfgYGfgYGfgYGfgZGHIQ+ASUWi5D";
  b += "9ZXQG1gphtlB7D7dPOlHTV5pmUhHdc4qx1YmoA22fKdKy4NkTHTcJB1Fd4Zx7mLShnTZOOg9FCa";
  b += "rDZ8Ll75P9KqBr1biyDikSHMmaepRMePEmHYoTJV3LJvYwicgdcB/c1MNkB0eyeB89rZqBHosSe";
  b += "5yMeZyEq6ZIS+OpEijHOFWy2E511AMAPN5q6YGy7Q+UdO4b8+iIocr+V3aAHAMDHCRvCrr4kyom";
  b += "NZekHDju72EJGXuqfkCPcDgLdlJqT9hzYDt1/mdlbWquxn29jvZYw0PXtwFziNewsBfzSXuQiVS";
  b += "QD3FyXSwZFNN7okwKnj6OOmEkOqjiXAHJUueBOaBz3RTMw2UTTKj3zvH+jodVo1pRg6J1RzAHba";
  b += "N7e8DazIBFBJi4VKHTu/aERNBr6AQa3kYEG/VSIgMqIzNBv0C+jHT5IkGRDCpVNPOOetasvtYsi";
  b += "d7P9P4E9Qn4xaZ8fuijcUrgsLaDyTfy+PrkA3iUkyviFSYfN8O4YUgW81jvcqYgBojgl7nslE+4";
  b += "e1NKWio6R7XB+pjF1ZhhNCJQQrOIw7odldAPCfCbCta039M7kJ2yqU0qjCKuqZ/8uecUW9vGNMr";
  b += "HXMwXWmG87Nca10o/Vuz1xs5A5TaJdBx47Qcpb4kV0RtuGP6D3aYocibBGoDvjvViihZMdwSEpA";
  b += "HouvpMuCnIsFjHipclcaqIy1eDxYmkFYZhErY7vOuOyy9JXKMhcU0a8hT30tbu5nvpSeElHLjRc";
  b += "us9E63IvjtS4WKR/SehCCo2fCnQACWCN+szZX2JPlOK19Vnyuc6+kzJW0+fKdxq6zM/CkD37Fnq";
  b += "Wd0cJnQqwRpoe28OO9AmuhwtQVx0KlIvzyunI0CzhfAZEJVTw9Vu0RXpqV8RSv7695xZvr8Xlk9";
  b += "84dmgfEt55Hctarte8QTZrxvt0bjWg+gO3ndy6Bp2UEZeSDTrf6ISHa+z67meDVFx5ro5nJYNce";
  b += "UuakctoSF7e1jSK2eDAaNQ13P2uewc2Ke6UzQ2PBXtJ0FbLFeOnlne6zxO7OupNf23L6nV3wZez";
  b += "0wfLC8hlOE6TnYvnzzN5G4VMVXStat0XtO20rdxZrgnE93aaNHxWep95CZ7CNH1Js+s6f41Q0IJ";
  b += "0cRwXCPVm6oMPRDSP265YsH546Hax6j9hbGNmyr1irL2xpTLs8o3Si4yXlFmZZhm3xfrJMT1HYk";
  b += "I26Ze3EEWHQVIn2ma8NDsMtHnQqAjt/GzAKkP0JGb+Mkh54G2daKmHbGadnTUtCNV044uWQtIby";
  b += "AhnKBaCEH0oFIRHiiyk5XoJlLRzQRgTycBe1pMnfRCm8gf8yPloHvINsFs0ye9uGYoG/jtLrL1m";
  b += "G3DSS+oGcrWpUtzydZltpmTXkQzlA3j10G2lNk2nvTCmaFsdMOJbB1m23TSi2WGsuGcQIDXmNk2";
  b += "n/QCmVo2b+LQQs6EOZOTXhQzlNPaOTSRs8WcrUpFeSjnVhU4AHQWzInkbFbKzUM551RWkckW5aB";
  b += "ooQj90tq8PFm3JYMsXit2ia3YpZh0gpcpK3eJJXLCSV6mreAFkT0netlgJS+I7DrZy4wVvSAydc";
  b += "KXjVb2gsiOk740lvLoOKPaTvzSFGIDUUrRcPKXFmK2SkzTCWASxGyRmJaTwGxGzKzEJE4Es8lKY";
  b += "FB4rPcajgFNfygxs1aNInCm67z7iO8OwWTQOjYkiQ+ze0rKbncXU4sAJL8xWijm1XZ5ZfX14KMK";
  b += "Nv7+gqjmtxebFvubrZ3a9zz00f526ucfV7Dz9ym8+XvVbP09ioduoc/fobbWO9UaOO/PRkrsZ0H";
  b += "att0d/J1eSBf1EQyAmdLKqa2p/rtBJNr5hGUl/jbuASaQJDPszFes042cDulpNo6s6OA8VzVNdC";
  b += "wxbeHwG7o7uiHng6KpGlvyEwsHSixVNfmmvgv0PqJVODsKGG1cNFlqGGfugDZYVP6/IeraA0/d3";
  b += "afy+SYdgNv8ZKu7ZKu7tH4FQ92VF8BQ++wxs/cq1rphb1H45j60rQMFuximEciaWT5VLYqxMdHA";
  b += "eK6IHBMuLcrI9EUV0xc530hg+iLH9LUHFnNUKPR+GdB20eiTrmcn7349/Ojd+cfz7Yf78/k0md4";
  b += "pqGxBPrt3Lp+Gy6LOXNHLJ3P5//65Pj2w5525/hZ6N5oEChYO6HkLmnzwVjQx5K0okTChTSO9os";
  b += "i72P2n+pF1XBTlW+g3XoqVQqehgJU3+kk3Te3JH+6FwBQT2ZwfifINZH5logycf6EEjo+SvCN77";
  b += "uZ+k5ukEPgnv+IcBEER92kfQmkoKySSLWyG4Y1IbzxQ8taq2I1QM4u0bMMZRyj7JvY4OI7uDajt";
  b += "LScG+cJj/gsNvqDYzurkhtbcQmEUxjP73oinfVp9W/1imOtHGVEF1CBhUt+iTfaMAozhvWZ55g+";
  b += "F38IfBBv9GX7hx7phY1l542jnWB42DycWwsT+Z+IkiZIx/7Xwp0m3POBcY3RmgJMMarz7jgCMys";
  b += "rp8O0h3Lelg3IlfnsQDGV6LVgvV7OW60/WzdWo5Xp13VxxLddL6+YiP7xiliCX8dnfvF5u3i/Lq";
  b += "lmigMllL9bL7mwpQKH5SlimB/rNst9vyP9Gz/HmrpKY1gdzINJDC/XwrzxHtDfJDJ27+6D7ev9c";
  b += "0SLStYwnWaoWD8+vh+CACVQRp6pqBj8Y8f327tamUEFmWSmf3idD/7P60MaDUHkvc+j3f74htdu";
  b += "BpsZlv3z5XzoN3kZ5pJa9AWlYSAXZdKjOsj0ES1DVD1Ii/kKpZ3n/4B4rTuy35APU1/h8Q47Vzt";
  b += "kYbl3VG5e0l/6YTHlkVYqUlQbzZHgTw1g15bXytapOehY2CgDf5/BoT+Ngoyc7IfpvD6Fc+ecSn";
  b += "CQ3PrlUnj+jhd8RTDAqPjgc21M8uZHYrmPmh2IVey4biVXAupmR2DZUufb9b6U5WISsOnS1FosQ";
  b += "JhNRCUwKOBJ4XM7ZNwfB26kLZQblD0iYr9PDyo1hc08g07VsgyhNDG4OmTMoO6ih9PMdakpwB+e";
  b += "3UQuIfC8Prsu0q3g92EsxHneAXsgMKyt0TBaWpz7XXSzP/fO34MTzGz8tz429UBz7sdfSxfJLKW";
  b += "K/+Hl5/PHZvfsQf2ip/LFLnXvl6Sd/VKInJJbeyR5aKi/8Zuc+FQaE5W/90nNBuav82X8mP8+H5";
  b += "aun5fe5KHscyZArlv/81c5i2fT1wrnr0kcP7E3VaeAzn5b8C+Xhz8jPj5vyp56R318weJ1T7R6q";
  b += "+/1VG3LzDRrynJZM0AKAciU7EIpiEN58Up3j1UMR5Rvpv2iaxrI5NLwhlK2lwsR1g5movBEcTKT";
  b += "Cn0gJqBCAKz8h7SWAPTdm0AE5Uhdcn1ZObqr7AQiZyiuSpQX1l2AE7LllcbAJZByrk4PkUOWpyA";
  b += "IZr5PSXSelNQRk3IBwFyoYqgNqbQLgfA9IQOtWp29cOU26uaTYt3XcamGWbwZujbWYyI0aKYBrs";
  b += "K7tjlEinSwB0953J/kM151xeo3uA/ozuzCqd6GL9fW+e+W5z988tiddytjOHJfYXT9xvS41IwYf";
  b += "V+ngMRX9evRxBquxoHzhu4VOmOwDtMDSqBcRFWvUaqBxLyOupXErocat/FOJm7BxRuNOI25O4iZ";
  b += "HGvjnzbAJp9chXA7Sce3CgFCpPpwT9asKzw4IhurD4P7kjw8DQghSahfebYE+sMEVDVjeQxMe+H";
  b += "BhlWmFMSu1mMtErQXIjIu5xJhLtZiLjLlYxaAZD+0xD1kv4sQWyfWbFxm+WPvCBcZcqMWcZ8z5W";
  b += "gw12PHXx5xlzNlw6Jur4R4AyCimSKRo1va76kMxtmddCT4s/NCpX3w2ABbbnRacRDPsfrg898+Q";
  b += "EK9F/B11XAYdZtTDVDVbZcxqLeY0Y07XYk4x5lQt5gRjTpih9hwze+R/9VusPotta6A/HeKvf58";
  b += "63fjrY55gzBO1mKOMOVqLoe44/lYzININZqUWd4q5TkXu60divhXX3mLMSi3mMt+5XCvlEmMu1W";
  b += "IuMuZiLUY9JNMLfFVr62VZfvl9Q9dsd44bjibtGkZGCDhTPEKVRz+LUQ0sKnNgy5Df9HONcHJ5y";
  b += "HZkVT3Fq3fNtuLQEKgqzNvw+k5Ymw5Cw9/r4B+z47uTa53WaaEoK5MKODdyCmvVlYN9V0JQRlL4";
  b += "K0DlwJeUR+uhJzK6uifcTsobDrzbYxyGbwIW6qwjnNkhMFwD+AxOCPWDS5mR3tJlYPLMY/PI+x4";
  b += "dCAskVEB2+sKGxATO7if4+0GcHHKzxkkfs8Rrv4bSJvmWodc04gXZcGLDTRvu2nDDhoEvBP6dGE";
  b += "L8BcIQkA5pd1EYXM8p7WDcOfjs9nFnGXdW4lo+7i7411qVqLaPun2Ay73TkS5IeTwlj7vppnDSo";
  b += "hQRuqjDrojYqw4mKWITAiDU51VlTgG924dOSKiqwDEJVd9+Iqx/nEPvqxBY+CV1CN6toST9WEP2";
  b += "EfgMSBxwtwxpnP27GLcYBI50kL3HGuqMXGKLOPtx4vtiypRXXrNgkIrk7UB/XZ6BzfbYf6qy0Vv";
  b += "jaE4YEWnWJ33WpvMmiAynmtVbdGgOSYi+K62Vdxvy7tO1z2ButkY/sxq6z5zxWVvVZ9wHfNGXfN";
  b += "Ev1IrGYg1Hi5ZIW/RLQ42tenBt8eeMK/6VoeJ9qy/UWu3fkmVr37pi33LD5d/0XYcz67lGvetWy";
  b += "Zs1tKhTLCrGCP3ndYqSN1pVT/pKXPCVeHK9N1tVJdzn/YeFPtsPP21fD1g311sJ5ucfNExXvckd";
  b += "Cx2pxbPMUHhuUlUgMra8m2/oYUFteyHna0BVm0KJrqrN9GA7CzUQSYZ5fROCCGp+p/fydhGKBKr";
  b += "r09Srm0Q9kHRgtUiV4+RkP7s7oOcvoZY01oy923NhFrGWJ2mt+YgeC7JDjxSTd1rFzf6k0922Xs";
  b += "1j/aRXP8obkjZ5vAhVdQfLTu2e25YFJWRHtx+t5XrDoRB0ByIlOFAgaOUd54+8McQd204z1CrSp";
  b += "nedWTO9QcXss1StauHtC7odUAhX3QM2p6m+2lN1Btpgq4oeLArYZw3XZ4mkdajx3rR9Fo/2WfMq";
  b += "fRY7rZNY7QbsAUCGgX0Wa5911vRZvG6fxSN9FvFtzF32mTRhTJ9Z9XROmtCppocL1ilMH0pLKIq";
  b += "8o9XfaGkxgTAAx4DBCQDfYyFDmOivNgAdsZyHci57i8rXgesEj4hLRTiHO0aZCtQ64QVkeVO/w4";
  b += "md9uHsXGbP0pB6RKRWCfDB+vfU001kvUVFON21mSXmuKv6TwTFJXQkbkdk6nvlpdArL4VeeSn0y";
  b += "ktN22L4ylosUh6d2qq8VCuE2Tjb2+iTNrM18xYAQr29C+ofYjmpLYFwLlZRv4BWOVryJ4ZiRi8u";
  b += "aPFyrWjSEkWOuT2YlLTkBIfD6U1BDvnH4kQUmjBKr100rskJK9vUHmnC2CGkngaeWs4xvDd7aHq";
  b += "zh6Ru9oCP6uql9uMas4fQmz2EhE6t2kb/e7wioqZKSO3HZdxWYQ1L/q2uCiMl85sye/daVS69jh";
  b += "Z+g3eG0hP9rv1weEeQ+25IfDe0q1oE7MNSwXCGmyP0uj2mOVrrttevkZXGr+DmKFNFuUksLeRyV";
  b += "hfPNkxDLw5Xvc+QnPbCRjgr/oLQfSf51YuB2kWfLFowFg5vjPIiUYvhFi2Gr8e9RFKzGE5qFsPJ";
  b += "WovhD3ATXqjZC0OA/DJsth+hNp2svNVADWJOW7B7yCSgcjeLP/OwGIb+XZ9wLVnNmIVCcWcxTFa";
  b += "oTGhLCZvf80+5jfRKgNPLV40aCl2hNxWE1WOEcGBnjbozqr199ilvoC05MSmCOwKgjrwW1A2GjY";
  b += "UfUZ6LuCQL5juh4cq+VzASnOyNntSHbIUl65NhQSSpY+GD1KRTW2EChCQD+yrNhQ2t12hwpcbTB";
  b += "g+Ph2/EXPgDaI1tYVyefbqyFpb5wvqWefnUTyoQsVEzX7oGJdTVMz9pOQuMmRH+HOxyYMUfYE59";
  b += "mDVf8GGw4PkeykZXQZ8ban7tRD80Ff5rM4Uf+8zXcQo//ZmvZQo/+Zm/7lP4yX8+dgpf/oV1pvC";
  b += "RU9/AKXzir/gU1vl7+fsUtOHrMn+fePxrmb9HHv/rPn+f/8Gh+TuoUeHv/QbO1F/rmuZyzJkaOW";
  b += "XbiGBSpbkjUHU+3C4+WI8ik3vh2/VkeMoM6GPjWERFJR4d0V3Z90Tl66EqfYTQxmpCyI8zRmgLp";
  b += "iMJIMDAFUV56Z94eBc4fSgv1sMLg/JCLQxNa0y28y4upy5QufKJ1aCcyuAtgp2V/RYdKsyrPtOs";
  b += "vVdp3cur86MUqvE9C7ISA3ceq5Pe3vlwY3QqhE8CwJwAZKWlwITPQ8LWOlmkWLEdLNZunnKxXo/";
  b += "3p05tsXZqi7XjF6v3KiVrQT6J1VAkbrmiw56HItNLRtVNEmw5LSzZpz/mnGMkg8p3AJYs9ItUdc";
  b += "vhrLR1ybb8ko0plIHp+VngrZQvfMy5I3nJwB3JV62itYQKwzA0WOA+AEs2hoy79vYZ+zZkhF81V";
  b += "kH7Mvr2RVNfs1Rse8GoNQ5adZb2ys+bvsYdQ9w5+yktPVd67hYu3GuYgm+tROpew6h7DS0B7xms";
  b += "2phnFOtbI6YbCzjZMCrWUKObWYDE+VVr/Ko1dtVyQFwr5e8/qZYtp0+Za51l4Z7/qOu/y6z5E8R";
  b += "QKTo6pS8x7qjGpRp3kXFHNK7LOEzBFVP09kQX4GRd/ZrkPdwiN3GL3N1DRydTgzzVpy2DvMOnPL";
  b += "45OBq+PehL5A0o93tDvcgOxgC0NFSlUPdHtV3CMlKHq4rgEuNaYyeV4U6ZIobFD87oOwZAY1TUq";
  b += "DLcpxQBF577yhusjCoGHEuDngqz34EY+qwKqKV7fg5G7CHWaQNDYohWxbMyLBAIghrJSIAIcUwO";
  b += "7nt7eMpoYcZ+S2guyjHlue+X5R+yTHWQa7JnCIqT/ZxQrlNGKTrS6d/UitAgKYClXPZw3rDCflQ";
  b += "SHaLF/htf7HWXSGSfh4mPtNPGvYJbIyxkK1pulC8z5lQt5iXGnKjFXNGYqIo5HPGtWsxjjDldxe";
  b += "SNG6Nj4R7zorHP0R7McjqPRRVhsHVH8L/rsfUDFlOxGzfYrZW8BXMALaObXZkDKmjx+4I+QYKzS";
  b += "pn38UZoDtWN6r0eNu03DY04R3WvFXCfdp6j+ta0AjU0BR3VsaahqKG16KheNW1JDQ1KR3WpaW5q";
  b += "aHM6qj9Ni1RDs9R60rwm5YQmGE7KNWknMQyGk3Zq0gLBDoaTFjRpF1ERhpOgXGx1odUxR+T02WH";
  b += "nqh1JdHG1eY2cPrumxpqa+NTT9dREU7s+9Uw9taupmU9dradmmjrjU5+vp85o6qxPPVtPndXUeZ";
  b += "/6Qj11XlNzn3qunppr6k6f+mI9daemLvjU8/XUBU3d5VNfcqnSz+mVOEysBmULBkE8EAAdroQRC";
  b += "kkgLRBUWLQVak0Oqzii2SS5Pwhouw9DY7QliQCP9PKz+OaQAFXEidQNChc/inwXalHgm/G98tTP";
  b += "Phdg/47wtRZE9HeBfK4G91ulFnNPL1JAT3Jchm94kywuRMSQFLFoKege6A1D7mZLZxMu/WxlgBV";
  b += "Te17tUIfeE3IGlRRpAjbgtu4TLeLWsnXLo20MA27uyYCqhvKaTNyLLWmp7I4g3kf/VbB3rt/oUl";
  b += "SIiM7enuy3JUz4XtYkFhAPUmpylxQ7Niila6iCkRDUn3VSdSBmQju3STtd1Z02VgGbWiZkDjofl";
  b += "Fp0Hl4sd++zNIrmic3SLFruJ6KpUNFE1k7Z+ZDm5I4IWXX1srz0cvBBQtrg2/cS0LQPHRaaKmt9";
  b += "hrpQ+kWbRI2b5D7qB6Pm1M/6WCPsWMgzB4+oVw9RGd0RLCACiv6RAvkSD3nemfhEOg7Lzg41Kzp";
  b += "sv52dapUMDg8TKzoAlSynhAQLTaAaYXr3IUZ2FspERQT+YaATX55zO/fjVDeDSLVYmB+WjZFzvY";
  b += "4jRx9bUFLpYBkrBA2oW1s2DlBiqrX49vUqEQ5VIqxXAkZG0sEd7POZ6lDPUj9vXrmZBeuOmCk7/";
  b += "fJqakdAiRtG27HXhEsU4Ql4PIaTJjoApfMuhAJPUg23SxAbKQIzltavTRiORDnh0Ww/VCUOFRfb";
  b += "4ppVcU1bXIzi2qmWMwObWgwpCmSHqT+3qrulAPS1cZ2c0gVf0VDDb5CsvHW/6zYSrRaLYA/SOKb";
  b += "WiVCuhIYlj3PExPrd2Ewsp4dIGXm19M3xqeH2NHXHE598tJg7ro4SdhW8GFwoaAu2s6AtWF7QXG";
  b += "y+oC3YbMEJOVPQFiwraAvWLSbU6HxSLdRlG6t58i6D+3KzVERwdkA3SLjudAAuW3M6xMozqcZWQ";
  b += "KyoA4TIgblsyek2K5+U9C0uPdF0bKkEBpL0CUmfdeldTcemujmnC668J+mbXXqm6dhWN+V01JV3";
  b += "JX2TS5/RdGysG3O688pTSd/o0mc1HVvrTE6nX3lH0mdc+rymY3PdkNM1WN6W9A0uPdd0bK/TOR2";
  b += "I5clJQPbY9J2ajg12ChA9kt46CYgem76g6QtU95giCEjeXLSJuzRxV/qVOGzbPTa2VgrL9j4qvk";
  b += "tBvlqkkG7BwtjH7rsJ/Aok+hwXtJaJdb6oVwXcu7T1MqaD0DyuqMK8I1sxfBTyMtJexbiLGOHG/";
  b += "77qWlq0qmgYrQrbHu+dcI9Twse5veTh6ZQH7seeo/VGK4duElD089YDc0DSSIUQNigK6T6MXd1v";
  b += "kabOBrhTldoekAgptTRQApZtr9ozG7pncr1KoKNGPyXgxrBhwpMjKD7BaBsgw8KIWOwMVRLPW2r";
  b += "tjwsmtcABQhuNzw1v7gJs2orMZvEtcBOn8i6CkqUOlsPdyfk7PjWY5w3sPYTN5zp1d1fs4ZGuj7";
  b += "O/r+ZR8C3297mvyxZc0m8h797sp0aK4kfyaG+KWuRtvfnqyJiwX/pGjWYgWk2/v2FiBWsQ1kk31";
  b += "d0DddbjrMb36qyz9uBABrEG4/RQSiyU9dBHYaO8m3rpu+XEvy97zFjgvrcWNAHHAf8mXNjH5e8H";
  b += "9/ag+vaq/EJG8Jr8Ypr/DrHY4vKr8gth0m6FTJCRJUHu3EZtJnwge4wG43T7hkPnr8ZQNtp9d/Q";
  b += "/VJgHtw9hHuyGPWCkVkcm+78ITRlBn3y3loLYz4e0Ns6+VxHl1HsBOY+AeCPZ9+mWizO9sGg3mp";
  b += "0EFm6wkLy1x7xtqKyWLcvWMqjX0m5fY2pJ/FutYpNGwrf31VKIRUFX8QdXodH7pbCgZ4KAeiO7o";
  b += "Sn4Z5HaAuy2/k0+r8gE7sUreDGqvRgPvbhiht6Mam++PvpmNPRmCx3gXzSs9U7nwyUd6eI0+0rc";
  b += "p470XYsyB4P0q0KMVclmxSwW7Z3QUaiADSKVlertfEulqqb8mdO/PLO3SChZLm95GKgg73J9Cp9";
  b += "8cowHVHLR0kvu7F/FQZr9KRUuVLxKBYjAGgOAfwepb0OhLdsTwcZUiBT4+gvBoN+TXxjNh/tgTh";
  b += "lpbTSuvwEXz7P9RCp7TihebydsFW95WL3k5Bm43FsU35+rWG3tovIWaGwk2W/DjFV2lwjDvgFoD";
  b += "XD7oQgPas0qPE1LOyK0QmMwYXmyWN7ywcL2SuR65fsv/4n0imJMlm99WBh29gqYOVz0o1e4b0Rg";
  b += "tyRc9UpLe6WVW59M7BUIh4tpXQUUsCWyhvyBkBCNriahmuZFlp9KisaiMF2at7MTZtzSENsww4Y";
  b += "0SJULAC+VfCcuYElNlVVJ2TsHzaEyfkB+tV0whZdG9TcadV5MvFOg4jYllnbBBIhWyqdXHDMpwZ";
  b += "438mom+5w6IFKWN2AJiRJttdmnDQmZ2KD8yMrKyocBNZlqdMpoilPRGrA38qeb/QzOQDyvKDR3i";
  b += "C5kLRJsLLZPCdYLdwIGOPIJ/sQFGkMMTcnO+dFVz0MhkFQMZojhCeut2W/F5VsrjS3KULnD60kp";
  b += "72F4p63VZK9mNanQIrot9SjQvgG63IvF9M5Ah2bjTnBP9CGzMeftwzQ0OYWqbYRkkApoRpEEujd";
  b += "AJ3qxSIeNKfNuCW9FKFj2ugkpbyL7VJRPQO787yKsChw2d1rQ/Kg+lbuYvUm/o7O3W37ydy82AM";
  b += "PVlaIeBvSqn7vd8jFJ2yt8u0yP2E/jDqE949o0jvKuDmKnNo2bmMabdBo386ZOY4mVU8IMdHzpk";
  b += "hinaHqQkFncwSzukFeuZrFfjlM6i7UNk/LOpMx7ncV4EQbAB4pJ6mpPyiwm3OwDMFSWVlGTzLWl";
  b += "v9mok3Rpo3r8gpTzYXXz1ammcminciiM8iQbhakcKgR6qFPZntf0gO9NpxvVVJadfEqjpxjNK72";
  b += "dQeWmGVNZOQWwU13AOHDthQDOQm20R1hFxQjzvoTQ4TPajxDTohIN8lcNcBfde3w+XWc261YIyz";
  b += "t6WEwxypvsFE4xRpzCTdhQYEqh2J2YGbL+O5L7dvrBQKp0QYp6TfRncgpGQq8NyTN/N5+4vwd7S";
  b += "2iwdbXyE2DnuOQmdMmdolYfEGGhRVh04BmCk7tBQzswy9A11K0tt13QhD/jRXn+IMCccKZVzrmp";
  b += "fcAJJcQp+4mYMpCUn5ONs6W2+TfAVIBXia5ihfCqm/OGLBsVbkuLKHSXSdPgqpyC32yqY21GvWf";
  b += "K8z/g7/omy3NVYKo8WwUa5aoLHA3ZmC4bix6gw7YGL6cgtskH5dHQyuFhNTHji4DFxKQPwVpiyo";
  b += "UgOT8a7okuQd/2FImHh/09Z9XzGzCkyH4lpnFAnD0Vs6P47Yu8ZpYVOuuLv8AoWYhbfNR5RglJ2";
  b += "uo/Sy316BxWzWWpPwzOZwf+hUsSNU8K6aMuStQ2CqJ8GdRmx40R7xeK7bbKm2yfTGSvhjLK27M/";
  b += "CeUQOpG9FuZzuavnfO6qty0frdUF2+RiVl7flP0xKgmjotnsF4lOdEo5eSwKmoBwceDeIOVOydw";
  b += "ch45y3w2oK+8kLpK8TnnOWeg8ng0H2RO4P17qNTy7pFyQyb5C9wgJsWey/xBaXoeZm76YSS1F/k";
  b += "4Osi9GeXqTlCzMeFOGNQz2hJZ8YjCld11MRj8+6FwXI0OjfmpsTEqiK7MkZMekoLZCvnxwAX0Tu";
  b += "aCs+FBRwVCZ/iRsW7zCtRQ0lR2LlXmfyh6LFVBsi3WQ4Ru7pWpu+cwZ57sBthNT2Y8CH2JKDynn";
  b += "hahh/UyWclri3j+prDhAko663WBKovMpVQO4QOrDrsGCSXlV2nSj5MZq5h5iLb11wBvZlJykMlF";
  b += "+zvAaerMPgOj5QD7Qgn1xmB0zeWypkzACi9wrU1Tk16D42KKKAPgMtKMFpJCJ8uw/XnXKxOVHkr";
  b += "eHxA+QnPZJ6GF5HlmslPgjTSQYPnbxGK5TfgryGlMCCTpbQiAnRCv7A4ClpZjs4CUcR3ICXrLNc";
  b += "j59U/AE+4z7+LT+EZo21HMKhwSBIfL/UJg9LVwQYT+mcXGpTMyJkLgj0pm98hna0RU71I1870bz";
  b += "dFjkmD4b0L87sHVsyPM9Mhksa93LVrkz9mju1gPGYLwPhkYjNckzqPK+VU6+O6SsZKAvuMQN+Y5";
  b += "aYaVwwOWLR1xv92CzQ55AzhDvuTv6O0T10oPDE3wfFWjTxo/HCjvwPHO8b090EcrJb7M+INrgbX";
  b += "fJz+NPrtI1XRu4V1fgzbwNFQscwvB4Ed18m7msImaJWBhkXxHeIHtKTm1sutqTkzVQYCh7rOpiO";
  b += "6We0MuRPcp0sCWF5O1lzLvZR0DQzwfKta2ElgXKW9l/DqsrHCEi3N9vCkLd5+lUF4f5uxblkK7m";
  b += "0eryRpgc6DjrW6ZIyuI+Kk5/NVB8uM7V32ymKrhIdgKLu5V9zvhaJDcRGJJwbYnM0q0krRPGRGQ";
  b += "4EnrsiG152HoSKN68Lvy1TFF5OVF7emhv6O28MN3qfgWQeBatC8V06a4wtVbm111KuG4p4Rsoxa";
  b += "xXCsrAWZorPW/dFMxC7pTcEcxKAnBzwHXgKI+upRJSrRt/ZKQbs6obhYHJqn5s+n5sDvWjcCyfl";
  b += "r2sVvvm2to3az3ZHN+T11lOuG454Rsqx6xXjutNzNK7ODGJS3PXIt6+hW+7Th6gi2MaHWNV4I0P";
  b += "9ziSOsn/D10SwnbT9EFi/lH558T7a6lcCOZ1qNctlgxSWod1gDG2S+G7o6qJvGWJ10xnxr2zFmd";
  b += "s3CO1ON66bLzqGqNuTjjQEx7a+D40AHyhUoJaD2RnDMUIYJiVc7ylxrCgAh2cbN/Pg4ivgD7ZA4";
  b += "pM1uxPQWOOWuZeRTE3Be9R8cof0sQ0LY1Vx4ERECAjQpBKoG9R6f99KoJ5f3+a5E84lZ5VqGlbW";
  b += "0obwi1Jhp/5e92ZjpSOaFmSedZCGXnpC+Q3WAD+eJd4IUXG4102dLyjSKoPhuSWSkgRq5ACa+YW";
  b += "nuxYijvZxfZkF8uHNpI5wMkuViFFrCe7uH6yS/QIl4wIKfyBj0IKe/B3kgae7KyoAJ3Qz1JeJvT";
  b += "Zi7MUV6Hb2jdLx76dc2H6Np6lN9wWwCCpcVsQKUXq2oGIhFm0W5vtXJaMrsrUyWp3UdWhNOW9tx";
  b += "lubzLTN2YfMbTV6PMnkRPm7/yIHE8C6mKGZW9QXqyH5ZXfq8Lc8bJPRFTqxGRWuWxuHSxTgmH3P";
  b += "Y5oETieRR3ySoG3kGUBBCw4i/SzNzrhIxQ7r0/4+Mkz/3fHCx+/FHwDpY+yMih9XAnXSh8lri59";
  b += "XGk56aPUqC5+/FIwRv74peBrF0B+KVgrgXz92Oc6XgL5xeCbJoJEXb6xMki2jDJIadY4IaRE/5W";
  b += "UQkq9ryKGxERROeQXAwgivxh83SSR5+JrSCJPmHUlkcdaV5FErppRSeSLYGEvmOuVRP7+Cz8UqS";
  b += "Ry1YxKIv9A0r5BkshV802SREqrKIl0bRkniZQ8f9klkVLFsZJI9iMObteWRGqXX48k8oJRSeSqU";
  b += "WYFVKAmipTkNyiKZO3XiCJR6zciimQpVhS5ataIItkJ1yGKXG1VokjMeSuKfBGfOG1UFAkLBkh9";
  b += "sCy/ZlHkMTNeFLnS8KJIa8YvFWjVRZGnWnVR5InWiCjyGFxuCoPOptdEkZDnqSjyWGuQ/Usnivx";
  b += "UTRQJ9fMRUeQls0YUedGsI4qk0O+JxhpR5NHGGlHkkcY6osiVBsdURZGo8ibbJ39hUSRLlCbXRZ";
  b += "HHTCWKRDfVRJFCO0dFkXYcvChytTUiijxvZAGcN1cRRb5yvaJIKaUuijxv/luKIs8bFUUei4ZEk";
  b += "T/mRZHfNVYU+cp6osjLFEX+SE0UKR02XhQJV8/HzBhRpNoWsGtUFLnSUFEkc7uxsqLILwZfiyxS";
  b += "SvblOVmkkicwAzVh5BfMN1YYubb8ccJIIVtOGHmsNSSMPG28MPKEGRVGwmdyve+GhZE/Y+rCyHO";
  b += "x5WNOm0oY+bwZEUbKyfgawshnrTDyQlwXRq6O1GSMMFJecIleGPnsWGHkSssLI1fCShqJg8QJU0";
  b += "kjgZLFY0ZdGnkk3BOdiK4pjjwTUQZ5OvLiyBMRxZGno69VHImzDcSRl0bFkUdCZd0uvAFx5Ico8";
  b += "LgUDN64PPKqr1IgeSlY/OZIJL8YfF1Ekr6Yr00m6Yu5qlDyEmCbr0MqKfkod6l35tdDLvmZq8gB";
  b += "bQuuTzB5XQVdj2Tyugq6qmiSfYoZ+6FKNnlJRXNfCsZJJ3F16qST58O6ePILoZdPfsjKJ387HC+";
  b += "g1KJrEsoPOQklFsf1iigPjBFRvhSOkVFebd0hy4W6kPJIWJNSHgmHumKtmNKmjMgpHwuvR1B5aU";
  b += "RQuRKqKOZno3UklaCiC+ZwqKLKI6EKbB4L68LKfxtYaSWspiMf/EaLKynEorjyS8FYeeWXgr+0A";
  b += "kupmpVYnojekMQS25/r4KuLLA9LP3AP/DrILGVb/NpkltJeK7RUE8LzsYkUN6GCJVPcBNrBvBNi";
  b += "pJuCu4CV0ITldQCshBbMr2UgaH7drMyvm5X5dXPI/LpVM79u1cyvW978OnHm1++C0rKzu0bXPw9";
  b += "YgferJm7okT6e/E01uyb7HFFH3yIlkI1ukI1Wg5e8sRYp4XbYTes1fVKe+U3HVr8EiILsY3qmR6";
  b += "gIGLYYmARKiKBAU3v76d90mG+x5LRACdjjXhwCSqAh0bvZIsAivAsVfGdfm5hLC9+j37BqBop76";
  b += "8ytJesjwEBcMCuESVAHegCPsJq/eDGAvTWFlQTtihQlgVEHYDmq5tYBzK2Dytw68ObWgTW35gDY";
  b += "1sXl4/9mGOQjIlBCefo3XJcdU5yDwDoDo2M/Wi//eBymy2p3QPfvQZ+mAEm/q+4peqFFvYOTTFo";
  b += "fw2+axsB3JjDV7a7dsB42MZREZWrQGzeEtnaEQS3LDlWpWYciILA9wAMTYQQeUCkHAiR1UUoIjY";
  b += "ba7hTtcnm/rIjvevzEuWA/nScuLpUr8vthWDk4iym4WJTAOrkitX+WT9GdIeE5ciMH4Nh9S6tI0";
  b += "Qv3sSY3xSK6T2HfKD2Qtrv3onRt8yDorjUP2Yx67yzY87F6GH2QnRTqW/exn2SDhPW9flm+8iCq";
  b += "Sc/lLdhT5qagLzXILOUtHgevHH/Oyv+sQRPMHCCaEvoqJ3yYeeV0jnpfvAysL9ktF7WeskVhA8+";
  b += "TfotQpU1XyD1SCr7ak3OFkJ4wJvJz9kdx3zjX7dlvxL1A50vE8M9QnAMXHTCJyKPsVfjEXPn155";
  b += "DnPjW/gztVYep6prz8a88FKkhWJfJT8JeOl3EVY9XIVwyxNbJPKcSYtYaJvZPQBn21QYjXhbGCX";
  b += "mSUl6Rk/gEpPQTbwYP/cOk2HJFM9oMxD0X6QeK6lYe1grlRYVxVXz6CtgasLP/QXmZQuHpnX5Ba";
  b += "swTNdwX5rqzNJ+yJgtXXSmeZfAuRfJpEFX89Br4wodB8FxjbBcZ3gXF+Uu9T72naBeaaXaCVXls";
  b += "TDkU6qUjgD2onZT8dMuLDS+XFzz0HuYJZdqUKN4FdKjp4oCCYOCwK3ZcxjDQjMynxZXgnEeIHs9";
  b += "BYT1MSmZ6Jw9ZyXcLNrHTkhCuP6INFG5Sm/i+yYtF2GT0slZCVbgYTJjLwGJhHD9BKAYqDD9JFJ";
  b += "RiC++2sLJrKrMkyAsCegyxp6rHtSrhUXnjlWXr4yBTDROgunJOU2YF9ZefguBx5sg8+FtamJHAW";
  b += "Zw4MxaobEAyGRZhRdsWU515xPnPQArqnM+WFV72rHgLk52ZvLyay6qVX69lhPMPmoRnhmKqEZfN";
  b += "AuToaXR7942eD8nv/mA50lIE35alX6t+EoLCKwNL4YxcKldL1r/VtA3yKcP0ONGV8QDjs0br9Lf";
  b += "lJ1RlQBRVveUxlHnlT8O9bUWs5PBQ+YnWVInexBKl2o/xIyJmGJfCRMIM7ogbseX43cu4u5WQZ3";
  b += "1W2eDNQhqX1WdzImuCg752Dm6c5TBohzPXbUThgRFV5lMk4h+K3RLN/M0o4aYL7TlKgBsLYUvlh";
  b += "ggwJMiS1DMoBRzdGs8fV7U30lijvp2XUj4EJqaxNhhOkUU+VsOuMLcsww1uBWKGSmjg98edhx2h";
  b += "clHPU550uZCWH/T2yGe9SLwO7iTodVCaGNEd6F1BYFvLO8X5QNqQqFqrzvD2v595qkd4a2RM3zh";
  b += "UNBUayEf3/n723gbLjqM5F+/f8zDlnpkcaSSPNSOrTHvDIlvAAsiTGjq2e2LKFTezk+bGcPO5av";
  b += "nmsFXLGi8VIiiB5kjVYMgxGgMAOCGODwCZSwIbhYhNBDIyMkoggsEhMEMGEAUyu4DpEAZMoxEFv";
  b += "f9+u6tPnzEgeYxvIvWiWTlVXV1dXV1dV19619/dJAr6BnNWqxh9NHuQLHnW1ecqngt0ypKxBjJN";
  b += "okLMZLqGj+Nmvk2K/Aa98NqfI2fJ81ycFKi+Ilz3t2Ev4eNev9delBSy4ZG2pjwagLFeXfq424Y";
  b += "nD0HlJ06Yr1ngX6wp7HVeA6xpsawhyjmnmm9JuONTB91Ae+Ar52BKoxUEA7NnC5RXpCOF9n61zv";
  b += "VF5if8aLfFGvDOAjZA78lXq+O4MODpJBrH9PqY9jRFPx8HKRnqOpuk0mh75yynOmU56njqmsk7q";
  b += "w+pwvUqQijXeIHZfHe4c6p5eHLuYZ3sV8Myjo3h6Uh48utno8rzoX30ZIBN/MeWka1XGmUL8Trl";
  b += "n9KRLDNBIOR/4KVqjqN/SodGFStKFpIgiL4wexgbyMeoxHHpZgwqP7SmnRNjmwaAe+GqQVPmhrx";
  b += "/ZK2MNr0CoR2dOe6ozc/l9Zlf/8vw+18+hmOSE+RlTCojc0bifP5psOZpuOQJ9AiWSaKzymcBdv";
  b += "MNwO3rsqrvhT6AIz2QCIashWFHTXUD+wkFZGUGwdQ7hxSVyHqAKQImKfZWkk4yocvAEWA1w0K0M";
  b += "IQlMF+rz5eBxOejBwQIFHkywI1xfRGCgRtKLg8XQX99QX0JoOWWBkPG/k2STsd/GU0DYoxk8A+2";
  b += "5cqQnbSf+8zS15jdgnxDKJbAPxt3x/HhBvAju9zlP/sTtW0MqE6lpOj5+z2Qx7uUKtG+NZT9Jbx";
  b += "6f3LeNu9xZsjxx+ubxY9+8Ke7JJ0Oz+KmP3fXekGYdWbK0XPrVyQ/8JIyjfDJ2rf7iI5+/uRh35";
  b += "pPlDaR/O/nJzxQJGZElQxnzT8e//o4/0k19myxvMn3XA3dOh1Q8ZclQ7N32+Z3XESciS5UOkX7u";
  b += "01/7KJVQNtlTvsDK94u6ooypVc7hUKAPlVT3uQMTZkmVakp0TKk1hifqaFocowd7+Zq+RNZrRYM";
  b += "o4nJlRg77GnFxsKDEDntRejKkYHeUC7wkNBIgOL4gBbtEVjnzOf8s54KznAvPcq5wlnPFs5wrAd";
  b += "AZRj7QO7FpylcpDXxRhmsBa00wN4oYXhrFskol7KSIVXixTdDGB0WEeOm68hi5zEaEb8l8ucFHw";
  b += "XLpGIjP36SLTF9BffAa6BUvbe8voXBLiOi6a+VmXg3RfvrDFi7dxUe3Qw2hOtT0DosJhS7XrkBV";
  b += "kyKyuIpk7mo5sEjJhGQVy11mNUZp+FI61M0HirsSwx3/KhJ1EwI/eoeHLRAo8rF4d3HSy90OxnL";
  b += "sVPb6wuhGQ3Qq4jngigzoIjkvQcewxjNbCvLBLTLDOzxsKUTS9YIraqEtGppWmuLNWl28PZp2Af";
  b += "7A3lylPVso6s162Eo4aUAwANYF1QhMBkgI8qgz8sQkhoVaZOonMqNFUmmpwDHEn5QfrhzSz/9QD";
  b += "s9Jp35k+dIdaS2ne42jahwc9KxR0nptaNoKGRrxkvJn/4OvTCJDTSCN9c0RHyiZlmsQb5pgP5Zx";
  b += "rDiG0S1nCAlRUJiki5Xl6xS5yWCIY3H/2ONhF2LCXhPGJhw04ZAJ1zH0G+YfQJJgie81EYEk4eJ";
  b += "RQDgU2ctBCmZv52v+EnnCMFqLVFYZPBCulZwrFT8nuBxSwkbVbLlbgE/h1xQGIjUKeZMZfMivZ6";
  b += "t4lUzUjg2GiGesLXXlHTeZuqwJgWXqIvAiOcDItSzj5NStD6lYFL1Gik6Pv/khJ32xApPu3i3x+";
  b += "+WHL51WcmDrpc3cWeU74vAc9BUoZZ9nFN6W7KiU0RHBarNEIiElHgJifMt3tMlFBL2wceXMZ1Cm";
  b += "zoxBCSCHHaQOMuxEAM0qz+RwIiMSsJfaP9vK4uWSUEg5cWAPXCZlkm8IcXxyBlkuIMW+zDMB7cm";
  b += "lKA/QRC6FUs14LkE5gE65GQfQSddyAFUsBxDppVgJpUfqYPhqqpDd1meAHaxLOqQZj4eeUuFVLu";
  b += "mMLB2Scv28Wiml5M1901cYOQgchkGF0FTK0G1sZl7vqe47VPkUTfZIUCeSJNXuUOhdptaxijDCt";
  b += "+2l7/gXmTN+VzE65Moh4mWkt2lqGH1RNfcMgZkkgj3wW4DhUS/ltEge1UIBFSjQdrjXEK7EYww7";
  b += "1D5jaLASCQqp8VCibNUdqXSuqiSqUhipbknKJNduJs3bsimNtkY/xmDOEgtbKDDaY1mLFNNfu4J";
  b += "jG8XG5U1pCddgVsqnd2xiIj+LnqFyoTaJrz7KxpPflJW5U8R2OWZJleWl3/4vhzJCElLV3ZNLIJ";
  b += "vb/bkEEqEdtgkf9L3ajuCmNAAeaXrzkUK9mMZEEyupvnM0IXlL4uk3JiEQNBCpavUwff2Rd377j";
  b += "7iukHa+Ly7ct13EY0IpdQJUKenan/ibScOyP+kYi/3N5F9ZvgVz4dZNEKbjTmbRk7JqxI4nzSfH";
  b += "NoHgu6RMGoUm9wdrhQq5CsIptw3vG0FFOrbjnriXXM2SUATQW/9AFtb3JZ3bky5SwnftjKv3xZ1";
  b += "60U0Skce+CTWe2JZE8rs9rt0XRybrdkXu7FIYS8n8Uybvyh7R3FSudHduS7pJDCn9MdpP9pVRyO";
  b += "2eXKal4VYjWOpuI6zUtqQTwJU4H0/EXdsIEzaqzTrWwBReSVx8Md7tuy63dlbKMFi+FS9mCw4He";
  b += "bjpPgv+mJ0YsCeOt52I7YlH2k702xPH2k702hNH20702BNH2k5E9sThthNVe2Kq7UTJnniw7URg";
  b += "TxxsO4HdIZ4wwGsQO7fcZ6HXtlvU0ecg3N9IPUi76KLe5sq+FW5kBV3zcdO5dvqg/FSlQ7WJlNc";
  b += "zYd+bDjltnI/U47VN4pwxH1XVnqfaO9034G4nFX5N3R/2t446hqWGGkNlauGWrlK1YEZFTAQmWS";
  b += "IhVqHyhkNbYqsZq3E+TjrzomkXJKMuWfSPwUINsunmuBPC7eZNcVWlUolVVBCVWIfKnhIrq7gps";
  b += "ZJKmBIrqlApsYLKkZuBqkzRUWIBpcXNwKamgLh5E0G9SM8tre5cyZWun304BxtUOmXH+KCAwNRv";
  b += "Epj6xqrXEpj6xqS3OcuWzLH60IwXLKnBcadJj8rdjGNOkx+VCUecJkEqE+TLnlt2Ac8+v+zyzLJ";
  b += "ryK5YOto/z6RWo1Q648RJLkS8GSoJrleK3FdoOwFtTkUBStqu8KHRLrYvG5Qfrwt+K+0nlLGxNP";
  b += "MEdEQFuhW03zxsAK1w5gnoiqoATJtxAgSTJKVsv7lcgf3P9hPEP2/LC8bB7rg8sxAoujppSd62V";
  b += "MInfRYyyf/2nIbRs3fLwtMv6ll44Mqz9wDln70o96kvDZ95RYNfiiJKcy8ifPZezs9Q8WfhWQvP";
  b += "vIjuuRfR8eyP/+CXYnh0/VJ03M6nX0Tp2X8jnb+QjvwsvMSnCqvP6Rz4LM7zz+Jn9lnoH8/gjXT";
  b += "+7JdWfyGX/hw6eO256+DP4GMQ/EK+mT9DxcNfqrHxHH6Wn4V+4j6n68Vn8dJfbO97Fkfkf5kW/x";
  b += "k6aOWXopk6/6u08P9Jlwa/kOmu2G6FoqfIkNQWztARjRcUTsSYUjwSZKYUwF1xQUuv0BcFbqCS9";
  b += "iYmCASs1DNLC2MFfz5psBVMvwRFEsxvYfSrvDBu9CU1Jd8Bfy5aZkhYruERQmi/XfoDRW/hFiZc";
  b += "hCrKJp250ND5Q67pMJjxSZh2XEOvsGrL9bNdpo+h28TluEA7hw7dK654xkIcTnMGiKEQd2AHphB";
  b += "X+GjmfmWDUl+CVx5cHZx0+R+k43B42swWDq6Uqdl56eY+GFQorTd28mGIevTdH/9H5wpZRxav2m";
  b += "QPf2Oshu3JjhvjcqMeKm8eXR9aipUSr2TZm/sq0WFX1Y7G6JX2jyNOXOq7NlivD2moIgqwdIYxh";
  b += "z5kSdkB4wLJDeNS7rHMQzmXOeafjYzHXt9L/FLq6NNg0ygheJAhq69ZY/4wcw5cQxI2Rakp6qb9";
  b += "O323N2/gZU2pItpXzhxoMwyrQKWhnsSDdT7cgAKRxPpsILR0CZBExpA6SVIifbnVur75elXZTFx";
  b += "Fp/FQYieCwXoXgoF6hCCud5PWtT6PFK/1+Uru2qPkrguU33ShkuksUtoZT83EqFqmCjivW6YKOK";
  b += "9cpgo4r12GCjivXfZW+Ot0V9cDT0DTzmmzNPNiaNDjRdCexwuhOY8XQGse90BjHs+HtjyeB0153";
  b += "A0teRxBQx53ya8fd27eBEeU0Ri+MmPp8q2Vjxhjy5eq4WDqRBdzrnhp83f21Kc+N5ffZ3r9L8/v";
  b += "z+dJsvd1UXbP1TxzUfN39tSnPjeX32d6/S/P78/nSc4273mzzXsztmp+Ne89J/PejzyvugPknDT";
  b += "WTz0lWIVxRQnkzvWCsWsoZhYEhCGBPUNYlzXT+K4923kNTRnc+7bHHi0akhr3+dVOobPFlMGFKU";
  b += "OBpgywLqrlTBlo7tViylBUAiK3xZShZEwZ5I7efSOoQ63FiqHYasXgwXDBu0+qxKxqtECbi044+";
  b += "MKyoTYSTezarrYREn+DSc8eI1d64o2qQ5eXRlvuk9xqo7AtkQcJFUKrBruETtoleKPaRmMKRKd2";
  b += "Cf8D9kFKrupoEGhQ0qCqQaRBjwa9GvRrEGswoMGgBis1GNJgtQbrNLhYg/UaXKbBlRpcrcG1Gly";
  b += "nwfUavEKDGwwXrAaGGfZGDV6jwRYNXqfBNg3GXQ13mXDChLvRfsvH4HILRqYyGCBh5FoP6EkacH";
  b += "JAUFA7sw1JsS8z5wmwA1ugnWScSy5pcqktuYqyCvA/95vJxE0EBjYdVF3CTrq0ZpJ1dDcTy/Lnp";
  b += "eFWeefRWOUWeIGqtaXXZm1Jgwu/03d8z65G6caSPv69Q+alduor/gYTnAyID26B3NQuqX/J3u8f";
  b += "Mk5EpdSNvqzkYAONEUwNYBxU8MV+CQ6eOMQ+4aWPfPeQurMQyCu6AwaOdJ6FceLjjlqHDxgXGg/";
  b += "IF7j+sez6x9n9jPeXZucstIYmNl5L0erHy+JcLc7T4o7OWpwWNqMI2mT6W2Q2p/usY966T45KOO";
  b += "v0GGy+7GkP2+LREgOzPXRNGdPaaoNaIvs/mUqxKh6JKNVbx17tNAkrjZdiaVS9FJXo0VOnnaDyP";
  b += "c/129jA4Af5crKqlbbHpesJ3yX/t1+H3xH3DZIov78zRq9ok1Mi25PC9rhwfc2vVIsVsF3Jd1BE";
  b += "D9gXayx2DfqpH5dhoF6G53Q5rtC6DPb3HZBaXrIBfbUj5gEAUGi9P0qyUpj0AQYkHeL0GX0lWCI";
  b += "9w9uRvjBWulo3feEwJB8Yx6otvOb2Te50qAJmeEk8JJJUeOhq+lxuoiE8YJQUZ4L8J546ST7yAU";
  b += "vHiqPHsiMv9hURwEufyBKlQS9yYTHnN/29uipmYqwcgfVWc8S1t7pj2DULrucHYcFp7Zem40z+3";
  b += "ZTpl7+2hkbdsK5W+FKPfbzZHUrN7sC3MbOw3T9bYWFuEDcLe+IrtrD7H5lq7cvsAjOvOH6WK/xZ";
  b += "r5g6yxXerFfsO8sV7qxXPPnIGa+ww6byVrxJS30IyRx99YXo4rLiuMiFL4B/CJDCL6VDu4HHIQu";
  b += "vD1dmk69XgypMiVWNENMGf1R978K0PzO/l4Oehmo9IICnH7iHHI2pT4/sQO1aifsXVJqFOyw89b";
  b += "TwfbwmMLdp3iErFH4LIKHMFUtb8tGEnsmYcAoNxUuwZcembJhSxVhIOESBxLqrpSZxVvn+rPLyy";
  b += "tJH9z3kpPX0wN0Pqd9AevBuJjxqE/ROAxLIUjRA3YK6WzGqH6hPMLL+zXPDHWmUlqLvyhx8ldxf";
  b += "43UpsKQxP+3RiGfPBZ58ns2BrL9G5Ts5Pr4tppt5ozGavnYsBWggPtdX9cXOaOy+jNNqRGQ5e2E";
  b += "o6Vf1MZ74NrWRBqPRpeqw4EUnAzr/Y3DD0588zm5dOTEBuSKFjo4hV7NqIkf8NT865I6U9W3wsj";
  b += "5iosirGOVpRWcA9skHlGvQBK8z6jDyWMaBmYdiqOpI0A1cBzwGcAns/eR5+WixD0QIBXvQ4sgAq";
  b += "nE/eh3YBP8ZMEEoZEklLlQ+6+mUBtQv4vLGdNIuKEZAAd26RwIPa79C+sU/eYhDq8DvmrKFO4qh";
  b += "ddRppHexhxRgpZjFH3MaI76itwZYuxXSyf0PcTFXSN/rYhVYkBi8eG9Qh4+hBpdCxsauwF7TtLm";
  b += "DlzFisSk60KIfkTu+39zxTDUxt999ptszRkCZCqNRA8vRAtdva6hzBPQllq8F2hKG0U88ziQexc";
  b += "hONiDmk2g6ILYaekn0nSwuT16BaZ8PJWI0ie2NY1hVRu+DMfWkJwMwOoF14bFag+s/g0QW0VDQQ";
  b += "g6S4Mk3p8bJdW0O4VDiRZ/Cqq6Ywlnosx5u3Wc8vuXZYOEPD5U6AyAETO9vhUw6kT/ubaSn8scy";
  b += "wZxsHjvg/jb4EaVsOHOS0BcpxS03d6zqHWEd/Ccfar3jR/LHixrppz/UesdPfCh3x+VnuiPuN91";
  b += "pZvYZ7+M7ufcxfYb38dHm+7gL72MflivR9/A+psj8a9o/ex/m/TzV+/jzp/U+7n+gtXUefKD1fR";
  b += "x9oLV1Dj/wTN/HT/6s9Y43H2x9H28/2HrHWw8+vffxbl83LYYMkL9x9qAqPLSq8JCq8JJOe0WR4";
  b += "wNmAiE91eFFAlqU04mvq28Gl3tNfTcU8yiCXKqB+tq76mRxkiuRcvqocwUxSpIN2bWotJ92zZKd";
  b += "iFkh8UQK6ZG/P+REX/EUU96AZd0W5MqQFar0sRuIBFFRIADHzNz8QsiTNp1FtMwT+TIjwke0lpn";
  b += "tj+BqbV2P4ouRVUrNso6bsmhHXVrrtRbDdavhUe8CFFwhPfj3xmfkuCevBjzvugyicx6WUVsaFI";
  b += "IV6WorwKfQb+s16mG8Rr0KW+NVjptIvATzYqKNEB4srlwl7Qv0oqoMkg5pbMK5q0jyMt3a2EgGB";
  b += "Li1kkeh5lvXGZRjUO3jGgReACUpcmUpvf1jsp54Mx4GZMU84oo9u5dyzdPVEpBKdVLmwmdQkcBC";
  b += "4mvRDyjxpoAn/xvAUAImEzkZ5ATa7bRDdC+6BXoNQEi4WD658NiDlZG7uQ5H3PAK4mJV0v/E8uf";
  b += "89J6P2dWOZBmr3Op7YUbyHHKvDm6uziqHn+5VTqik4A585/uTUhrojCT9IL3lgJT4RvmJy31k0i";
  b += "738cOT4/9mRn7dJdLbkpoeA/ZU2wk/JjBgtdsxMCbl7G7juJs/2w36sUkYAoJxkQRDjfSx/coqL";
  b += "q27wuuBhgCo1ouIaMG0Ej/L8nmW7hMCJnI10qWDQx0UAtcnHnbWQXcClIuQ8NBJCUoidTZ7LV4d";
  b += "5iB9Bh4r0LStfY0YHivTnQf4kBIf0irXQfOMuhJja9jBGtkwG+8zQpu8iRlqEkqo3Bb1KRE6Cpk";
  b += "pK016ZjqX1wJFDPz4roecQcehAyxq+GE5zmbBu5sH3sjtwK3z1qo0Ro0FEHyNqmOgkX7B6D98PL";
  b += "eXHvjJIWrLvPRHVKV5FFWgMfPogmpFOCxBejk8B6mz4HxQ5eCRGSJ6OZmipQvjRAYZ7ClksJdO/";
  b += "Mje5QnHCorelsRJT9zykEFj6Wfi7jfa497stkNZpUr5ChA/DdM3sbUcqrGjhwNdFjdPuIwrVXqd";
  b += "IrG+ly4g/PTQ8fQfn+f17ogwWqZ9frQN3LflWEiKQFUM4LWATeTY7UsHUpHq+qLfhiM4p6UpAKY";
  b += "at/C9XiOd+nIGeB/AfTM9mE+YkITJXMKIguEH6QGbOI6jca+ht5Xu8CXf3IdfJK0LVg9F9KHvO5";
  b += "uHs7lL94mJJN1Si4PttZicpRZHWmpxgEdE8WjWA2RX9AYcND7px0wGqW6WNkjn2/SYY45POY3oP";
  b += "QH0QIYIT9IIYx7OeJg17c9SoFv53dgvv/NvpwALwrg0ItG49tqFKuhRA8MgrqpEczOZPg+6hMZ0";
  b += "gYSbeIwq/gzk6Wir6jtlIjRAocACjdMHjypWYimNtUqD6lh1EOB/vGgf/SThzlIyreiC9lB+j8B";
  b += "vOEubZBpoRSs2Dbg4B921/l6X5iR7ud77nEIrukDpBZSfnPgXt4HB7QOI1k2/lx3hw/+t7AjFOV";
  b += "+T4g66Bhmbe0paWVnp/TaRBF0f2G/oqzfxmDsz+V7CnZl8L+HOTL6XQOHo34CZw6atV0clz3ZS3";
  b += "3RSImKUCNxsO6jRjCkkJaA/Wm59qv3WJ2e59YSbv/er5OCEvkTtmx6eF05c7BPqBaSe9ibJVSct";
  b += "7ZgjTthSzTVttdRqKPOnvC7n2suJtxyrG1azd/eat4s6OQYSjF0gSyiZfmITzNtnryIJFXQZR78";
  b += "ovfu89NEvSbf7M+gydh+ThPnaa9M9D8vBvmMWagldH+82q4SscaGhRLI80cIRI7/CA2yRPQA4e6";
  b += "854KSDF1bASEz3ydCK3h9YnGGCsSuoVDWd+lsFlaoqAoEOtfnShXowVQaZT/ewc4MZmCUZK/Waj";
  b += "Bzd2KsvhdWGC64TGShxvR/0Bj75rMBBc9xvgD8hPSIrOgCKn5RwgdodIQucDI+DVDgdMgrgCl5E";
  b += "ETMKcUyJKGF6CVFeiYuRJexxFWDbJHTGNRtTRP3mGby4WvPSTkX3b5Yd98ukiAXNUrIO+7EOe+m";
  b += "U/irnhkD5HDz6rPtAq1njHfcZPw4l3CngYrrpckL60duvCFhcN733qMXEhS//oGLMXi0zEE98iI";
  b += "7rxHu7LO7IzUtwHrS7B6DzwDmUNxp9hyv7Ax4Wi4PevZ761N/j1UlWsc8j5vPxZgUetRUY9K7Hz";
  b += "ytiYDk8fjRjrfCR1Y3egIXNpWN1BlfxMXCqLIeFrXK2ok6kWmyQPtms/rX4uY4514/hs7Zb0Xcr";
  b += "Cna21wNnQxzz95q+JBqtV9IS9p2h+vKba6ZuwtCDjKIx7Bz0n6rB5dkuVV/53llaO49AnLr51la";
  b += "hSLIcRC/NtTi+MWC20Ba35+fY6t0qOs1sdEXji7ufotFN63Ff7tKrdGtEG0BF2brZyi+fsTkC3D";
  b += "ocTebBMC5kw+A5yjIjzTP1v9fU1z6H1H+eqX8ffXy1/mG+/uvwc3HcF8+btf5Yj8gDhLgPH2AeE";
  b += "oC0YPtPoP1HYV4Hs1s0X5ViOwziZ6Xkzr2qGD8DLMO+JljJ1UMtrKV/atJQVn6ugxI2YnU8T1Kz";
  b += "rolZnn0rRA+Nu7EH1q1InbN0ceIwqvjb3rm1meluDQwrs2Tha0lCYnajnonLhSbIz2R1wfl00o8";
  b += "XYK2ZG/U+ViOSvkTyhcw35RNKWgoIsjnvCNNOoPws7RjTQEleziY0EdqP+7JsoIYWvTleLKsQ9K";
  b += "pTPjQWcRemP8fQCXVhbnQM6AtoasyBH3cxJr1tfhzpg8VR+uTDWuUOcxtHCfgU54UHUEpkBzJEy";
  b += "+aAaP83SFHzQXCI0V7v4eZj+zcSLRs0EfkNfbGCGko/4qdKpO0o7U2P/5Nc8z3P4LyRtW2QVjTR";
  b += "R/zmYjA9gWw/gHO1f618tzDJ4gMuRZwyBfDSmCY3uBQXTfwgd1E/lWX8JJfSvT/IXdRLyxx70YH";
  b += "8RcsUPFGWzulQejB/UUQDHnvRkfxFy3U9I0sSuex4/iIqs6r2ohP5i2J20V655lT+CkIjBdkD/X";
  b += "PuinrsmrWXGy8bWfcG+cmg45c1oeOXtUDHLxspTVjo+GUjvRl0/LKRQQMdv8xCx4+j4H4U3N8su";
  b += "L9ZcH9Lwf25gvtzBfdnBffbgl8n5S5FuUub5S5tlru0pdyluXKX5spdmpW71Jb7GrbRXrTRPxsM";
  b += "IoztgzYha606bl5v3rzevHm95eb13M3ruZvXs5vXW1orRsFxs+C4WXDcUnCcKzjOFRxnBcf51lq";
  b += "Ocpc3y13eLHd5S7nLc+Uuz5W7PCt3+aytlXFvKs1akcvnbMkfERy3uQIjyVqH7sCYlDib5C70+u";
  b += "sJcFX66wM46q2fg6Pe+vNw1CPd1kPwfBxF0u09BOfiqCojx0MwiKOSDD6gs9RX4CiQ8eshOA+KB";
  b += "9g/SaKzLVlq7JrSk69XbJDk/P1JRS06+uPzpHPEE9u2Jf022xOaLT7fYn4k59EeCttyy+IV0kmZ";
  b += "f5nNf8rkPy/Lv2J/Ulajk+XxoIwW5l9u8z9p8q/I8g/uT6qqXonjc6X5mT+2+cdv1vyDWf5z9yc";
  b += "1xZWpx8+XbsD8dZt/l8l/bpb/+fuTTt3dPyd+nvRH5j/H5p8w+Z+f5X/e/qRLNTlJPBCfo/kTm3";
  b += "+3yf+8LP8ADMrihNgoMhUn+8diAHrL0BrYP7ZJdUR+fI4ky8cHCWRajetM6ERCDxNiJtSQEDFhO";
  b += "ROqSKgyYRkTykgoMaGfCeHYJn0/ssBnQmVsk27eySc20TVk9jWVybqUHcgk3JF9U72s8xLR2TXk";
  b += "1guhLfdtP16E/Z7sCHuaR7Ij8oJO+ZDPDJKTHO8jcRjtJSnimby0l6SYlyWAZheini0NSwP4b3i";
  b += "er1rhyA5AaPS9HURLvYb0GuORCccD4sxj/TwmZzcNOwQElGVUllBgQrWZEDJh3lZAZp5EQpAabg";
  b += "R35kXTzNBeZpjScCZ/RWjzTGmRancBCjh4FMDOAA8MCzFqLGXttB1kgiV5XwH1ECt8oC5T2epvC";
  b += "Ix1WvbBk7A71GgSKGFEk8BmCT+M0ctlKYgfWQKtpe2OEtPgBpXbAjfc0SQ7VAMuynmnnZfp3UqJ";
  b += "qnaVxCcHmE3gQWx8pKWMrMKQD9ONb2NfQi3oy/qSUAZCunwr6BaUpAfo3r1Nrh5nNoIeUA4TiO9";
  b += "rhqDHy3bMHcM9gxYLzZagp+Q82I5QywPbDHnyau3TtI4lJrtn93oIc9iILXsSId6q2rlaO5Wfe7";
  b += "ldPMp1gE4m5DpVjQm5TlVNdRmfKyW7iJ2q2l5mLfUNr3JbqbZTVVMyE6iu2LwxcO3SXcqNvuQ2n";
  b += "9c8JYwoLR6msY4oVSylpVP5uud20KzBIBVSaeXe2DDbLvUO0qaUN+BNdCggpU+1ohP9jcw+Iwfw";
  b += "Ity13mOeIoNPe0ZaBR8oLQGOuI3oFk8R7Sh4DCSBjOqUm3bXcDOTmkiItpSS8KW9MQlH68zdm1Q";
  b += "oI6msG6T+lgZNDkuXx5XLN6mMHVhGU05vQASV/9Ilq1oNWdtO7ZdP+v9EL6vmyC6P7be8OkXcLV";
  b += "TuEbIVgwgBltRGr1sY9I640T8olybx06HROuCa/WvHRI0emHqhgf9jGvf2B2Zr3HseeG4b9689R";
  b += "WpszlJszaLyxtMYPbyKTLnuJpgiEyQREw32xWnfhXm2tGXTRS6JZsA7bNmLU083LwoNzS5z3dBo";
  b += "UrJOZkqgPpp0MKGwETxDknTIAXYgk67hHgsImgsgv+iQFFWCFNK1eHDC/vcYgzxOjQAvPXFCtZd";
  b += "B+sj/nKIVOensTkoyTWjQlsZ0swhBs6glftUZNVuQaOEScIu3bKqXDS8uLGIPnpjK4BBj3eBGVz";
  b += "tik6c8uw07RHe89FxlxhnZ8yXnOswufFcgMEnLDaihAyA8O5phPCkhuGn7fmkmbCSnjzmvTvAC0";
  b += "s8ceMhpgFuOqmVvlNsqjzk3jmq+thzylRrFbvTI6UNfveDlcanucKe6tF9u9x1HlXgYSaxFg+nY";
  b += "iLZ3DM5YMlkz1cWypYSgLZ9+Ddx8hqEGQXzxYT8MSFjHNkEqy/PR6Pe54yu98R89/biubxhMPGP";
  b += "aPwi+a+KYAymTZFmStsZbaT6rUM1Ik6NqQaBgodyvDqN/8CxinWKAroN+Z9BbraN1iCieMdZP1O";
  b += "6cuDtTcRk1UxFgwHdbTQzWYtEuDLGVeTKz+2l9SpUdJidovACodunLiLq7knWBQup+PzOnMDc8a";
  b += "G+Y0wp6mtqmZPLSI6YasAG0auAoK2ninnZlJqaJvfcYxZRDiglqnJ+Tdv7W02rnBz82Wzsf/dhz";
  b += "1s67PzZbOzN1Rjvf+bGztfOjH5utnR//2Kzt/BmDYByptaNxny5a92nrLq2mSIHOntZmKe+GDI0";
  b += "mkOZhy87ZWD12ZZ6UmaZKZ+SaTqnh5bTsDWE5WknjTel3QfG0xBYVB9EuF9bd4eWcyMNR+hAHoA";
  b += "8Or5KP5bs//o/wRT66+Lc25Y9+R83ZZArm0sfOkv5Ix01x9b6R0yLPmY0+lKnq6cz3GAw5xav61";
  b += "EHNsSC8NLjid8b4HyflpgeyYvO2WFyV9Wk21NSal08TqgN07niXW1Frt1D9GwpgE53FAbwAJ/Ez";
  b += "ZajQ7E7e30NwdjDsQjmIcWr1YA3LVhGxj+xzFypzY3QXbHWDStO3g7DeMNw97TTSIfnQyN26xkR";
  b += "e6djYJ3MgPkTGJEnSr8IafSsnbd00TUBfBBNwFxsTaoniKfNig/5V0e8rWdyZ7rf2ObgdlsaSkt";
  b += "57wKL1tx0GyuESsw0tx5caxOxIOQ565FNzLjWntASKkpAWN0uM60z6ei/6f1HRTbBlwuyjPM9pB";
  b += "2IV0od0vKwPu9qrnGpCyw9YVhNWWF7rBtiqcAMncYaVTQCsg2TGE+mlzm6HNQxuawkI4MtY151n";
  b += "yKEjRvOtmSAhyZ0hgcod9T4cen4s6xKv5W6+fid5XgZGWDF39NW2MLtpRemV0BJIsqJmF0tI937";
  b += "6IV1ZfP0M8/UxRyfsPe7TnrC/87Qm7NzeT27Cbu79rERO3fqZywT9hhnTanPnp9TIza1efufHzN";
  b += "sow26O5Ofo3qyw3CaNfjk4R2ebNJyj97h2kv47zwsy6znfoCg4q5ySoWOth/qSNJ4J7gHmgIKa0";
  b += "qWUt40x3dtgTBfCmM6VwHJWWVu3JYRc99TADMWSOYtXv0VHW8sFXAGjAh5ZF/rB7+CrlZyft5KD";
  b += "hKFWcmhDtZJjGq3kYMSONwolwmrlYKaVnA/+Z1rJSceElZy+AOk/GKPapp61hVvCzThrDOdnxnC";
  b += "VYadEXAq3of6GxhLuQXRaIkFjGczPGR6KKpm0J41IbJUoN0ufIhXXXJJwqOBt1CjVhOt615IbUp";
  b += "bBzkkfhSwwg3uJi6I83VLxWFQfHW1xG88Wrs4hxq/BVwoO1qkfVH3H//IhbBOBE1HtZ9Me7YjOh";
  b += "j7j9OJeXrPaKB7WnPQJMC0+kTEtojAyLSqZJZ1WMbcp2LynCkq5uLfCp6fHIQ1hwZzhZF+g3krl";
  b += "bo+km5BtIvTIVE1HNsp7SLENdPr06eJV6rEGNNzS1t9LvFG4atKkdjS9pFFJ6OroZw9Xz+jVbY1";
  b += "lCpZaiohnKBw5F0THfcyqcChxSdtJ5zZegq/7JuMhqRwfeMotfBHouEu3yngAg2cSkiPycgXX34";
  b += "KZKbElknaV1uBKCemr4SKd4KoZOzI9frsgeDmGuNJja9rMuLTyAU+t742Cc3ZlnG+UcTvop/J2H";
  b += "pZkltMRrRqs2PqcNkwn81JLVwn3WWc2vZbXotfy2vVaXrtey5tVr+W16LW8Fr2WN6tey2vRa3lt";
  b += "eq3YaUTv8O2HJHUqf+VlfrvPbK3f/Bo8vqv9awALhSd3PeXyHV8eml5j0ev+rIv5o7tmW8wzdcZ";
  b += "i/tFdZ1vM775ltsX8nbe0L+YpnLZ1Ni+n8HxqbfrP2EH8p91BvKfoIJk2varadNcMEjQYR6VDTa";
  b += "hPcJEvcU1QgiEtm9VpcDzE1hcFJLdqdGw623ta2uhXI3FPfiQeejZHIpQHt0k/fWf7MDxy23M+D";
  b += "KFYsPduGYNMnTEGD9x2tjF4/LbZxuCJ22Ydg7/qX2eZ6d/9q8Y5w+Cr3Kp7obFnaGqHyTOGR+6q";
  b += "5GnDWoDrsJLaYFZ80Gd6l6tYjDFjhmZZWkDditSfiFxkaZmuYfeNdNyUFLC7raoWKE9FAjceR5a";
  b += "/ByRA+xPCfZDrXWnoW8ry7TUYyh03KjcY6sOllAUPoC17V0WZ0t38A8L7onlceavxwW1dNO3IbI";
  b += "JKm6jUcMyqW1485CHzkXPM63ear99pef0OXu5J++Kc9s7gtHQG+4VzZuaZnrWI7AvntLx7Z+YXz";
  b += "tEvXPT/GP/mntjJKRtysnblv7nVHen0X+mCWBbq6XGJU7z3EqImeaqd81V9RaVWVdbd5IKiGowv";
  b += "It0LGvfTy+lpdHr5y0hLWar8k+v6HHLWRsv4Iqadr5V8i1+7WX79rZsbdDoKRKDseq3MjDVJL6Q";
  b += "dkg7AwGpsZlPjwVjExUVeXGxe7EihXSi0xkJ5cWhW1ni1qn4TUUkudnmxay6ecVP1Ag+MtA0ZzM";
  b += "FVDq9yzFUz7oZ1+gdr3rk7em8yrG10qSFNKtwySiQbqSttaju8VYm2+4laT8w8CZ+Lc9SmXqGzF";
  b += "rTnAMPJAIz9JMeCdhRMeRPRr8c+5619Hn0BsaMYWK8fWGuWSZmMWAfYz+jn0qnsaQuTiuG3rfEU";
  b += "eEu6DNnboqRq2G4jnoMBfq+hfus2zLfzeAYWm8DIwrPMNyy4z0tCngOvCXgU8RQ9hhP3+UmB58B";
  b += "g0gePNj1ylbAFfGt0Pkr68b2UPOfmPZCSpbijpA7m3ZCSZfjiSuqKLHVcUpfjcSX1vCz1lNwFeg";
  b += "P/SKAJyrYnCVOBVYoVWR9y5Imcpo9Ikr1qrC2IJoCVMxqtCEtREtD1xGgOgAsF0a+xoA4JQUgXS";
  b += "HrNkOtFsA2XcJ6UVpXweYbI7/kYX2TRw/WvjhfKe+tkYyxKOuIu0tN1y3vrlateHc9PavFiUtX1";
  b += "yAtbIle+Ou6D7or1u9NrXCgjGgbGj0tVIxycH/cjWIU2lbReHLwALqCa9wKJPoY3i4OheCmCF+L";
  b += "BJW0eDl4EsULzggTxUUlfjIPV8TIEF6L98f5xsEYOdmnetdiulPQlOFgXL0fwErwV9AccDEOv5T";
  b += "LvRZCBJL0PBxfHMQJpSPogLcTBJXGI4FJJe0Ivwc7dYTm9CAdpHFzoTbn1kTj3QnMve3ls+8Gy2";
  b += "PaTpbHtR/1x1s/i8+OV2+MXxKu2x0PxBdvjF8Uv3B6vjl+8PV4TX7g9Xhev3R4Pxy/ZHl8cX7Q9";
  b += "viT+te1xGq/fHo/El25Pziew2Cr+voC/F/B3iL8v5O+L+Pti/q7m74X8XcPftSPL3zBy6RuTlSM";
  b += "f/spPAWJ2fgZFdv4l8oDxonilpPzHw5Wd8Sp7ivZ5zAALLZx/+FY5/4LZzvfJ+Z+e/uiP3Z3xBb";
  b += "Od75Hz9zz+uQfk1kOznV8i5/d98HOfLOyMXzjb+fly/rMfvP1Ouf5Fs51fLOd3vesbd8v1L57t/";
  b += "Dw5/9WvfeSOYGe8erbz3XL+Ew//4Licv3C2871y/o4vnv6CvzNeM9v5SM5//+5dx+T515oTl1BF";
  b += "5XBIYQhjQHVg8ErYaQZiTf4wDLvkr8pZ6iRNtkv2SyDf0DN8Bc4w/9uZv21eP8t0H8h0b6Z6sxm";
  b += "tu+CGoPIRs7ETZ45z0b+6Bo7YbDQgdKHWT0PrilpqRLt9u0+gcMROG66wXu+lyQbCP7yDSkhDxE";
  b += "vDNZcsrtFt/K4CEYFGEkRWVLWw2gzEKirG1rY9UjAbVSqCzCqE1tVVR7PeRrrnbSIvfdXl0tDAj";
  b += "nFZ6Kr9lmfUcbxrIMO+op943xD6IrWq9l1ShQyOjxs9CmeUPrhX7rC5Ev2voP3BK8bysfI2L7ON";
  b += "K2Tk27JUHZNF1fj4YeMNThC3rfLU6ettGvS4UKPfrAlc4YUvo4UImyxsJLpXE/07jUR0FxW5r6i";
  b += "p5lk+iR7QhwrYmikbEDyl5pS++u9u+zU+c6qRBwQfuN/TsMYFXE7OcZHwFWFFkYP41VMLUbNNA1";
  b += "n52KetXQhqAg9Cm3CXaRBL8udw9enUjT0pvND/FsABR+BmROHXWBGpFxSenMpoGF7ThmlA+VBFk";
  b += "k8PEH/KV9Mk6MhjQwUIuR8D4HaPm8hwLUuor7/WApBBvLvabLWQez76nMrxJKZWxzNVH1Cwp4/A";
  b += "KqcXgE4wboKR4gpYvq5wFt8iHwJjs+oYAyRjXzStVKPpzj+ZEplK/c/SKRxM7jdOjb9qnkr61Y/";
  b += "nmuf2++Vg1wOmeX7kqjyvoA7EKsDojn7q6j4GQQ0AwuFHitHl0jSRONqBiL9ELFidKHABWOp9ok";
  b += "P51/TVmTYYo5cjFiPmGlJcn7gY8gOs0hCSUwFaA2J2FaA4kLReWX9WEMG8xPHDVANw3mulWx1He";
  b += "eduBzVuktSGTZJaRVCoPO56wQ7vJp371M+0twFpDLOizK5BeourW0gf+PqUAQ4tNdIFQPriNp0R";
  b += "8c9w1l3pQE5SQmxQwJ6WjxtxOKIPeZbikc4HcWkXzavJFxkX5aCUOhVLp2v2aOHPJGU4uTIsuog";
  b += "R2dMi+m5BC6yXyNErpcksB8OyR123AOmQgqEq0VQ6XALRagFFq+JrIW2p5YgKYyVJHouLmxvGwi";
  b += "ITEhWIV1NB2+mRBn3zGBiLxjZLZZa9Vn7mvxbRDhSbGFS0sqyJ0cOBHAp8nNLmsc2QC5dALlxAu";
  b += "RDVSPyGwd5BSS5LclESN5UD3ijAlcSgq3zXnaFpsIoFo1b4L6w7j15rFQgP9nn1Hf5Nhu9aBcrB";
  b += "hqoNnLoPHzULUQDQpEA/4o75ekfjXiuw49P9w1glf4KEQFrhTiEgJ/ZhTfBjXRNQu6drgqpi6HR";
  b += "wYEZaAyRE0G6tcrp1P3suRcyDoQ+94U0RvaoGW0xEvzkVsQTo1Zy7TBEx1F2rnDqK8OdUREKM5M";
  b += "FmEYMyE0uwAkUEcyriPJr4DjWLGIKpyCrnhSginFMRLwLiNhlbTRHragUEL0ERhTkVMQy0bpLAm";
  b += "iLW14h8lKKI4pyKGAHStxLLmjKurJUQbEQZpTmV8VLAhCtbrSnj2loZwW+ijPKcyviteg0wBrky";
  b += "rq91IPhtNeGZSxm/U+80QoIt44YaT/x3lFGZUxm/Wwe57IlcGa+qVRH8PsqozqmMRj1SH9KsjNf";
  b += "Uagho+VGbUxmb6t2S71SujNfVOhH8IcronFMZf1Sfx/myWca4W+tC+HoXpXTNqZSb3ToQJiZyxU";
  b += "y4tQjhm1hMNKdibnXrPUZWs8XscWvdCN/OYrrnVMw73PoCg4Zii9nr1uYhfDeLmTenYu5w6wstP";
  b += "IspZp9bm4/w/Sxm/pyK+YBbX2QRXUwxB9xaD8I/ZTE9cyrmQ26914LAmGIm3doChB9jMQvmVMz/";
  b += "cOuLFdAlK+agW1uI8JMsZuGcivmUW19ixGdbzJRbW4TwEItZNKdiHnLrfQpykhVzxK31Ivw8i+m";
  b += "dUzF/7dJd+liumGNubTHCL7OYxXMq5m9cumofzxVz3K0tQfg1FrNkTsX8vUs/7OlcMdNurQ/ht1";
  b += "hM35yK+bZLz+wTuWJOuLV+hN9jMf1zKub7Lny1qdGwxZx0a0sR/guLWTqnYn7owoEbGtysmFNub";
  b += "RnCf2cxy+ZUzE/ceqJoNXaNsoNzjmeWGq/3ah4tkXJFmb2WXV5ltkIlhm0oj597mYk8NUVd3ogT";
  b += "jS1rxHWNLW3Escb6G/FyjfU14mUaW9KIl2pscSPu15isQvo0tqgRL9HYwka8WGMLGnGvxnoa8SK";
  b += "NzW/ECzU2rxEv0Fh3I+7RmCyM5musqxHP01hnI+7WWK0RRxqrNuIujVUacafGOhpxTWPlRlzVmC";
  b += "z1KhorNuIOjRWMG4qXhrLw1ljQAKAcIdtkAa4xeQWhxrDHV11eUQ9+6mm0lavLTFpPLm2pSevPp";
  b += "fWbtIFcWp9JW5lLW2LSVufSFpu0i3NpvSbtslzaIpN2dS5toUm7Lpe2wKS9IpfWY9JemUubb9Ju";
  b += "zKXNM2lbcmndJm1bLi0yabvcXGKXSdydT+w0ibfnE2sm8c58YtUk3pNPrJjEe/OJHSbx/nxi2SQ";
  b += "+mE8smcTD+cSiSTyaTyyYxEfyiaFJfDSfGJjEx/KJvkl8PJ/omcQn8omuSXwyl0imCK9hjGQDWW";
  b += "urtC29Vg7OpwkBumtwgbPiIguNFciyWOTf5BzdSSJUBvlekgFNIeLGEZq/JJwzAu4rIcfzYNIag";
  b += "KgG0nndmilg4A8oHKIM2XM0JoPteRoLgVfOGDbCU8UIZDHKS8Z7YIkr0tu3W4XUFouH/10k1NuL";
  b += "XnVHAAl1yu7K0vZ2JIP6Hckgd0cycF7GtGVKUN8r4m9JDTQBsFUvtCDtpk564FOHIOV3B9xJh1c";
  b += "z7GK9DUkIxhpFGQ9rijUJHS80US600nIMtW0TnVg34C9XlEXpyjnKkOhFxnsmDqPnIwpceTjNnT";
  b += "5dJHgkY9f0JWF0LmXDUiP6hq9692+o0DuQoyApc3M8mq8Z/8RXxqSi8qmQP6kEab0Dmt/AXK12T";
  b += "9U11DiqMSuR/y+nc06hQWKfUFVgcSP6tm+0foynb4HbNe2c09unDjnpXzq0+EofxcGDhw4ZyDd8";
  b += "NKQebJuO1rYxQJS0SPHBjuikAELk04978ujl6Pw1Xn+TGbCDFlnyNYV79zzqEvGooZJD0WW0iiM";
  b += "+qnysFfe/+ag92aNGaPHYPouar3txWZ+1H5vEhejPPXAqohVCaXHz7P1o/XRCn92CBBO5DS+VPu";
  b += "4uzNMDQKoroih9Oi/DVuyXp8jdE6QvAYh6wDkFeOmIrSZKOuaU9NjfWCdPmMOLECpBv8iREgyIK";
  b += "CjBynqUHpHSos97dT89amIeLwfurjQfYfUUwy96W0AzCBjocTEEOwaaIt/v6fbJpEcjbWBnOnFE";
  b += "XE8n7lrr70XYudbfg7C21p9AWFjjEelziptQ3/KfpU0oY7plN6Hov/B0tqI8bkCVzFaUEo2oppF";
  b += "4r1ESpHt3T8m0Gh30jTtzehcS5ksCe2CQTuK4G8eeqqwVkjNQKyJfkatXN1Kj+eo3ILUuMAchVk";
  b += "2/VX11XSBqr4RpCl40/EWnyOHkUsejqLQuX/4QY/BWGOSojP7NpUqL7ge66kxdJQZx9CugJl3ZF";
  b += "8GjWVTq6LoMDW72x+hNldsJs19T5nKzsszG2L3Zxlj2ccl2xH7sojkNBkeQxwPOQ5JvDPLMqTJX";
  b += "vgCw4WH6F84G+f2us2FTza2MwOCI+nl6LI/ILDAiPXB7Uhxx/q9g/YhXLxAf7lOf1u0Q/Ntxi+S";
  b += "Fl7T6x6VOtMtVSIiaqx/EgPrcEWCNtGbcZzM6MzPCFwUoG0X6UuMLLV17rU+3L35vfuRalxrlri";
  b += "EDhlpOkYZCFaME901C0yNlxPsKPgxSBMAIr2ykkz88BGvF1yzRFb56FRhWpRV+nBSw98GhytRAq";
  b += "uGZmRMGdQpnoT2uaro+fWEKsYsZhgwlUvFUvsZAYKZ4FKRVAmCgKQwpnWu8kgxf2Z7Th5wmYY8l";
  b += "ebnduNLn37Taa4WWNjdoXKMfCN2LkdnzZdYtEh+NElBa1cUlVA/2QOH0udsl3wHd+HAucrkvcZG";
  b += "rTDnqRUl87oZB5/AMpevebyiCfVJOTxMyHbtbnKmDLZigjc9mWjGw/SgCHs8Wsz2/LuJ8+G+ebj";
  b += "KUODyixzydgLRGZqGofK+mK3y0ZlFoZE4oDjhk5eXW3qMeTHrgCFjCVh3jERCQepUhGM6qNk8Vb";
  b += "31A46WEmPtqA2UzBPgqrdS4g+2QQSlkSB5VbjxZtNr39aOwoYzGDRgwtjrkYIZCHYZqaCyYnbFp";
  b += "sYe0GmQGXBpwhVBKH71TZrzVas7gpasNtJACCvG9FSgMX4+fa/WiK9Uzdj2V3tBslmEQsQuLuBM";
  b += "+93huwM+rog8z+wlMru4K/6RPzfDeAjb7gaM6YVEdOuQDY8qKvohNxSsAsngBzcjd9FYCAHroAA";
  b += "Q0BtvUBDAAHRToDzoVZnsXs3U10i870d+w2GCNc5vP4p03+1YJm074jeg9SIYawE9EmP8oVknuF";
  b += "dB0A2dQc1rqCldmeP+ErxfaJ0z3FLTZ38bGnPDT4gZrbqotptradE+GZ8QmmPABQ0xKiCV8EUD6";
  b += "4uIskqH0b3dkLBHYLkzf9p4pJ4NDkEve+J7ceXmXp+/IsUyg7e6BdXoHJ859/i6dGGgbEZ79HeJ";
  b += "pytJLWt7hHhJy7i1E99q36OXeoj4e3uJer/kWb9DC8BKHrqj5P/s7rJ/hFe4p2Fd4l3mF+4r5Vx";
  b += "hmr1ByWraR2V/htBk5b53tFaLBTE+d5RWysw423+FKfYeDz/QdounO+A6DinrePy5HEwqjq9QkJ";
  b += "FHlVymWChzPV2BRI/3n/LFU4MQdrRWYzlcADftGfNGW6zwQrMnunw1Pusvh0c41N+/XHtWb3omp";
  b += "5Fw7lZw7cyrx2h9hXfMRLtZHWPfcPoJ2Tn6c4HdqH2G1PsLQUz5CRadcKYPzsIaTRUBhs0zpPOx";
  b += "oHy3K9PZuAuZKb0tPSDS6E5cXV8jNOjC/D9UB9T7YiE77ZBXXsBchBHaVGT1d4xVlAIhMUcS3aS";
  b += "h1SbA61Ij+wefKGQv57DNeVAOEdxovnczXmgtU2pVEWi5FLyasy2yc4iuCHSoxhipNudlGfJAUc";
  b += "NLSpDjQlDgy3CpQhoYkYScM+SqnlLqggIc3Ns6nMcZV5hejyAeqAqQ+w1/h9651mgIAlCK+6k0y";
  b += "1QjkyuwYkCvSXnpcMZ66XcZ3GoYjqxyjj9RFgtRDLTdgqvB3spTdZv1L8CH3PwVvaJUWlP82Xf4";
  b += "HsE0oAeTnAY9LnYxF/r/DCSJ1foMeofd7WA2Gl+078r9u+dHRb+2429Ddl1J/S3rqsKxZzvexSJ";
  b += "MLrtQF092K7yuxDyS20JM7fje7wcnTvzuG9ik2aeiLloZeWyuMwzssg31F3zcXKNNG/5NJYYayA";
  b += "srU9EOfecjhxlrOJXvY6VUn3h6VLBbr1Bep0pisow/KZdE9rkIF9NK7Ql7cFcYAH8yTqbw2gh3A";
  b += "qEl9deAai/yLL1fSlv40GKsBUsJBTfbA7dolHmDem7yiZx+7Z+bZTAg56xMexRN2/xd/wq+6med";
  b += "ToLpJ3C9Yz9AD9w7HUUCwEaw9n1BkvDpd4dXykeCISsdEqSFRx3wVlGF2tZOZS3pNlW5slNlY4P";
  b += "fpMw0CH584cr61PSLaXqoAHZayqqR0iuqq47SkVUSAtPS88mBfcVVFMB1aYyjMMNE3iaTt0P4n+";
  b += "j2ulN8C75DM7y56L540TE86Bnn6YEjSDmhj0Wj4CEZ/Ru/OcReT1/qcnV5o7PSm/tSSD7DQ1yVu";
  b += "xkFTUkqE7JgECFHzuFfNUrNvzSmd+WWFGp7lsb79lI/1vjM81ugZH6tpXxca+7rb/+y5eqx/Kqo";
  b += "EOGUoEmSR9aBI7S2yBRSinb7nuESZ8TYoV3Eh9a+gpxlJjgspHe99Cl1mOW35ZbME5GQnjB7xQS";
  b += "AsElckS8xSBlWfMfgZcj/liZ90qRI96DascdKxis4LBfq+hKCs27EZnM9SGgigxwO8kNCW56X7s";
  b += "IS3S0Q644T0e1FiChjBghbQo39LSP+fPW4jOoJRNEUmMVlyRr+pc8rxkkr+x0rUBqB5pqAWkfBI";
  b += "KXGjT3jNdhtMXV1oxsy3MqFDVLrnTxU4jzUlfz257KODVOaMBzVqoScC6HLjgN7NFGZ9LGFoca2";
  b += "22KwW1y8yKOXhoYJ3VHOVsYcGKu8fK3ExRH0StjPkr6PBykyiMl9hub3UcCggRb88it6tR828gc";
  b += "7Bl+JnxemUe9wsvR4x66djJWWRTXyOelzLtjoOoiIoc9/rmncEQ3czMKTtuRJxOV3vRrOk42WCK";
  b += "Tl6m10E8ZPFJFmh8arWSFPhZUVPImFPuZGOH5iiFmychoQT5ehdro6RotWEQEFyrEQNCWglyR4D";
  b += "h99yE8+ZVDH7cgnrkGNvMwFl7Cmv9YfQPTrIIyTv4bOYpwtN1kMXXJVutA83mQwaGpnWiMs3dw9";
  b += "Plcmbbq+D7ug7QVxCX47LY+alBtLYFe2MbHYZAWYZispI00hl7HSIpk8nEd+XzYYFeGTlhvuknw";
  b += "33o94zHu5a9dxw14TmcP/K7MO92VQ6UnW4T3kc7ke8bLifrLUO9++cYbhn43tP2GDmswz3P28d7";
  b += "lJw9PnW4f5bz9pwf+wTv0TDfdefPXfD/duzDvf3nXW4jz6D4f7IA09nuN/1LAz3YxU73D+jw735";
  b += "yQIVqhu9145yRqZCRnS4fzA/3M11GO7TTz3cT9ZmDnezTOBw34VVwhOfaA73Sd9gDwQ5Zr8dyqj";
  b += "o6OqSi+qe2UjTj3/qkOEHBxffarb/UAtX+lA7x3ipoU5AKXQZr9sMZ+GrFAiKgFHg0gvS4589RO";
  b += "48eq3caQ8CcpCQP5wrT7Unp+Or9qZq9HU/YzJvrenhrKZ9WlEHWzCt9b24tb6WYK/ypeYuOn0Vu";
  b += "GinTtpplSxKiuiDsexdPuyUDSQTVnnypu5xlTSzVHe59y4ShbplG4nChUQRYifUVdci+v/A7rnG";
  b += "+TeTKNycROHOkCjcnEThtkoUuulZ+aKRKOJsd9t4VyTuVS343UBbwnoVk83GPsLSAb87MPjdrmF";
  b += "89xW+yFf8bj+P3+0b/G4/Vg9/xe/2+ZBc+ip+t5vhd2caoSZ+t6tsqv4M/G71VfgFP87fPNuPc6";
  b += "j5OIGSLgNOVyq1kQ9DpYunwOrkY5cnIbKZPIlvniQ0TxLok2TA6u5swOrsnHiSvzLA6iHFxyZwv";
  b += "N22UZ87lfn4NOo65je55w12cOWfm48AqOBH/vIh/TGY8FAU8TUV4KvipHcCXAA/2OpXLxt8wr2r";
  b += "yD9LFVWYHue+VBUgMD88RJysEN458BPyob06bMr3tEwcGncnPUiPagZ4+6hTStTtOupl5MD/xZw";
  b += "3tKl6IENJMtmyU3dUqlPR2qFvxSJ0V6A/Ouw6RijnDrfRm+VFcxgUujT2sNJ4oSmN07SC9iAmi0";
  b += "fSVK6TCFyRqhhu0DrkVAV6CHem2G2cF4mLMeOMa8+0ieWWaPptiyzGM3w9SsaAwe5nleIS9rPKm";
  b += "DcZj8AYso7GMnY/i+nVpAOGDYyXwOKxPi7Z/Swmcj/rao1zP+vKmBx72M8a77D7WXuK8nWOPhHM";
  b += "dAkZ9PYUzbSPvYgi1gI36MHtRTDTs69ez8xB6qll04lsS8wYq8ORXw6wS4VhWeZ+mMLspZ1GA9y";
  b += "j6mdsw0zelVMvFxrpJ5rHVBp1ZqYHQc5F1VPS8A7l31Kacu6zBbptKkvbu1rV1nvvat0qOHBXq5";
  b += "p7X9t947PcV90UovsDVmDQe42um1+l27LjLtw6Br3XcetGlv1xJduxQ+Njhc1qHgnMnt2eou727";
  b += "C3SBWKSOyb7itjnznbtamv9A76Wp3pwFIXu8Qe4Ul5cbcT/zZpvWEpppaOb2Fqwcg2lj4D8Ir2n";
  b += "2EhvNxtJwHDItql5m6nA7L3ImvtIYO3++SAuKEPijrhst+LctHhFLbC9CtBR5oHq9Mg5WkqAPuW";
  b += "ukA7ER7udRd0p9580D5b+FYliHy41d6vcC5wvli5y/oIs6MPOYY/18na72gH5IHI/ruKyukV/je";
  b += "STUFdH/+mpRQqqcrLMbrq3yB20ciOzBtBd0nIiT7wH4s60XFrbL1f/oRbPVh70pss17jXEjbR75";
  b += "v7PZNsG08H3tPaqKTk2z8Ve1T1brzI+iKjPdJl7UMRLS0+UjSWCUT674OeFUFE2n42TZd0bWp7t";
  b += "DbFivVKxt7+ndVfnQFvF3t9W8Xe/J7erI60YvcHXGi8/2/grzbH7283O9u5/r+3+Qa770z/EdP9";
  b += "su7NmOvCM7r8l3/0hXh0JZu3+uGf6oG+7/y7b/UBn19L9D/h6ESAuJv2Wjq/dDd1ftzGnAnT/Qq";
  b += "7739LS/R8tt3X/o4Ht/lN2+L2NHfOb5Zbu/43yRc5bitr9dxe1+x82PoBTQa77Z3WLvvDcdv/1o";
  b += "1n3v0x72fqff/cfZ7XY67LuP/um5s+n+xcrza8jX8tCUxPLsik1+Uz+O9PZSI+2fZf+8q7cndG7";
  b += "v2HuvHCud55QdrmsGVbrzYee8d6ua/Z2n6IZslGp+/gYvmFrN5OlRM3QMleN1ZWHLp09TlDJ+ug";
  b += "et9UAwDX9s8UAoPbsGAAU1QCADL9NG4D2tvZzbX3AsEBmjX2dNva1z7SxD/hPt7Ep/RwJztDYU8";
  b += "EZG9ttNrZcnm9sTHlsbBB629a+Wlv7yp9Pa1d0Falz/Akb0dUWzo13qAGw1BBb+CWYBTBcZ46xK";
  b += "x19H/v0YJFWO8MSNr3hTG/M96dc4iRbnW+iwFuwpX2pQfOiEiJaa6C4gGyMM1NUc2LdjjPHwuY1";
  b += "0wVu4ssRzpwsUtXGM+PlBu3HkL6nQ+J6jwpM2QO9Q7Vhy69BQ2hK75S4lt1FOBMtmb7XL809wT4";
  b += "1L2atUZuLTD31CV5s6oYnuEhrY57gxVqL5jU1+wQv1nvyCXjNPH0CXtGDJ2D+hfoEzM1GZ94+fQ";
  b += "LmXYonYN7l+gTMC3+M6KLK917sna9WrhCKOgcMs7YRijrjTghF8yEUMR5B4FmnbNxGKGJ6FYLTZ";
  b += "Rqnkd96iRuhiIkBhsbVGhcpFkJRJ4Qi19y5Jneu0eNEPusit9SoOqbBHwWd+caub76x66tldn01";
  b += "teurtdr1eWo2ujpz1jcj01NHAI5h3AMdG/c1Q7kGpWetiWxRAwF5BJVnjRrTmtQ5f0p69npJHAI";
  b += "ATU0GQT3ApkJgxUt4tVaN1FEiZ5XIhPtc/B5wReqA7Cgfd/rlyeg44dVfpGOnBI4nK3WU4hfBVp";
  b += "bFJYtQ41J6ADNO00ZWJNAVHljiwSx1wkDI5c4GPDtNk8pwNOmS2nXhFsliCsF2x6CLzO8LcCuA2";
  b += "kE70hcvwc55r9Y/6UfasrgfacvT44eniPoS4y120LZEHmkxNiZOu2TYKKYnMT6TjujTrkikF9br";
  b += "/E34ew5/B/j7POlxF9afrxdI7NwsNpjFVmSx87LY+VlsZRZblcVekMUuyGJDWeyFWWxhFqtksSi";
  b += "LdWexeVmsJ4vNz2LVLFbOYoUsFmaxIIv5WYzGsBofdj4KRbk37HyECvNh5z6Esgi9F2E47HwYYW";
  b += "HY+RDC8rDzpwirw84BhPOHnf0Ie4adP0E4b9j5IMLuYecehNGwczfCyrDzAYQLh533I3zhsLMP4";
  b += "dCw8z6EFww770X4gmHnLoSrhp07Ea4cdt6D8Pxh5w6E5w0770a4YtjZi3Bw2HkXwnOHnXcifP6w";
  b += "88cInzfs3I5wYNi5DeE5w847ECbDztsR1snsAKuwBI2Gb0GZG5nROCaFb3pxOe6Le7FrKmt/u4E";
  b += "C0y+ZVzsiSASF6H+ibe90QRsOQEOqhtCwewqNNR5vLxMBq9mxxtuD2bmMbZQiQAJ017QIS94iLH";
  b += "nfhRsttmOjCPBF+Z1wm0TdRYrtRZKvBFnaEabBGMK3aSAjfQ2XA2V4I/HT4GGntCNeFi+P42gSd";
  b += "dhTgkmquZ9ktDt1eFxuzJexVVtMT4SGi5u3mw4bcfPmx+Wo/bbHQFKJLslvJW5b1qbyKEUdcdVq";
  b += "uzd60mdjGU7fgx1aQkkkMFa6A9+pYjrZ0Yi+i6bD27g5QGMd6VDqmjS+hoNeP+S08OMbETESxu4";
  b += "iq3Vo9ug37dSgrdFsZSyJ+IiGsLyoUh0eM0uZYMrxZopU0zkWrvXHi/EC7BfZwqTKmC+LmRlniN";
  b += "sf7og94CLxvMw7b/e1UlB/aiUbtNVTm/QjHeT+XCORqupDabKo2q4ixH0GEPen97euzE7tb117n";
  b += "tzfujI70TxeALXlpAsOeeiBF5AzQwIuyhaYRZm8QSy8ZI7twmeDWsIunbVVkyO90HvMI5IltlgD";
  b += "q99BBG0d2HYO0uPw9UwPhI0MOPQYU/blUo4wZW8zBR1tj7TzlBcvwiYe7+mlMkU9iA7xorXe/a6";
  b += "uJCcpToJ4Xn4OUppIXowypL4r/Ek3eRGpdXH+xVh+LsLFSHBQViXux3tbgh95vJB+Zt4O0P48qo";
  b += "8tn8t9Lj6X+JTW8Xl9HJ/X9F43U2qV0vcFSPpmZoJdiksi1XsXOXfJdxIT650IpaVPePqVnfb0M";
  b += "1uPdENsIciAU+rjF2LzG8CTIhFW9ez8AQBBLgS+dlUTpy2KkPlclqPHArPCqUhyRQaE9bw0Hqvp";
  b += "UPSVgLv7ktYNgyp45w56r8DP9fi5Dj/X4udq/FyJn8vwQ+6Zi/GzDj+r8TNEV1n8DOJnAD8x6Wf";
  b += "w00u2GnLIKEQwrOK4LcJNkU2z/6PfGDxKXdqkjpj+W89ii7NYdxYra0yGou7HDDXiblkwXpeuqs";
  b += "+TFYp8P30zZXg4My/dNoblStyT9o5tVfABpMoqKDshA8ieA1gfTru506XstJQxWu+hH770jHmpP";
  b += "5rMS7eDviT6v2Ecu0rd9bek8dimdHzHJnqRdatTI2ghh4yJGhMqCsa/G6RsURYDJgBaUX56oh/4";
  b += "CKvyha8QdJqIZ14cbuDOr4E8r0YfVxsCNdDF/kZFCqIopPC7HNg+sMFlmVvVT4HMtB5TAHgoYzi";
  b += "6WQ/L6YNYW0qZOIRxc0UuirQMriejeKFxgYpQ24XZchDViXTnNtL18EJusy9Ud05d+3lxFB306P";
  b += "zFNWvAgRZEfyjTJRegeyj+qqX2UixIM4VBScemGUzUxZTUAbakupiP3dGqi/lsm0T+yeYxRxHkV";
  b += "TfTxbjZlo9r9FbWA4o7Lo/JKa6CpaALzL0hH2C3Jr1ZSpZUygd8Tgj7LPqCswkKnBLw2LBHEAEK";
  b += "rVWCLZPaIjwrQsN00QoNkx6EBtXVltLxkC9gkg9y0IvuNULDeGiEhomwKTTsCTPXlExokOKs0HC";
  b += "8OKvQcKwo5ybCMwgN4yEsj8pWaJBbWKHBmG50wSeWQsOx4kyhQerfJjQ8lhMapitNoWE6JzSMF3";
  b += "NCwxoKDWsoNKyh0LCGQsMaCg1rKDRAJ7mGQoPGBrPYiix2XhY7P4utzGKrstgLstgFWWwoi70wi";
  b += "y3MYpUsFmWx7iw2L4v1ZLH5WayaxcpZrJDFwiwWZDE/i6nQwPivhIam0ABzKBUavm2FhvfNLjSM";
  b += "nlVokFXrUwsNtL2aITSYsfEcCA2faQoNH20KDeZ+M4SGP0cr3IXnO1XICw0nC3mh4URhptAwXTB";
  b += "CAxRXvG2L0PD5MwgNRyqZ0DDFBWvFrPErM4SG45W675MUZ3ahYapshIZjFc0e/ZadGozQkLXywX";
  b += "JDHzETESaZcjKXcoApJwotQsN0Ya2/r0yh4ZgtTKo8i9DwSCX2VWiQ80rDwkqRh4WVzAsNxysQG";
  b += "qTbHK88ldBw/wOtQsPRB1qFhsMPtH4eH3ygVWiQtfhTCA3TlUxoGA8zoUFmbd3/gtCwK6TQMFls";
  b += "EOPAyAhTngoN+2zCKQoVJ8pNEeEkU6ZzKSeYcrzcIjQcK0uPCig06D0pNBz1VGg47KnQMOXlhAY";
  b += "RPlqFhinvbELDUa9VaDhZzgkNTwZWaJj0VGg46HENsBuf1/RBL9sKLKUPF5F0OmgRGv4zuMj5Yl";
  b += "GFhqNFFRomQv3Kjof6ma3PV7EgGnB0gVWKIxUaojjKhIYycEvkfFWhX+Fz4I4mPQPApNfPZRh9K";
  b += "zDuahXDYAvBoBvCQ5DDXJbVF3SLTfFh3oAj46kS94g8ohSFspCITFg1YcmEgYYEdtV1vjQIFrsJ";
  b += "NoqxWKYowrUkwIDlZt/EzZaYJf08WWYPNbigr2JBX8kv6OfJDczCvNJc0CO1uaCvtC/ocdrNnW4";
  b += "u6CtY0Ffsgr6KBX1VF/SoRnQd1+qmGlIfVKOq1fBmVKPK1NmrUdVqeGeohtx/VO8vN2OlpK1exW";
  b += "r0cLJIzyhdzFNhIiB8tBEvuOSX1wq75OjWQGJRFpMe3g35otvIF91qVdNNLyZFv44DlS84ZnyZm";
  b += "z8eNHGbPZUvug2XrydJPQASVPmAAkS1Qc8QShh+DZJPiAEPCcMnNPtRr8FScQg5BkTORsIglsj8";
  b += "ODISxnzUN2qRMOarhDFf56KIa+bIShjHOIfPz0sYWITKtFlsShhTxVYJ46DXImFMembkPVMJQ4b";
  b += "c05IwdoVrWNs5SBjynHOVMCa9mRLGdJFwDDUjJHba7bZOs93WabbbOhXIl9ttndl2W6fZbus022";
  b += "2fNHa+GYedp7bGqIDS5jrqDu7L3KH2xTQSrUqw9zE1SvTTcwyaEKE+YBvvK6RQCSAuakS6soFcj";
  b += "pbjaTmelnPiO7ac87Qch1e3Fjdoi7NIQ5XPmqpDj2LwdtQ92SDisBR6J/QqMonCCqZ7p2QheLNP";
  b += "adyJ3hoo53fEbTm5o5F0aNjeCyPJSLFEFGMlbVrOl9bSorDaMDam9CzgOwEO/KTcJV2rHh8nED9";
  b += "8yBigp0Ea0QT2PjxA07Gx3YISHGTWWlLNKeW15IwpQ2MpGRiHRfozwM7WmGzQZLLde7HNYHIuHo";
  b += "zWVPILxsJ1KNfc/eoi4Uae9fKIQEvhqKuE0frFmndQgwHdZkZTJ270VT92c/gj36FNe6woNUCEy";
  b += "ZDlvUxelko2wb4IKEk7w0celPb9o7rffEd+E9+rwoxqv8HO8155mJuA9ARet9Puzu1wt1jhDyYB";
  b += "bjt4y844uGWtP4gWAi4NU+Nb4lDTY03v1fTeLL1X0yNNj7L0SNNLml7K0smzjDMOfGYkkPuG4Bi";
  b += "o7HabTPV+xurmq2V0G/G88tAFc2OCV663PLV7CzG8nyeGl+7HL0XlzXOozdqfV2XeH7gdTVYSSy";
  b += "ni4YMoo8wx2GqAQStQ8aZgO3EFO8RS8VcmLh3xQcHMNdKkgrnDQWOV8yrQhq1yfj+pblRsnjXeK";
  b += "4GnLx9Q0FYSl+o/FUFG75aEsnz/gW8QeZ10oKGsbkoOB9IGYjsmtL875ibYBk4hD5SuMVBBUy54";
  b += "NJn/CKMB4QiKSlsdb6gZXHcYwykMEPkgQOhAnIEmt4mrjkZf92K9RGr2YTLCynMNO1NubKoJmmi";
  b += "cgX/N/bDgdKIPeyaDORU0vZEUhzmIbiS7g/qaGgiCUD1qJ3MJdLk90ExA797nrlWoyUlCTZbj6k";
  b += "b4ysXyN/nHhloFsx3eTl0tOjcqImPcYRfc7HSvpHH7K42+1DxznE7ZQgyPS+WNpr+edJtgR7ICc";
  b += "Dfh+a2PFZ1XPNKJ4Gn3nZYzX/NowXAtmmGTmtbl8x/AJ+KEQx/ldNJc4ClK/LVoTruO84D6KxV5";
  b += "B9kCyTroW0NueL/Q7F3uSoJ0z5KkwzpN+jo1wSaHp2fUcoFu06P8UF1TD9Id6vOxsU9Xe80ciVd";
  b += "XgEx1UzBzfklZzytvA4aZazDMrLe2uuVQ84+xtJ3wFTJSAvZCgIOFxLlI/Q1Kby8fRDIISwwAka";
  b += "FGE09FCOOkJ7ElLDl6udQHP0EcrlXHD4UJlBtUJpp4BnBm2YEBi0EvXWKJqVz0Ja6hS3CrVFYEO";
  b += "RFicaDycPQWorHIOaLSO4TIyxNzGszCcusl6vNfzfxQ3oya6OsKFdRMDU3k5lfVVImOb1scKmBo";
  b += "KFOKAY5rrJS2WX8lDDJ9BXFkHgmusHl85vnsjpfWFBEs1r72U1891+XFG/ASKQ3v6bXqntZkfyX";
  b += "kP4c60Rc+f887yleRa/6kc2MS0AfEwHqlfy3nNqZggpc7POEZr7Ea8Uly7jeZY6SaohlXKXCrWs";
  b += "YWHT2LgLVmYJRH1O8PQQk+XTLQSRtBkhVA2tHdLXUMp084ctp5eVwYcX4rLlzbR7C4dP41sKnHh";
  b += "BZeTPszt6FYOvOvUMc2ObFfEVFlfh95yRuklOLELt6G77Qgh/UC3mk6X/7ufNSOfykivdceSfft";
  b += "UUeI+emDSLxVEm1DusbFR9dbLj1M0ELwIMu1ULao9I3zHbdrBjPIReNxakjurWOQ8TNln9ptere";
  b += "6GWrDrdNJgyNjiF6DxnUPRV+cOPDJ4zp2pSat4+op/YajyydPGVdOHNZ1s2eWt9anT1fNBlvyDi";
  b += "xyH/atX9+tZxr8LePeaxn3TjbuOcQtr6wd9/TOCrJxH9hx75px73Lwt4573KDyTtdCycU5VEG/F";
  b += "VVQXROTIIcqGPEpo4YuP/sNqqCrqIIlw53qZov4KAnRY307AWJQrtV1bRP4z8+9sbeahS4ECwer";
  b += "HYhpWBEffe+Uk62fZQ2osgUIvxNFMkkf3U3ZgmTrbw2kmz2xm2IAWYvufYvEJ96aoVXg4+k0JQ7";
  b += "5U4mDuaONMDR0zKyUW3gbZl+VWsCSotO+cQ1e4QWEXbRLbCywrbTiWJjM3lmvilLXuDxncEq+Qi";
  b += "e7ygnPhfO7zafVdB9TTt3LeYHh/XV6jgsv3Ro/bunRvVN675prPoHqP4iRVKl75uVAbvZVp0F6X";
  b += "U/Hl9ccX7kvmqIAudFNtlP9jFXb+96fQ9VutQto31Anydkp6F88ZZ01jLqeQebLUpaoe7dI+FNy";
  b += "f/r0+zRlwZqFzLPNFQesTB1d4NlEyZNdiHU3/Z7/NvCCHcU2Ri5YngIJRXUpRLwKFSvFppSwmWK";
  b += "meaZw6teYfyH6kfxsT4qXeCYlQEoQF0fiiRF35zaeCvRUCadKradKeqqKU9XcqfIlUBLgVIRTUV";
  b += "zOTnVcotqBC+GpjZ+O7FTlEvqxyqlenOqNK9mp6iXwdMWpfpzqj6vZqdol5Jjj49QMG2kpPfn6Q";
  b += "46k7NzW8nCo4ba4lD6RP5s9nz17Kn8Wj1g2xJxZjifzOfCkHe05xm/O5cADV9pz7MrnwHNX23NM";
  b += "5HPg8XEiruHUbnsKD09MHLsHxBkqzA5kHBTsQbYz5GdfuWDHs9mlvOiB4GeuzU43WzvZbxyp8rJ";
  b += "PV3oAiKhfMWOafswiKcoEGPrUx6TEqm4QRTjt2JAU+ojKKCtJ1xprEBY8rLphc+yHquDiiK9U/j";
  b += "DDsMrwVjHsf4C1kWOoQbkwq1NG0I0kmSJ2iEAt93em5Osjx6ed3+hjZHzH1X2bpmS9ooMZdyGpl";
  b += "ZzbVHdypHyVccPDmK3f8DLMuo2vwcbxAnLrOScPk+ey36d7Pik/pWiEMMJM2SGH13NeOvYmOczS";
  b += "XmYA6Ob+1rws5qbHviffxcO+6nKO6wGnLQqy0y0J8qE90UzI4E6Gndh+wicsIJXVDVIyJsB0C7W";
  b += "spzIzsO5a0n32wFfQ2Hynq4vyNlJaXEeGvhlktbKWHNNZW2pyc9Mv3GjNVjkxgDqJ07lBfeez5r";
  b += "GAVLm2y42YJqCVReMwxIWebiyBiyT98h9P6atNJ99psBb3e9kSdAYEoqpboYYdyPSyF2e6Wo+km";
  b += "+mDD005ig9AJAmfKlirpI0I145YFWASbUunM62UmlpYXxXV/+or9USEXYDZlkVWEQsvcAWYxGtx";
  b += "jCIWX3t+s3WBpopYQvIbTaxzFk2s6bmVcdI30ktZfcXgnCGyX5/xGcP0QHEwaFpx6arJQH0X0vJ";
  b += "oUkwXXSViRHFLetv4eDB2+aaa9h81GC0Z3kxy5yj8o3JsgBymsr259FSXcLafq+0HTytUDO23b/";
  b += "qQWWl60nRSm4OSII/J8XMS8aPfssQDSgvYbFI6FHGl6epK0zUrzckm6ocaLHIBGOgOMp3CqbqYG";
  b += "pfiF6eTEkSPqNilqgfv1UTeh7IFqgyop0dTb2vd14XRgPaH/mbHzt6X7dget44wJGws4AvuiemM";
  b += "hP8b+9AkBlBvQnXoFIgPyc1Ou2NpQYW+b9nDjewv2OHgccdGqJoyqFCkWZAAsAkbuMl07eiwE8x";
  b += "I/aozS7K8yqDy/2Xg/zrGHMNXy3FjRlwaE/lzlOMuJVxdTwKMBSlux+axdPnWy0fXKHNoP0/ip7";
  b += "eeX3pGgCTkuN9Ccs443Lqp8nrqLdi4A/po/fk2hNuMP2s72/eQBFmKmYKy0eca41D0SAikjiLPj";
  b += "KbB1oTnr5L3MYih4+bJbWNXeTwMbIVPRAvUDNy2dqoJMdXc5SpdLGsdpo/sf0i5cNP3kj4ilJhO";
  b += "NiH1jZhsQioaISWHulEKiojfs1KSUmmk8QbVNkASMlYYOb2hKuRzMIBxE1c1as7CTRjByOKsfqB";
  b += "FzGjqEzyrT4BjcXOTHAKpTG9P8CWWss2LbE3AdQXAKD21FtU1gZFTmwDsHEyVxFPIy9l0OF5u9X";
  b += "GTq5t3lFBWOUrqkTpXdGG6cg2nLsVkxdgxGC6A0Xmzat9bYHQSab0A21qa5dZZcHhU4+gin1vZ2";
  b += "rL0MSKrTKY6wzsZY4NyuetDlnQfLXrIw6qrpFk9LsHKwzO4fwyZg+H+MZqr38nfdnZFDz+Mrr4P";
  b += "qxRrU/nMqhT7D98rZXoTdHB+Dgrsh6q7L9FtTbF0vZbFJ7Fd/GjcpzSpm+VNMDmRRgm7FFg8Znn";
  b += "gAHhyjlWhJhleptG4+NS4yI+qYktL2DmgZvHx40UvB0DyffhmuvmqFI2SrgNKZ7MqBtK/z8WfDB";
  b += "oRPZzr2UodqoAHosTFWAKbzxfOXNNXL6MA8yks66cw0F1Hv2HXxw6MBAK1ODBaH2VISjvSid1WY";
  b += "SdHV2R3ynR+pogOqPk6qObrkL9Tb7aKPQ+wUVScV+qO2t3AZt9pwgArE46I/iTBwR3qjhLTGzxp";
  b += "A1HEFX1BmuzjQZ0QNyC5AUtGxUJHxU7l82W3usPsFJW0Q5OtHKZ3xqTGMyY1nv0SGpMaow9XlaF";
  b += "vTGp8smYlQWZSgy+Ab74AWNEak1cY1CbAAzVET0VLc2Qnj1SEw3c3+3JADTGTuKopEoY1PWzwuY";
  b += "Jmf6bdWVLVRZQ1zYvUZNJrYo0WKS3gU45WTMqjUpZ0DK1EB2iI0P0reeSmclzmthgU5imvC4B/t";
  b += "CUpc1FdNtBNAaGb9nk31iU9veutf+VDXV2vASFJlYgK3wQMuRsJ6GRgI9qQnGpywxYkp8KsSE6h";
  b += "amZDMPZYJKdCJa5ocoXJBskJ1Eol/FSjPxVhXId/+jlHydMdbQlWi2TrIroFAWjMpScFhHhk20E";
  b += "bg1uHzaQl8jDSMpWKpduinZVaVRcNiXpRqYRossLNyX1eJjeoA1PiqYIHMoc1GoIwFr3EIEd61E";
  b += "3hyzNFTi49M11oxsfL+Vzq7qxn4OScXdGVu2JeyxU9uSsW5q7ozV3R14zD2TjLvzyXv57LP5DL/";
  b += "/xc/sHszun0eWZrNHsuNrOMo+kfOmYgSSxf1fEfO7ly/y13MPXvuYPp/8gdjP80fw34ebNrbs4d";
  b += "TO/KHYy/MXew7035a96cv+Yt+Wv25K95R/6a2/PXvDM7oI5vwKxISk2rfHrRO5mC11Fp0Bmhzhd";
  b += "fyKraEklH/v3WVaqqib0G1ZuYEgx6n0/dP6YE6m2C6F+9ODAQc9EebFv9q2fgsLM6+KYPGx3MJ1";
  b += "oxvFtkCey9G1Q3AAEaXCj9Drw60Z2x8MYrGhCv9tw6BWHj1JumVNiYRcLwMwmjXx++xy7ick2kq";
  b += "+FSJlE4rRJFr5Uo9l7iXbyjRuf3YDTp55Q7Zewe/OhN9NzyjCY+JfGGk9SmEmLhy6PU0ilnjNPP";
  b += "pWPkdQvspyJMKSPKZyUwoW9Cz4Quw6J+JIpSRIjO/U32bQiUFF/kUyHz6egY7ucuUXg+R4NAg5I";
  b += "GVQ0ig+CnQa8G/RrEGgxoMKjBSg2GNFitwToNLtZgvQaXaXClBldrcK0G12lwvQav0OAGDV6pwa";
  b += "s0uFGD12iwRYPXabBNg3FXw10mnDDhbhPuMeHtJtxrwjtNuM+E95jwgAnvNeGkCe834UETPpgxi";
  b += "007jXoxXYktSL7RIl8f7EG5LQ4rlC2bFMWvyDeqp8wrbTvr2rNe+9kwpq21354eKN+WdB1Zfabb";
  b += "ONm5dBZKwR64knWiksvl5Sw/nFEIqxUDBGZmxQKtlp6dUTH04KzH5iuMigGxVCoWmIp56W4XFcE";
  b += "SmdyNFLBj+iXccsiJXpHuqAfG2u0xxy6Pgs34vYErpc2b1M7CnCrx+PHsuMrjk9lxxOMnsuMeHp";
  b += "/Kjnt5/GR23M/jcdcexzzelR0P8HgiOx6UY9fEV27eRBMAIsvq4yB5dfMRhrJHgA+mrT6cMm3VB";
  b += "42pnMYvy6oMP05bXTh22qrC09NWE66ftorwBTXV8+Ac2qyeojqH8imSZUKLfpIuLDNSdfeogP5H";
  b += "rad3IYq7UAbYdgTX42dC49fhZ5fGr8XPuMavxs82Rq/Ez+sYvQw/Wxhdj5/XMHoxfm5kdB1+XsX";
  b += "oavy8ktEh/NywPbl0JH7jtmQ9f1P+jvD31/l7GX8v5+8G/l7B3yv5u5G/LzXbOJeMfPgrP8WOyK";
  b += "Vma2Rbcukl3kmYKF4iKf/xcGVnvN6ekkzxBDM8YTM8fKtkSGdmOKUZfnr6oz92d8YjMzM8qRnue";
  b += "fxzD8jdf31mBtJ8XjKy74Of+2RhZ3zZzAy7NMNnP3j7nVLC5TMzTGiGXe/6xt1SwoaZGXZrhq9+";
  b += "7SN3BDvjK2Zm2KMZPvHwD45LhitnZrhdM9zxxdNf8HfGG2dm2KsZvn/3rmPSDi81Zy7x7vTMfiV";
  b += "sT4qtvQ7rCRf9jV4+AeQw2E21ZgKqdRhdQj6ayX0cb1A9TDNqvs2qKh1CD56hynfpZ8zR0JJekD";
  b += "/cvABoOJcUWxJ7dVxg+AoSaKtkP1ivKrQgua3ieqfi+XURz68eKWjmUupH690KdTlPNQLzY1f71";
  b += "oijsF9htgX1iqSHTGTJAkJVJQsVqmoRibaTXoV1WkxMt2SJYrr1EUgtWa5AarHaGa5OluW8spOw";
  b += "L6mn7lhS7IuXqT1Z2Hfftrh+n3Z/qUexb5sMBr61/cmydPmW+JL9qbt1k+JAx/F8XKEdXnObd3z";
  b += "J/mQ+ci/TzKsl8/J4HjOz85vMl9jM85B5vmYG3Wdf3M3MHAjtmbuReZ5mvlgyL4mXMjMHRXvmpc";
  b += "jcrZmxtlocR8zMAdKeOULmpZr5MsncG3cxMwdLe+YuZI4085WSeREAiyQzB0575k5k7tLMV0vmh";
  b += "XEHM3MQtWfuQOZOzXytZF4QV5mZA6o9cxWZOzTzdZK5B165kpmDqz1ziMxVzXy9ZMaJ/UgLNe0V";
  b += "ak+QAAJxAv2cQJ/g273Qc7L3DJSABHxV0oO2kYNXz2rfRVqp2YXCZhfi7/r9cqnc8VJUnTfFcNz";
  b += "L21zMgmwPQUHrbedjm5SaF9zpKpM4LrC9JMz636XmJh3NC2iXCpkaV9iu0nJF+y3ucQ01Oa6w/e";
  b += "Ws9zjAK47qFbbTnPUe9/KKY3qF7Tlnvcckr3hEr7Dd56z3uJ9XHNcrbB866z0O8opH9QrbkVquC";
  b += "NvuASyBS9s6ExaC1fycscc1qLbhzOm9CNfi9skciUF0ldqpDMCMKb3JMGHomkq1HCH7rBulsCzb";
  b += "WBM5UProqOqMAfQVbpW+ijXr1s0JtltD8wmBbnwMakGXzpuQlvshLUI0Ysmxe/n/z967wFl5lve";
  b += "i3/td1loza9bM4j5huLzrA4YZGMKQcMkV86EhoTEmaozRqk1btXahVkiMNwZGwQQTrGOku2gxGR";
  b += "UFLdixpbtsS90DpXbcm7bTU3qku5zjtD92D/XQs6fd1M221Jzn/zzv+33fusxakDRpzz6IWfPev";
  b += "tv7PO/zPu9zZVUxjJ3lFWjAEALJ0dmOiuO8VdEJV89b4YypcH7xOdfIYYxeXHYaaIc97FahJIx6";
  b += "P6fsMBHcancwn4ezIzHOttVaaMgr1jNXabY4bGOyxXFeCrlQZjrLt8KWCmfcLD+ZddhuNQDiB3M";
  b += "+9XQXzqUiw2VxCk23sR1mAyRqyErDYyLzynLR3crsPjfI38e22tABLGvklq18QC+yWMZKZURsAU";
  b += "tc+hExpzkX52GXPdM8u2j+2nfJmb/yTJaCtxgRakuVV2IL7t1i7q39rZCiOmyGGhjoiRDCSNFKW";
  b += "X46n6/l6b55um+ebsSH2hg2slQxJcANRFgiTzenfELusojnADya7bI5+GuvK/YQOsW957kXs5nu";
  b += "G+O+C6Yvl+rDW8UTmspI5YkADDy9SbWBED6hK6QaUzbuhsGRAZDrp6jzDHVO4wjkRwaEujMNf4q";
  b += "PLKHLjbQhgKSzwccVGj8dXZDSXqbKDFQKVLlElZmoAL4IGjcLFYgeLlJlNirs24VAE6i0UuU8VT";
  b += "pRaQeiIdAcKvSa0TlXgkSEsO0kZE2zNG4XZmAa7S5gELkyF5vIU7pI78s7C+gX4pZw5w2av6iDO";
  b += "nkX4c4O09kpne3UyRsGd7abzjnS2UqdvDdwZ6vpnC2dbdTJ2wB3tpnOWdKZo06m+NyZM50zpTNP";
  b += "nUzcuTNvOmdIZ4E6mY5zZ8F0ThcCrFs2R0yyy7rF9HhEgaFPpcq4y9Ri6EtELdYjh5qXQgCOkck";
  b += "QT2HBUc9A9Sqx4JxnAA8sOOsZwAMLzngG8MCCcc8AHlhw2jOABxaMeQbwwIJTngE8sGDUM4DHux";
  b += "6nSldDLJiexoJpyRw4xF5Wo8T6BCXm6vVVKLE+QYkbpDOFEusTlOiUzhRKrE9QYo50plBifYISs";
  b += "6UzhRLrE5SYJZ0plFifoMRM6UyhxPoEJWYIg1cPJWDfySq6yYMGFfb5aVQY8mtRYa9/bahw3E+h";
  b += "wjE/hQpH/RQqjPgpVDjsp1DhkJ9ChQN+ChVsdElGhf3+dVR4CahAbMFTYHDgq5TaDB5Ng/68c21";
  b += "7AYR68V6A2CXxXrBLpfYCOPfFe8EVJ7UXII5JvBdcclJ7waST2gsuOtf3ghe7F0DAvk9VLHpVZ9";
  b += "Gra1z0Kr3oVXrRq/SiV+lFr9KLXqUXvUovepVe9Or6on/Ri95whS5zhfslPyB76UsRM79Xipj3I";
  b += "Sli1vdIEXqi3VKchjUtxelY0VKcgfUsaUahTLosxVlYy1KcbQ5EGVTmYCVLO3ROF6R4A+iOFDnY";
  b += "hRS7wGNIcSE4DClCOXVGigvAXUixBN5CiiE4CykuAl8hxcVInyZvvARxKqXYTUXz+UvBLEmxh4r";
  b += "m83upaD5/GRXN5y9HzEwp9lHRfP4KBL2R4o1UNJ+/EoFvEGoKlX6qmM9fBZ5eioimYz7/ZpwRpL";
  b += "gaB3MprsGpXoprIRKQ4jrIE6R4C4QRUoT623z+bRCDSPF20PlRVeIQkPT3TiN+hY4Gfwu6hSX8+";
  b += "Pt+SF5po82jVnl0hG1EnkWzSAMJC76qQ21gzqAtLCx1OQ4U7gd+M4/aVPcDk5Kpdz+IXdezSjaH";
  b += "v5LOUoIg0ruuFyVc6JszaoFaAo4mzqJhXGMOtQG7e9NnZWJbHD6SIQiYOdRm+Cgp59ut9KpyxGu";
  b += "JD7UZc/hrSQ61gT3UmgOnK0lDxcyCDWrkkBvgIBog0xLRkA6iQNOIaM2gNT2LKMIcoic3EDXqQq";
  b += "QuvUCXdKgX6cX6jimCbIaJZZBeorv1Ut2je/UyvVz36RX6Rr1S9+tV+iZ9s16t1+i1ep2+Rd+qb";
  b += "9O36zub3/GxrYnFkfEscuz5mIAwf4uVk8xDbLLFTv6rN7iLdnjbjSHUNNaMx2GHis9AMz6kqjTj";
  b += "2UQznk1rxrOxZjwAoKxe0eodRTvp46wNrWcfbMSMqjFj1Of+VhYbQTHuW8V49v97inFWMDPm9gn";
  b += "mihoj1i6zg4fPClff2MmymjZTZo+Pml6V9Lo1vdLuVbez36Wq1C6zSdnbjPoWycveVqn0jHZY3+";
  b += "h/E8rPPh0003wK/VC6RhMEiWJtUzT5KatsKn5SiZxSpeSU4rEXsOit+Ca4yhsxpWIxJWhS1ogpF";
  b += "cSUEEtGnPyoDz89+FmMH42fefjpxM9M/BTZfpFtzbS1v0tH4u0SAeeQkmBRObHa41eyAs5HU8Gk";
  b += "INTECqXipCPyTVdPQ7SLecXn3avwk/HYIai6yU6R8aJBS+WMEz4Yd+lSkCAK40YpK75PHPjljlK";
  b += "LmD+3Mn4gqheUaW2MIaWCRJNpZxwhlsUVtRuwhPgT4AnxJsAThPeFgm4WYwrxI8AV4kSAK8SFAF";
  b += "uIAwFeE/cBpCHOw/jpPAYhKaFSVgNhW3Qr/eY1ELag2+mXKDn9EiWnX6Ll9EvUnH6JntMvUfTHt";
  b += "oYV8k3W8bGGj/V7rN1j3R5r9livx1o91umxRo+1eawmZN0jax5Z78haR9Y5ssZRLPKhbWRdYxxs";
  b += "RFxUpqL7FS8H8WhCrRl+Fp3plBf9/u/9xW+w+UafuMG86O9wTS4g/ozQZGbjhGTzJCBKZ8ivPjN";
  b += "sEfcS1rC2hXmxCGsTG7GC+OW2T/lpXUL66Ewafe57Ox8CdpsmOplGv/rb+yfAXdg2hJT5u7N/+e";
  b += "xH44NEgHNq9Gcj/+E70E7YNjquRn/wze99Ihtz7QFOrdH3R7784yA+fAUc7/Pb3/ric0F8Lghwh";
  b += "o2eGRz/wfaYqQ9wFo8+MTgyvC0+IgQ4g0eDgwdGsjF/H9DqyZvjx6NpA1CbO7D4JIdV4j/RLXDs";
  b += "k6MeFhsOdGE3n+Si1eaMl03OeEvQw97xfnLGW3qQndjOOeaMx9mpHXPGQwLxM44547VKgCs544E";
  b += "DOu3EZzzOHS1nvAKk3E58xkPgAXvEQ75he8KDuj+bBqNvTnhLDkJFZA51S6sOdUtwqPPNoW5J1a";
  b += "FuCQ51vjnULak61C3Boc43h7ol9oBlDnVLcMDyzaFuSdWhbgkOdb451C2x5zZzqFuCc5tvDnVL7";
  b += "FnRHOqW4Kzom0Mdd7YkhzrqbDGdM9BJh7pcfKjLmR5Xd+PAi0o/K47SAWY4rzt8xYefrt7sIBGu";
  b += "aU1pQthGC3Q5H1s6gdwaIyiQXGMfBbJrTKdAeo1VFcivMbgCCTa2WCDDxkyLI62LBRfIsbHz4iO";
  b += "iefAckSLZA+Ku5IA4mBwQzYO7RHqE4nyRHdlToXnwQpEb2WOjeXBJpFxyVoRxGc6J+LPYHNUyRi";
  b += "eXrdGc8dkmZ3iGlurTkRxKEI+watLdGoUnL9tWVtHV3oU3Tey51c9vpX+52i24RokHBVfGKvGys";
  b += "eqK347e3553oL9jm3I6+my1yjt6gD3vGOWdtSnGeScjlr+eVeL5sRLPnnOE+ciwQSr2SuyUfOJJ";
  b += "zjuL6u9AqXPQfIlazCehxfVH15xTOOiCYXZcPW+LYXemGRPn91VFNFQS0dCpjj7YV4661qbjEB7";
  b += "42klzSOiqE8+whxv8so1sqF32Oqt+mjGfloc2fNrhqZ/Gj+lJx1F8qU879Yo+7fKLeRr85Y1jlL";
  b += "imJd5R7LKvrD138f8Sj67YT0oxA2yvqYpNYwzNYy6JrmaOlKPSyN8PxEbx9uwKR/0vcXJ64+QmY";
  b += "WmQGxme8og3EZ3ac5JPka7EwyTa+VX+6oijp0n0nQ+woxLUvLhf3rqn/6GnsjsMA5ax7mAmOhjh";
  b += "fburOJiZOPNychZWY494xtTNupSEil0+ApvAhV17uQkuRp8/NuoUn1WStXgxOzxV3LIFIkNP3Nn";
  b += "g60Rk0LqqmFh/YldXBCXMFj8nzvk6h2C0Snh3JRnW28JWdiHg/IBhPkq8jJ113gc4QhW2tFbE+A";
  b += "5MmgxHTqQKccUlgyjTE07NzuPYpY4PPghun3jRBJy9wE2SIsGoWkLeHfgd+eKAA6ZCuSjJGF7qT";
  b += "P7J71TMJOLMMfXLf9cAEttqU0Dyg2oeL2kOTW5O+43yeDTh8X/wDXr8Z+sBUm5ZCUiI1LP2xnMr";
  b += "nMkNJPfGkNwzNSTHaiF5F0fEmxqQdwkgxfd+CkAyovnx6yHrQPLRMA/iLJ5flw+eAo4veiL/6es";
  b += "VE5ln9zIUtsZ+7+K87Iq3mHgmw3GuTVzI6DRe/LLPshJa3V+OAwB1it8JYssF7F2Sk5L1ZudYhi";
  b += "78TGYat8L8gKd2qO1qW8qTOEX9EuRxlnMQLg+h0dkn+FYvBwxA4AN4nMEtliNCrvNy7P1j292kP";
  b += "c92S27x+8o6CL9HuSbQgX+3EEj6zM3ae2CrOE0z+VZw1W2DcAo3CDaZmFzifyUJBYi2SWZkcCB0";
  b += "DTzjN/iCB7g4/wcdbiCOs/0mXqfNI5mBGNYXp3IucwrIHoJJp4Q0t67k4I+84r/3xZmznx2FAhR";
  b += "vCbO4gMursdEwjLSZxmzkPsBiw/4y21cNAmq6HJ35IiHBaThjE7L82NnI0QH+i9pYcNmqJ2oH/g";
  b += "cSjR9CGRo1kk4EnClH/z6pwzInal9rLIbECduXLdKPc9QGEoxT7jtT7lsEqqbvS4i9L12nVzmUr";
  b += "iO5StVzdYPn8scWj/qIGIxpk6feUsohLmbGUgQkBIO2+HEQrV5v0A9bNnhvYBQ4piSP9ZBfETdi";
  b += "N3JvY8r6IEvc66fydfek03W3cMQKXDGiEJJMnuUS0ZFE3IOcj3OFczrDAFW97i4f2cnZ7lBFe/x";
  b += "UIu4XOMH3n2Qq89Bnbnf+GXhNC+OKx0+EAw/H0OYXHPTFaG5EiT+/5OFmT0jk4fZtHu6JDH/vbs";
  b += "7XfSFTNphovnciE9KnDMJ0bJwubTlIV39E7m7ycI9nJA93MUlDP1P4hSKxsak83G5VHm63Kg+3H";
  b += "+fh9uOQ4OwwZ/Jwcyb28cw6hjHn4T6bqc7DPenFGYhx5YQhmXPNi7XJiyHE34n0ixCy/UWSMZhf";
  b += "7E+rXvx76TzcNIvIw81vPLfeG1vs55k5xhAQREpN7W4fUzui5GsMCresiy/GpZMZQ/urcXg0xuF";
  b += "jruDwBwWHj7kJDl/wBYfH3AocHnU58YRCtF6FkPbRXotqugqHiwYLfAnAcswVHN7F08j5IgiHL3";
  b += "kWh4+7jMMXGZdOuXHaORU9z7L3/+FV4PA/erc7X8wIDu/PCA6f9w3ofHke4/CELzEoiv+Jd68aH";
  b += "B4RHB51OUBvNQ6PMA5zYP3hNA4fcy0ODxscziU4nEKVf2kcHk7j8KEaHB7KVODwCHB4bpy+3TNh";
  b += "+l4aAo9cEwJf4OkXLErN66gbSgqTBgg8mmFOA9uQcDNCldkpXfatO5ibkJQFErZAnMxVOkG9qkp";
  b += "Qr6oS1COUCuKb+3HGgin2BbwKh+nKEL1GogAOoO1LooAM5yjLSSmHGFMZCfv4lI2MW5QoA6M/YK";
  b += "/cQz8wXrkSPYSe8X6olFKBfjpt6BkJgXNNkX8kzowncWZ8xJnR+bfHsYLdOBC5DWlZ5LuYKGfxX";
  b += "T0T4hIBayWqqs9hGaJ9CBsqxzR7MPsXvPvgy3r3kZf17pefPvky3n33N2ru/nBFkDQnPnM7PXzU";
  b += "vtqneFW3/UFtHEBiBL+joKc1MWYQTpq5TZ2KyaOKP2JhRByJBkFokIIh8mxoXSLFeyTlAq1YE7a";
  b += "lNbqNA08z2eRQ5TnrP5ypuM4KAkLXBN4xYYOJgDJrL7y+xKiSeDeexLsxXXFc0Z+NoWLM23mda2";
  b += "MzjngMybTBfoE/z9a1a6bNj06fGxVTd1sCLSwOKSd/Y3wyspoiVfyJssH7ZMVK7Dl+oXcJIBHn1";
  b += "LwRHxWed41INaiMbioBHJTIWZNGyC/hVsEXOnyp6ZEQpo/KU+D6l37KXyq5lp/SXzYpO0UEq0Rr";
  b += "a5v67QP+UmmRmNrsVnyuf4eEaD3lJQTKhh+MKVjSYEJmJQ1aAkolDRynt8c2MNjk4O3bKMc0of4";
  b += "OE2zcl/Di/j2V4cXj0OEQexJxlNDhiBhPZ7d8ZfDwX6hYrm409g8S6TjOjnLVCze6KKSGcOOiJT";
  b += "rRvk+edBg9vuurvHmQJKpE8O846gN/jdocTTrvDzPYNnxEzMSx23s8zEbOAyZOS0QHf0SxQTCjM";
  b += "CgoricRmTzEZ/ElHpZj4jRwdksbwYZz/yBcRZIWIn5uIGF0bD5bRLG5jyMAZeuHsfFMGJtAtxAi";
  b += "SRQbjneflSg2MDpCFBuYESCKTYC4NS3QK9L/1KbIlSg2WQ7+5UugxSyNkThwfhLExjNBbDwOYuO";
  b += "ZIDYIa1HKMg9qwoex9lxYp0CWdzYJYpOFYVUgQWyya+PoG3WD2PDnE1HNmLfIIa8tLs0wEHA1Mm";
  b += "bIsdyjV0bIAZzL2U7HhQ2OLyIRnyWaWGrm0OHAfgQ3EYmETUjBO3/GhFFKR7zhiCUcLSQnlPo9j";
  b += "kgInMVOdPEPToKb5ABgNjK6I6JlJxr/Zwl67ohomalPn5YgdyKAcehkykEngViXaThLlzlgJ+80";
  b += "FQvDbktXvxxoHZw7N1q7gb302w7+xYmX5bb/8LLcdt/Lc9v6zMF2DhYx6nBYLKQx24BBr9pyJPS";
  b += "fhKQJfCLVdu/C6UD7T4qljpIxT5a8DTY+nQkXDJnYu+P4NEqEbxzoHlRKlySODgeo0RLoBjI5Wh";
  b += "HFz3ghbW/uA/bIb9I9nfsk8cMdwpVPPEXlySdNkNFLbSIiTsRftzkdtCjmGczORMwYZ6JTZ0ZZh";
  b += "JiJ7jAiMdoxQDVQ6oDSpEKWizyBOGP+0wkjq0NW4QyL8ZPJZnltNplspbNcukViolP/LWU+TRvd";
  b += "B7VG+77Ly+9uonwH/tNJOycosqgxOoSSScTEFRAoP2nWPpJk+MQ5lTxEVMa5g1OtaIl6S+T9zHf";
  b += "5KrYuy27x7ypepI2Bg+DJQJ9DyRZN9iz6QjpxfwCmQnxT5DoW6grZHdqgBuKI7W31Y+Xl4uwEOZ";
  b += "udIBUxT4ixRNx7MbfgzFUPI7NEgEmr/Dhqoa8rODILLRy7jD4ynjiPSxKbzWR9CcTKzGNDDY6P6";
  b += "Nh5xDsaP0meAdbvyrO9aMfGgiPX+eY6P76GxlimU/P9YzWWcAYpNdbZXSfjaMKyEr+M/Dz0ascF";
  b += "M2iqbAw42iwrWmF6/t2TNoQUbyp+Kjqc/WevoUM8y2iRQ7EATpc7jOSaY/dbM06s+WgwJ2k6AiQ";
  b += "L4oQ88+RPJ33OYG6dy34D8hXyCRs4KhbfVPhmifHW5uWjM39/womWR6eumCC2Ee4vcfPgE8pXyp";
  b += "G5DfzhJ2VS/Hi+mG85esVsLzFHDj92noF5ZklezWpkJcU81ouCpnCscVqYQZL0IVYsSRo0GxUyG";
  b += "ibkuUeOMfNKWdEGzIMnMBZSljPIGXUtRhp5hsfqVCIUnGIOfIOflxQnvuSUCNLkWoszakyuJT94";
  b += "Z7JaXVbpFl0TXXPwyglhMIsfkJMTLR1OGhSd+ydhQn2GMFhb36amkKh+rEuwC7rRaqyTbqRqNbK";
  b += "lYeiZb90ccoh2X0KyMuIIYuVNXgs+yQHmi+MloWVJzIuXRKdNq9EpSyI6Q18adUf7wWP8Dkt7Vj";
  b += "jFCGx73qrBjMc6i1UgAz/lGK25ilaXo38UOSN2gDugvuT5IWyILrG5sWJwS5ALxfxNvxYtuGDKL";
  b += "YSA/5TwNxnhtpjNua/muH5NGzEt+q+6dv996ff6Wnyvi9PUHJuZi5U7xWFfZGPDxpiJCkaxx0e7";
  b += "aLmEjfNk9bFJCpTTSDorkrpLrrClk644a3AIrEmTpBj4qIrvM4fALL3jme/Qxvy/I0k6LI2K/6f";
  b += "iY+BzHp9tz6Pz+64JJ4AY8A9yABmCpR1yyQxhix6XU4WxMhEfVbDaSK+4EXpLeGKxssqlupgZjz";
  b += "9NALsjHw0HJc7GVpA8CXWtkFQ0VKgf0yaaaIMq1682N1LRSBv7ZNR2DLbBDilTbVakOBk3ZzGt7";
  b += "himjjbqaKnumGxlP5LajlHq6JR841XfQR03wKqp5jtaAKdWna/5jpYyXEZqvoKb22q+AWeL2uZh";
  b += "bi7U3DtTDudGw0MnnNqJHaS+9mjyMyec2ikcD8phRzSKvtrJor5iNIS+2vmC42008csnnNoJQP7";
  b += "26dEI+mo+Fr45M6JB9NV8GtxyZkbjn6a+2u+DV3Y0jL7Omu+Dk3Y0uYf6bqj5PjjrR6N7mH5Xf5";
  b += "9RRIwP1djV07+5EjWsNr2Cq9un7uqYuqs4dde0qbumT901Y+qumVN3zZq6a/bUXXOoqz0a2VuLX";
  b += "x3R4N5azCpG45+rxalp0fDnarFpejT5bC0ezYhGn63FoJnR0LO1uDMrmvhsLdbMjkY+W4svc6LB";
  b += "z9bDlEkOBq3+/wpcl88o6S62jRl3JUtnNLGXg38w/fGq4pl5kongQRPDcVQZJfUX6q0rmuks7QD";
  b += "FtxENQYrv+IK6r2bfgAPE1HmK8dOoXNu8E1W9/heu+vVhWaN0xQsOsWFtpvoFpan+C4qzTDX14x";
  b += "3Yq15CWYN+frW3SWywVevdk62eq2xtUzVEzYyOVsejC7SC7X3AcXloK8frFFgMkFiPBSb95+EV7";
  b += "lKJJTvhcfhunS0+h08Fn8MFuj0VIDEPbDrb5SKSM7KznGF4XGZ4MmB4rsB2hhiey7A2vsz+lhkO";
  b += "zpKjvzTwffRnN/NB+ejCfxRuR7EfL7idPDKbMutzBuwD8cKXPdrk89FlDD3riidjCCX3DxTupMo";
  b += "yeG7F6N2jMlpSlpmxg4EwQqOtVjDvFm+jG2LTUT6ipiqqC7QnEa9kNbh+bLktRj8QGsvsRSYG0k";
  b += "UqL1vDJ7H99FZtyDEm/rRhQZr3wU3UNJ+n5nZp3kvNHaZ5gpqL0jyEADim+Rzc4KV5D0LbmOazc";
  b += "HCXZsziLNN8Bt7t0ryLmrtMM1yr5kkzeM/5pvk0NS+Q5itYD6Z5jMp5ab4MA3PTfAqoLs2XsFKl";
  b += "eQ1SAy/irGrLOZblSv7t599V/HsT/97Mv6v5dw3/ruXfdfy7gn9vNHEw+2wczOVxHMzl691RwKT";
  b += "PxsFcGYd3XM7BwWjAKTuA42D21w4YkwEmDuaq2gGnZYCJg3lT7YBxGWDiYN5cO+CMDDBxMFfXDj";
  b += "grA0wczDW1A87JABMHc23tgAkZYOJgrqsdcF4GmDiYK2oHXJABJg7mjaZnvXuRY/S0YlWGelH9O";
  b += "Jg+s8MLOaQ9+MI5lcNa9EIZBoRtLQu+HOcCkGi3bToWN+2yTUfjpkHbNBI3XWkxTYfjpsu26VDc";
  b += "dMk2HYibJm3TcNx00Tbtj5su2KZ9cdN527TXNq1xJ1q0uo7r/+vgOh3gwsXA2EokXox/jOt0lKM";
  b += "DaYueU+0VQ2xHOJeubIVrfzRKDNCSaPIbxIYu5IYJ2i50NIQGjCD++OtUnEvFOaDHv86xj+bAj4";
  b += "sfg8OX4kM8WKkeakOfb8Zo8fDF2qTe7qrelrgXR8ZeqtGDj5g3oQcfNu/g83GsRLOh+Zk4uHWKf";
  b += "4/SuGmJ/uGm+IubdtK/XtOOey2JRn7D3FZH49+MP23yiPk01nzTEZruPcIfeANc3PhhOO3hfvg0";
  b += "tPqmV5vndFe1p5/P7Sx8WCpv8ZvJW3wreYuR+C3AGrTSd8qjcWCEkSceDZclPAJ/049Ot6cfvZD";
  b += "+haYdTwxpKnguad5bTVCHkJ+JYzdTTaZ9zA0IH8AcgOz9vOvLfs87vezxvLvLvs47uuzlvIvL/s";
  b += "07t+zZvFvLPs07tOzNSWbTV3Q/Hg6a0KgDQRMadShoQqMOB01o1EjQhEYdDZrQqGNBExp1PGhCo";
  b += "0aDJjTqVNCERo0F9WnU6cDIBN3a/djlfBtv00t56Q8HVSeApfSvRJiJvzfQXwQ0vZ042n5w4DnO";
  b += "/ojzhQnIl7UHGekwoTzjIG1ZZncV29Vs0XWut1emrrGjxX7GGK7sJnKqjC+w3+MOtoRtRwYY2cA";
  b += "ItBi/20LiDXwjupQJDWW9gZcjohJxAjR+nvjvEg9AlfniwEu7P1UWGA/eaLhFov2E07DjUwXuIO";
  b += "F07PVUgcNhOAO7fAun63DCmZjzFuOrNQtsDF4aldkcM6VQGcpaXIBvhG+uVBSg95SenfgD0/vON";
  b += "p2udM5K/IGpc5bp9KRzZuIPTJ0zTWdOOmck/sDUOcN05qVzeuIPTJ3TTWdGOqcl/sDUOc10LpDO";
  b += "YuIPvPwgh6pG53zp7Ej8gZcf5NDU6JzHWHpQt8f+wO2mx9crDnLo6LUEYfB6KagvZlfsBOhHrxH";
  b += "o59JAP5sG+pk00MfTQD+dBvpYGuin0kAfTQP9+LUBfXHyydcxwCGGaW6y6I9lKhb9SKYC/plrhH";
  b += "8mDf9MGv6ZNPwzafhn0vDPpOGfScM/k4Z/5vqif7GLfiTDehezNxCdzSYI0F21/vdmrw3+x7Mp+";
  b += "B/LpuB/NJuC/0g2Bf/D2RT8D2VT8D+QTcF/OJuC//7sNcG/+/r6TyMD/c/yAXROT4G/pwr8l64R";
  b += "/PtzKfDvy6XAvzeXAv9QLgX+PbkU+HfnUuDflUuBfzCXAv+VawN/z3Xwp8GPCDVzI6e4mkstXKK";
  b += "dAOFe5zJDKA1zTRftFuhKxvpQ0rK0OptkeZxgq+r/B9mvU2nC2ZxT6inL+N9SEsArFwb+XRK1CW";
  b += "nOlKSTz0ZOtIpF1RzBk+69qnjUXCFpnorf80LORwsTFLEYWYXXSCxckaKWHYVgJKLEooPNS9nTV";
  b += "Yzc8xxXxiSX9eJ8sfDz5QyvW+WmNl2sV5Eu1mT7/pH53klnc+UHTzqbr+2L/8qp+GSqNv3mv3Je";
  b += "3EdPsnP1lF8tt53qs/ni/EM1Jv2v2iKZVzu4lnkibmjnhsEJb0vU9kQ0gaYCTNWjgrgWhE7xWU8";
  b += "7nHsXebitCSUSsyMUnS4eUpKS0FpQwmMaJs4wKnY5k7tYlKCRBmNyNpfE5LLktDl5J5//se8GO9";
  b += "ztiR+HpGKPrcxjI0561R1QnihjKG7jSbh3eWI7xeAcZJe9HOJGrHBaxJTsu87GApxHXrURja3IW";
  b += "HrfFmrJHClldWYUIQV9nd3wgrPTmJTq3K6SmMiZfNLiPQ9/DQ86jaefGcVCOAuwsaFT9LtoudO0";
  b += "MKjpfip1P6TrZZtKZdzgJFMwG2sz7sCxOysmYWJlEohTSVYyuTvity8J443Hfqf9+ATenEQ+YNt";
  b += "PUHIaFmYfZD/pJC8zIfEGNSCGPTRnsApP52UO0nmZg1Re5qBuXmZMaY9Mdy+mW7Hx0ApnWfEfZe";
  b += "7Yo68vDtMozs8mG7Inuepd670TZ7GXBHhiYcWZX1Uc8tEsFuMowGuFg4PwYoFOs9f1Y9cVP7VYf";
  b += "Hn1VCLtB5W/I5rBh+8ZD3TZpBnipSGJjz0GGdsdu5L8OMyUXPhrOPcWJNN4Jsknbf2o0tFp2iS0";
  b += "CsKlWKNgttpDZMr9Xz1pQlU+x4bukAaIVbC1r+zhVzUxVH66YmkrMZFLZ4LPVWTFFPh05CVQG8I";
  b += "cRKf3EZou5zzG0WWUx75gDJkfMSEDbhGnlTtKAcfhOcWB4zhMAmeIf0h8/15Lf2D+mDj/vaZ+6v";
  b += "gH2flLEmz5km5Lbtxfed+75L630J/V6dv217/tHfm3VCQhd4s3hWLgqL1id8jJSFHsEVPXNnaed";
  b += "E1iUWPlpooraAS3+6afkeL+2CBOiA5NqsMeY0xYOL+0oS2cb2mG+CUo4zOmOJ5NW55x2fi+CUkz";
  b += "y5fdZiTWgl8iIEc+jF6VEEtPCJwrzpOHfygWlYzJBEgnH/mRWLEed1V2B74jF/pMXTdao11RMxN";
  b += "9zaYMv1mrpOK8zY4xIn4c2Us4+EM6b3Pbezkixa//+Tf+3GGPlxxuwIa87PHCFtyctpmpvfV4cY";
  b += "3Hi6sloLB4vGCDlPCQjknQHqdtduRzHabnxuMlyMN0D81ZIfPGqtm6rrDHi/U5YRcrifPDr8S2F";
  b += "mYxuFWLQYaL217+jcbDzBcYO9HZ/0bL4O8UYKQR78VEIQmlfPnvR50k5Ai30WDtGvcvDhGcv0/u";
  b += "aWNtAr+GXcTHZN8Ug++wKkw5rzncR+O0dSXjcJX51zlJxBE2jRRnQYMI1NdWFpty4wlFS0PClLD";
  b += "7mFe5VmbmLyk3E6e3F17IATvgRR3lUiZeRYKohBgmEkgpiOGuZG0ZiLRx7tPNwpUHMqegk+f+kO";
  b += "ZpUTQxZt2GYf5bgt2CSrilaBLdR0BRczapcXqPF//r4qBn9kiJhWp2SyUelcQcddC2JEikhL/Ko";
  b += "pwVToiv+2+uCsxChm0GLi2eksTpRdiwSB4oRs3itKxTFamFMS5U7C71QMGwjy0VvhRaekP/fqIJ";
  b += "Bn21L159bmxkHlveD548YSzvz52wRvnE1p05aW18fV5r7JNVajUfG/klBOSBFwPc6zhwHCxK3cd";
  b += "Dv/hDL8zdXZDIOWJWkqtYSS2a7aJbKlaSCY3Cg+BSYCkP1hbbx8v00QPFPY/TzPOX5oQ4ZeIVlT";
  b += "Ve5Fkhdb/ixjRZ3OxU9IJzv2xRwgwkEZrbyrD+Zz5lUD3A0Q0Gi+bvoPGQTDhXr5pzFeudtqSBY";
  b += "/BE05+IsluiSTQQmQOvlr5LfBFzuk71PVUkHr+pK5QdMyq35G9wmYtnRoJ92E1+bPAgpkDbybNe";
  b += "7DMAwqDFhwKG8o6JV1YdyQy5363Zu2vN3lUSysyHk8eXVXqKzb6SXj0cb+2ky+gausmeBTSM3Mj";
  b += "jnQuOGRsRHFdt7Iq5O9eyuIa7Uyn+yp5F2J86vqL2BMLf+4bKnTnllZ32t5Z45IZ1MqcixzKYsS";
  b += "O02ZLvkVuOC20VQzln491mpjQdRSToBnwTVZuwZby4Rm08TTbXp025cmvn5eH08KVaGMLUu0vsj";
  b += "ZwEuBWcjAzVRZCjv3dNOnbx5maQmvgfKn7z10nwucrJ+CHO8T8RlyZhLXkfL/4ux5uibiH5Znf0";
  b += "E16OjfXNrotLgBbCBHhwe8U19GJ/rGRr9MzWiPA62u5ehBriuZ7fVINKEjkvZF4bdv3sX9HGUbC";
  b += "YaiRbDocs9S3E76WPNMFEzA7CwaSYXV4rgfnoKkwNv5OZMRwzrCe89jdh1u5NPu+lfVtyo9y/1I";
  b += "2meqM/ubobRTLbIypB4UNqoxym3fr4e0gZ5B1hc8M7gZC0Zd0v7uObCkqiaGy2vuF4FNh93taKz";
  b += "7jiPk7Fp135kNgFmgmwbE+xB5EEPMzJoWWeHFrkHNJZlnOXHELu4HWhXfMa98M1jx/4NJ/a+IHP";
  b += "SMwQ8CYVL5ffEJ9gPDk5EhbcIztEdNExOe7k1BKdOcFnFZZ9DJ2ETy4fVF5dcwsTZQESidEG9xi";
  b += "8ynsYc8iXdI/q9xj8SXKPwz+J7/EaFqskoeHoJu2eo3C85RsWXOxhPE1qowkXIHNW4GMptithFn";
  b += "vKxV+jiSaYeppjFkSTvzrqsJTA4aAG0YV0HX6s6frZuJK/qxJRsL91yp+ZghtFOauzS/v3QcU9w";
  b += "waIczrhKdD+AVkg1Vyry/jqxCiRo8m5+DzYRu0zz3jXi7s6OvsVw3RONR2Hq6bjcNV0pOtn48q1";
  b += "f83okZfyNXJ1dPhbjb9m7NuVXzP67cqvOZauj3w7Ae41z+4f8/ucPm3eB1gfzZQzKzu0+tFMwzY";
  b += "CRYopmYc5iDGyOMlBzMuvYYZI3GMdFhUSurG4pYP5+TJLF0vwa/0t4oru5oQVTDqugo2qFxDWck";
  b += "/rK+NAYqIkeiNiWf65Cc8Eqhows2tFSDamY+3lYBvM5X/24i7vfymXS1hUfVUvv8Ex7BWzeWUOt";
  b += "8B8B2/cZXPINHkG4PHpS10mlYn3RiPK4NB+Ar5YesGYYBxslRxWlRHjRMMvpMUY+b8J4nOZjU3L";
  b += "QUUmAssknUWcMwkJSW9w1mXZHqcsmXDBhPRI5ZyLGBEu7mqjQvrW41iXo/NJJMiMiQSZMZEg3Tg";
  b += "SJOeX4JwVTSJBenEkSEZovyJYso0E6caRIF0TTvglR4L04kiQUzyXP9ZEguRg48ScFR/nsxUdv/";
  b += "slVp7MKcfI2We5isHAxOZxy4gZ60nUj/7iQU/Yew/X37KOHwTqEN212URyYxmqiHzM8z449fMOu";
  b += "XWe97n4eRPO1T4wH3+pyicI0C+M/mwz6W0y6dcYXg0vCgmgF4dXm2Ky8Q4TgQmAK0HVOCKsF0eE";
  b += "9SQ0J624V03FIPQ6al18XCIaO/S3CXNw/G9j5uCqrz/+o+T6Cz+Kr7+z4noTHet/4BCMNSEH/vM";
  b += "uSEbkpuiF4emv4WplDkCpq291OAAFAX3wFDzYOeg2U43iNMcpqLl5jhTh5Jnie0a/Mo12qO894S";
  b += "3e0bldbeM8IpHagoPics8prTfHMZ8jW5SKOMpLPjvo9HKbwxZ6z/W/V1pG49br9T9HD3Ul0scyt";
  b += "htEvIad4dINg/K/3C5qV09u+Il0deyk6urdB6MXOraEflfYs0HtLPVGXsmIg/j07NMYc/nlF5yd";
  b += "YfeDoerS3am213dFHuQzXXrpg12Ru5m5OQ+iG3GIj36L9V+9D5acDarUR29nL9aaHvkk/dj3e33";
  b += "odJV6NrgbaOq6Sn3Rf/5QdPpDVNR+2dwBAh73dnUhR3/71nkT9HeDWuedRb1nnTeOv3Su+GFOwo";
  b += "FEkC+6m5FNC4KKyHugC4Q1+sqBk050AD84Amivi77SeWNXqZMYTAIu1V61+yA1lxbGUQpchC923";
  b += "Hz0eBRo90QIbUiXdt5Lhf/4z859BR9GLLlyaSb9LSKtlxP5T0SzyqVWQojttOlO26ynUdF9oKs0";
  b += "PWGA+e4tcPcNwbDQ/ALjuy34Xlj4MNHw1rsLXjRMrMBK1RliFyEEEhAUHyJwhMBZbtJP6m6CRGj";
  b += "hM+qY/pz0F6v6BweVGeDLgFzNAPsEVwb4NQPwDAco4aLLQZfzls2hs/lENO68Nxo5GJSjPy6+j6";
  b += "jTnzoPsLLMfxz7w96TThlfbM2Ew2V0efeGHZ+kuX+SkFbvDru3h730l9qXS3UbUsbZ8Uu3IzPM7";
  b += "m2617TopXrZdm7ptmaz/Ja5bWw72x3JWWUfnrxSOeXN4SyOuLN898ESOr5gOkqugUs3IeLyJ0Na";
  b += "NANh786wB1rF1qj1PoAkch+PLn/pJCfj0AR/lRflLMF96I85DpgTje66k4+sdIb6/spNBaLaUQt";
  b += "qe//vc94mmlbiJtAjDTSrbSwqOI+rWXDlRBeyZtx5lGVI1ArSErXcF3pdtMKICQGyDX86Y4bS41";
  b += "HDYDoxZaIsHnnkr33TTS/FVerPl0xESlU+Eeb09BOhei2976zohRe8LaWCpqbNJyB/pUOtbt3UF";
  b += "bZHanNpFkwFwMFq//2sPWjdWMiJROO9m0usxpV9UILCztpYaAFjBH20nPaJJrRuws/7S4isQ7vB";
  b += "8EnE3jzw5ZNGiD5TwvG05GHQQnMNg5bpBI7WQe0fIZDoZcU9qi2Xtzcs0HsBlKWlIDH0bn166W5";
  b += "eScmd6D0fKGTl7Xo2tBLyaAK8ec0+aij1EXb17iz16Ha+byh5EfkNqAlv0KOX6T48OpuP/uwz9N";
  b += "LzokNfMi8dHaNStDg6Zxs0MD4af46qu9F/Dl9Zii7G/YgecPTLprviOQ5/ZM+29Ndy3I3W6FR8w";
  b += "fQTpRkgHj3uEIsYW6JRoj+zhf60Q3aYYTVAJbGp/ZcmP708aYi4Hi59EKjb6xWJJtGypamhlfYQ";
  b += "AXGp7n2YyB2IEecx6F1Pm2MWuwWtREMynK617iG4qTq6l+1+0NDGaojIAT/252ymM6LKkb+VWvb";
  b += "bFsWhrvnvOO27R36frlcDHxnYcPILJy742zcMfumPho+6WNAHQ3WilIF8iInx6+CNKVEe38xWKH";
  b += "J3WpubT1ALAgpliGSbUdSeofZ3xgMhuCekL74TyrhsDz0cXPcYjF8OBWVzs2HmI+lOrWGOULjAW";
  b += "saoB4Ixn60mYIIUlEuzUBWl+t2cwo+wEwTJ24JslTTVyKHnQvUBcTXOlBuQulUe5ZZFxvoTjrYE";
  b += "PaKmXcTFCM6m6JexlcGLo4fo/S5s7yAfg2H3elZOwbeDYNQtzdsH6gxK9dJjjYFKQCQ+DCQTaK6";
  b += "cLyFeFjaxzRWPM/dZDwQkaraZJqLlfkIPmrKxTOhGvTQr+XxbB6ghzGdyoJMHPi10MpyF6bcjHy";
  b += "hMjzgOkje3/hSxFgyTpGcdKfWCe6qcJqJ9n/kOramuaOz37JqqmLdsmcHRYO50b8286V47Z3Gna";
  b += "W0wV1pMMaomi27AE8WfnKcuKhxSoRI1JX1jz32FDs3RyBzilqDOw2cjCYESW4xcWwaN27eUpqMm";
  b += "315yGYdNXlhXbBKRjQL+VDm6QzksyCmJg4V7YqcYiKoFLh0FfcMmojc33Le1HHpiLjhrE7I/bdp";
  b += "Kzwj43vxl9KTpuiOC5zFoYVsQk72Lz1qyNzhEDfOjK3HDyBCP2PM523AODWuj/XHDgc9Sw7rosG";
  b += "3Qc/0deMzj9Jr8hXjtnLy4fCstAX73WeaFPbww4cV9WwOdy9MnC7IuxdYs+EEcy+PlyEh6IFrBw";
  b += "nZ4SUOEzOGXBQuzdine5bGZQgQmHomnZdUz4kIbJ2/GUvF7wMEjZObdLKHMRzuAyV1QQAaRgpgY";
  b += "GV9LGRxQFZ4xTTSbtHGydLMW270tkhJjkyFQgrQSO/eKYLSX6hDIE6LRvkX7hMHhBL/R3C1cz3p";
  b += "jGTBVT9sUPSgyxhdZb4kZ8YADTJx6ZMnxPhT4d035OnSluQ/SCPOSyeuegyETFwV4GfhCvVvWxl";
  b += "YKezrApbCJIJcsCG2GuBM940TYBUqf0TOYM1G6SziTHKcqLXEikSxOsZcxXXQix6rjRO7KkG+gQ";
  b += "/HNJW3p/Fr4pmU5twKeHQ9yaVApGWS3gvSgLJLCl0L6e8YtlxbR3yteuYRd4ACtUsQMp82otESW";
  b += "fcmRWxHPRX8ve6V5+DsclOYLfSgtoPefxUg4CwFXExE5EVX65AKmZRbjNQsRXWsIiPPpRsZ7yMf";
  b += "KZt5hY1dglcQC/EfIzojYyTNdiex6MWN1kKB9zmD9PcZQphbPI2TXIzLIWi8O8tcBOAF497BKm0";
  b += "jWDQZhDdVKkau5TK6iHY+Vwzm08EGxpldTrJmWYvGwDj1Hz91E1GjOJku0OvRMEK0OIlodVUTrB";
  b += "la1hZzojZfbFiIwmDn7daEYRPG6XhI/xNUd1CM2Ht4msLSbiL50CH2ZHmNklKNvVyWe3Pn47z6Y";
  b += "ENHkIsUcJlcsQV2e2/wUc6vuASsqc0urykXAqsKmAuheK06TVNtY4BR05agftc3gkNraUjBAfMZ";
  b += "IsVpOrIu8FCA8AYRXBYhB/+oBocSwvhEgVAwIdRWA8KYGBETSpTqAAAwgXb0vAUSHsZci/rKNuM";
  b += "dSG8Ro0N7Ns0g+qx6SL5oCEEzM6yN5MsGeib/aHNOJ5PybxXR9dZjeEWM6TTB9TpuE6Fa8ZTqY4";
  b += "DYhQ5UTHF47FUkmWJkItfEEs5SN9aRVE0y0/JWdYOQdl7Og8Gf+DjFGshNslolnDhJu5SSreJJV";
  b += "7SQ7ZpIVT3KrLuCDseSpTQ6mPN2Fah6xkntQU3EPGWDENXEPikNW1OMepuhpm6JnKu4hkGPv6c8";
  b += "Z7qGNJrVATOtxNLAOneif1Fi57llW4+kXy2qomDU0rAZzhrqWMyRIEB8MOEMKKKxXms9R6Vpqf/";
  b += "Zlf/YFRMZcvgmIgMQxh1cBo7gn+dCgPpCCKYEUTAmk4GpZPH/qeQ+uYd59zPt0szL8ZOJhmQs7V";
  b += "mbVxt34YGSpDDPm/lUz5uk91ZuC0jCteUFtQQZOWNDejb0Wb+xAMIQzWXuZrQ5ocXp52YYV+Czd";
  b += "DqtQ/v4cx2fGu7vmazUYa1x260bhtriieO3mRLSmcw8UPPEe6eeDLm/kHp2Qo1U6dzcSarZHq2B";
  b += "f148X2igNPDpnRkf9OGNmWE6X0V2vxds9sLUAs2OiFWxIAztfYX8RS++cXV+8nC7Gy4lq9xccbr";
  b += "wSN87WmdtVjv6wteNszSq/LNxiFzuiYkvjgpOuRWepFM1NHcBborEcEgPvi7XfLbql1xvKrfNGc";
  b += "3k9Q7fcqMZyIUtiWrAcW3rc0Rx+T0GIOE3E6MVfVmhqo6+mPzl6C2g2qM+9XQ3l9DS+GNHcODFT";
  b += "S+TcrvYjricx6vvwd/gALHv25uRuuFzx5cr0f7Wy33tpt/ea3N7FtHim72tJnzxNxqj0mK9XjWG";
  b += "1BFQVpU4ZDgvhluh0zhyZWrCqxqD8WLgW89iiO9diVosiFCxuRcyTnEQFjg5D77EkOnMgkVOmIE";
  b += "r7kjLJUttEu9RXo13qS2mXelPapb5K7VJfWru0FNqlZTXapb6r1i71Tq1dmq+XiXZpeYV2aSm0S";
  b += "0srtUtLrXZpeYV2Se6AnM/zb1cfpj/Lkea1Dbql91Bt6TrvUfpDC+2j16JU6mOl0nyjVOqzSiVd";
  b += "o1Si7V6XS+30p6NcKoo3TWu15JZ6EWqjVk5rikWjPOplWW3Y/QiVl+pe+mOUGbFOCT2tok3ysfJ";
  b += "b6ZqlA+FySaLjQ8Hk/xtWMNG0viVEntTNooYjOti6gbjeI2H37nCpXr4TSe7o70PEOLVq+4X4uF";
  b += "ZMiOnupW4o1VS1osphRRX4T/9xqsSKqljxtApTvOFVO8NlT7IGKrxV9FThjZrVVjfrW7dv0zfHW";
  b += "iirqQpXV+iqVk2pqyrdtkGxmY6TUlaxqmrFk2H/BjVQukmv0su1fX7v9vjlqD1+bLd5gL4Zz699";
  b += "yhr6jpu308bN+/dyfvnSMnporAgzCazpW/q0d8Q87fbtYR895nbz0XfU/dQ7r/JTw1XbNqht4Tq";
  b += "9YvfBMGdVZzmrOstVqM5yVnVG67eQVp05rDrLpVRnOVad8ThRnTmx6iwH1VkhVp3lRHXGQ63qzI";
  b += "lVZzmjOuPuWHXmdOWJWbttW+kWfZNet7O0lHhYtVn4gnXQEm3Ty7fpNdvCngF83Up9004iOGL4l";
  b += "dPe+0u+kexME0vQosT47i+Hs7GXr8QgaNPC3BFNIF+rl9J6fhjHLjoiFFzDtxLB66YbdhPMlpd6";
  b += "cTfoV3E3AmUr4QQmFTcVk2MxMFsGTRcRCAwgkNObhUsfAeuyHCSgR/e/tZQjlFmnbxkAnLu3lVb";
  b += "TB/VjLVFtgL6Fhhf4KVAGKr4T3ad/2wAhVL9eCTE5DRoo0TIt3ejdxX1ht175EN3gxm1U7dn21q";
  b += "2SGCLXhu0GcoHN8pI3YtJ67UusfGuhg5r6B0o30lfSkqUO8Kft+Wga/Ts8bJkc+vTodKompnTQM";
  b += "nrQMnppLePgsBVDjz5PDSuiyecT5UGFwg5kPJof7fp0ldx6+PkqyfbQ81Wy78Hnq6Tjk8/ZBiM/";
  b += "n3gueShYYcEGHA5WYpaX0XID5Fe8lT4EsKC1prbRsl+mVzzEKrFwje5+ZCstEYIyppdmlsjLbVi";
  b += "Mt+rbB4gA3TGg7xzQqzB5d2haj6u26b5tpeUbHH0LXbR22zaAyCXgdktlGXCJijT/ax4idOjbRn";
  b += "O/VmDFF5S6+WAEAbaeDZAxsuL5BBvCwW0EeVwLAwY00g+9Fj1+uV4xQPSlR694KzuQolByzD3lt";
  b += "DEtOj5sOBBZGnfTPW6SZ+NmhMw3PUSLrXsAODvw1q3wASIM2eAPPIKt4a1baCraRdlLZ0xTIua1";
  b += "HfYixCazXxBYhqWlbnlEDo9YbR/Rj0esfkivlkesjh+xbMMj2+nbHuHizO3pB3nxg9zUgxz21W3";
  b += "XRTaeao19elsxtDPli6FbxWYQ2ayskzBVOqEPSKXYKIotaZxiwzGJCFR09Gsn2aWjbEu5crT30y";
  b += "aRGRiGHlfj69rgC1LqEPaiy4SzVc01w/U4j2UJ59Eba4iXQkNMOABEXAYdca9exjriPmduaYGoi";
  b += "vGly9aLfD9yjVmRURUPK855tCxWFfvyMbGqWEHLfEiZayvUzGPsZJpSMx9WkiI5ffXS9ThlytVL";
  b += "01dPenz10vjqMxh21k1fjZDEFWpqBUb/sid/9wXaP/L7sBWZQk3tnSjNg5ggVlPDevDNc9kbomy";
  b += "LCCPtG821PDCtuZ4nmmu86TwwPcV3mqulhIsdUWbztUT1rDKbhVPDCsrsY60wfmkpJ/oLNkGb9B";
  b += "DrRE/nU3fPfYVp2hVJhgthkwuFZI79pgqQiW3fUjK3YREoPbmUYVsQcQUJ29lXrhzONDpIJyWGQ";
  b += "yYoo4MMaMOcuYkWycxYBxno4iYWFG4t5cWbN2OCJhDbNg0yuGlVOsjJz1RR2eGhKjp8eqiKUu/9";
  b += "bBUtP2cbdM7fgcc8Hhbl+1KSU5nhorx6Uedj2TS/cRGy6XxeNP2sgZRpdhMNpIgMjJkw4NBDaBM";
  b += "WJXb8JiNUzYtQ1WFZg8PiDqNRlvcRbagjILaSVVd7BLhMWt5BrEoG/pELXsfxOejO7Ylwyq8jnG";
  b += "LtY8YKp4jE08bdLbZIRjCVt60M6lhZaKRAFsa1UkCH3c/r97RN0cPMaDfb+JeQAIBmIG80JPMwj";
  b += "fNg9+NWSOYyLJ6q/2Kl+I4ZbFkZFk91Gw2kEU8pI5py0qIphR1jmNfPmBtriu3SYH/XxvOIBWrm";
  b += "UlXOZdLzrzifL2XeYjw/pAye2yycKTwnwjwds6b09LuFeIHcAgOnN5s5kJW6WJj0/OtiYiX+Ta8";
  b += "QkF3zrCqeVyI/00VKLeRmejKtNF/lQE/PY/4wnDiL0YxJ0WLoAc1jhXp7sVD+fcFaF3aDHMkOLH";
  b += "GFentJMmioxaRmqBgE9fUNYoSMPQR/h1rChbRdLJTt4n4G1/6gXMImdipTLk2HW1sWdrB859Ic/";
  b += "B3NlEr4eyFbChFhhI1xqmmdnslErRBTPa4W76GtoliXxtGdZmAe2S2PzxNomgYsvIcN8mWzIuyi";
  b += "D6u3TbGWJkjvVJwZNbVT8QjEdmjfRD8FbFa+BLDLbaJDWrHJZiX7JxRGZmuJNxVfF/UN8ROq9hQ";
  b += "/2VNyZjENQ+s8Q7ugTL4O8V8iJvdKxXrzOb3efLI2rrCp3nyyiZxKWbM1nlRCqaubVJv5r8GkGq";
  b += "OeHL49d9+1Taqf2qn9lDbfT02qj43ar51UPQMa5Bn5htyvq0v4T7T8m1ipXjPXc+vNtX8PvVCzu";
  b += "XbTunuZ67TuXuYaZmzXgsDuVSGwexVz7VXMtZtCYGM3YlSd+Vif7Mf6ZMz1nLx4RfFcE/GeAW39";
  b += "HPxH88ncyWyJAlGX77GcTkHbOXXB8zSbU68kEalSc+rLnPrJnNK9rwl/3avC36uZU3+KOfUM++7";
  b += "WnVevdl59M6+K57UYTYOnV1F3lalN9Me+4V86qdRp1fczaShSGjdgOA+pKSferZp417zJ1OcLgr";
  b += "CeTQ+fgfMFRB0zhI2a0cZGWwKgGQKgGQBQ0OiIkTNHjEXlsDWGUUEXDAjtEQOK5kUg0osAoIIEP";
  b += "iSI5QGxGgAFFQCaIQBi8LQnxwHzAgWzQ7fLg9pjKkN3L+j25Dgww+7nmJUZyXHAAoxAx9M2R8+g";
  b += "f3M2xeBpfhBorzgIFLBJttddFAS0BffiNHDv1rvteWBOch5oqTwPuCluzK08D+Su7TyQKOmrubA";
  b += "petqm6JmKC8vKGQenUvo45kMUn6UTXoXOWEL8zcQa6zmWmWzmc+wlogHtdp6hOS2XCqwJLvk85y";
  b += "VahpaiFgxJd1lDXe/IFbkPFDK8DqHxLeJiWKizt+8OccZUjHNYoTDjKFWojrvKMv8+cg1bJTLHj";
  b += "CjeVwA8XOiEM6w+psd0sdJYF+nFu0RdXEQXSDYLEj26YdSPIXJuovdykcc8wyOi089a9rXSxmJG";
  b += "mrUVOWtq5LTo+LM1I42lxjQwYh16HsRgHeJr3aElyqnE6GybIbc49+yL5pUrTm6zG5/cOgFzR3c";
  b += "KrnfiLNHZBNdTZzb32s9sLzvOK3zBSzpr2PnrTJ/gOpM57MQcdmIOO/kEN1tOcLNlDmfj9Da72R";
  b += "y+pNPbyz6HbmoOGaln/8vM6GzMqJUVzU5mdDZmdDbLzFncSGen1PmJvSXc1EtUHih3i//tNdhfV";
  b += "BrutEVnHRiT9VhjjDbd1uvpdd6D0HW39bgP4uch3bZSPRI5rIaG6UUbBzTFHxZyt8EKQcNODY7o";
  b += "bca8YTEPb2PttScdX4s7zAWaDRvi/q9X9CdWDfN5KIwa2qJzjpm4Nhg1PEJ/NGIwtun5a/G2nLl";
  b += "2K/0dVBLp0U/P1W11XHgRpa+40wT2USawT6337+0cbEEi+kh0QfD1bvGzHEwhR9uMbP9lbZx/U8";
  b += "H1kmtV6lqVXKvMtVFY99rqcEns9VucVDZoroQtSL2ziY10a2XcKW3CrkkSdUK8jRUhp+5ORVVKQ";
  b += "p44HA3Qhm5zJHSbE40+I7FxnGjoGYnYyVE2xqjCMXG+YyKfaftsh+MkRhMc3xNvYaPruPCW7pS3";
  b += "K8rbOhxpSkzWeMYl/F5b6N3NlliuxGZQSZjRJOAXs2DmG0sevHzlkEbTDtMuBCEruJDRcdZrPlo";
  b += "VJBYfAmEikAO4+bwEoUoFbVDRqRdOOHGQjTaGESfALv6pYisZJxWpUkUjjUbbZOyDL9hk7KZh8i";
  b += "em4eYKsEt0qzha1i7x6JfU378Xg/tHvmo1F+UWw+QrV5GjOmdyVDsS4lrifXUil+GEEiHOPN9m3";
  b += "gaCcHTdInHRJkatCbGb43CNfPdY55TjUg8/jSNK96fRFQF4PXkI3hhspgRThmlu8bc9cFA52iHA";
  b += "SJWyiCOQTqzt2cTayNuOOBcZiXHhczRYzSEQOFqGiQPCaMMB2xGoEeEISy0cgg7p4vGgvIcXaLm";
  b += "H8zPmy8xNcbA2+BWWw6xkbAevgLhTeRv4kO9m8Coj0Ua8JIZLYN5Tgo3gKziYKVsf8/MyfGTX2d";
  b += "Tz5JCVPIoRzeSrt+F5YV0pYefcWFNYJ5Li3sFRs5j2c8lEUjz78dE4Wzq9b2scp1BJFnqCDSKDi";
  b += "2Zotbkpq6366I/cFFCVm/YzKKMrg/amOcG71RyLoY2d0qYOvtuRlwieIHx/5OVvdlinzbv/fTDB";
  b += "5YApHPwAmYeoFYFWEUpFPA0R6/W2mJ4J8hYkRNhehO3dvw9pyhWH0jYUWJavvOMaROkpVsRmKdr";
  b += "YLDYuj7JxeWw9vwYvM8j0yUGg4raKz5tZlu+p+tD8Wkei9SEykRbS6CCAGFOsmVLL2clA8CKmGf";
  b += "m3O9Yj1Ltboj3Sy7JjAUeOUFHLAxIbrfgZ9jZwi6/KixmtKk76xa/77DOFPQlsfr4yQmr+b1vc1";
  b += "jjiKUfE5VvtRIzMjCxs6hvyrPI5w8urjdqGlQkXaomqabM0ptQKZ2JlQ5MTaUHcCbgZhy6y3LdI";
  b += "CMY9vphsBma0bAuBhM/1BGU7QSiGfaEbHl0CabDschwhPldqi62qLzgc1ts4OXk6v5Hlj4jBjBs";
  b += "V/8ZHVMVDKvSI7Qqikc8QkqyUcOSRErtVGVssI0Q6jb3XRGLchKDdnm7jmN8/lSxVXqP0Fq8tsZ";
  b += "rCkztEk3Tn4j8qauTomgT432GblXtoX5GgRDxswkSqzxuDAA4OfAzsx+/Q6ezUEKKURMeoeOCzd";
  b += "L/9svKVoS0mGP44mBqaUM4E0Ory2fM9cm5nDthHxHvzJN0q8/5fTcDvVgx+bxLw2zd3y9q4mDma";
  b += "3ziAJJa2ye5rg2Hm4tCW7BNKOMCxzjkjrOtuh5F2cn02uX6DYCv66frcBjcvEVL5emvr2OuNq7C";
  b += "wwX24IIFkCweJhW53XUeiR59VrFSLnOgwTVR0dEim3BXKVcTyO6vsA+WdGF+Lv6tk8axwxjlSLh";
  b += "X+FG4wBUT/TN/LhKk+o/JMQohCHzeshiNG+Mf4lj9U5V5lLC/EL/yvUy2HuOW/JC30Yep/U+s8t";
  b += "mCIX+q3XXmpHte8FJ4buvRO7jW9E0qjnEwVX49F7J6qeNB33Tpfzw/yrvZBkhIawel5FnYjmCPS";
  b += "+pqthLmCUfpCjk48zpnfVAJ7CKEQugqzZ2IBqWiSW0ZSLRe45VDSgrsO010nONJmdJyTN7t4rTj";
  b += "CaPyGnJbb45DYQuv/7qpI3UhQS+pG3FpSh7YKUgcaKaQOeTNStO65mNY9naJ1E24DWvdcTOuebk";
  b += "TrkEa5Dq27bGndXzOtO+Y2oHWXK2ndhw2t+0ia1n20ltZtS2jdZZCWGlr3h24VrcOwUVWH1o0hy";
  b += "tgfujGtG3Mb0roJV2idJAAxxG5MVVC7cWWfZandD9LU7rRKkzvBkQbkTuKZT0XuRlwhdxPuVORO";
  b += "rp+K3PH1CbmbcBuQuwtuU3J3wUZknyvvVE3uJlyz4P/KbUDuzrvxij/tVpC7Mb7lj92EuI1yyz+";
  b += "kWo5xyw/dCnL31+46b8RNv1RC7sxL4blTk7sp3wklmGnJ1zO5O1PxoITcpb5+anJX70EioInJHU";
  b += "IFsL1XmtyN0xcOBwYVDLmLQbGPrxhzE+I2xC2jqZbd3HLMrSB3I3TXwYDJ3WnXkLvTSUDl+A3xW";
  b += "iNBitytiUOmGl9Z+sFRlz/At3lFuPg3RkhRfLjpVS/Uveq26mweEsVfsRilImmozWgx16QtgUTA";
  b += "M0EuwbF+3mcIFb/Af51VkGhT9YuqI2/8S/AECMAldY72ytELRFr6o3U0IXAaiVo3wTlD8q4oTqJ";
  b += "Djf4TJSz2jvsk/MYgCyA/riTi0iAtgkMnneKnZBpVdJxqkSt3H+R4MO7m4i8SCIz4qMmrfN95xd";
  b += "4lv8qJhRmYxHbfUZ7H2OGbkDCSswOnkTwV8vmbnCmnm0rflMOWKv4fyhTOqfyWdHDuKkmZEWf4V";
  b += "jolypP7uiCI8sQZi8/efixB89nY1UjQTFBvEVqcd63QYkWtfMtBVL36o/vi0SKX4n1ARVf+gTAv";
  b += "X/w8IjK/oFioS4N7aDALayWqtCOqP+2Wk3xLvMvlV7J8joMz0zb+254JaW3ledWxq3l89Tuzfmk";
  b += "8/dZfj/OnvBthQvnuEnnVZClByOya29B0TXWblPiRX8ureq09GcnvNRHn90KZToOlIBJeZtwVhk";
  b += "jSIe1nsgaaZQt7bWHIFvbYwm5b2GULg7ZwRZnCZVu4ZAuTtnDRFi7YwnlbmLCFc7Zw1hbO2MK4L";
  b += "Zy2hTFbOGUKPcQKb63/P8nhxCa/P+DMZcQ0EOjZzOgiES25ASEGrVl5wGNgQGyPDw6YG72t1H4+";
  b += "aZdnP4bWC0nrmGndWhLQhXQv9sCHFQeY0eIDOoMQJhnkTWH6WHwoWlGimyD8R8AGUB4UezwgRAS";
  b += "abVvMzTu3PCHCKtb3bduis6aDNiHbJ0nXVEV3Lu6me2xGZLfIK/MLEjvrRgP8fuaFig/RdPWXzQ";
  b += "vRmxmLrOSFvJoXcvmN67+QKxnbpnohepPN8iZYmXg9gsN7+IUQDbVcjErEXa5gWY//eKS3bI0Gd";
  b += "2zlBAsZ7NacWyawx97AZIz5tq/ad6RFkVTEWkByiFEl64DTQUR7jOkTsNxY5gDPlQlYgHwcXISh";
  b += "3BWJVAUh6GUpwjLukhShMp6UYp7Dt3OxDVjvlK1pwHnHaOgJYx8NO6rQ1N3grEOSjagH0jieu1J";
  b += "cuiEuTYtLLVISjNbt0eDggZHsY7qDNuI8IWYh+sTgyPC2x6ASeWZw/AfbqZSPvv2tLz4XUKk1+v";
  b += "7Il3+MUkv0B9/83ieyVMpFfzbyH76DUjb6u7N/+exHqRREv/rb+ycwzo8+972dD1HBi37/9/7iN";
  b += "9RjWw1Kb7MoPaQYgwhrfKBPAAumBJ+RGzxLdzHoEyT47FegT1CNz34F+gQp9AmAz4HFZx/47Bt8";
  b += "5qX1JgQKmwJ7RpVgj2t4FRGy5nvEoIYltoSRskc7Jhx4Onr/clx6wpEIy6OIzy1DUXbjsW4y9ut";
  b += "Kxh5SyVhkAawa2xPvMHJEdVhm3EGf0FGmfebvlZVr9jPlm2kCX3eWWVGAsLGWswVHSZxkLAf87y";
  b += "YJ5LBrgk0Xz9CRkU/5NAOlLPIw0MeFEDL3GIVQjwkTYFUQPca33ybI0L4gMFMVnGvpZhwowZFgN";
  b += "zorbWVLVYXYZrTfZUOgg5Smaaux0+GsGuge4+4LSXcu1c0hDGIiC4ww7DgKmKWfEbZmXCXsDPiG";
  b += "4pMgBoNW5ln8lC/SjpD1OECaUYVzPVhvv/gFT6ZymFNE8mHSExla/j978oAhkYIi/DhH8BWaRN9";
  b += "Oi1HCgHDE37fh5xH8PISfB/HzWvzci5/X4IdPSXdw+jn8rMZPP6cN5JRxnD4OP5r1NvjpFERAQG";
  b += "FWlrGS0CS6m2JfDF2avkc1woeWhXDwaO2aSSeqJeTD3Ms0E10TWiLPsc0QPTJhkXewzUQbhcoYR";
  b += "DXNEBMwyZF3t81EX4X+yHfZZvDDTIzkm20z0WihTDIftpmoOJMpmSrbSmReaJZMozSzYMCYo4E4";
  b += "ETDfIbBMZ0llZHnK7hyCLM8IfFPI8ijhyvOCK/sNrgwpwajFSTbSOeJryQl7jB011EH5CaV8s1+";
  b += "JdKnexpUcvGiPpjXPNrdINyG7gSSecHJSKq5zilLqXMcaVg+6fUdLqWed0wN7GxA8VsilKSBH2P";
  b += "GjlWVewERY7hHHJFrHOAYhR55r1FiuDlLHnoqELb65py9U9VN/odzO7Z9XNtHczfTgm4tfgb5wc";
  b += "PrmsIeqPdFgSzn8FM+az9f2RIfy5XBNkvN5OB/2HhkIfSQT7okOUOdaLKwFSdLnAF1r0DgvSfrs";
  b += "HtTzaPxpGr8OXV1UGaPKLagsocopqtyKykKqjFLlNlRCqhynyu2odFPlGFXuQGURVY5S5U5UFlN";
  b += "lhCrrUdFUOUyVV6Eynx67QPemV908xry1OjhIPVJ5FW389NLzkzzP9L7zTed66dRJnmfq1KbzTu";
  b += "lcnOR5ps7FpvMO6VyU5HmmzkWm83bp7E7yPFNnt+m8TTrDJM8zdYam81bpXJjkeabOhabzFulck";
  b += "uR5ps4lpnMdOncf1F1xnucu09Oj/YO6lyvDeZrAszSBd1moR+NUizCdKdCfobYN9UB/V33QX6Hx";
  b += "r7agv0yV11jQX6LK3Rb0k1TZaEF/kSr3WNBfoMq9FvTnqbLJgn6CKj9lQX+OKvc1BP2GNOij5MM";
  b += "dfV8jPPipRniwqREe3NsID+5phAcbG+HB3Y3w4DWN8ODVU+NBtJs289fGkB+k2v1VkN9Fba+rB/";
  b += "nX1of8YRr/gIX8Iao8aCF/gCqvt5AfpsobLOT3U+WNFvL7qPKQhfxeqrzJQn6IKg9byO+hypsbQ";
  b += "v51acjfn4b8mxtB/uFGkH9TI8g/1Ajyb2wE+Tc0gvzrG0H+wUaQf6AB5I/R/D0SQ36Eam+pgvxR";
  b += "antrPcg/Uh/y52j8T1vIn6XK2yzkz1Dl7Rby41R5h4X8aar8jIX8GFUetZA/RZWftZAfpcrPWcg";
  b += "fp8rPN4T8W9OQf0sa8j/fCPI/1wjyP9sI8o82gvzPNIL8OxpB/u2NIP+2RpD/6QaQv0Dz984Y8h";
  b += "NUe1cV5M9T27vrQf6d9SG/p1AOf8FCfjdV3mMhv4sqv2ghP0iVsoX8FXrGZgv5y1R5r4X8Jaq8z";
  b += "0J+kirvt5C/SJVfagj5d6ch/6405H+pEeTf3wjy72sE+fc2gvzmRpAvN4L8LzaC/HsaQf4XGkB+";
  b += "HwHgAzHkh6i2pQrye6ltaz3If6A+5I/T+Mcs5I9R5XEL+aNU+aCF/AhVnrCQP0yVD1nIH6LKhy3";
  b += "kD1DlIxbyw1T5qIX8fqp8rCHkt6YhvyUN+Y81gvxHG0H+I40g/+FGkP9QI8g/0QjyH2wE+ccbQf";
  b += "6xqSCP03hucziXeP65LFN8Gtqfd2uoi1BdjnI0mi2HzyoU6FB+E/2dpL8fV8W3UXE/jVqxxnVKH";
  b += "VS5SO03olKkyj7qeQbxDEvTqHaBulaiMp0qe6mrH5UZVDlPPctQmUmVIeopoTKLKhPU04vKbKrs";
  b += "oZ4FqMyhyjnqmYdKJ1V2U88qVG6gylnq6ULFo8ou6lmyhi0F50KKHS5cw7aNcyE1D/tQyVEF9hI";
  b += "hKi1UuUKVblRaqXKaKotQyVPlMlWWotJGFdgCLEaloD/OH9lOjZeoUaPiU+UUVeajEui5a9xR2M";
  b += "R9nCax1xvNQtu4FMUxLvbhHbJWDbkKXxHXSpiHuPYMoHAhrs7VRd0xoKfraQN6pp4xoGfrWQO6U";
  b += "88ZoJPhDQM6qzMDukXnBnRetw7ogm4bQGL7ATottg+EGUKYbWGWf3P828K/rfyb5982/i3wbzv/";
  b += "+vwb8K+7YeGTG171VOgJ5dipMzZ2VJhZD5uY+doTWrFTZ20XDYL5fxb2+ou5n8jGTp2L+7Pcn0P";
  b += "/IurnlblTt8T9Oe5vQX9I/bw4d+rWuL+F+1vRv5D6eX3u1Pm4v5X78+jvon5eojt1W9yf5/429M";
  b += "+jfl6lO3Uh7m/j/gL6e6mfF+pO3R73F7i/Hf3LqJ/X6k7tx/3t3O+jfyX183LdqYO43+f+AP03U";
  b += "j+v2J3a3UZD0OGiYy5w6rRL61quGkB9zI3vwvVTbvxUro+68Vty/bgbfxXXj7nxLHD9qBvPGtdH";
  b += "3HiWuX7YjaHC9UNuDEWuH3BjqHN92I0RZCB0GYNeGg5WYZ8bYx/NET1sboJ9MWIyJeQBB+wARr9";
  b += "s7YBDMsDgX652wGEZYBCwpXbAiAwwGNhaO+CoDDAomK8dcEwGGBxsqx1wXAYYJCzUDhiVAQYL22";
  b += "sHnJIBBg392gFjMsDgYWB61gP95oJgEindhmwa2AYGQCepYQANTP3RcolatqOl3zRMUsMONJRMw";
  b += "0VqGMRwvcC0XHCFxOtVpuG8K5RdLzENsPsAQdd9puGcK3Rcd5sGZBZYxBlDTMMZV6i21tKwBpYs";
  b += "TL9ffoSkJy1uiJBC7qbGRyF3U6OjkLupsVHI3dTIKORualx09KBqiIuO3tEQFR29vSEmOnqgISI";
  b += "6els9PGRqGB32yuHnGIMIqn0A9iFq2WtbetBygFp+xbYsRsswtfw726LRsp9aftW2zEPLPmrZZ1";
  b += "s60bKXWj5vW2aiZYhavmBbimjZQy2/Zlva0LKbWvbblhxadlHLF22Lz/g46OH3FUBHetAXVRN83";
  b += "K+aIOSvqSYY+QXVBCU/r5rg5D7VBCl/tRlS/jvVBCt/RTVBy72qCV5+Tk2BmNEIgfjT4NrOUeE5";
  b += "gTW85yyFotbnTevZuPUMtQ6b1jNx6zi1fsm0jsetp6n1y6b1dNw6Rq1fMa1jcespaj1gWk/FraP";
  b += "U+lXTetdm03icGr9mGu+wI49R40HTeIttPEqNh0zjamn8tMXp/pcfjx19qBkaH2yGxl9rhsZfbY";
  b += "bGB5qh8VeaofGXm6Hxl5qh8XAzNH6+GRo/p6amr3v8cvh1A+Y9ygJ/N7V+w7Tujlt3Ueuvm9Zdc";
  b += "SuS9xw2rYNx6xVCnyOm9UqMkwiW9E3TejluvUStv2FaL8Wtk9Q6Ylon49aL1Pot03oxbr1Arb9p";
  b += "Wi/Erec9nGel9bxtXeNOMC1+9OXHYXrQx5sh8W82Q+JvNUPikWZI/BvNkPibzZD4SDMkPtwMiX+";
  b += "9GRJ/oxkSf31KWjxECPjLoMXHfSOaQDnGxGO+yB5QjBuP+iJcQDFuHPFFeoBi3HjYF/EAinHjIV";
  b += "/EIyjGjQd8EZOgGDcO+yIgQTFu3O+LoATFuHGfLwITFOPGvb7ISlA0jb9svnBI6q8AJe5tgsPLm";
  b += "qBwfxMMXtkEgW9sgr8rmqDv0ibY29cEeVc1wd1SE9R9ZkrUnciUw08o/TSwd5wOMfMhfDMygG2W";
  b += "XtFBbcCW6VS33ZbpCLjDlum8OKhshU6X82yZjqJdtkzn1oW2TIfc0JbpRLzIlun4vNiWcdbGUeo";
  b += "V4FozTU71uzJNTvW7M01O9XsyTU71Q5kmp/q9mSan+n2ZJqf6/Zkmp/rhTJNT/YFMk1P9oUz9U/";
  b += "1hyEoRY1AD2+ZXuhPw/wj1nlX6E0DFQULLnapyzFyOeLgavbStfgbDJqgwpIrrcRE6xmnAHpEfX";
  b += "6HiZ5UVIF+m2i5lJciXApEssAB5kiqfVFaCfDEQGQNLkC9Q5UllRcjnAxE2iAiZKk8pK0M+F4jY";
  b += "gWXIZ6myW1kh8pnACCAgRaZlFZR48x8LIDum5RRAbExLKYDEmJZRAGExraAAcmJaPQFExLRyAki";
  b += "HadUEpQKvmACCYVobAWTCa5BJkMXBB4KSq3ezOPhCBqLcpzBPkxkr2X0S1ctx9ZM82bHcdxequ1";
  b += "NiYLrNBN1mPABMIRLO6CLEv9MGkKkYMuAZA7pVz4QgeNaAbtOzIQ2eM6DbdSekwTeIXPhlFwkPB";
  b += "+nlW0ckfCBIL986MuFDQXr51hEKHw7Sy7eOVHgkSC/fOmLho0F6+daRCx8L0su3jmD4eJBevnUk";
  b += "w6NBevnWEQ2fCtLLt45seCxIL9+0cPh0IDvDxWyldPhCtlI6fD5bKR2eyFZKh89lK6XDZ7OV0uE";
  b += "z2Urp8Hi2Ujp8OlspHR7LVkqHT2UrpcOj2VdQOkwPa7yPnMo22UfGsk32kdPZJvvIeLbJPnIm22";
  b += "QfOZttso+cyzbZRyayTfaR89km+8iFbP195GKWj437c6K205+1wuB9OSPY3WVb9uaMZNdwMsidx";
  b += "Ho7/Uk7ZE/OyHoH7MEzZ2S9T9ohu3KiuLN8TzSYM9Lfp+yQK1kj/t1hj5lZUdjp3bGoOitauxSX";
  b += "NJkVCv7yYyU9aX4TFlo3YaEXN2GhFzVhobubsNBhExZ6YRMWekkTFrqrCQs9rwkLvaA+B71T6SF";
  b += "FJyJmm0WMYbQTIr0QPYTILEThIJIKUS2IfEKUCCKVEF2HyCJu5LJIIFZyWeQOouwQacMyLouMoT";
  b += "clX/jlV0b3MOo3I3d+M3LnNyN3fjNy5zcjd34zcuc3I3d+M3LnNyN3fjNy509B7qDyHwLxEESr5";
  b += "Inn4x/hHvG/O9mQAkf4yiE7maXmc110PGsMEsATH8sawwewxEezxjoBLPFI1lhBgCM+nDWmCuCI";
  b += "D2WNFQQY4gOG6jFDPJw1JhHgh/cb8sf88L6ssY8AO7zXkEHhhvdkhRvenRVueFdWuOHBrHDDVzL";
  b += "CDV/OCDd8KSPc8GRGuOGLGeGGL2SEGx7KCjc8kRFu+HyGuOGF4GJ3MzO8BHMZM79deLm4Ng8fEd";
  b += "cW4GMzFYzwIN1iKPsSGeGXXeLX7Bx7vtk59kKzc+zFZufYyWbn2EvNzrGXm51jrzQ7xw424z92N";
  b += "eM/dk/Bf+zJ0lGTTrCfwblzrmCxnOwGBJXleDcg+CxnPNHAmYPegGC2nPYGBL3lyDcgOC7nPmER";
  b += "MnL4GxBslxOgcN0ZOQYKy52Rs59Q/4wcCK8j2/8SyDaXxWSWzV2QYnC7E9Z2XoqpXZSws10pRnZ";
  b += "xwsIuSTGvOmFbF6YY1ipWdegVY1WHmrOqC5uwqroJq7qkCau6uAmr2tWEVV3UhFWd14RV7W7Cqi";
  b += "5owqqG9VnVZUSy9KeFUxWDhucEvmLL8LxUxIxhWCpiwfAlqYjxwpelInYLX5GKmCwckIpYK3xVK";
  b += "mKo8DWpiI3CQamIecKhGMMGPdHuvgIGXLlmBly5ZgZcuWYGXLlmBly5ZgZcuWYGXLlmBly5ZgZc";
  b += "uWYGXLlmBly5KQy4YPw6kgHPyihXn2clxnQZeC46TfdWjuD9dSjeXw9nUvvroUxqfz2QSe2vw5n";
  b += "U/ro/vb/uS++ve9P761B6f92T3l93p/fXXen9dfAV21+vKyVeCaUE5PeZamHS2Uy1MOlMpkqYNJ";
  b += "6pFiadzlQJk5B3qVKYdCpTJUwazVQLk45nqoRJxzLVwqSjmRph0kjmldqh6UnXhUkvizBpNU7qT";
  b += "PeWgTryCWM1/VtG1HKPwv/nRpO+KGl7qZ1VXVbJZdVbRrFlVVpGmWXVWEaBZVVXRmll1VX/Ooqq";
  b += "Q7lYUTWSq1BUHctVKKpGcxWKqrFcxfl8OPcvoKh62ZmPoBnzETRjPoJmzEfQjPkImjEfQTPmI2j";
  b += "GfATNmI+gGfMRNGM+gimYj4BWz7MwaahZPVg3y/Tq4n8n7MGQZeAwEOQB6w6Vm5gpoUIPS9Lmax";
  b += "pYvFPPZ58lpZdzjfPQFrdQ6zi32hq00kltpKI2UVGDvZCt0T6SQ4iGm/Wn8IL3EG29OXKL76KGm";
  b += "7lOr1LA8JuL92KIKn4Mfz6lqDoffz6me+gKDqcQlqJDeCXjb1fqcYfdsM+62pWiA7B0h0vb0ipX";
  b += "O45dsrzC1W45jT8NNyd03USVMVjFo7KCKqdgEY/KjVQZpUo3Kiupchym8aj0U+UYzOJRWUaVo1T";
  b += "R7PxHlRHYmrDXH1UOu5wJwAnnIQ+57ku72i1nR7MuuNot1VJR4pI2r8K7bp7pnC+dCyq86xaYTi";
  b += "2dvRXedb2mc7F0LqvwrltmOhdJZ3+Fd12/6eyWzpUV3nUrTWconTdWeNfdaDoXSueKCu+6FaZzi";
  b += "fGuuyn2rrvJ9JTgbNjHlWGXJvBsGuqMlvMwnasS0J+xoO+rB/qlFaBfSuOvWNADDy5b0AMPLlnQ";
  b += "Aw8mLeiBBxct6IEHFyzogQfnLeiBBxMW9MCDcxb0CwB4vSoN+qUJ6Pu0VObhw1eZikpAneDBAtM";
  b += "5PwF1gge9plMnoE7wYJnpXJyAOsGDftO5KAF1ggcrTWd3AuoED240nWEC6gQPVphOgwc3VeDBTa";
  b += "bT4sHyGA+Wm54S2/4nkAcJqoY8fAGuBfLwd4ghD1eHGPLwcoghDweHGPLwbYghD7eGGPLwaIghD";
  b += "2eGGPLwY7gO+RcP+WMVkB+pA/mj1wj5c2nIn01D/kwa8uNpyJ9OQ34sDflTaciPpiF//DrkXxLk";
  b += "L1RAfqIO5M9fI+Rhgx9DHqb3MeRhcR9DHob2MeSvpCF/OQ35S2nIT6Yhf/E65F8S5GGhnUAebGQ";
  b += "15GGufS2QP56G/LE05I+mIT+ShjwM0mPIwxA9hjwM0GPIw/A8hjwMzq9D/sVDHnHTeum7SnQiWJ";
  b += "Pi7/MImyHAX5vEy6iKk9ZVAfYuvU4iZtwisTJulSgZt0l8jNslMsYdEhPjTomGsV7iYHDEM4UYD";
  b += "3pBGoBdScSzeborHfFMVcBMmc71SXiMBGbzTeedSXiMBGbadN6RhMdIYLbYdN6ehMdIYLbIdN6W";
  b += "hMdIYNZtOm9NwmMkMAtN5y1JeIwEZgtNp414tiSG2RLTwzz6Aq4M57WNdRaZSCcCsg31QHZXPZC";
  b += "9WkD2GgHZ3QKyjQKyewRk9wrINgnIfkpAdl9DkG1IgyxKXjiOVFYffj/VCH6bGsHv3kbwu6cR/D";
  b += "Y2gt/djeD3mkbwe/WU8LMxyu6vgNjr6kHstfUg9oBA7EGB2OsFYm8QiL1RIPaQQOxNArGHBWJvb";
  b += "gix16Uhdn8aYm9uBLGHG0HsTY0g9lAjiL2xEcTe0Ahir28EsQcbQeyBKSFmY4u9pQJib60HsUfq";
  b += "QeynBWJvE4i9XSD2DoHYzwjEHhWI/axA7OcEYj/fEGJvTUPsLWmI/XwjiP1cI4j9bCOIPdoIYj/";
  b += "TCGLvaASxtzeC2NsaQeynp4SYjQn2rgqIvbsexN5ZD2K/IBB7j0DsFwViZYHYZoHYewVi7xOIvV";
  b += "8g9ksNIfbuNMTelYbYLzWC2PsbQex9jSD23kYQ29wIYuVGEPvFRhB7TyOI/cKUELOxvLZUQGxrP";
  b += "Yh9oB7EHhOIPS4Q+6BA7AmB2IcEYh8WiH1EIPZRgdjHGkJsaxpiW9IQ+1gjiH20EcQ+0ghiH24E";
  b += "sQ81gtgTjSD2wUYQe7wRxB6bEmLMNYphKPGOy3Rv8WP0u6x4L3Eoy6hcIp7y3us85XWe8jpPeZ2";
  b += "nvM5TXucpr/OU13nK6zzldZ6yAU9JPCPxkdclkde5xutc43Wu8TrXeJ1rvM41Xucar3ON17nGJp";
  b += "LIyCu+C9JHtnCFZFJkkqVYJrlMs7lQoczty/TN9Dc1LlJsGSv1UjQ4XfI73mzTiaHAiYQdpNhLp";
  b += "UUuKM6B/C0vToYcp0fOL3VM8uNIbdFqa+RuNdkaOQcyt6Ml/0mTws1k9OXky74k2UbWZslZGCKF";
  b += "faRKJr+2c29BLH0/7ofe3QU3rzlzIHIxIvekWitJ/PBAV3uSCr34P10nz+my/9hHZuniJu0U/yj";
  b += "OE7y0KlO06yivMk90nkbn+bM2sHm8E3WWbakYl3JSyt+m3B3R0HdPcgZsxSVOWRftpRK+0eVS5E";
  b += "hCPddMDrJN/rOrAjMjnGwyOn98lIa1IeMkhgXR4OApvg4ZPZGCVRJgpnJfoj0r91YbFL0P9ekkZ";
  b += "TLSTfe6/MauDmwJWXc5abVvclT6myP1OCer5CfeszXMSFZAfg1PZ4wdSY9bRAJolyZE+8Z5wNUu";
  b += "l4qcBZfujJtyqlHz8i7Sm/JtC3J7dCJXdobz3NLojQXk2MtEqozH+ehtozfP0IzSe3ZsKVNBMmZ";
  b += "7kf8EaiUvb2/Kqfe84hFJq+dGumxyX+usSZ/pIIG8s47zIXOu7cBkjOYk75K3W91dcCwOoqiKD+";
  b += "fzixxGzI8PDg5+GM+hHlkHQKwOQbSwKhnq05IM1UuB+UeByhkw5+jpOc6Zfd5mnE6BKlf8OFqH1";
  b += "eYwy0kOkZJTMOOCU+Yc1UhMKoA/hrSvxd9SkgzzmApbfC4dVyVf8CJTHEb2xUxxD00cUB5pYp9A";
  b += "Hl6e/Y0y3tEZ3YKkjFho48g+StcW/4auXOGMqALm9m+BBpGitSUZpTe4MpnnnHJkTIwIQ+6lFsL";
  b += "u47jP8eeAyMdQpAEP0YDWtUjiKY9YixwUKJ9G+REujqH4IBVu4ZyR+LziRUXv9RWPE6cqRkjt05";
  b += "u0eXkZwAPpfjQ7TL6A06WMrABJBOkj72TLbU6WPr4lUhs5Ha9vkyF7jCxY9h6WUI7+ZMvRPz03K";
  b += "nkto3PPjzrF/aAmTh60ReXjCa54obykZaEnZjHvyGce9LjvkcTavHADzv9pHosJpln9r34kt8Tg";
  b += "9/IM52Wtc9pUQgp8Im5GiJxjSsxYjdy/kpTTXk/9bcn1WQQqXewwhXOBGZw5OepBithRZa9lnCs";
  b += "ed0OAmJcLhthOIVcAONOH40wHHP5moZLKLCz+er7V/wRdkHzTOVlf/zwl3k/69fB+xLV4P+RZvB";
  b += "9TgvdDvsX7MTeN92OuxfvTboL3zwneP33VeD+oDN7/NeP9qFuL92fcGO+RKzXB+w8L3p92Y7wfc";
  b += "wXvdylB/G3aPGMtsg0oSZS91t0ti+AyyoNK8mAzStMnNsZ9OJP4ckuaoalxf1TVQf5R9RKQn2e5";
  b += "BvmH/GrkH1MV2E8YbZ9rsP8Haew/rdLoP+QJ+uMr66O/JDCeCv1H3BT6j7kp9Cf0tMmP66O/6ax";
  b += "C/9PuVaL/pJ9C/+2cCBuzji2CP74jL1lqHWa7UnsE3XKmQS8n6jPY5UQemAEnGjtykiHkoH0xuC";
  b += "2C3Vq3iNJat4cbfGrQ8iV+8ccEtsW0u4GR4vzduY3+Dt4HHSRQj5xAe8jxLTscoeMLL7yQvZ/fV";
  b += "EXEShV/6IVOQeWxldEY7PHg47ZvMW8sHB3zeLLFLRR+LnSObKDS4QHM4OtCp4t3yy+q/AJqJTgU";
  b += "T/k2VTht5pIKeVordmJ3u3Zok/5/2XsTwCiKpXF8jr2yu0kmFwlJILNLgHDfBBGBCXIJCAooKk8";
  b += "IyQI5yLE5AEWIQDRRlPsJPEDkEERAFFRUkICo6ENFQUUBQQUFBYmCiArkX1XdvbsJx5P3od/7/r";
  b += "+HZmequ6enuru6ju6eKjeGzsGv/0p19QEM934Xe97F6qdXYEFdV9ZOSIYLqSXaFpNjBFKKTMIcf";
  b += "2xuNauPCWjAr3DiMOksOvBumRGHzX2pdIdkJ9ccaRxhwEnQOxwPK7Kl+jtM+I5ABc4/BxUkQdRV";
  b += "MSyw3AdUHxPTNGDyFFJUZMjpHUcfspn6wRUkRDZxsHeXzwrqbaiFLpy3KhGvrT0LYo5l2mM8aOo";
  b += "NoACkRgWJNdKBgcQpUrGWqb1NuhrpyFCOVYGaDcUe5nTLCJC3H/UpC0u2ULJQpMwY2tqMXfKMKv";
  b += "QmR30RdN1QCqEH9x2pYHHHJWMNv9X2q47aQIBsBkziM2CPqbtZNzkc8ZejBqIFi3SVTMfVMmOul";
  b += "hl7tcx4qWaD9pZvFw1aX7bd16C6NOUN9Qr2TR1sL1MmTcy2QCPEaJWtfQvmRN3L534psezLPIy0";
  b += "oBZSrk65hK5bcA1S3XU1Gw0CfHwiabk0i0rdMHN05YGpMH+0SvUKj9v8j8de2jnUNZAVyZgLIyP";
  b += "ECxVjbDj0FmPKU58F68as3ROKkqAEAZN2j2O+ihNSMiaTjk7x5SU+D4W9JjE6k5BxKWi8xBAThi";
  b += "mBBoZxYBoIoMmqj2Myo41NXLQLqqrekLIMlFYXq6qkfLIGesQZclaIIvuUcInNaBNj4Ik+Hhvp4";
  b += "7HA2+PhsvsgSu4YuNtBJhizBoincu7K2S2qMWgRagsUEhBYqcQqlVlVq3xVnTlQQa3zPyFf9olp";
  b += "V34Cy2N8cLCKz0CHGMk0l401j8F92ePQQ+dlzqpoynKTh4yymGTVxoRTb5R9GF/dDMLcEVNztGm";
  b += "sQRrUYWQFeZhhrPlumxRgxsQStaMkNoC7w3Quo16GBxxhbCIEUEhtWhS4HKOOvexEIDKPF1IkiX";
  b += "QrTnfAfBC52vw5DZ4DvmKmQcSXOyLYvLRlBiAbLbE3Gqvk7MB0xAvVQwm/W2Y3oBPDDfUKGkzY3";
  b += "eyKJZaYHLVEVUphYE0rFdnqN945acokeUjR7B98OYHA8twmELbKJMZ7dRMYnLHU84zlsxUQG2gy";
  b += "qAN+i0shcGdFLRYUJxDNNpBUsaj50GSWdZuPjztcnIHjxeTn40xORHK6U5DunHDZfGgbUbRizKM";
  b += "7jRHXjMPbJNIhiP27FVY3WukKykiFCQSSkeZqMpIzFj+Hwo4Kl4zaSOrFOFklI6FnHO/SS7SIeH";
  b += "oo0pi2AphICBSIEeOvspGDTBwJmhv+HPHYwdeREdV4LFLQlDFV7o8EpwHFRHFaYhStybRARDSDf";
  b += "b9vBcytJqixUZN86Ws2VE/fHqRok4DvIqNwgXXRSpJc4WjdSFwFh65nq0WqbwVJ9a0gqXgBrVsP";
  b += "T1aTSOV2WwzUwoED2gybsfN7mNxrkf11zeTaRYdM3QI1oRKnItwSYc0PJyFs88G6he50yNGBqxr";
  b += "xmUkSaFhrqYfcwQiYEIikdOtaWh5xhyDgQMBJ6UFrmVUVioATAROla3CL17C1RuWD2yR0pJKiP2";
  b += "yc4fcTEDgXCJwPBEomBwBTA4GyQGCaHyhbqWt6mFd3evUgr+7w6lavbvLqiteQeuaj0ZaAP3Xxp";
  b += "w7+xONPHP7E4k9t/InBn2j8qYU/UfgTiT8R+BOOP2H4o+FPKP6E4E8w/jjxx4E/dvwJwh8b/ljx";
  b += "x4I/ZvwhA1LFHwV/ZPyRvFf/B0LLSCj2gqx2OQIUVt/6Jqn7TmYuW2ndFI0ekytIRRUzCLVXEy0";
  b += "6Mi4BxiGzVIQOCxQAI25N4XQCoxwk7qFGJ7+nCxO3TF+OQXoC6jb2IS0eU4iZgO4KAjUGf+K1db";
  b += "gmaTKOYf4PChNDQIKGZpzjj1BpDX8isXQolC47IUrbiICNGGPeiYDSNqaDQ+kQKL1KlEbaN3RjU";
  b += "2BRJtyxaDAU3emruCU1GleHyrdJRJ/GJMOm9dNtOtg9Opho0DYrX8FEe00P8gGAlFMAupnfmY2u";
  b += "WWRVq82kXm65o3Qn8i/seLKehzAeT3adUXm8gstN1fgUjXu2hAzQPgnnIcxYxbecTJNLwKDCKcQ";
  b += "VJKMEKiEJKO6AL+/+Dto3A+W9XVcbqUn4jJ3V3DWLI2rHOlVgFT4YzW3oEA6jDcFWSJFegDkTH0";
  b += "TGCO/SDoIUjubL1LYaq9XRErOLa6ZrhHgm0jBcs/KRu8vEqRkjZjpBnsMBjxEDBvUgnmwDwAoNP";
  b += "nLkgfKALT45mrBMEL++XMyrXpZZ6o6ZFrDJUNF0mYV2aAQhnwcdVpsuu63BYO06TQ6gSZt2VHWB";
  b += "0sBuYBjYDSig/BYEfJYbl60noIiBJmVmGWPzDTUL1V3d1CdOV/tBdRquQmeKZ8xZutonjlelm7V";
  b += "KE5bW3gUZr500uWSxwSG2ObRnaFMF6LcfbW1MfZd2CXoE4zQvEQAaqU+YgoG1YE0WtCFhVvSGBL";
  b += "hkoZA3SgDErZAVstPsoDe6UEnBZAsKySyQ2jZU/ExAY/3yg83McpXcMFRapgstxQQgrhITYe60O";
  b += "HiLcGJlocWKA6xgG9jNUrbzwi/jsE/Pv0PoInbwUD//E7J4Qma1KUzU0wNIOxI1m8jHqTqMc9Xq";
  b += "6R2sKl1rIENLEyao0cA9FuB/zI7Fl6Etje+0BGL5mQr6j8W3ZuGgniWFiF7G3kzLek7adQqiaUi";
  b += "9wzYUgpDfBhEDRvWrEh6iH1RXJ0Lvq8Vj85H4fXiy1ZNLWi8u4xjCNoDhGozbF1oX3HXAdQAzDZ";
  b += "8xzphA9BGHhiWu26i944DIgajuwGU/KzI0VCB5eixmQDLVDI/Fwu8pE1OHjZa+lRoy8MiKOyxVT";
  b += "6wVqG6jIgQd94GJq9O00+Sb4xGsKK1aKJnaLBgHUqL4TpQOvITEZahQxrtmBTwNM18WMz/qMi8d";
  b += "5gglYwhtb7jJ8mIpuXo5tCkjajIW4CqM+zC0ZiBaoX6ORvt4dqzamYn3gVnTFEe1Z6lJYXzPD1m";
  b += "cvDbZrz7yVR9uivwjiO3boaJHmpmusl075JrMDjAeVPqTil8CrKSpVKIYWyfdAmq+USUjXCUL+C";
  b += "LBF33wBdkB813KbCpJkNQ3GKnDgss/ZjQ+NcPsshqH122XXBakX9oo9OXtmEbpbInHwAVuk3ZRR";
  b += "S1dt6KhSTXF+HgRtLu320r05O1uEpuiwDjROKFb2gmDmU1TQukRLPMlUcKua69gXDx2ERoKGfG6";
  b += "7KatMAV1ECtcgHdCv2Kd/eMgK9hCJpAVTQnQVWg5DjhblstKtbqDWKtvgSrA+MlibYGHsXwQJLi";
  b += "VwAKKr4CNbJNLCqj/qoCpegErcHOXBfeYLZm0w2iaRN2ksg5QsQPstLDgG54gMsOyYBwc3al11C";
  b += "IZspGWe+FzoAMaXfKRPxkJ+S40Xob1QSvKsBTqFi+wXhN2oASUARwl0ZARRu0RHgJGYyn00qN5/";
  b += "eEZCzzlLMRnsNMxJqKxWGaL5gcC7veKfTmz0SkzxZRMd8D82sJlx3O4ltwS7uJwR86Meyyoo3Sg";
  b += "2xi4G053Gu3M4Z2TNubMpCu2V3o5rahVhheC6KiUSPFWfZh6gdPTMkywiRMFtAeFktwbaRvld1V";
  b += "oP7xVcZkZpU/vOFzcpRmUhN0A3ddeacowNzPMTwQ0rWaTlwY0WWyVm1lL563/Vy0d7Wspa3OSr8";
  b += "2Jvjbr1GbWHCTdOMITsVOTL9vx4l5lWJT9y/4e4sNigA+LXsjw4W3GAWiE9igKmgtLtqP1aeLWJ";
  b += "xcFYoKjLcjW/dlaDC6qENf8VnXQZCMrQntCdsRKuFDOlCQ0fKezNWGti8MRUo2XMvZYU9Mz5ICE";
  b += "MN+yPB3S2GKqlgJC8H1Wi+DhxOvDSY/EfauPTUZMe2WnTGUCV2WoGr+8wleFVl+eYbi0rIGLUWG";
  b += "6FDvx5g94tRXS5ctw8VeLndyg1Ul2mkNGRTmUn3KxkfC0VeurWSrWI/vfhqvFWvWahzG5vKSq2p";
  b += "paMC2kmgwl35CL8ZHASu7h2fGGlm+Yin2Qnm+YiwkBbafCFPmurH8+4uAq1qXGDDCfhaYczLr9s";
  b += "ATdHsuyD5RANle6nSy7JeU6mRDXccWeHuQ7HlIWe/AwuhtmZ4Z4WVzH1ToFAm0dz1uUsIk2ILZ2";
  b += "Sryw5N1Og60MuSOy1rqViZgZI2x+d7DOUiLFkoA7hKdoYsXAHcpTnGJBwa3xFJtYb3CH8RSTWI5";
  b += "wh2NKxFrco+Mpjom4qDBhgltlFxO7mNnFwi5WdrGxC8Yqc9kNq0sGu9uuY1PUlawZih6MPyH4E4";
  b += "o/Gv6E4U84/jgmkldKcsKIlfldMrL3+2OJMUQC4rMRRn5Xlgw1v+dKhqPfUWV1ZHFegoIWzNbDe";
  b += "Rnd8YBbWemOZMvjAhPRV3QALUWeMoEKRTFqFeiJLq5eqBazCgXOYmSqF4pmy+qiIWJAqxeKYevs";
  b += "onWCDqoXqo06j+RrsiCf6oVi2YI6WsDTLs3H9SRDzgcqBO3VvjJfj8B+itCVlfleWpNHGwCT9Vh";
  b += "MiKEEGyXUxoRISrBSQgwmaJRgoYRoTHBSgpkSamECKZW6iRKi8sXSJ1AQJkRigkTzB61lkyH3AM";
  b += "2VtGFdykcNmviEmt9dTE7ahuKTk83QTMdsEyim7GQdPySmJrId3iqpH1ttt7lp89DUgzYudTB4x";
  b += "V456myo8Rk2sfLutqBOjoIPLNvecWR/2/rFuc3GpAIjodilwGMWXHsivRJXnrBjTIGbkya+OYn7";
  b += "PWaAtEztI5mOf4EmZGKbDUzKsNUO3cwtM9+is8zUUEUcFqN1Z7babOKHvaBVLqaYMubMukQBuxc";
  b += "4t++Eg5PkXolGgg9Vj/50aAuVM1BQvGjBIGQp9iWEUILTnxBMCeHFhjXfqMQEp2Fy0qFE+dKHDl";
  b += "OBmnUGG3S0MfCJYFGmglWpOFxytW1mJauP7xTBB7K/vbyVKqhoOj+3ww03m4NWmhOBgkhQQMlYt";
  b += "atTcjCwHd90WST7CAil9VjKbKT6MpHs6uFyUT3JYZWYQdWG1s7xDJ7CSIwdZlDIAmSbpqGZoAxM";
  b += "NtH6FqHQi/YCEW0m31wKMFA0CRU8mIksitYunJkuhVYtL90IdbJtUrIukfr9S3qOr0KV4EnyRIZ";
  b += "MECBDZruJDr3g3jsXOFpCHFbpmxa05M5ydHbYUWKHHWUf5MRlpcCdS3iCTRp2FAlX3shAxR1uvn";
  b += "7AdvmzYOrQmcb+cbjlRuux2M72tIFhQnYh094QrmWwdXdc0IV6rL56cKG3Bz4N1hFt5uCejpUqa";
  b += "qSSz2eZ6N8o0WnBlI4SlOj94wxaFbXFuWTWWAvjAbiFYaKVE+IIqz9e/bHUBw086Fw8Q9oL7i3U";
  b += "J8azmNcbN8NtulU7o+BSis2Np4AR9k9A31Yutc/C1pppRzfGfy6UlmMNkxc3t5SuKuM1LX37YoL";
  b += "/cMscZ7kLZrCb9snsYl2mv2kSnloBXs1Picpcy7RrdV3QsQ4QdTaGjQ2PXEnIXGxooFpoz4t4EX";
  b += "SSC/Q3WqDB/SGqyklcSbdpn+OhECijsXNSjVQtGbscJ5eJLTigRsjPUFiwZCQd/7EwVU5wI+j6l";
  b += "mRsJmXyE1G+PVlrI9RfcEcmdGX3YOSmO6VMvXp+Mj9GCz9ds7TX2XwwY61t2ZFgvmsOjHSjiW3r";
  b += "6ZnaOZXMM1qz59WZsf+hCbQ7TJu/nCXgQ0HYy3xrnWhZA8Gr+0+y0MxRmF5Pm8paC5eJXqE9rdL";
  b += "2HxiltI1kZXuENjp6hd2i2+IYokQM0Lh4tjSLtzHsxAC0zqydo5Nw0IluMxp8MjueYELzyoTLYq";
  b += "oBLAXnRhISj3ZQJUZrqJioMjHBjo/hkSiZ0W1iJnIU2tB2onTiO7Ldqx3SQWHjxHnn32lBI9dt0";
  b += "VaaaGXWgu2NQlSANrRaIIpptdRJy+NiR4XOrTnZ/qupOzP5eAZRrr9RklvBRik44pc2Sg5olEJ0";
  b += "hM3w5Uj+5ooMB40J3NACOg4WMlaVL+oENZOcIKCVrBBFkei0AT8DjZvC0IWcncmsCYbUE2UU7ST";
  b += "bcM0IZ66cYsJpK/Npa/NNW0xxgUR32VMkVyibvuZEycdliH0E7GAp7MyeG9fL3U4QGcCBFBcuWL";
  b += "IiVqRJ7OxEl0pzBYkLT/O5gnE2IF2FsJmBIjKE6MrKmUzg8SaY0lbQxoW0py8BUNorbHVXq49kp";
  b += "2rRLpUdGWRFUc5a/ePqYNvmDsZi+ShbEBk2t9yMCzJ82A47F28uPiOUaiv9ZrIVYRgkRSb9h5/e";
  b += "NNPkBm6DJTS3HWnd3EiJdIViKTudgEdqDk1mipAJyxGnwdN8CKuM2nQ+v1oSDwduY6O+5tMfWHU";
  b += "NbkNnrPXq+chtZLYL5ec2VGtbdmKGlfVzG5lzG4lNOB+3IaHEuA2doyXqJK7jG22Z8xUqYOzYXC";
  b += "Fp9+HxxEAC5Sf0HVQQKwniR87oDdpaoFCmiHygOlZaZHWSwtVdxX9MKHAQFDzTBYOgyooqOXxng";
  b += "ZykmrixT878CoqEos3H45tn8d5Ey8XGebjX5uIhlKSOUoKxXWQlZBo7WZYRyb5LkbsHM7yNDVO3";
  b += "S0mS1F5ix1GMZwGmE5cIL/MDUsoc0G0rlGQ6zAnSQzf2Yf1WOthpTPuN6teqZKYuJXYPVvGqs30";
  b += "ACVsFBKxRabfCDj9UMgSrHX7oKPm/jkFOEsRkMy4AKdQDrCnLZTfuZbshsydjWCqeSKEFYFwJxv";
  b += "O+PdhKZlAwOwZsYkuQMrcTFFyWMOUH07HDSGPGKlw1EcKI4dKdnsSJB7OCcW4qe2T5pWVxfxW4E";
  b += "ajBZAkwY4Eai1S1BVtqxhFTxbDQqRUxLLwrFePwr/5+5PtFdADTJ+mURH5y5HQVPGKp3nku3mnI";
  b += "ikzIJMV2PL6Lv1cNfO+vWImZDWFJyXZMc6HeqyBHVrFv4S4YexbP8YgjP9j12Hfd2an0SONR7Dy";
  b += "lOi788HWk8Qjr2epHXEh3ZtOGnRXTZToyZESSquY4q8h23K44bCLF18e3mcqAD69Xs1GSy1lwl6";
  b += "Mdkdl5gSCDKxJm0je1QHmJ3/novideoi96bKATMKOOHVuwcN2Q1o0lfsDfxJi3jY2FBU+0or6H3";
  b += "2TgIRpk6MiTdCsdamAfVmhHkCdWSiBEgAl8acK1F20K9tF6NdOFSinmggGEZaAy/JKIFvYd7Msl";
  b += "EzsSLpg6Kf5BnHGp2Dot2c9RUUkCVVolukZWj3wcsdSWKXSkx01pGv7EaBVsz3MJbthuB4rUNiN";
  b += "VHKav6P5P93u1Psfd94B+v3x/i+H4X+/3NJALzHLEtgl7GfVqNseABfBPQOi81RKFbEvaHnIhUW";
  b += "Gj5MvYoTbKY4ZoRQe58ST+rZYwJg1cW8b1U53t7mS6moIdg+dkXEl0ZsbViHieK5HOxLjqk9nma";
  b += "kzj4mrCGF0DGgpXQxqMpnTAJKUEpQVYMYOYddoL3oaL2H1p3aArSD3cOlBRvOPHd5rbjKZexRcV";
  b += "klHbWA8X2jIwNFp20c05bhxZDexEpdBlR0WYThHZkcVD397sisBLV1ckXjq5ovDSwRWLl7auOLy";
  b += "0dMXjpamrDl6SXHXxkuhKwIvu0vES73LRQLnceIl01aOxc9XCi9MVTaPrioEGNKFvX1S9MX0uo+";
  b += "qN6LsYVU9qr0zDa2J7ZSFe67dX5uG1QXtlDl4btldm4DXGmHdoFbrttrSn/ok2ZpYfLLfCtKJO0";
  b += "WsZz5ed/xBmoI11WD1j/85VL8CoBbGORApHY6OEPidT6ZyJmXemXXuFCDLPFYqXQpcDL+NcTrxM";
  b += "cAUz9KZx9Mo4elM5etSsYI6+k6Pv4OiHcvRtDOsghqyF4Wilj+noCwk/ChaGgpWhYGMoBLFXTOO";
  b += "vKOOvmMpfQSgEcRRsHAUrR8HCUXAb+6fuf1fNRF0bcXEZPy7b8YE5060xpHTjwG8P/mDJcocx7B";
  b += "KMZ7c/vtKc5Q6/HJpX7KkgjqaNo2nlaFr+YE+FMezCGVIhDBftL+2pusax1V9uBWbKe6qO8eBLj";
  b += "82RfT0Vb7z+6FtPKZmip+KMN35/fhX05P9zPRVrnHn117kwC0MZLlHG5IWlv1qzRE9FGp/9NP0p";
  b += "P01FGNMWzTitXoGmHAxNJ0MzmKEZ8gd6KoSjGczRdHI0HZftqdB/p6di8PM+YDv4HSBwm/ZKITK";
  b += "Z9koeziyOnoujp3P0Ejh6dTl6dTh68Ry9ONGLvPN4n/GuYnwLT8fV86H5PKE5nPHXdMZfRyN/TV";
  b += "KykdCwJ6bxnijjPTGV98QfGtBQY+uaWftlGsBBxHZ/q3xoskwDOIDY7luvPXRRIlLvS2x31xsvY";
  b += "Niv2n/pgIYz7GozpDSGS9g1DaibDaiLDajOBjSBDWhdjl4djl48Ry+OoxfL0Yvi6EVy9CJEL/LO";
  b += "433GuwrRu3QoE9hQ6mwoXWwo3ddhKN3GqX3LTymZYihdxuryj/aYMsVQAr/fs/2o2TeUCcbnM79";
  b += "52fp/cCjrsqGsw4Yyng1lHBvKWI5eFEcvkqMXwdEL5ejFcPSiOXq1RC/yzuN9xrvq8kMZx4Yyng";
  b += "1lHTaUda/DUNY11h186HWLb1bWMWaf3vS62Tcr441N609XmbLEUMYZr5QsKAX4/9xQxrKhjGJDG";
  b += "cmGMoINZShHL4ajF83Rq8XRc3P0XBw9naOXIHqRdx7vM95Vlx/KCDaUkWwoo9hQxl6HoYw1HjtW";
  b += "tVP1DWWU8crBLz9SfEMZaXz41jPtfZMywvj2o+VPyf8HJ2UoG8kYNpLRbCRr/dkC8y8VlaVzD2z";
  b += "x89cYY9P2E5VKpl9Unt///HFTgKicveDwfPN/ReV/oqjc+80zqywBovK1uas2WANE5Ucnz/xozf";
  b += "KLyt+ffvmEJeu/ovI/UFQeWlfynTlAVL644e9bA0XljOMfnlQDROXBA+/vUP8rKv8TReW3z208r";
  b += "QSIygOn//HPQFH5+5y3D0lZfllZWbF6yn9l5X+krPz75NnvyQGysmzfwR/lAFm564enXlUCZOWL";
  b += "v25fof5XVv4nysoN8ysxhKlPVr6796uzgWblB3NOHwg0K08femWb5b9m5X+irPyh9PXl1ky/rDz";
  b += "11tw3/WpPvHFi+hefWQNk5bnfv55v/a+s/LdlZT02lBFsKCPZUEZdh6GMMh4qmfobaKSc3Ucac5";
  b += "9+/SCoPbUYWhFG+ab5ZaYsd7TYHnn88Vd3gdoTc7l+rMf6MYL1YyTrx6g/MJRRHM1IjmYER7MeR";
  b += "zO6GgeLDeBgUXpSpitJj9QbZboa6RF640xXY+jAJpmuJjXQm6AnZroSCTW9fqarPuGqN8h0NSDk";
  b += "9YaZroY6Ht9TzWwrEo+i6MyZgdmIKUR3mxfVfMNW6MUd2mKCcEe22Otlu5mmTDo+iado8ZRREh4";
  b += "UV3DHCk87JjIfTfXJiwZuZ+GJgSZsR7YB25FtyE6Wkns+x/I2Svwk00Tu7c6ZKOlOPL9TR9sLo0";
  b += "xR3vn3+k6KT28SAIan51/v04f7OxVIRKd4iva0CW4xiLlZFMbQ8xYBoA2qBDx5DJ7ET913KsnqK";
  b += "qzlmJJp2OC6SiH/oMaJo+SCAkqxr+NX0QFw7DzjvC/LJLIsPGvaNyKLfWBfRuenoNoyFao3Fops";
  b += "3BzmZ0QRu00AWXxQBUDi23tC8hhDsg5+r+2ywh8/PhqRKBmTaAvTqkdAz9DHe80kGK589IcQZMi";
  b += "ZmKRbafOdfCMYCcVQkBUyEopYOcAROxbzgF3AtQidLGAaPNkzWMJDsxFJSjy6xoBrjDuYrpFuG1";
  b += "01t5muTreFrjb0pxFBrl7oin40UmT0kDGBfbXAbi++/Ku4nbzz7CIzuy1d//B7ErstW//tfJXd7";
  b += "vzt510Ku137/DuHY5hPDBN6w7B6dQsQrVe3efVgdI6BPjHwLKMriPfU7llso9qo67KqeKJnBtvo";
  b += "tEKPGBPyM1nvoe8I7BYLTgK3wtzpTYBJkIneBOkAdCH3DYufX0LXTMSuEdUp2oN4jLwc91OX4JG";
  b += "BcvxW28oOU0+jiQ51ltGNrH2MxSA10xWj0leh6PekJBHPsdEnSy4F7tYnZrqZB+B8PFFszHhqm6";
  b += "R1howZ9RF9M2XYjMNQzAJoV67k2ZX1/c9BrXjyTQmsdqd0pXrfkQKfPCwK+muuXqDkRM2qT1yx6";
  b += "pPk39Ekqj7BHRz4qz4Z8Cg2B6+ikcL5gajAiidjYARKEtkQNJOemCEbajEOKIy5ioeYgzLdijgw";
  b += "bMoUdzbfnTPTf5xY3EX67mJ8d/G+O53fWQzscUABX27IxegVEqaljOcsAl8fjFMPnRfQMaoebnM";
  b += "cP/8RTGfzodHEhQOSbSzZViPZyZKd1ZLxBKYPC9YjdKQTadEII9Q6oX5E5OmqbTAUQ4wEV11AMJ";
  b += "4+jTKs+S78pFwtBovGqkNT4Q4/0AiBrs3OxG+9sEGGpMfgNDbrtRE3c5y7tu7AyQJTQg/Va+OtV";
  b += "48s1uvmo7uDTPQ4akWPGIphLnYrWfl0nqxLJp25dQXTHFwPWAG3cvND3WbfGJl9Y2T2jZHZN0Zm";
  b += "3xiZfWNk9o2R+fJjpFuBdLwwwxLyXWY6MBs4Vn5cUHjBJUzX8KvxHu5w0deaQe4ZwnDATHpAso0";
  b += "l22okO1mys1py9QFTaMAUYkJAyWGMkGGUocdMKLQ3z5TddPBkE9yQursRbux4sx5uaE1hDdyQfb";
  b += "oKbuh00HK4CcObJXATjjcL4Ya0vnlwY8abOXBDWuEMuLEGuuIBzummL8WjdVs+jl8WCE3mK9+69";
  b += "gG3jq7bLX4P+S6EzX7n+G6EbX4v9Qn0QRkggCee9Gicx25KmkdJFpbkoqQ5lGRlSTolzaCkcJaU";
  b += "gHWH+53cs7qXUJGwgCJhflf3rMhyKqJhESqg+d3dJ6zUFSyyiopQbi2/v3vK1WuxL9rW+ItE+b3";
  b += "esyJRrMh6fxG73/c9K2JnRTb6i8T5PeCzItF6HBbZJIqAfIv1+cGnfPoabzPlE4WcEBRyTFDIEU";
  b += "EhhwWFHBAUsk9QyF5BIbsFhewSFLJTUMgOQSEVV6QQ03WkkF28TWY/hezkSRY/hezgSVY/hVTwp";
  b += "PArU8huXiTsyhSylxfRrkwh+65CISb2ieOBq1CIiX30ePgqFGLS7VjkyFUoxMQo5NiVKMTEKATI";
  b += "AlS6IM7X8Gtk/DYqEU8DxoAwUQpB6QAGD2wnxDAR24HS2o1X+jW6uOoCp4SypM2UkdIC8gPsqHi";
  b += "m//AklT4NJkGhEJ+HDid5oYC8oLPohUZnpB5zMSqxKKqA1WWRUmv5X5AJQMWgKONBZ92alU/SwX";
  b += "tV8RDJxEOoHsnEg0Nw9kgmHkKZeAhItrFkW41kJ0t2Vkv+N8RDlBAPtYR40IR4CBPiIVyIh0ghH";
  b += "kKFeHD82+LB/ieIB/ul4sF+qXiw1xQPdt3hm9mOy4sHux7qKxJ6efFg1yP55I+8qngIrzn57cB7";
  b += "qouHsJqT3w68p7p40C4VD1oN8VCr5uS3My4TKB6iAie/nbGYGuIhSoiHWkI8aEI8hAnxEC7EQ6Q";
  b += "QD6FCPDj+/yEerkIhQjxchUKEeLgKhey7CoWYGIUcuAqFmBiFHL4KhZgYhRy5CoVwOXTsShTChd";
  b += "C1iwcyYWeg5Yo3c8TNPHGzUNwsETfLxc0qcbOGbsASFw5ZUZi4gvAUeQOfx0cwi5VJRpVMZ9SDj";
  b += "AS0K8gmBMvbsBTTx5tMkDiMbVI+4EhLHyFovEtimUrc2Xx3Tt+d5ruL9N3F+O7ifXdCYoSgxAjx";
  b += "W3pkQADuYIWibECxKDDAj9NC0ObDL1YtPdw2wdcdzNgLZsZeQLKNJdtqJDtZsrNacgh5JxXCwUT";
  b += "CgUWNAZERxuXZYW5BS2Qh46IEhwhHKwj0K/ySeMcvo9ClH535R/KwoENAlULOECxncYhWCU1gO1";
  b += "YfkS756N+djD8L800Nskol408F44++7cUljpA/TcBXGy7kDYFGH5igAWPmQyUU5AwNXyhymB7uY";
  b += "NHlKM3dKg0frkH7k20s2VYj2cmSndWSq4+bhcbNwt2U8nFThFBXkpRp9YFjw7WsPjBsuE6t7yb3";
  b += "oSX10a1LknI+EZ25JCnnElEZSVLOJKJLmCSlMtFN34qdSEQ3MsDxE930scuRRDd9Pn040W2pyaZ";
  b += "VJsiDkU2jqzLOpi2CTZtrsGlbDTYdXJNNn0jEtqCEVjmXPpZIni8ohTHpI5hiYSmMRx/GFBLi6h";
  b += "VYdCUrEeorcQmHPsNKXJ5Bq1jiXGKggeDnz6pPgp9PDLQP/OxZ9QnwkvqiRHXurPrk91RfierMW";
  b += "fWJ7zJeohpvVn3SexpmEyVs5pSwiVPCRk4J6zklrKnPKGFVfUYJy+szSlhSn1HCwvqMEubVZ5Qw";
  b += "pz6jhBn1r0AJputICQtZM2x+SpjHUsx+SpjDUix+SpjBUq5CCUtYiatQwnJW4iqUsKr+FSmBS+o";
  b += "19a9ICVxQr78yJXA5vfHKlMDF9KYrUAKX0pvrk48QYM+MVWltdBYYzuFPI9kNhkID+vwxgvHACO";
  b += "bKI4J5q41grjzoorFLJLvEsEs8XJgjGb2OiADjZFFoHO+GyKH4nVeJ4v90z61qH/OgNn4/yjtlv";
  b += "yNldCkvtl1oK2YTftmHAbtoj8ZsVKJmIQofAyBUAIcBsAU8uU9m3wFukpPVeVjLPhn3aMzGPFrj";
  b += "tBlzvmXbKWa+eTKPFk9xlddY7styiqxQnrXRl8V2ds7JwKax2nNYvbFDZONelW7z+UBeBVCoD1o";
  b += "PUIiAEMl9hCTbl7HSvoyDxK4dF+cVPZjEqIP2W1Bs03f9diyMuzRuJ+3LsM0bp9iXwa0Y3MOifZ";
  b += "lgeCyhyOWAhyDN7tuXseK+jLYWrzHuMLpGukPoqrlD6erEfRryKBBEVxO6MreSj6M/Z1/Gwh2V2";
  b += "7x6qFcP8aLrco3vy4D8dcBfGPRURX36NNOo67LjV3jGjET84NLu35XBvuO7Mg7/rowdd2VAzFr8";
  b += "uzIOlg50aue7Mqw22pTBTYMlAEChskTmjGBaIoukiP67p4HqqwFGwfQlYDA6zSkJxw/1lzyyTTL";
  b += "Wo7e3C1UFhlPrhx95Uk7LTO6YuSwCwTJZOJiGRymlJCDlHD1yTvKnVFJKZUDKMUo5FpBymFIO+1";
  b += "KCSZ8LBtT4SoAJd6WeSzRMxUzn0h7BxgDmrlDjguSyG6EuUOaZyxfq3fW0TUSRs8KzM3UtiTzMO";
  b += "dABQkgcCA2Q3Lj877aJhX0kNdokgMQgtsSPGwZuZzGICkjGpX1c1Je50ifnkw9ssvryvYiPilY8";
  b += "+sbTw0x+FELhVRpMOaknGhssJCqhIQMa4uVBbIPBq/8bb8PuUbVbrvRrdIGeQVfKsivMMNF3wGV";
  b += "IA9Bc0H7tjHpEb0EnL0nkK1ccCTkLkbh6ey1sLPDxGf/G4+iz3LcZpvoU+8tQ5GVTyRqakciuc/";
  b += "h1Hr8u5Ncl/LqcX1fx6xq8VtT3ea+YEeHzLIUTRtWDyHt2ddPMkPN9ZGj8KrtstKt5lUEA1ob9E";
  b += "wRGh82Y1MPtZI7BbcLgIK04M9DgsAmDQwkwOKhPLbxPa9CFhXcrVY19S6/UkrHmLJeNZKkvmbo9";
  b += "CBpLspRHFbUyWWplstTKZKmVyVIrk6VWJkutTJZahSxVRTBBM0hPrPIhuxI+ScUTDyVBzF+MgmG";
  b += "uwCbQluEGvgMdL2EEWgCZ5x7Jbcbvp4ei1jYEfwbhzwD86Ys/vfDnZvyhqECd8KcD+UoiN0z40x";
  b += "R/6PNr+uqaXGXF+yIYRPqiEzj9X8fTF9hXiNTAiFcxJhXkg0jSKnk8F/TxAABGcEA/vt1FS3A3k";
  b += "uI1YKNV4UVsCR5u0M0aBttmeiZqrQqIqAfcUagwoTKrgKTy6Zy1eOoqxa36Nc/olbrK4tO5nSzW";
  b += "HVN4dyjoNzNJqVCYQrxZYYrzJoUpzhsVpjivV9DjISjSCq57AUsKCmypGgcTAr/Er7USbV+AliM";
  b += "UtRIKIrQEoWihYnLlF3IjKXcNlcXcCL8KC7kRlLvelxvuV18hN5xyN/pyw/zKK+SGUe4mX67m11";
  b += "6jMDoI5m725Yb6NVfIDaXcCl9uiF9rhdwQyt3hyw32a6yQG0y5O3kuCHenT1t1UtYuhQUXdNvIE";
  b += "68bp/dQcsFAIT/dxL6YrwVyOICqWzVuRd+do8BGrahmFmqTQRS4Ec9G1MispOcqL8kC7m6GOWXG";
  b += "3fc/6QwAukl2g7LLVsishCm2VsEzSMBIqO04A9hiDW+52VC0F2RKLAnC7XDVB4YjGCTAiiQEdQE";
  b += "e/klCWCOYahInIVjX+85F4H4Bpa5XA8scrgbNMPnDSaiIL1uSo0lrVPxa4XNvC5zFTtNZ5FEycw";
  b += "HH07SezOmRi7zTZbnsqKlluRzcmZJFRNe2YIMTyQOjbFRUVaAXm/0qA99EUPOBHyMYjKBTMtbsg";
  b += "GFtrbWSHJPNipW5OtQDfRhq7zPXU5PwFAiFylTRVQ+6zTCTq0FyrqE9xnyKAa9DlzFSispjjrAY";
  b += "Bwo9ZQdJ0pJHSLW5yc2eqbcImGoiQdQyC1mcYe8drDA/1EqKpG0lVz0WoxXLJO/SquGs9vZLXqo";
  b += "4Al8DxjnYRn3iXGDKwEvWplTJU1x2FhfLQv7HIJt5J7FwRNxWfJvbhsjIHBndjsioDhRxfXR7yv";
  b += "wN3+zCv9q3ewOhu5nHHV+4HFD9UuwTdSu9doLLzkQjRsrgPhoRQyvDF1QkG+6Y6bb+cS4r6xszO";
  b += "kLB82UYlMfnf8rCMMIl+Z6mSbgeQEqDOaAT0cpqjm5OzcabUg/4PSr18MLYmWDqOrQd1BRfNdoS";
  b += "1s8+eCr3pWTSg8jzKTaHDilCbygTyekG87CqNlFjblDBtGSekFTyKWZLUR3JKneRGjhY0y4ZLAc";
  b += "PGCtc1ALVPW4KAHaqAcA8OQB4RqYYDBiMY1y+71YWt85qt8UUZg7nB4ue7paMs5AQFyZLEpaiwC";
  b += "zaPY73FEWh2FvC122JzJ3d+iOxxQMn0vJZ+FcdnVMFuDZ1YVAYSiCHduj7Bl3PG1VSptHS+BRof";
  b += "aURivs49t5xupKJpig6EnOhu+TQO+DHVOYykVdl8hyiGA/K/VmoemMzc+BE1WGAXvThq2W4JPLd";
  b += "dYUXJv8Z7yMvuiWysQYKaOXMEWQ1kLyeoK7mIBdyazB2owKd+3cM3Mw4CipWbnJUTD5o8bwsRVo";
  b += "x4casyQjFSAbMTZ0RSh6GXQq1k7Aw1Hyw53E+sxxcvlEpwgRMAmwirpWjFz86sKWbewdL5OwSJj";
  b += "iuu0/Id1szycmwjHvOFqxOpbgNEsbFsGABPD+GEWHQiWKhOyjLiMlHT6AUgp7EH+i2xdypmW4v9";
  b += "DJ3dvgMrbzjgiC+FWcAVQvsmmxFs88t52VKY2vVfAq1Z83kTsoAGReFukAsrVkYvo/3Fw6jmZbb";
  b += "MfyEbuZtN1M6dkYfqpL27ZCjQavYiQAdLiZiIjbeejML9HVrQOuzqPXmS1pvpm179DyFq8+FXJu";
  b += "GzhBdQC53dVW0nqoln9aZlOd/PKAjAp7B/gKMZPQsiAyZfFDJWQ4X2m8yq4C3WOYtFn5+WYvppd";
  b += "yzcyani4CSmeTVjOiCv09ydEOHfywsCU4f5KQUbQ0aRmGW8anAh+HlFLKEnChmUUQPxwYM28io2";
  b += "k+xciDFqkixqo9iLYSZhWPGXV1dSrEqyoRAilXxDDVUZ/JTrIoFLIJiTf4xM5HPUXqVGZe8OMWC";
  b += "Bf1HKFb9IxRrYxSrEsVCh7AYVH+w45+T0aWWjI5cIY93m3xJt5l4t8nkvMosKnRjpGM2bXDwMRz";
  b += "UBCpP+6K3UJxwFIYPTp5qyyaEuI9LEztTIrOHcWah22uFRaPJZE6kq71GEQiTEjVjPyhR4T6d6v";
  b += "xxUKNsPnDqdwCG+cDS6VDY7gMrHwcwCkEvC3OETlNZeLcYXFOjSBR4rkebZuLehMkpPMZ2lZMDA";
  b += "8uWLRaxXSkACOZQABAWWDYyk31noWgL0MUhecwUr0SRFvDKxb5XPnItr5xA7zlX/ZXj/K8kEeD4";
  b += "QhYhMQPceouIu4EONSm0SFaIVVZUk9liZU41KT4uukfb8XYFc2MJ9sUuuNfekzFejCiCruT2vVV";
  b += "B4goNj428iAUV6BVvc50X45nJxhMIhiBIIeanIehAkBzgPugDyQ3l91hpLQTJy+TnCNLYch/kjp";
  b += "eDlKSJ6iTmJbQxd00bA4RsxOi0wBdD4s2IMXZ+VcEiruiNKQ9XPxpTKGaj7MsKFs6vMVuxa4yKj";
  b += "Mr8vDVSK2RXLbzOo6DrjdQ8YMVw6eWKpkC4Lg0vm2R0ZdlInSG7YvA6GqOrNVK7ukg3iHHVxst6";
  b += "2eXEa5nsisUrfuoFlw6ueLxorjp4WSW76uK1RHYF43WIKwEvLVE8N1JtLh0vS2RXGF7HuVx4GeB";
  b += "y4yXJVY9pIlbmZY6CzyHcCDSTJpDWxEhCRbsxklsTHq+0CVo4TbhNE6Y3hneU6q5S3V2q1yvVra";
  b += "XuRDCGITWmVI8t1eNK9fhSvU6pu36KXF7qDtctpSlNy90N9FpYJqlUV0t1e6keXaprpe4QvS6ma";
  b += "qV6cKmeUApldb3UHUpPWrDqhimTSqfgVzXQj6U6vMFUqjtK9dqlwN8SqZhVr1WaElLuTgI8WLjh";
  b += "cL1uaYpS7o7QQ6CEXr/UHQnPpCSXw+vq6GZMCy11R5WmdC6HV0H9pe5ayTCIaLFBu1IalUPloXo";
  b += "Ey6pPmzio89tLUxqWg6EfAXVQVkQyDBiGyNBthGZIqbtuMgwPhrGAd2MSvCgkGQaDfPhHlqZ0KE";
  b += "dvwtBvKYlYlRU6ISWu3B3EKtRoq0bSo6AjU0IRjSCwsSgrNBkohxqXUJpiL3fbcXOZZcUmA70QG";
  b += "nZ6pw06JxmoA5LsHLOgUrcrWR1HLQwrTQlHLKJgnFIs8G6oUy+FXnE7WH32ZDUPlUro/xRbOe7r";
  b += "CyTCktXRqAJiS2qXu4mpsxxbsjqcnjGJ9yUkq0OoLLUNBsAdlKwO0PGjHuj6m7BeK1BBSiTiEgk";
  b += "jmhIPNbLaopPVXlAyWA8vTWlW7naiWGA5jmRSny1AfClquRudpjlZTnyy2oFqD2YkAwSUrLakWg";
  b += "h7oBx3PQy4K8HbYkpTohCDhnoSe7o2xiDHjo8rTWmCGCWJN9ZBj9jYMlZLg1K3zsLENcLPu6iM3";
  b += "hDIkO1c0FqABmwgEWZ9fZjxoTDbw2CqR8DEtsFsNsOcDYGpGeRyU1AG47NDwLFAIJ07zN01wuRD";
  b += "V66OIOb5eIHqqJKRey9UeGT6eeJmjriZIW6miZsycTNV3JSIm/Myvzknbs6Im0pxc0LcHBM3R8T";
  b += "NYXFzQNzsEzd7xc1ucbNL3OwUNztkERm0Qr7SSivKGSjqW2l1bJdZ2L0K4XNTK8d11SVsa5b0zR";
  b += "NTt0mZPJwF6szszQW4/CNyLLiORokYPdg44k9nSBVg6jF/6k6e6qUPONBrtHFYEhtQYNOD3qX11";
  b += "80YAY6tf+GC9xJFrIHzJFrF8w/nQ4rjIRrOaaJHysTNVHFTIm7OS2KoxM0ZcVMpbk6Im2Pi5ogk";
  b += "unj4VXt1tiIr5KVWBLnQHsVencE7GR2isqqMkpLl660FqGYONy5UOQq8bL8OsyaXrF8ygRIYIsa";
  b += "jJbsPTaQEhqLx6vOLFpspgSFvfLp+6W8sgTXLeHPdO5OtlMAabOxZ/8rrLIF1hXFy3/5Z91EC6y";
  b += "TjiRcXHmZ1sO4zZr8zZRDBrF+NN7Z89pxc4IVhwi/OJugqDRMtTMayRVcWvEQk4U3AMC1Uxd3Di";
  b += "mOWytz5VvqigXTNEt9oKkYH31eXGNxC7P7T55ZJLBiEjHv/9AKxw69QQOAgAexGl6MBz/WitVYW";
  b += "JQLDmGAgZoxw/J1C2xnM/b3OAm0kIU9GSxoGhL7dPHaCbeFTFGeZhWT2PxzvElGc+bGB0Tp5szb";
  b += "KTorHyCk8xWY+6XssEk0f2jDhH2eOxmjz8Ngq32PMLTzGafY/5nTJfHeFfxI6mtaZbMZO/hiFR6";
  b += "ZjBhKPihzkA6BCuwCwpb2Sacubohg7PrEo5knyROPwmyw0q+oLa8QCH1Gsz0ZoWkFNKvv8NgYtB";
  b += "R6uhXkitiBzt6w0VBbP2eaPyaFinGUNl8gUthqoPaI6WEh20syVST7f9jA+u7ZtQyzCTJIbjRTU";
  b += "lbXm3KU9euQ+sh04/FvcOfyaNwCYtmObpJ2XJYdb5kGmNAfu8Mcj7kZ8prbSxJbvZM2J6Z38gYS";
  b += "NTpTLgvtpwW6KwInOx8UzLEiECJQbggVawk0oC6F3UBUlWFUHVUPuGSxrGi78YUOfJp/zkSwQke";
  b += "ZW4jCWMYvgjAuCiSwUoM6MQFqFPqdws8TN8nnwIooMGszXEUFTNta8it7WNYA6+SMDSEZTzrh4b";
  b += "FdACvuvHrlkZqEhKKyHicUnsLnNPHwZEmOcP3YAe68JcWir82Cz2HTuzp65UDaxE7ls5TNlMvpX";
  b += "xnBTk5gZ1ZIH53CIriHssDNVUfxwQHE9IEAJf4DWorUw1ufU3ysxeg57trIk8FX8PfGZvhriWZo";
  b += "KwlprjHaVyqIwqgYLNINdxJDCmOQOIn6icbpDisWIN0TpxjE2MTByzTHKvITuOVWL5V2qw7HIpF";
  b += "hwXlWyx02TjDNwZ2bDZfJPLbIXRQgHFvrITTvEJhZBXAmW6Riy9pWYNjDWWm0XiysDYxpgWsKg6";
  b += "izgLNwltlc6aLEuFmWJj328i2IdgFEG3BY6gEenxZJxLh6lgpWMZCU1UZJiD2BEx6YsxkmSiMDi";
  b += "UnkoAqwk3iUFkprNxQPJqKIairkJkymOxXZRqlWEbeVv6WDILozpXIemlHgaDdPdwCHAbI0EsgC";
  b += "hRu8rIUKV6UgN/LTN5AFskGfxWDI48XENFGrmEdewSkZ07BEeDIbP9xpJuuLCEKG4UsTRYHRTye";
  b += "nGSoPLAl5iGpEZrkaihstHjw6OA5PDkg4Sijg5mzpu9QWB5vFeoMMQPxc74c7EgY/kFB7gnvGsx";
  b += "1TsAIxhzR3EY5wPYyGLgd6d4nzocia/ZtEVquLXLMdKM6iDStdA1cWgUKtKisyEbgfciUXZa5S8";
  b += "A4Jmsurj3Hh2XSF355Fuk1GxAhrtpAlDC8UsrkKwaA8tu0oYgwfjhjwps+h/EgXGBaMAF1/assU";
  b += "X5G67V2wnCmOCDPHBVTcJsNDyurMIynwtFseWRagJc0op23759diu2S98aNxOvJK/bcn/4G08Vg";
  b += "cFXTMSeUhgZC/8jqKfs1UhmWIF4IrRYv5Cmb1NZW9T2dtWXeVtGDiZcSTdwvdc6Ngf0KBv9JmiE";
  b += "kNKCWiim98Fo+ct+NFmMY1Ds7llLYh5x0e+jioHxuvoykLudGKRxjowumI6l/apygo6cRevJSvR";
  b += "lCXZ3CrDFo+4mDBOq87eZ+z0vbRrFq29+vCLQQMSJArVSwH2MBSrnchI+0Al3ZMiCGq0n3KYh7g";
  b += "x5gGFGclsx3w33q/BV6Bod+xSZBMjVL1GhBpjL9vlMvDooTXf1FU7gbGvHMYOno5XYxIgF2yqUT";
  b += "YYmAlLcLE7Y8fCCprCu3iyQneGCHWPC38UCo0JbiSuzRe30ake6I+fttGJHlq4OwzJFEoYsLmGl";
  b += "xDi1ZEEDg11BEP9vji6rEkUhaariOyI8yHMLIlwMsTXGdMAjRz5g0SyiVyvOAKniiNYStl9dMOF";
  b += "ksm/zt+Ju1gpbzx+ZOHmbe+dKpnkUCXZ4Vj5vOJGy6VCcpTa01LzUtMyCsfrucUe78js3LES/tO";
  b += "kMPht4S0qKExr0Xpk67S2bTqkp3mS26V3SEtr16Z1WpsRqakd2t7g8aSnp7W8oWWrDi1bp7XIzh";
  b += "jhTfWOb5GanZ2b1qLAm9ai2APXPE/asJHe3DHDMgo93mE5noJCT3pzb4EkxcN77oX33Ah/4dftf";
  b += "WNysfZpUHdfqLOxQwKuBXUPLvB4C1qMzh2b6k0vTB3TonlaqndUbguvZ1RGQSFUgo9n5KR7xjVP";
  b += "86YWegqaZ+Q2az+yVXJ669YjRqS2ateyZauRLYoLCgqaeQuatWneunlLeqTAU0htOcbbciv8Yd8";
  b += "J+Db4q3Pd3p+eMQq6r1nL5q1aNk+mR9JyvZ5hqXkZLdIKhxWnejNSR2R7EKHRMBlz4b0T4C/xur";
  b += "1/BHR0VrMRRSNHerwMi7b0IIwEvPQYvDMd3rVIYn0eCNcPgJfXyEdYD4DXwV9QDTg2AG4mS1J0A";
  b += "NwO4JgAuAPAdeGa7ckZVTjaR9nXpws82dkZeYUZac3SirzFHuyENs3b0aOjUwtGt6ZUdjsyw5Od";
  b += "3sIzLi81J33YmIJRRCffK5o0BXC7D/564V/rbs3639H99oG97+7e7OaBg5r9u5MACYFRZHZGmqc";
  b += "FzjV8oSyxf3hVriMdFIwsym7WunkbMQ0yRuWkFhZ5ifYqVU1Kg3cVwl/odXtnwejU1ozm2lejfO";
  b += "pWKd2kSalwTYG/CPgb9U1QZum6Ua95T+d06vhz/xWTbg+5bdpo8z+e/WxKQu33Dt8zE3DEuTrdI";
  b += "klRkjHjEeCG5b1TCws9Y/IK9cJcPT2jOCPdo48Yr9/n8eZepyZ4vOmeYSNSvUg37XjXsbkDZOJJ";
  b += "A8aojyzyFo72eOHFUIuekaOLWd2Mk3NGTqFnlMeblptTmJFTlFqYkZujj8gohPT0jLRUrCI1B4D";
  b += "i1OyM9Cs93MjMeushPhMF/AifeSmpBRlp/TwFBamjPEbRqDGenEJ60QBvbu7I/iMH5BYUQCYkQN";
  b += "kYiyaZkcvBFXu+pYVJD0xzwp8J/qCTJSv82eAvVb85oyAvO3W8njEmL9vjq1v3eoCAchj+Hq831";
  b += "6sX5YhuyR5PeAlKtl8XaQEDl5FD03Iz4NwH6jwALwmBa1FOVk7uWN73OYX68OFNdRwVjw5jp+fk";
  b += "igykvBgra28juCIXgqK+wRR5g+CKfQEtS/V6oem5I3U+Im1ap+oFnvwiT06aR3IEtNHJx0bAiFe";
  b += "6B0goA0b2PqicUUh6bk7DQh2ezgVqTdVHeXOL8nQP69dqz4fWqE+DP+iBorRCfVDGGE837/i8wm";
  b += "4ZedDKQs+4Qn1sBiDXVtSEDbVpUmNeh42PK7ZNvk5zo2hEIdBp6xrzQpK6w3v/Bu/ZqjDa/Ksl6";
  b += "UbbXy9J2wZVl6SBcP0AeHmNfCFJBSwkaSAcGwALSSpgIUkFLCTp/7bobDFuDKmMSXZNehjwuR/+";
  b += "WsOfgOdwDfLPJsaP7NVp8SKo9CRZe6nSby9PHfJz/80nTvWfNj/X/Oaau55PjPkrJN9wR3XJJ/0";
  b += "B6ZeaDXgVeYqys3M8YwvH53kEQ8O2ODXiFeE15nl4AO+IqAEjr0oDxgpcafjtnoKi7MKOHYtyxn";
  b += "pT85IaDdeBtwPjG97d6x0O78ku8oDEZfXiX62/gIeUO6uPmz+vR2oGYg0CPy8VpLCeVzQC9Cc9y";
  b += "zNeTy0AfppZANiP9ozTmbAYnINsAYsDx0WOqaenFqZK56B+lEktJTozJPlrxUfTPcSc/VX7s0E1";
  b += "zRg5XvepT5d9MM3Hlf3ZkIWvr4n+5YqyHCCiwOrTcseMyMjx+N/MChR01CuDNeJzAWVTCwr5M3l";
  b += "QpIDLHp00TeIfgg6Qd9TmPKY3V0ECepSJvOZ6P5Dc+giPfkN7HaR8qxtaY2szCguaG4VQht42Np";
  b += "cjRBLXCwIyw+tJF3WyrMs2sUCMRR78oTwV8GMcTtULi0DvQBHMRCiknQnRKK8KrqirCPWJIRwg0";
  b += "JsCKmmejGKU7aEatbVVKHv2GmXzn03y0oTQ6jSfCgPnJUVrJPVbR30MtLDTTaB9ZI9sDi1NavQX";
  b += "i9br8zovyoi00anwP7yzTfNW9NioIiAn6oeJGrNGUDY2DIBXoPwIgJ+uAa/kcKjml//tasB/lT5";
  b += "wcxiTx0O4PBaw0A8C4foB8FLeZgEvr1Fe6AsCFvpCIBwbAG+ukS/0BwEL/UHAHWrga5ar44NwrQ";
  b += "A4COAGAbAD4Ho14PAAOKpGfVG8PiGL+uchwdeURfrwW3NzPFwWXYvYkuIDZCKu6sQH8L6619PSb";
  b += "cNooAO3U6AoEfOACLaq5Ia/NpIfbsLHMRBGGR7AezMK0ILRwaYFu7FwvJ6XC7bgoN79uvft363P";
  b += "sJS+A1u1btOh1bAh/Xt07NXn5h7NBvYyWjdr3a79sD9pxaDQmwocv0UhmB7DSJRhAxMjNSkL8B6";
  b += "MOijOLw7fwfUNAd8Ff3EBMOotrVAH6jtw2MDePX3N6dl62JB+N3eEtlBTBg68c/Cw2/sPMwZTkT";
  b += "9SdED/AcP8MvKynfgHa7p1cN9h15Pj5dIqQnvOJ4h/EI3kRWnSCOT7OB/+otWXI1HXtvpyqSwiB";
  b += "PROTBh5aS4WNE8tGOb1jExqxKST5G/bc9L/2zLt9ujqMk3AQqYJ+OkasJBpX9eqLtMC4b9KpsXE";
  b += "VJdpAhYyLRCuHwALmSbg5TXKC5kmYCHTAuHYAHhzjXwh0wQsZJqAO9TAV8i0QLhWACxkmoCFTAu";
  b += "EwwPgqBr1/dkyLaGGTEv4i2VaYmx1mSZgIdMC4f+LMu1cbHWZJmAh0wQsZJqAryjTWv1xmdbqus";
  b += "m0Vv+rMu3m+L9epm2K/zfWVf5NuSbaJ+TaZRZki4rHFqSNBtPx2Toazc01/LqWX9fVYbbrn7bTi";
  b += "dY1dM1eeM9w5NsS45N6AL9w1YBxTrcEAmrbrn1yhxtSR6Sle0ZeH/xGe8bB0LVt3qaa0VtYV5Pu";
  b += "hnd2kxmdBMLtrufuV6G3YFhedlEB4NCBU+vIPEY3lXUZ3ewDu3tAALwf4H4B8AEO/7k4tSakpiY";
  b += "w+gqRGU4CDqsBh3M4MWDvBmVvg//h3k3DP3HvZpxefe/mWoRfwxqyLhBGPSlg5af6khAQeRMXWy";
  b += "fVXWz95xoMiutvpiAjvgbuf/1lCiIAuhn0xVj46wt/9dyadA6u78HfaLdG/dokgK6aoq4Ff83/B";
  b += "3TV4k+kq93u6nQlCACXyzvqAZSBbamnUZmO9Rgt9M7tl5rXlyjldr50OZDv8VVP5Qua3YC38tvB";
  b += "hSM7GDnjB+cUFOXl5QLrTx/sa3H33JFsjVmsnaN+wLdpq6W3/itto8vuaqeTcldVj8mKzgqTDQL";
  b += "uojCdvU0APbTltsj/hB7a/4n0cDixOj3Y7QMLU9OyOtrh31+9J9mr/l9vr+2sX90+C4TrB8DCPh";
  b += "Pw8hrlhX0mYGGfBcKxAbCwxwQs7DEBC3tsIO5G6GP41gKqtAWpYzyCX6cyLZd2369Pb43y5Hi8G";
  b += "WnNqErsrrZ80LgycraBJoF5JQ1VGL38gfmIX3T46LfDdRvX0VnpIxHB1tW0pSUNNWkovONXrt8O";
  b += "uL2PXpBxHxkEQHdemFOSKINj2ugv0rtbJl273s2LSXTMEJiFNzdvvK+bIX031Hn97IbL2SqsTyu";
  b += "TGH97UmY0fy26SMeAsb9RMrbtqZAcZxwt/yRTdbQnOw/qxS7f3oh1eCRX9FD1Z8y1o45MtG1jdn";
  b += "ila2NmaPhYb25aWhHQSbqeXoRMEgg5DfgzbcMBKA2C8g0DNgLR5NTJLMZJQOaENBXKxNUow7cjy";
  b += "dhZ1ZgdqhHCNw8PIOHkh/TggHTfc5B2uDE7dCPyMnLyigoLOurnIV2r8QyinQsdQdIFSCWyCcPn";
  b += "r2boHZr89Qx9U5PqDDoQ1gNgwZAFLBiygAVDFvD1PTQyekxqGmNerQJwn9CUMaYCrrgLGPuv3l/";
  b += "EqM41vXZGJQ6UsdWWkRkgQTg1sh11riReH/SLMnIKm92XMeq+1FHQiuodCLi+3IwZfa9yZiXgrT";
  b += "ITyAL+lMOdAxTMLsgPAmCD90O3wLlMqhMXwGiMN2dMuH96up5TNGaEx4t78DBHMgoL5kBeZMCza";
  b += "cAdUkGp8+p6aqGel1uQQUxDWg/lcNFse3M2/6/zaVnpcHN2LDTNyg69XPlA6PV98V0tAt9rVBzC";
  b += "46j2K77d0L25RSSEioCYRnk9qdhVhaOBNffp3q2b0WdYDzDKBt9687Bu8DsIRXpOLnBmYVK4rg+";
  b += "BZXnS0lKzcIZUYyxSbEt29OB7rtqJQ8iTS9j1EXYtof/g+miJT/TR3YM8PYiXe4Q/X8avQSwfVX";
  b += "y6PsrhR1l2STl/TuVXhV/5a0rs/IY/XyLexwuUCDxsPF20p5Ifb7k1t7C3sEt8NtxAFGjdcnOKo";
  b += "WOBVkUqyUQO9ESVMbUw1xv4yEAmLvuljkOjEOQFT7i5KC+bDvT29vEKnsOf9qeL6kB7q15H34wx";
  b += "GYV9wUAcBKQxaLTXUzA6NztdvDHDn8Q4WB2+JB3DOX4YN880LiFq8WOo0a016bdWmnQM/nbD30v";
  b += "wtwL+5sNfOfxNgL+R8DcE/v7M5a0C0K9S2cSVprZm6naGwtoi4EyFaTYCzlLY0qCAs5XruaT8r/";
  b += "Fs2qY6ngIWeApY4CngvwLPosKMbMRybxu2XWjmGmEg3DZAg8Izaii3hrRlmpUoV4vTTvcACdHjG";
  b += "tXhntWW5ozK48AR51n+7FNTP7b9Mw4b/2uqGN6OjfI/uS4h4A0yO2QSCLcJgDfWyEe4bQD8Yo38";
  b += "F/lCuIBfqpH/Uo38DN4PgXAgfpk18gUVCzirRr6gagFn18jPrpGvqJJ0Qw24VwCs1shHuGcAbKq";
  b += "Rj3CPANheI99eo35HjXxHjXxnjXwnzx+z8KfTM47Pf6fe0FkP//NkdpPpNwzy/j1yjzms6q4nP/";
  b += "usl3X67RuNzTk977p92/luLziXvendsqvrDd+0bVKWl/hu/RnRdS9U4cc6QcWK5NzhkM58/+qQt";
  b += "wfeOa/XsO533p43cMj7Y8ecuGPpE7HWobOPlPz2xr1noyRj3hmYIPvMfybBjmKfukkxHZniO1/s";
  b += "dHN4gdgp5/A/ZCYuBbxQ5jvvHF5UA15cA36yBrykBvxUDXhpDXhZDXi5zHakroUN9fpTdsOvvoO";
  b += "E/3pEt41vm3DozI+mD4Oe/qbY/vFLc/tm9zz6WMWURbOfKft+VLO5tV8s7Tx+weqv3511dPq8sM";
  b += "NP9f0sa02vk+fWrlTrThnW6mCje1Mbtxu4IDW67qx7b61om9TT62m3N7x+v78VzRze9mn7uBtZn";
  b += "2xXmOIu4DdqwDtqwG/WgN+qAb9dA96pMONAwO8ozHC4dgIvuQgEXmK5lsHr/ZcOHttq69SFWU2y";
  b += "zDiBgBUOd8elE66wDfBmse0ADjPg+poWX3VhloVq+xcWDcpt58ALMx7eMPTnquL5o85Hj9v21I2";
  b += "Rb8/tH9Xz292n38tcV9n1zH7Xrpz3Txb97lhsjJXD893fOj+evebVxy/EjI9Nc097v771zohhdx";
  b += "2cc1vXAY2GrLmt4i5pbZdp8SGZS20Dznfe7LjmQedjh19OX7znYpWyfMtA876ngmz7bmjT64FFj";
  b += "QauPFmg2ecoS6f/9HPs3zc+3OD3nzeUHG3c+cXZq546vq5T7KL5c+ZltU+LSXt5VO6nmwd0mzXz";
  b += "QbPlbL3FRRXPrHhj+HubF725ZLVl3ENfxUx8/sZRG4zSXS/FxvUsjfop5ORL20+fHF4Q1HhW2C1";
  b += "9ew8/Zy/oe/fC9vcm/DbhrrvT7KuzS7/5dljv4JzjL556bWn9U5VFz+yxHv28ZOLjF6ZIf1uffm";
  b += "jW+Yq1B1Ijm9gbro5Z8v2RGzPXrH2o47Kb3rl1aO/xJ9/ttHzAkOhvf4r7Iu2p7U2uvU/Ipb1j+";
  b += "LOrqVdeqaoa+PzFqmfrJp5df3bJRy1HbQ0vPT21z9j0T9f06fbSyrg+C76ZdMN3YXLstb9nSTm8";
  b += "pzL6WjnRvxJ9p6vQpGi42i61Pd9a2jVwUok9677j03t+mvjqN69P3PN8i2fHbb2x4J3HJ34x5ab";
  b += "bun8SlF+Z/9CRd9T3PlrxXkIP97N/mxtXuue5lLwhi//5qvx6yEuPfzRg95ScB35VjYfTBnn0yp";
  b += "jbVv+8IGS1p8UbtabWbda3x0Nftdry8syjQzdNuPWnF2fGf9mwXcz5rM9zkpNK61iPvjF4UNTdk";
  b += "t3z4+D5j3Q6/sGsDzd45hk7TncOPblnXcqOWTedbv73Tkvn9P90f4cj7qh3xg1qsHmN6UAVLjBl";
  b += "l9WRZrR8TMoLfSNpyMnoxFFju0Yf6Ha83ppFrqiIhXFdBg849pL99Rb506wJw1x73s1/sdv2Znn";
  b += "xp4Zv3OXQnujfv6xZYZMOyzq07tx0f9n097s81SX0SNXSWfOeW1ogHX7KfTE/Y/7vuc0K79nQ+Z";
  b += "kFO96c/0XE8J7T8o+6lr7RsPPDZftuv/vIi953szo8YqR2nWyJj5CeO/1STL9pX12c/YTrt9rra";
  b += "k/q8WNpUhfThqqf2n53oN4gqaLqoyH3fHjmdd2uvx4R9OiW/UM7lJaXrx752dudjozv1LHee2dm";
  b += "f/lE1Np6I/vVPZX80P2Tgz/6odkLYWunPjz/zfuDrH1GOnp1HJKy4q3RRxtUZOSff/rFfbe2OrX";
  b += "0nm8rldsqZg66Z7zU+IG8+TmHEgcP/7Ru1FSr0fCXvCTXrb1dLZdvaXH0H8/e1PfrOePv/LnB8C";
  b += "2nGh+7uMhUfvuApHEHP/d8Hyt/12rv7JDu/VZ+0mfsDzNKn99qPBL/+X3pZ+pvGFgeGzq05EicK";
  b += "7GvNv2+72rvuWFmrbNNBj6+NuSnoJcbtD/z1eyDY7Z8uuupBU17rdhyZkpMWvfWkfsrJv6ya469";
  b += "+ZO97gjp1SxpfaPy9hv/ufVMzIVmXQe+U/lmveP93x+SUdXtvrRDK5rdFHxD09BPf/1y3tBDu59";
  b += "4wbsiY96+qovH6rd4u2ps+NOrLKG9K8+Mf/BCy5JVc86VaumPPj+o5efhnuAys2fSiq9+lI4M/6";
  b += "lwyWtJu11nx4942eZY//G4V7t7vylKj0lY8OodUzfeuOGbs1vLxv3zodBlr5RGffXDxcGnDix82";
  b += "rxmxaEFB+d/E2TN/3nrnW8cDX5Bi81atzHY/th7GzaMeu2Or/q/sOjWO+/Y+8h448KAYTO7mYrS";
  b += "Hv3ilz7Tgt5u9NkDE1PXf1NUMDBlb3LOxcW97ov4/Ivn6nw/objL2g9PHfngy9BJI/fddkv85Dp";
  b += "b+xzqb76/+DHPgMb7vR9vuHPpbzO3PtLz2fTkKZ9kHP8+SGscmWf0aPF6y/2r5f7P/y2/a25p5r";
  b += "qY7r+uvzB2yYhXlkR8fiq08Jmnb37zk87T7ui3rXPEozPuf6PLxloz7mr0TkfHwmFha2dnr/bIn";
  b += "22zrLhxQcN6mdGeOfZ3P5hVVTk4+flbGt04e13egPjPx4R110/0ndWy+8n3f3zw5CdT2tjOn3jy";
  b += "5qe3l86rbDN2z65BTW5J2dbh4QtPfh594bcNrRuu/H1J+Og+R9v3b1/1VT3zyE7bGoUaleMmh+3";
  b += "q/fXvptYtprsf3jvgti8WTK2/551D26MWftLkmW5H7jc23zyuabzzZuuZqbcp4feb/5m5zjNpSI";
  b += "Le9bbWp26O7P15Xvi3c3/9PSWzm3e45fNdL2TFhPafYSuMqjh7Mq3TKxF67cj33A/N/H3jwXc7p";
  b += "6T3vaXB7780bFTve8f2mzqeO9vv15Zlp0s+Tdx7ct33r835uFnXXZbpXV64Law4Ye+G2nd28yQ+";
  b += "0/qVpm+VHWt/Jv3IW3f+8tQzeYce7HvXPY8ta5NhGbkx2Tsp1/nLzuJxhbZOGZUlH/zqKH3Hnbh";
  b += "twCuf5894vN5z98d/MmJzeb0JH3++76usze6nIlc/nDEz+kKtiIXdqr6OW3kov6hjomf+g+/9PK";
  b += "LR2V/ejm8/5/SC1W+1PtNw+5cxP2x/re1rrd58tanmtG5dc/87kcXzK2bNfMWbdi71jS7tIs/Pn";
  b += "XZPi94PN862NHk37OGMrfdMj6517PCZyk8PPB0+yjvlq9OT7mgyauWQV+5c3K9OQcEW03fTlfcP";
  b += "7cl22Je12jW7Qcbkp2Puf0BTG++92doyuEvvlBXDBm+fP+5cYS/gzhcfGf7E9EeHV/5tZ+8m5tY";
  b += "dDkcu//iBuU83SMsb3N3Y/tnax+wdzw5tPCvls4gH6jbI+brNxHaP2e6YOmGp+YPKAa9+W2eLJH";
  b += "2RMK3FwLd3TzE32vroaccvEa9teW7r3At3DrVGD7r36buWJY1xtD+78f0pNwwcM/HXs09++dwvT";
  b += "WoP6D69B1Dvo4uOvPeSo8ttj1S9PcJx14X33/V+3bdPK2nVpjnvtz6VNeym/LlLph4aM9M1b33f";
  b += "979Lf6wsztPJ9ZB6cHNcWCt7qxWTyyM//7nilqeOf1Rv0DsL1/668kjnpLkVOautM+ObKwn3fDA";
  b += "7uuzk3YcuyAM+W/npeu8KT+2OPac82GzoV1seePif335/fvv68gXF2XteMP++OOdY3N/DX0344t";
  b += "C2RnHfWxPf2/GLd+7h2TMHjC+eMevW9i/e9tzoiT0ySkPb/nzDnFUPLE/vd2Ryyczfzoy/O+ObZ";
  b += "U0+tg8aFnzr1EaRM9u8kHXbstu67B6ZM7DrHROH3DS57cpnln300G/Jg0/+uPbjkGdmF9yb2Xrh";
  b += "wsjYWeGd1r/epEf0LQ3tv/284MDJ79sf2/L44AU91vWP/fHc4vQRBzo18XwpPfjPz2duH7FlREy";
  b += "Dpj+Wv7vpHXP/Na88E1prjtz0t/Gj774pPXPRlz3KDt4zMnLr2S7PDQyu89rREeUvvPHl2+HRnR";
  b += "9xzNh674s75FmxJ8YeuHimX+x32n5rQr+7Ynf87cPfg2cOvKXNTz3ndlieP6TWvCcNRT/f3So9V";
  b += "2vjz7ufrruo8x2P327pWBzduXjCqdcWR1U+3l2OeO3vCSkXe0z5KPHrhZPvbxYc1eOTDi9mBc3u";
  b += "OLnO3NoNGucu73/bXd9tGDm9RdAvpuRv0n7+7bOf+mZH9PH23rr7gw/uyjD1GNg1p89jhd9N/1h";
  b += "putB6fOZd/xgzx9PbYvzw5Wsf/dhq1JK4LstGffXEOeuwEFftoEbR2hMD5j2w7enGDze+Iz281s";
  b += "BdPygDfq667+vnrB1Gv3503IyiQat2PbI/qtkrO16JqPPihw+P0eKbHO25qF3298P7pWmPDDsVM";
  b += "/GeRWVL8n87WC/i/JsH8jt7M4YGvyzdeeb2H2cWH6k771H776+0G9y/U2Zq2Gf75xaow3I/9wz9";
  b += "+s2+w34a0uCtZRcPDehcbL2j3ooDbTI7X8y6/5dTa0MXmvPOjHnpeJOUUXuW3bVtaWJyY+eH973";
  b += "+t7B+ZUebe25Je+lM7L5NLzx60WQsvHjH0pXb5YeWFd146tz9P3WxvlNc2P7R8mG3tpiW1bxXos";
  b += "UWdvGT1w7vfOTmVsWTtq2/a8vWmx79eIIa9tYPo5Y2n/l2K+nl94bF526t8/yFh179un/wnuVLj";
  b += "78+/fZ1nRasfSbzH9/sev73Oc3SXpvdzXTs7Rd/OHU2563Br3kPlm9PnFdnXu0fP1r+fP6u2kG/";
  b += "r97WX0t6OuUz+VDvkL3e1mODOmYHnTm1dtj3YZsXVCbdWWZfcaB134KMKO+yhN83WDzf5Y94ecf";
  b += "j3vfnD145cu/Jl/oOS9/7oPOeI4/eE/LjfKPl+GPPzz2S/nnVkTb/uNi53T/fSkxfnfj74sWewn";
  b += "r20W0eq7QU9u2sjGsTvGJP4YlZ6zZOfKLtmidXbzTeeLh4xuJy9Zt7vt8ydOWuz7aqs3/LeqZdo";
  b += "753vHjhq/w2b5wOab7mbO+9Cccntryv3StDt3x8tCQiq/aKaR3H1tt9a7T3qQu7164rXhl67yvZ";
  b += "VRNOOJd/7A6uXXqhdNbhhr/cXx7dctXgRQfWzRln3rKvd9G5fTNuSq09NdreG1517/Hzi3d0+Wl";
  b += "d1ShT3LAOEzIXF29T4yu+C569efyLX5+sd/fbqYO6O+sNXTxZz3lvYOOxdUMfn1x1f3jvlacyw+";
  b += "zbbm64VYvXBrXK7Gh+7MfXlLMNKhefPrFk4G0H/t57kXR+j23Lx0GK9EqnT509jwxbHPPRvXc+l";
  b += "T1oy8TBcbY68+5+4Ijr3b0v1X/phTt36aVu06tPrT89Sds+pbxg3icPLhq/Y//BiHa9p9zQ/MlW";
  b += "Qa6h67c0nbtYnZ3+y9Jnxr46eFS67a1DX5suNC8c90DzKXN/D7n3uV23bv815Fr152stLxkVT4H";
  b += "i3/KN7kWgdweXf7yitPVA9+nGTSf+o+VIW9mARK1s4rS44KWjZ+z/qn/lkciOpelRXcYcjQSDYS";
  b += "k+l3J7hCpJHY+WKue+CHXa5C1nu369f3HZt7KlVYPbkm9zPHvz29F3zvtEGTXou/HHN+rhYNkvg";
  b += "+dmmDKGnDhfVbVj7/gL93z0w+lldUZV5Ua82WbVpC3OQe+1iWxwV9PRU5sMC+3eq82suVulvx22";
  b += "Dh38K1hA3z/8W9X0z49W5Xo+6rin++zC3aFnij2WtG9u+2xPyXHjpthGXwSbLj7Qd2SUbd1qqL7";
  b += "q524Xqnqe/Knq5dYZi44v7d3xmPW+11pPaXV61YmMijNL6j4WecqiVHVusMFu+n7ez0lDp8ueWp";
  b += "+5K6NNyjdvZ0xJiiho/UluVM+Nj59sNiJhyXbvD40bHz1S9eDU38Pn2Z5M3VS39PvC+qY7ZoWPP";
  b += "750/+NPfRv0zNwjo37Z1P3BG5c2OzRma0irpOS/fVBr25n2I25+PeywrfT72zZNXF04e97w0xcG";
  b += "xTd/q9a3b7WYtHPlxcUJv69LlIc+dPOxtNfPvXD36Yl3j5200Wb/ZdqULU0ijtRuOnbKmoxP5e7";
  b += "Ntxce/+SmVVWPrR/77RuPb172tw+am7a3q9g6wDbpeKMbrNc6EB+t3wcdWv7M6d9eXn7w2543vn";
  b += "/xUINHRg2ouq/2qgWjkvq+MGS37c7X6z4yY2Rik0nyqxWhLyw6B5T1nXu5vUP+odY7c3KefvGmr";
  b += "nPicl4tmLNyYKetRW3tTY2MFXtu+rD/gcJ79w8Nv9byQIgrgTB2K9dqun64YOiKvw1p0XnKg9se";
  b += "usk1J6V18ohHd96c1CGms1b7QuO1s16pnLCm/63j6+y8d/ID52d97Pg8dNndS1d+cP+EibMab/s";
  b += "i+sCPr9+ate8xW4uVews///+K+w6wppLu71vSCU0FpGmwAlISehGlC0iTKkUhkIBISDBFQEWCYi";
  b += "/YsaBiV8Suq2uviBXsfW241hV7o30z995odN19//u8+z4fPOe5+c2dfmfOnCnnzCTe6QuW+88vy";
  b += "EpaaX9xUuu+P8b20ftf+88Yes/i5IgPA/p5MjowE+8wVo5ofWt7Tj0mo0Gy7BleSvvg3lBXYxx0";
  b += "wu8Zjx1fru74T/2Diq0GFXsYbRgRHh8f/yhtVfXw7nfa+0/q/Fm63TQ4d3hQ6CRW2eSjVic2Tsf";
  b += "WnXOzPpDcus7A+STn2Igk4J/L2Vy9rKsBwr1VUVRkOc+xeZuF1K/Jn7ng0rsE+tEHvshub8/SR8";
  b += "LCpZ2eeKytrq5+s2VQ/K7ZL9uXB0wf436Du8p118rVATT/wPuzHsQHl17KMp83dFNb7ORFmfQ/e";
  b += "p4cYXGy2nfmw7JR8fFs02Mb/co5dJPr22QldZcniK4nNUz4VLRTmnMRUzspzWaaIn73auAaBVqx";
  b += "sSPo2l5d+7WvshS2pLxhbTf1OJPofrrzi+kyt96iflO2zk+vG12Bx2zw7L9t6QeaQzw8mDQykIe";
  b += "EBCxG9txOmiYNO/90rKw2ZcPh3Xx82+64Ls0t23yF93fqlLAPluLF8ddB/JNVd9t1pKL2t36nh/";
  b += "vXXHyy7eOnX245nTNT7ug62D7k1/c3n+4RKPfeiy0xPljQcqDsw/UFDxqyvN818ne1xixwb58c1";
  b += "vk+7cmXF93PJG54vmrTsocX9Y9dOSEYSq9j/VP/gGduIb4gY+ds8Ok5h1o9Rk67GJ8X8TKZlzbz";
  b += "87ilVzqbWY5eOWrlxJlzL27ffgwrUbN1/DsWc5UWseALfr62vvpmyMf2eqvgg0skEy8sTh500Qq";
  b += "zWpkf8tp21eGcHbphWxLabY6f3Ya5z6wBX5D+ICG+aBgTud1yx91oqhm6gCv1zXyduYFh8Xvp+n";
  b += "Hh73TR5+Vq/V5BUSapb7MdVxzIX91zZ2/nBx5th2dkv6p903DplMPC5JS5p+ItRNnKVw8Of+gdN";
  b += "6vaWjp0jCHi92orXM26mzzyS3t7BqpqHo+EPBtdbuj2NKlbX/OEK6q6DUeW3zdMH+mGtPQbcXqQ";
  b += "4U0/n6pa/J/6BxW2HaRThZ3AvFvb27cO2dv6fHD39x2vmRlHrBcy1w4NO742cpXKbt8SwyNWSYp";
  b += "azofmmgMdbzzUO9EOz+Vty+IjL0SPkU5nGBfWyHYN7bduA7utquOpsikdSzYVNnPuG8aUz+6nt9";
  b += "Sf/nv1cdBSImLr27PDTdorYi176kx6rnhzyIg9KWbEuDc3j9kvO7230sszJPHll1vKg53El013x";
  b += "MxnMTuO5+yak5ZTW97N5MLZvk8qXtrc3n56c8qqiPPVQ57NfWjxPKt5q363N6zgq4/CNw3/sP3F";
  b += "mNCW3Cr/wfMuLep5eX5IfcOT9b57K82PTPmt6tGZjh4OW0rKJt9s0jP02jujyNyt+YVd8sTZe+4";
  b += "gR2be7NP9dflhPasBp1/X9j1yhZY6+tAA224DktIsHpW9NkARv4ad8IP8r3ko6Lq7YDr/dHXviW";
  b += "gqKM9rvm3y+bEb7+x5+7HAqNbr9HrjJVir8pPj8KNSi/z0rN1ubulC8x4bV5vTgVSyG6SzlPVPB";
  b += "5F/Kv7804L8U2lkcDxot+0f61vbl0993572nrdt0i7m/ImezfOtK3un7u2+L2uI2XafO4MvurSf";
  b += "GVTOasAo80Stu1va6SGj13G2BnQ02KrImvXFK3Zt5K3HtH/5OOxfKSvvTCXPBPxOnR8Igxtw8BC";
  b += "oLJ4yshZEHjWFagtDSJWaqNhvjuFDSPMtkTKR2GG4ghcUy8uTiVQSyjIMPNYkyoGHlSVF38432f";
  b += "EUYjFvmFKZr/BydBTJMmFWHLPFSphXWV53KYhsuMJerLAn47KnQgYIJRJ4Zk2TmF90KHliVeZAh";
  b += "gzOkUhii6SZ1OFijT/SDy9Alpcnk4ZpcgiPXamkwpHAKzznCWOIFWeq5GIvXkJhokyeq+DFRA7Q";
  b += "8gwLkyPNUVJWZDS5SRRnaOcEFCOGyEwC3ORSUFmBngLIbEC/3ycdExjjFxkItRFJi2/wLN13B8I";
  b += "0Hsi4eHkqiTIHGsmBqqwKL15AdDyIUaES8yQ5uWJJUYxSMkAsJXPhxUsETURWoOApihRKcR4vSy";
  b += "XN/HrOHZQWlJn0GSDLL/KHhnFARsAnJuoCapxmyYV54gJQH5oQYrlcKvMC31VE5JJU+uAJqXOAI";
  b += "8Xk9t7Xz+nFUw6DWqyg7YqVfzrrRqkj9KL2Ap0otSNHSl3RksB+dYcAl3AWUC+hLg3czpenGSDh";
  b += "aaTukhl4/jHUADkIaCkgNaBYQH5lh0HQ17Ru4Pd70FhPAEoHlCmUwnwIMzPFCmhJCp61Eop44bJ";
  b += "MoYQXq5TJhdlUQTTnp2VynjALHuQTib9+JoSwYqvZCIv4L448KpQiUkmZyIejBOYDdlBJugESBe";
  b += "L9QB36gpuFVI3DakXi5DmkkSXFMJDLXPhLyJPAupbzNNaDb6eTNqP+e30bubAgbaQ4E2SMJSQt+";
  b += "G6mjp/+W/UZ9T+uz/3C7+szSusQFNStzJTIFITetXSkLBfUrBx2AwVo1YCBfc1xhhgWQCSX5eeL";
  b += "RWEKoqdb2yBDMwwIPcysDHgU36/tOGh5m4xf9SdL1MOXfCaRT99y8jn5GPkc/ol4qssc4IY80tA";
  b += "hk3iWXasgnuJz5+CTl1aFwQ38JyND3OFz5TyzPPD0fVTJXwmes7oc338VPF16vc/lBiDqe+5Fx/";
  b += "wCkKrrExJdRgYgdZHZeUc2BiA+s9MbB98P8J2+q9Byi1FgdNODq41mAwPnXIlg1L9SB34Iu38Ss";
  b += "98VuHPpjaKAwmeBszFrO9tpvCBX3Gn3u01xQVhZW+OIG1OCSjt0dXzc+3CQ1bXfv9wTvAt6Nr3K";
  b += "M6mfTXCPrazJTTPSgk2k9F279swNrjwV3O3h2rpgfMz1Z0sa2oLHRZyUC/2dBzzkFdV/7jBsgHl";
  b += "OYsAek2UDtq0wtr10/uIAy7DKd5PGMUPWpB57bZPpE/LY1Mz9yxB5iLDq3vHC92tDiuo6f7i6/X";
  b += "ZIeHF9Um2TYeiy1IBXu3ODQ2ud416sYYwJTa3auaN32bZQRd2KKsGjR6HlXqdZY4eahy0WjT2hZ";
  b += "z4o7HDrnZEXhRPC+MXzOw3Yuzesn/SORLLzVdj5U50mT7rfY6Bfi+nwp6bJAzf4RD8QRM8a2DGi";
  b += "Mbmf6PjAxPSlryOKPw/M20OTrrjtGB749mhj49PMcKOtby2HNi4MN6/MX6OyrA+fLcyalCPHI95";
  b += "/7v8Uj/KIkH8qf3g8QxoxoNlTb1/rygjTUXUXbA5ci1i+0CtYWaMbKVreuLFumn+kz8k7V/c6FE";
  b += "RyPedPz/lSE7ku4M7HUosHkbPnXVatXGUctevX0I7TwsOjDDvpvbi6pTTKeJHhurPmv0SltF9pO";
  b += "LTyedSiQxMe7A6yii5x7H2rZ0V8dFrzq0FNLVOjzZe6zTX67XB0RiDt02Kj99Gj4+m/oCm2g/Li";
  b += "jxneL0wfVGfrkmBaMW/QKNcjG+/uPzVIcmTwGR1jJObka4eDM81dYjw3782Td8uJOZlkw9bPXR5";
  b += "jef1X8dOVl2J6RFofWjWNFbtJ+Gbz9M39YrnFiX+Y2Ctio1I3PRnyaV1s5o7rGaoPd2K75J8cwt";
  b += "7bIa5nuOeuacMGxDksn7Rys39xXPGxeT03hW6PS333Wdr59u9xihF7pnaZaxH/JHiH8dtbg+JXd";
  b += "k6/3RQzMf50l8JLGx/vi+/fsY/oTP7reL3rrj5tZ3smdIgcf9bHNyXhjMHF5b1YsxPa5tUO4Ied";
  b += "SPDx2pO0v/JLQlaPjnver+Anqv8w6aU4LUq892Rpk37rosTp246+t+nXkNg0xFmxM4I2ONcVmWU";
  b += "l9Bx8wh95l/OrbPA+G7XHg0urBtu6VNXerLs+2NUvpNCwWS/piLX982epAUmv5Z/W9HQpTNpUPl";
  b += "Lf0W9z0lnT6pwDTx4k9a/qdPzFSpPkqDrT9+umRSQ7WfI/hxSMSx7bY4y7udHu5GX2KfSMmy+Sx";
  b += "7UMDihmdUtZ5e04r3JqQsp0jvevAfbTUyp+Px4bVnkkxYf3y5NU/ENKxPqH3VzK+qTyQ8/Pr3IS";
  b += "po655bcvpGR+akpMh2dmd0+nFikGXsw/gwxJjP6NEdHmMiSvcX7IPZ/hQ45vHmJfk1U1RGW2yyN";
  b += "RfXlIB+EDRl4Ve+jGMRE9Amm+Q6/eSrePpyuHnu3wa2E1Y8PQksTHxvEhd4duWRDt4DqjY1rK/s";
  b += "aicfkhafLnQzqvmj42rfcOr6ZHJjvSXqexc+/eeZz2x+4zQYlXLNPfxSyflrAmJn1b70kONZGTQ";
  b += "O+w9krsdiAdq0gqG+n6Jv1Yi6zn5aO9hO+azzhMUaQKC4v7H3Ctmy28mlpuF+BVK+S67Ph4qa5Z";
  b += "OAlpGFU2RJCxASlb9GinOOMy8qi9S7clGWW8prTY9w0Za548c1/vRM+sX/koKKbEK/PIhC25c8v";
  b += "zM52ylwQX7lid2ebrPzjh3o3M5cNsPrraGYhqj75VBrgHigp38GM6BRWJEu7tz0pasEXkxnW79/";
  b += "HAQ1FAecB11abO4k6KuMhL1yPFL06+MygbMF785LPASGy6RywsHJt8sOtLsY9O+aerl7plcc9v/";
  b += "+Xs5MSs8tK0xvbhM7I+b9338m7G0SyPpcOfVTR/yJoYSH9UvNcu+3JY9y0z3wmzp1i+SN4+YkH2";
  b += "8x7rXnfRO5vdsYCVeGkyOuzavNN2rOeuw3S9Wt1Pi3OHhQS2ZSzrumJY8pUDzROyrwzbFrZpVPY";
  b += "RTs6WyJqae3t8c5Izrl3r/FiZ89rrnO5dXnXO1cCqYdPi7uVwE+r8N+d0Gl6eO+qSaVnocAUjKY";
  b += "T3qGQ4a7W7vUvTjuGcGRM80OdPhoe/WjvxSM+uufwE63cLC2Jz9+U6CUriJ+dWM0pafxt+MNdWJ";
  b += "Bt6Bnub6+qj4zb2WG/JOO7MY0N2DpFcOOmxeO+sOZLaz7W+T11OStz3fJrVHWuVdFcs8Uqwcsp7";
  b += "HuV/auOGrLzfH87ZZxxXmZd/3tt15s4LedyjU49us2JIy+X2zl2qvaWLslvuxoSNkJaUNlc8rlw";
  b += "jvSv8UmxFuyW1K97/ct4DA9nIylxbL/Mg2bzxjF2sjFEynw49RgQVb5WdNc47t6CyUVaSWqfef8";
  b += "w0v96zuCHeLDo/YHJl4HNeWX5c9TGjXja/5j+d57JEpmjKNwQz557ru49I6OQncJwzeERu0uzWv";
  b += "b/MHPHw2qjfXJyOjbg9w9T4aNvHEbGvly+Rt9nLL38IWME8lCGf8m7elFPSCvlGwZfno8POyXXS";
  b += "xihmRGKKcyNTGvgP3BSlcXLagcUSRYPyZLdf7q1Q0GKKNj4cfFUxcW3iAosmHWWnug93Rqj8lJ1";
  b += "HKePPX1Qply288Kx0wEZlZvtRp23c+8q+hxQld6KMVDpbou9eXhWmys6boyNeq1YdZhVEttXvVL";
  b += "0+3elBK/5MdbUtfNNYf97I6f2qBneJjRvpGFn38lH2lJH7hKOG3z1yaKRR8fSVfW68HZlc6ThtZ";
  b += "L11Qf74Zvs4PK2gl9OByk4Zcwu2jn1xbJFXXUHqsscuvqFtBZ+PGljV/eFUuOdtnI3XhuzCNfzq";
  b += "HZPnLi3MHhqW7zrmYiH6IfWsvzmzaJyzsqTjg75Fgqr1juG68iKfujney2etLYoYVcA56XK7KL9";
  b += "malZLleGo6Yn2am928CjZJo/0qdNGjxJLuo9xc982qmSAnTltwqNRQ5M+WgX9bjb6VoWX6/P66N";
  b += "EXfaZgv+MTRgfP6DP+buDe0eEezdt0cl+NTmOMWnZ+Qo8xHyZ1DvZflzTmS1x97hTWrDEetsdqN";
  b += "3KOjzn5TrEnQffzmE+vZ2XVRDsWe1eYHc6dk1nM8bHayihYWBw+3Sa1bt754q0fF3m2WuBjK1XI";
  b += "5L6N7mPxuUj1wDt5Yx+k+IZFVa8ce1PeYPEw7trYWeW0RnNb3ZK9N8ZJB3n5l9jM6n76Ud3IEmd";
  b += "lTd+uo2tKquqeT3h79n7Jv3Skj7zaAgppEgNCdn3OIic3Q7VkzDR4HBke9PtnNqP+TVsA0Giuvc";
  b += "CB7+BJ6s1BAZnI+DEJuRgAT+7CY+IaXIuSx8o1+ApKzsE0+AxK6h9rcD11zF2DoX2BnsShy7//g";
  b += "1K/X+MtIDWD336T74AfUztoIlmLk7PC9n/4h1D3PrPYlANHh6urp//XAf7T+//Pf/+XCd9C2b8/";
  b += "4Tsu+37Cl6FlHAJ+H9F/aRxC/D80DqHO/944xH/f4ZVyx3x4VlcuhfHfzicnlW10suNoYystzGF";
  b += "8/x5iq58aHyCsDuQo4MKdPC0DahOC9K2l4oI0iVhqoylPO43U/NLEN41GGX0SKnkSaD+alymTqP";
  b += "K+XTjxE+so50aQxlFujSCNo3zvVaqSSL43pvIJ+Pv3rsz5OUcimgeoWJ6c1FmuoHSWNXgJ1QY1e";
  b += "OUP7zdSRvo0eAvFoKgLFb5aU78sJ8tOmpz+ZmT9hZzUX/3R/DpNQa6AqqQ5X2OxUJD692KpKo8P";
  b += "fsP+kCfMR/qC3zhMk1IaDlGQiwOaOMm8IMhgBZkHchAguX0+FSeVDmEIsExBrrQSmsiEVQsEWUi";
  b += "5Ubq8SA3A8CKPb/q56en7FeR3Pakg7QNkSWSgPwLfhCU5Xvp1BakdpnlP3UHCg4PUJ+DG1nqXIZ";
  b += "NJxPAUP7RHoPz+HRiroMIwwleSebADjcUX/Ma0/Gie6XApJf0bTlWSxtE0+F9sW0SzEri5UGZvq";
  b += "EEaNGgwZIPKzRdKczKRMUpS/eEFi9SwFFLa0UJehgw0xQKxRl0afj8tg4wyypD5CC03+f+Av/RV";
  b += "kf17HcVPNHgHxW+0sfZ7d4of/EuaFUKF2M0lTZKTPYywmkDdDkEp551VkeO0N2UEUIP7/oB9KKy";
  b += "tkx5IaSNC3a8B1NVLodRuBORz4dRiYCS1YBdNXd0VAw3LQIN8lAFHaLQxkTJ+Bw02JlOCVobWGA";
  b += "XHGWijAn5LqPeeA9feoO4bPDYO+y71jbW/rZyyZQB5gwpuTQOCV7EVAiqiroviUwafnCjDSRqDS";
  b += "dDokTtlMMaTMrLlqFUfET/UTyRlSFODB1C2P3x8EL8DTUAkiu6H9EP6kzb7vLz7+misq3yVc0gB";
  b += "xsCwQ8dORsYmnaGOF9IfMTO3sOzSlWfVrXuPnr16W9vY9rGzd3CE5v8Qvzmv4UkOC12OJtFRlKq";
  b += "xBo/+AY/5ARdT+B9ItEQFaqRi7YrUdh9NpVX8g/tYQCUIpQf+fzDdox22FDY+Ypma2MVCQorIHY";
  b += "QfV45zZI6kbQ6xyBEOpgVyqLOjGJaTR0r5s0A4e0qVyIZg1lAdPFsmJ64YIIYwGXFXFPlTpYTsM";
  b += "U+cJ5MXfRN8eGKpCLpngYyrvhkV+2r0hLgSSi5X5QNH0GVVUJwCQztx44OMJ5FJszXjNYxBKswT";
  b += "Q/c8obQICgC5iky5TKGwF4lHQutL0AVyXjnhUQTEfmiBRFwozlQpiYszYBy8DJWiSC5WyFTyTBI";
  b += "QrkRyUMqEiNpKGqGSKYVAOMgE3EwsUojFufAzg2KAX1/jkwJJlVr+VwDplKxGQqUJ7l6BwquUmi";
  b += "LAyzq+MwsDb46ARQLVrhSC+KRiJbkRBXM0TCgVSbSzI5HJ8mHx4FVbcMsRVp8EqtjzrMUO2Q48R";
  b += "VEeUQPQnw2c9NjLpJIinlYMILAmryBrOao8MiLwxYhNK6iZVZQDdze+uhN7Ht/gt+9WIFNJRDzC";
  b += "xAtluVUogWkWgfoCn0+RIZeBF7z8nHyxplQiWYFUKBLBOzyI5L7uD2occ0DlKsTwVaZMKiXaD/U";
  b += "DpijMIJqOJjaVFCQHBAEQfpgMtBctrBUIxCtWfoezQBIiUIy8HOIKMZ5ILAUTDqoMMO0sKI0SXS";
  b += "cX1DTZL1GKxkEGSlm8K9AaFOGdegOB7ygFvGzj+75cBmiC1mQC3nrGs5ZRRo54Npr+aVFMCjK9i";
  b += "ylDR1R9aoboAq0JxKSf92fwM0cGe296MWlI6BmlEE1trOaDMZ6QjcCkitjynl5M3pq2vJgUZDTh";
  b += "mnHqphqlCLTfLJk8jxisySwD99PFpKBoTZnF0JRtCnWL27Qf3KdTN6DM/Em+FUXSTEcZkCChVe6";
  b += "xBoRCeAM1KGhjOPjA5sYjzY5o7lWErUYuhla3oGWbPJVSXPjTFORi4h3J20aBeKGl6dmUSQmSbf";
  b += "GIuRXZvr/ez0IxXQSpGUsakDkylhSef0yFCAyivzeWNBoV//3OIRDM4F070AwcIZTxhslkoKfLZ";
  b += "Xlwaxm65BJfhtjPY5UYEAPsj2l89Qdv5Sgh62aS5lYMCvth1K0XFPbFSKva2m2wnBpvNO13FlUX";
  b += "BhSeA2juD37gLVfzKTdNO1wAy/mNrQcAsVCWRzUS7T5QQfjTGj+i4MgRpVJGZUUQVf+dlcnQb2O";
  b += "CHzUmhAOeEieThcu+2h8JpsYD4BoBhoNwOBoEyImrAQOJ4QA8yAEg6OsAAMP4A44fQ7F/+Bu6wZ";
  b += "gh7w/+yioHQdYfRHH+SJkylmL51E5vMJg2JkJGnwz4PDSXLAJloTIWCLi8xkYKZPKxkLVHklwLJ";
  b += "hBC8PVvSYUDdh0DshoFmPU310ANywWJB0G+HKrw03b7BhIhJ/aHBfUjOUYQwYD9CQYcDfgvlXYg";
  b += "YL9+gNPCwBrOC3GoFEjPwDFAw3MDvrJLP5LlUhHEf+OwIYDjasFvIWIgv9WGBLuN/spuAwluC1I";
  b += "Lhlz223CiUBESS5ZKQnUX7X1pYSZhrpTs3Ij7OAPCQNife7nCsUCoAMK/g6OWqAG3xnMVjt86fz";
  b += "oI70bxFzY5sbOHQ/W3sy9klvKE5HiQATosYDWAB36/Xb4exONB9RnNDWUGFGluKNOl+IsR1fd0q";
  b += "N9GlBCsR/ntRQnQppRVay6VNw4Vnwn1To+KsxPVL80pNwPK7IkRlYYx5U+Hin/TGAOkEtBUQKMA";
  b += "DQeUCCgIkAcgW0BGgNiA2kYbIE8BXQZ0AtBuQKsBjQUUDMgekDEgDiAU0MdRBshjQA2AdgPaAKg";
  b += "S0GRAakBiQImABgASALIAZAioGYx7LwE9BNRQRC4eaOpSn6IOWmaA2NR7HapedLWeXK1voEeVX1";
  b += "PfLCqsDkWa+uVq3TKnR2F9qr40fjV1SKd+m4NvrgPoS6kB8hzQbUCnAf0KaBOg1YDmAZoCqASQH";
  b += "NAwQCmAogD1A2QHqAsgFqAWtQHyGtBTQPcAXQF0GtAOQOsALQE0BVApIAWgbECDAQUB8gL0BPB4";
  b += "e/DsBsgSkAGghVp8dxG0iwEXlLT6y88WP392D3fNBNKQ4awJ5DjCxch6EPIoeYAYruCdA/9xJZT";
  b += "Ik/bi55/zkpUHzXtYTCTHzgyMNAL456kP4McSIJT38+Hx/7SqIFXlOYpyitKIJSCirwtBfFbUBJ";
  b += "u4sYXCkRTGqL5UB2UMJkgTvPDVxRF1GRhB7QUocvS5DjLPFVTHEdmbid2JMpQ21UxI8cuzf0lD/";
  b += "F7MOIrodES7Dj8k+sND+kfFupvviDMRnRG/WTPBq15ov/kO7EV38VYPI33HRmX3F+/rL7Fu047f";
  b += "3Hpuv2mJ81q8V9enkRjidx36Xs1BxzgsTJl06aB8+Y3rkxyNOtRG/5abLw2r178+/4p0xPZeW7N";
  b += "qN/VwM7JMvuTfVy+uPfOwIv6sSdNn8Rvr/fEfT95W3/5D+u580+20j7F05KfVkyVROonExAIMHI";
  b += "yLHEVgOJPBRZg/V7XIIQ+KVP14fGT1JANiUq+i+sJPPedIVQrCN/LV/8i/8Q8tWEDvGr8Ffxc3y";
  b += "IhD5jAxmGyI0sB0wZoMbgOXkBVA4oDXGGjiKfy/xqNQZVhT2daOSBNP0V/GA6bN5LQbNsMIv8GE";
  b += "hfLA0AGhcbFaZR9FhdfgI1Sb0+DP1MKOBn+heIwGo5SxJQ3moN/Hp/MD5v6AdX/Aej/ggSgpF2q";
  b += "wGP0+/REoaQz067dEv8/veCp/8O9ukJkPXm/2+5Hms20Qn65dfNKkLX/j7ebLBI66vf9gy7aC9g";
  b += "/NtwnMvZrr1zQ74aBhSyOB+7aUzNrUtWGGXcsLAo9fHC+wTh10KbjlHYF3nVq7qbxmxFJhSwuBz";
  b += "0x72b2gW+Wz0S20dojzYgt9Z4ee3byghUvgxPO/DCnq0HfctpZOBHZPaI5wm2dw9EyLBYGjFoZ4";
  b += "yJ4tmPV7Sw8Cn/Qa1/PMBOU1pNWOwO8qDlWcq59YZd7qQuBHNbYmCzkuTa6tfQk8c7urbXO2x/b";
  b += "o1kACe/evvXj3cl1Zbms4gfeeu2TWO/DOiQmtcQRecKrnvvPLc+dWtaYSuGxNRnEPSc2tva0iAn";
  b += "+4maY7OGvjqiutEgL3en3st7mfHrxtalUSeI+6vXr9pl27OG1jCDwtbIyEnpYxqWdbGYFj+Udc0";
  b += "tv3n+rfNp3A8b32zp4+IXJBcts8Ah8Ya5Pfo+DzXWVbJYHL9zzas/zA3bXlbasJPK9YObk+bcOn";
  b += "DW01BK5fsr58bn7gr8fbdhI410j/0KdXrKl32/YT+BeBQBzfc+u5z23HCVxTMrqh9kH/RZ3azxK";
  b += "Y4d3H9rhBaqND+2UCX5qjyFnUo0d1aPttAuudRsa/2TWpNbO9kcDPzQzniFiP9o9tf0Hgs5OjZe";
  b += "yz+6cvan9HYDux6YPBJrsv7GhvaUf8Ji4CzJLuW3m+HbDgeRCctjNYc/nJE0LXEP5l1Jx4XrgJJ";
  b += "3g7qG32vE+Fnv1Lu1A35u0wYp4afb7isAfRvhEkP/XZ6PNOY8tjiVsBEGSY+unG1R4Xr+QRczAE";
  b += "Ceq22KRX76jlk4nFXjBDbz5+WbAy84+VxMIugqzfVDfdQ/zb1gPUadlb4o1mM1knx18n+gsYgS1";
  b += "H+H+2HHL8DWEkFkEGPzZfa5cTMUcXFRH42Yx8M9FL9GZvVELgsIKmxYtW5a30R5UEnpBbvHN0If";
  b += "tNKjqGwAWd7xStaIzbWYCWEfjoiSUpcyamTJyDTiewz5AFdSdiXetq0HlkeasqvqTutJ1/Eq0k8";
  b += "MO0qkUHlgf/dh9dTeCe0z1vuRxdsqYFrSFw6vKFq+SLaz8YYzsJfP7g07jYQ7d3C7D9BH7g1+2N";
  b += "yduWyeHYcQKvKUy9tOQ872wWdpbkBrFWo98mGy8sxS4T2IvfteL2rqoHS7DbBF6w42Fq7IUb63/";
  b += "BGgncN3Dd6htjljQ3YC8IbBC4el14+Mh9z7F35NnnSt9fmmZunMbAWwhsV5a41qCpawMPpxG2PW";
  b += "0Es58+Wm2wxBvnEngpt3JF8xKDx/F4J/L9O++MGzzrmnzcgsAT6teNGjowUD0N70Fg+zs1uG+j1";
  b += "aE1uB2By9sDhzpWZs88jLsQ2G/P9MqlJs6Xb+J9CbzB/OHOObdMl73HAwl8o+DuXumhBc/1aeGo";
  b += "9krr34+82fIchYqQUnjlBsTWcjElwWvwBmoE0eDqH/DGH3DND3jTD3jzfxgZeX00w3JfnrWA17c";
  b += "vz01goxV+yw/xwRHpPxl10vjV1WxpUtgYJbdHNNgX/as79azgcAuGZ2J10trmHyzBa+K+jf6Hcm";
  b += "sVVxPmDvp9WX+jsEaChT33CQ7aam8EqZqIIr7++oh6AZBz77+nI6cXe2vCOWNkHWmwG/Z9PUh+w";
  b += "GcxcktEgx9i5BaRBjdR7/+2jVEndcpmGxDmqPf/nSSTwh8CpLCM1N78VLilrAlz4C/D5AvlSsU3";
  b += "+cflW5iDVBi+g4N9H36ONCtSGPkfpKc8YSH4rZVuCXU3h82fCghmCFTBHEBFqOeQK5b+xOpohEp";
  b += "JbnYggRPJ1VSoN6f5vXoOuaKqeZKraHB+ouT17m3HO0u5n5tDbmmv0pqtrCa2jOEtWtQOB3FYQe";
  b += "FFLOSBrEOFD1AkJXmLGeERuCDIqznkKoXBXNJk9CqtWdkaYgtdCeRQhZWPj8+fqyjdWiLOUvJ4c";
  b += "rgVaZPO4fEgBu7pdhzSEf4mVnCj5pL3QA+j0hk1l9xanziXLEv63/ipmUuWG0akqauGuWS9rtJa";
  b += "LVxL3d24HrZD+DeaY8exAw9eMa/YmmNt99NvBRok+FaG88gVZTE10+IX8vl8Ad+J78x34bvy3fj";
  b += "ufA++p4AvEAicBM4CF4GrwE3gLvAQeDrxnQROTk7OTi5Ork5uTu5OHk6eznxngbOTs7Ozi7Ors5";
  b += "uzu7OHs6cL30Xg4uTi7OLi4uri5uLu4uHi6cp3Fbg6uTq7uri6urq5urt6uHq68d0Ebk5uzm4ub";
  b += "q5ubm7ubh5unu58d4G7k7uzu4u7q7ubu7u7h7unB99D4OHk4ezh4uHq4ebh7uHh4ekJsugJkvcE";
  b += "UXuCYJ7A6ftvuoHiz5Ani+eQZW6gkyux/P/yTxPfaTqpH6SUq8RZQolCrJUWg02mpcG6bHIVxNr";
  b += "mr07zifMyh5H2XzfPJ9vqbEpnRIM144dcKIW7W0rQ8akmrukM5JssuK9E3H8CnKgbT17NJ9sats";
  b += "CAsHpJ+oS7gWQMLgvIYxma92R48h2RkgL2TqJngUAEQOKAX1im4QvIFXhqD48MSqUL2IpIJiY3m";
  b += "Ig+Rqjf5EipZcbvvE5eQK7oLwVPuG0tovjAfzqucG8BuXvgTyf7iDbupoUT6OS2uQa7MsjxXYMz";
  b += "f8AiCqc4ODgMIc7BULUNOMp33Af+Ah1bXEHuGOVXkPWi6c8Z4uwcKdwghtVtDX/Y8AqGicniw1U";
  b += "bELaqgjyWs7mCPNKzvYL8Hpo4NIpsQsIYPk9zRMubl0PouOVIFXCc51mTeyQ2RI40+WkET7iiyV";
  b += "lIrup1WEgef9HE/dP6pcYs34Vk+2WipHLcn/yqAO+WicSOxF6W5gIL4A+E60mNzRZa2Iw6ooCgO";
  b += "J3OYGBMBovJNuRY6JhyzXQN9Lj6NAO8Q4eObGPUhNYZNcXNmOaoBdbVmIf3we11HFA+LsCc0HXY";
  b += "BqyatpH1BWumt2JteDt7U2HRtBkr+YmDp02fZXFHT39geHOLg2P/1CFpD8pmzJw9Z8O2vftO1J4";
  b += "6/Vvjo3aEZtjBRuDi7uXtExo2pGwmeLlz777a0+frGx8hNF094q2Xd1BwaNhQkbhs9pKlp87X6x";
  b += "raAKfQxJTUoWki8YzZG0CQE6fuNj56pWsYFCoSq8u27z946Mq1V6/HT5i2eu3BQydO1t+8FbLww";
  b += "Lna8/WhkVGJSUPTpsws3/bL7kNHak9eMzQ2SUn98LGtXZ034re7el2lMgvLtOKxm7eU7NtvbNKl";
  b += "a/CAyKjByalDx5bsOnH5yu1Xr9/LFeVK1YJeDo7rtuw+dLL+2t3FvhUL+eVdL14+3x4ZlZzCZOk";
  b += "b9HZ82SSVufv09w+aNTs2W1V3quHC9RuP29oRXlq3cXdp4wJZ5jSGYWmNnnojvSu71Bw3ZaE0R5";
  b += "oLjYmjTAbTkBOt34EZz8RpFhw2zsKZOIbjOJdGx3UYqJ4RPZJpzkxkYgwTbjQtALfHUZohQ5/rR";
  b += "bPsmcbLow3vqa6jj9uKmzHGteJJTGN2Z3YnbifucAaHYcZIYvahB3PsaFwaigt07GhmDB1cXQNe";
  b += "OQoicPVqVl9cH+/L9GD1oY9rN+zMcjS0x630rfTV02njKkx1jCbPozvSvZmYXme2+mA3JVd91Yx";
  b += "LV7fT1Xe5b5bi7uzS1E7qPSz1GTqnszfOYXiwgllchlKnC55MS2Krx3e24Bizw2nqqYyNq7kmNM";
  b += "EKWunNXkwuna5ea1D6nonybBng7Qya+iBujuvrIgwUBYXD6EwmxmKxMQ5dB9OjGaCGWAd6R8NOq";
  b += "BFmgpnqWtAtWV3RHuhwWi62Bd+G7cfqsQvYZe4V9lXsGnYTvUe/jz2mPcFe8l7RPmFf8GaU29u7";
  b += "X2RU+bJly0dPm7tg5fa9E7cxmGw3n34Jbxsu0Dp1dnNPSCyp3rzlgOu9DpOmzFz2tTHCthgZJRK";
  b += "n/rLb3ILJ4uh0MnHz9Fq/4foNtvus2euZHO9+WTnlcwxlaYdeNiVnvGtpj41bvMTBsbd1/NKqFa";
  b += "tWr1u/ae/+4wwdrpGlV/+gQWvXnT1XxTQ169azX//HL5raT9TSeN179rJ29vAKCQuPjo1PgG0vP";
  b += "VOclasoLC6Zurp6y9bDDZu3SGUH5w7tNpqO0+zxLBx1dFCPs8QF+ha0Huwu9D70QJqerbqa0YPW";
  b += "g2bNctGJDCh1ZxtzWJ29gzzxTBabb0y3ws3pqK8HbSDdkcZhspm+vN40LtsN96KbMWlcZnSou7O";
  b += "uM9OBxSntFTOwD8vW2KyXRScTdiRIIFDXlMlhhLB6s1U6/v1sGd50DmMQA6Ub4HT1tIwuISyOeu";
  b += "3QbkE6HIZuRy8Gx82OZqL+ta8olhvC5gQHmYewYnVDmRz1h2COJT4g1B3XY3EYnkxOqZsp0xu3S";
  b += "ED1nXTHL8lS6aiPTw3P1C3jGxiXV48bsOLXcZ5MW1oqoxcnmGNN7zhua4p4IM2TaegLm0TFJ1bZ";
  b += "VVv2yselzvqoJUOPxiqdPoWWS9fF2UyDOekD2Mq+6g8cBSvfKHgU7AqJbFP1pNIB+AR/faOy6K4";
  b += "MhvpKH3o/KzTfHjejYaW+XQ296Ghpg+2439UfbcJpHBo23jAw3Ed9tC8DpcXTzV2wUj07moibwF";
  b += "Fv9rDUtaOxQY9gqBePv04zxHXxAloaA/QvfS7NAxTOmtUtsjSOawny4sbSA17ZTPWZnpwyxl/yc";
  b += "OqZBg/GADb+412tfwonhhsVJMMftsyA4O12lIySqhr91S2euobnp3OkjJxsUjIF8izwD2WmGpSU";
  b += "9f8siEtl5OmLn8wciYtjwMzRhf/nl+S5qH48fpy8KFguywuVaqYn38mMcL5O+SCujyP8UB75IG/";
  b += "W1FFA+NTgVGp3Cwr342k8ZDY9HRnSsQrpYMLryuWld22yq+pjy+fZydbes8PWp9t3aU53QNp4bs";
  b += "va091a0ftuKMfKvYfuffeNekJPx84rPPkWwpC3XVaE+7oIo18NXzEoSmYVs3T/ihikXhgrvrAiF";
  b += "rlpFYfcux+/+YEw8UWjVVLDkxVJPORl0iu0JBnJR5iIPYqiGPhHQ3T4RgaoGHBrDENp3dEu5ik6";
  b += "Xmw22pmGsgFzo/fB+7JsO6M8dxCAxgJcmcnBLFEvGJzGAl44mBmKYZ6AC9IwMAqgXTAc1YGYDjy";
  b += "gnTBjwCO9YFrANxPnYF1QbxCWC0Jag+hBrDgdsFAmpkPECrMEEsUgtsA8sW+pWKIhKA0FkaMsdB";
  b += "CKMbmsDBRj6zBDMXNCS8NdDwUp0nXQHmw0i4YyQKYwU4yGG9B0wU8Gqo+CusctsS7g3xdDmSwU0";
  b += "2GjYGxCVVg3dCROw9goA78FKgHklgljxFgMDobyuwpofIDpqDWbi/FAIVHcAyUygnuxMGwhjuqi";
  b += "TJggjtX6IugxKwSfgabzEEYOhtBQDg+LxhA4SqCmGB2twMw66KK9WKY6DjgfhVXWGw0ANY9hXFA";
  b += "uR9QZxIphdFBuW4yFvoTVhoJGbmAAp3foA3Q+HcFBKWnWOA1dA+JHsGg8WEdAG4266duAcnJwAY";
  b += "iTifrgPegoqx/KxVzYgD2gaTisSlAp6FIUZxkRNYuixqgeE6cfY8HCmMBaZcAPBT/Cc5A3BniaY";
  b += "/Es6DIcJYKjYhx8VDrCRrH34JuAFoHOAunRUB7HmkF8KQaGO4AKB4Ig8B1jDLICYhnFwGGsoBZD";
  b += "YFIoAr6uC50Of6EMfQQM2AjanzYIuCMOmAkC6oBGZ7EwZhfaPBxxpzmxUD3UmI7qg1gNiRjpIrQ";
  b += "KhPGhgRpg5jGRdPUrxO/eiaOIDooji1B2vlwmUmWK5QqMJQEzGJUwW4zSYlQKJcIFr+CRBbHIPq";
  b += "OIphciyxNnyMUFvEzojyFwdeA7uNOJc9I9BQ7uAge+vRRO3CVFPOuv56Z5YI7rbM93ted72DAKh";
  b += "BLgncF3EHg68LnwJIN9BpD/s8XSDvD6LA83EFDk4eGU6emeYYPY6ZMGJ9KyxMTNcwqsj34eecrF";
  b += "PlsiywDTwz4seMecvbhQ+f8A9ABijQ==";
  var input = pako.inflate(base64ToUint8Array2(b));
  return __wbg_init(input);
}

// packages/ecdsa-sdk/src/index.ts
init_shim();

// packages/ecdsa-sdk/src/lib/ecdsa-sdk.ts
init_shim();
var pako2 = __toESM(require_pako());
var base64codes2 = [
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  62,
  255,
  255,
  255,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  255,
  255,
  255,
  0,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  255,
  255,
  255,
  255,
  255,
  255,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
function getBase64Code2(charCode) {
  if (charCode >= base64codes2.length) {
    throw new Error("Unable to parse base64 string.");
  }
  const code = base64codes2[charCode];
  if (code === 255) {
    throw new Error("Unable to parse base64 string.");
  }
  return code;
}
function base64ToUint8Array3(str) {
  if (str.length % 4 !== 0) {
    throw new Error("Unable to parse base64 string.");
  }
  const index = str.indexOf("=");
  if (index !== -1 && index < str.length - 2) {
    throw new Error("Unable to parse base64 string.");
  }
  let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n2 = str.length, result = new Uint8Array(3 * (n2 / 4)), buffer;
  for (let i2 = 0, j = 0; i2 < n2; i2 += 4, j += 3) {
    buffer = getBase64Code2(str.charCodeAt(i2)) << 18 | getBase64Code2(str.charCodeAt(i2 + 1)) << 12 | getBase64Code2(str.charCodeAt(i2 + 2)) << 6 | getBase64Code2(str.charCodeAt(i2 + 3));
    result[j] = buffer >> 16;
    result[j + 1] = buffer >> 8 & 255;
    result[j + 2] = buffer & 255;
  }
  return result.subarray(0, result.length - missingOctets);
}
var wasm2;
var heap2 = new Array(128).fill(void 0);
heap2.push(void 0, null, true, false);
function getObject2(idx) {
  return heap2[idx];
}
var WASM_VECTOR_LEN2 = 0;
var cachedUint8Memory02 = null;
function getUint8Memory02() {
  if (cachedUint8Memory02 === null || cachedUint8Memory02.byteLength === 0) {
    cachedUint8Memory02 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8Memory02;
}
var cachedTextEncoder2 = new TextEncoder("utf-8");
var encodeString2 = typeof cachedTextEncoder2.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder2.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder2.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm02(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder2.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory02().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN2 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory02();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory02().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN2 = offset;
  return ptr;
}
function isLikeNone2(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory02 = null;
function getInt32Memory02() {
  if (cachedInt32Memory02 === null || cachedInt32Memory02.byteLength === 0) {
    cachedInt32Memory02 = new Int32Array(wasm2.memory.buffer);
  }
  return cachedInt32Memory02;
}
var heap_next2 = heap2.length;
function dropObject2(idx) {
  if (idx < 132)
    return;
  heap2[idx] = heap_next2;
  heap_next2 = idx;
}
function takeObject2(idx) {
  const ret = getObject2(idx);
  dropObject2(idx);
  return ret;
}
var cachedTextDecoder2 = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder2.decode();
function getStringFromWasm02(ptr, len) {
  return cachedTextDecoder2.decode(getUint8Memory02().subarray(ptr, ptr + len));
}
function addHeapObject2(obj) {
  if (heap_next2 === heap2.length)
    heap2.push(heap2.length + 1);
  const idx = heap_next2;
  heap_next2 = heap2[idx];
  heap2[idx] = obj;
  return idx;
}
function combine_signature(in_shares, key_type) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.combine_signature(retptr, addHeapObject2(in_shares), key_type);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    return getStringFromWasm02(r0, r1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_free(r0, r1);
  }
}
function compute_public_key(id2, public_keys, key_type) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(
      id2,
      wasm2.__wbindgen_malloc,
      wasm2.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN2;
    wasm2.compute_public_key(
      retptr,
      ptr0,
      len0,
      addHeapObject2(public_keys),
      key_type
    );
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    return getStringFromWasm02(r0, r1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_free(r0, r1);
  }
}
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e2
          );
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function getImports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr0 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len0;
    getInt32Memory02()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject2(arg0);
  };
  imports.wbg.__wbg_get_27fe3dac1c4d0224 = function(arg0, arg1) {
    const ret = getObject2(arg0)[arg1 >>> 0];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_length_e498fbc24f9c1d4f = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject2(arg1).stack;
    const ptr0 = passStringToWasm02(
      ret,
      wasm2.__wbindgen_malloc,
      wasm2.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len0;
    getInt32Memory02()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    try {
      console.error(getStringFromWasm02(arg0, arg1));
    } finally {
      wasm2.__wbindgen_free(arg0, arg1);
    }
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm02(arg0, arg1));
  };
  return imports;
}
function initMemory(imports, maybe_memory) {
}
function finalizeInit(instance, module2) {
  wasm2 = instance.exports;
  init2.__wbindgen_wasm_module = module2;
  cachedInt32Memory02 = null;
  cachedUint8Memory02 = null;
  return wasm2;
}
async function init2(input) {
  const imports = getImports();
  initMemory(imports);
  const { instance, module: module2 } = await load(await input, imports);
  return finalizeInit(instance, module2);
}
async function initWasmEcdsaSdk() {
  var b = "";
  b += "eNrsfX2UFld9/7zPPO+zsMDCvjAzIQkkkEACuzFazexpErfoT//Ir8fT03OixkR9NmpAGmNddje";
  b += "GpGuLLVZUolRXpQVtaGnFSjXqomhXxYqKFStWfi1arKhY04o2Jr/v5/u9d2aeZ58lpHpqT45w9p";
  b += "k7d+79vt/vfb/XeNGrX2EahmFOvn5y0oheaBgvNMyJF5oTBv1RwJqgEP1Q0J5AGL/04kzwGz/o1";
  b += "Z2Qd3lShDehYlSAovwJHadDFFmZyP/Ra2Oi9R9FlSQ0Pj4u6MYFy7hgG1dYt6rnmFClosc5l8dP";
  b += "zr5V2BlDWCUdE+bG8bDuhRQC+zUvfumiW299zYtf/sqXvPT2V9766i2bX/7Kl9760tu3GA6+LSt";
  b += "8e9WLm7fftuXWl2x+1V23br79DsPKEnCGW68ZuuP2a1/yotvW3bb+JWuvuWa94SJBvyS48/ZXvn";
  b += "TLy269ff3Trrvjxbdds/6Op9227iXr7zDsApBX3v6aW1/04pe8aGjw9uuuu/bFL7ruRRvuMEwk6";
  b += "JMEr97yottGbx3ccN01Q0+74/b16zesX3fbHYNCqUpy++bNr9p86x3XbVg3ODj0ojuG1r34tjtu";
  b += "U0nCAjNbXrb5Va+h6I9PkRg+GnhBObCrVc8LHKfsuYHtOZ5TLgdW2XHLZcfzfNd3S7Zf9jx3wPd";
  b += "qjjNQdVyf3nw3cALfcxzHp78yvTiU3Pa66Y0eAb04C+qOS/Aarl1xXMLl1F3Pd1yv23OXl4PAdd";
  b += "1lFmVzLUrkIjNBpX8mkeABlwugjhO4NhLY9AmvzkKi1GUEHoEvl7vLXuB6BMAN9L8KpfRAZxB4l";
  b += "NpxumyLEjmOHboL/TJIDQKrQew6tku/FGM7TKztMA2UlZkjTL4FpJS3bHsAFdiEynNKhB4PfLQD";
  b += "j0Voet1LHdf1yiRD+mdZlmM5dtkJLN91fD8olwh0mURBiV0PmTw7sC1ir0SICDUR4JWJTXwh9Iw";
  b += "ZVDiAZHEMfS5bRDTH07+q5YIHEQ104bpCTJlePJ8USHJBvO9DXBRPeu0jUVHCqkIAvoiSwCcOPc";
  b += "OruJbnWRqBZ7O4HDKVIDAQK5ZRQiZXlOI6HBAFcaYA6uHPrrzChJCKKAVoCxoljumbRZRBVJKZV";
  b += "EEclQN6BmQSImXi2bF96FtLxK25Hgdsx7ZLziIS9+LKkopTKhF8+Uc4iHWmyifjQTSJrYxsNhkx";
  b += "mCQYQQkYYPiUBrnE0soWkWpTNBFpg2qLaNXcksRJafTd9yFz8EdFxyNV0gf8s+k7kQXpKwBkR77";
  b += "LH11OQREWgHk5Ry74FOzy0+GfzZR46oX+OWyvvu9nUaAQ5LFJs3UimU28267JXLH8LXJknp39M1";
  b += "zTtCslH58v8p/ze5PkRMy7zM/Tf/c+fjG6vDdwYMJMJydnjIr/1nvp1fdecfsrXrX5tZbRddurX";
  b += "kHO6PZbX/3yl77yRVt+Z/PtxvfsBRR51+9suf3Wu37nxXe+/LZbR29/rfERu6vgt17xojvvfNVt";
  b += "xu+5CwqRm2+X2A+6ywuxL3rJS27d8irlNO961ctfueX2zcaPvUYhyR2bb7/deLNX2nUf05yalaP";
  b += "mnwRf9t8ZHPf/wf+Kf8L/qv9h71+tWfOM9a7gkPeo95g/6z1onnfeHWzz3u79rfVBezr4nPMl+7";
  b += "jzGedD5nuC91snrfcG9waTweP+64PPeB809wR/GvxZ8A/mh7zVf+v9u3dfcNR7vb83eKO5L/is8";
  b += "77gz4Pfd8667/ceCnb5+4O/8Y85fxG8w//L4C3+g/4h/0DwJ/6f+tP+XwV7/Hf57/X/OniP/yH/";
  b += "A8Gf+Ysf8d/vv8/f7x/w/8r/c/9H3sEg/Qv/S84+/yH/L/0PBt+wv+zs9f8meJd1wHuT86Hgg/5";
  b += "B/1DwAf+v/Q8H/2Wec//N/aJ7wv2c/SX3uPtl96vuP7hfcT/pftT/V+/t5keCv/buD8547zAfDj";
  b += "4afND7jjfjf9f9T++I+y5nt3nI/bj3Me+VH7A/Huy2jvhnnG/Zn/K/43zHvuffnE/6M8Hrvb+19";
  b += "1ibf+L8m/3H5k+dH7sf8T7qPWbPeO90/9b8sPWwdzg4a5/zvut8Ivih927vU95bvZ9YR4Ij3ieD";
  b += "L/g3f8B81Pl7/z+8vzDPOp/37zf/zCz/5B3bUUd979fMSycuMdJpczSxVxiRnRrpjBF+yY/tyIy";
  b += "s1NvSjJ3IWGn1xS4ePbGHR3fs4xHGAR7VuIRHEJfxcOIKHkZctW6wbyAozk01M7KHyXLJZoes50";
  b += "QEetC6gXDNGIPWr+OVQs2kNmg9myOb4efdxEpDwh+O9KbWlrieGrFl30CZ6pF1c43oXGk9I7bwu";
  b += "C5u4LE+NvFYG9fxWB2HeKyMu/BYES/AI4oX4tEXd+PREy/CoztejEcYL8GjGvfgEcRL8XDiZXgY";
  b += "cS/RWB60JglFVBq0tuHpDVpTeLqD1nY8/UFrN57BoLULz8qgtRPP6qC1A8/edNc39+10mknfIIt";
  b += "gWfqmN3zjDX4z6We2o6XpF35831+8rpkMiEx60j/90Fc/P95MlouszhlN+p008buDfyGo/cz1XX";
  b += "GEx5Y4xuOeOMFjLL5EyNquyJpSZG1TZDE7lyiyE0V2rMiOFNkDQu1yIbJPaOu/GJL6hKR+IWlAS";
  b += "FouKLcrlFMK5TaFkklarkgaUCT1K5L6FElL0q9v+/pn7WayQmhbnP7wvUe+4DaTS4XIReme+x97";
  b += "02ubyWVCbXf6lY/+8MTvNpPLfy5JLldkDyiy+xXZfRcpycuE2suFyBVC26W/VEkuTHd95Z0zWzN";
  b += "JLkjv/Zs37jQzSXalH/uDT7/byiQZpp/8r7/a5/5KknMkWU8f+fBP3uJnkjTTx/7lpw/ck0myke";
  b += "5947l/ym3SSh/55x9sH3sKSrJ30BqDexu07oFXG7S2wJkNWneh5CpyFytyFylyuxW5CxW5CxS5X";
  b += "YrcUEt5UNceLFMlSiH3FJPbmehpJvqF4txfIs79ZeLc72Tn/vOqvzc9/OXv7RnP1L8sfeCPfvKz";
  b += "8Uz9S9NPf+SBx4xM/T3p0U/+9bT1FFT/ElH/YlH/IlF/t6h/oSJ3gSK3S5EbKnLrilxTkdtQ5Fp";
  b += "aykq4SqZKlBev/m5R/yJR/2JR/5JfSI30gxN7fmAVaqT3v+FLX3YKNdLJL3/iW26hRvrHN337Q/";
  b += "5TUP0LRf0LRP1dov5Q1F9X5JqK3IYi11Lk9ipylylylypye7SUlXCVTJUoL179oai/S9S/QNS/8";
  b += "BdSjX7pPT85/NpCNfq97X93+HcL1ejsF7ZPvq5Qjf7d49/66eueguqvi/pNUX9D1G+J+nsVucsU";
  b += "uUsVuT2K3CWK3MWK3EWK3G4tZSVcJVMlyotXvyXqb4j6TVF//RdS9//obZMfGivU/X/3nnfu31q";
  b += "o+7/46fcNFqr+f/3Snnebv6r6nypV//1vOflRq1D1H/rE2XNWoep/9Ot/9R2nUPW/+e2nHnR/Vf";
  b += "U/Var+499+3z6vUPV/5C37PuAXqv6/+OM/+MN7ClX//V+bffNrf1X1P1Wq/nd/8fG3/G6h6v/c0";
  b += "e/MFKv+c2/9iz8eK1T9733vX31k7FdV/1Ol6n/w2Oe2by1U/Xu2nz5YrPrv/+6h6YlC3X9u5v33";
  b += "/aruf8rU/W99/Zs/bxbq/qkT3/ihWaj7j37/3R+2CnX/B3/yiT+1f1X3P1Xq/g88eG62OBD92eP";
  b += "//J/Fbv8Xdv7oZLHb/6Nv/u1h71d1/1Ol7v/+/R/b4xfq/h98+i2f8gt1/85z7/6zewp1/9S23d";
  b += "++51d1/1Ol7v/p4/91P7Xke3Td/92vHX4PNf2W6rr/x3/37R+/rpks03X/v//wUx+gpl/vxcjaE";
  b += "lk3RNamyLp+Eep/Im+6TKjtFSJ7hLalgzy16jZjNzIjrxl7USMqNeNSZEXlZlx+AnLHIr8Z+0xq";
  b += "FDTjgGmPKs24wsxE1WZcjWqxWbUqoKSJqeXmSsNIGmnPFhLU5GP2pjTYspmCwd38RqGeuzdvHrQ";
  b += "MkpvTjK2qUalUIgPTrX308AatHnr4g1Y3PYJBK6RHadCq0qM8aAX0qAxaDj2qgGGn02ZzhVF5y9";
  b += "VW/4Qzjgnv8mjirDCsGy7+f2Suso0kfn7NQChIkufXTITC5JLn16woji4ZS1ZE8S01sqUouaXmE";
  b += "NqukRpJdLWxDIK92uwhTTpR/EwiyUnNlDLxtHh4S+KRQshkndSguGhqb4QIh96DZmqku8zwS/4y";
  b += "ypo809pjqrxJMe8Ri/MmWd59SLbHbLYBuOSZ1qylAFxSBHDGZgCXZACOItms1QYgPWfjdbd+JTM";
  b += "7a8tzO7G4/5PRiuGJsdduHf7E2w+fccaHJ9/9+emD1higJt7h2BdBHk6C1Hg2CdKJzPCSZUKpDs";
  b += "5aEqyaFXo7C3xRMHqYYiqc208nfgNZKdofTR9/3N6UmOG1OZBrcyDX5kAij5NSFEVEzkqSdkIGs";
  b += "7tMnx8NmvQ7bYbHiKcSPp6xkzKFyht7k0q6cmPNI7yVmpEacaVaqkSV1NyE9Q0I3MzRNfqrVwN8";
  b += "Gt8UNxAjgKFxUBN7SMELIsyVlpGEkUePZhJENQLWTLpgpybZelKLakiwgCh2mpymFgVROBJ1RcH";
  b += "IZsqBlLVowQjF1kY2EyKPdERF1kwZXYNcE7U560QYEVRJj3zusJH2pafoET5uG5V0JyL604NZxJ";
  b += "nPcoptWcQ0IgbTE5/VESc+QxFD6Y4sYhci1qSzn1ERxPfK9OSP6e099EaSqd7IOoJoiZwtCbWKP";
  b += "WaZHko9wpwZ1RRP5HnAkwmeKiwWwKikl2+smQpUhUA1YWyIN8nBQJkVUeNKssCkHlXIkVVIb2a6";
  b += "6nkooFg/YsJwIPsba2Y6QXFjwMsgm0KSKVbCb8HNkRcFBMIj/OSzKukE2ZrZG3tgzItcslwKlFj";
  b += "xpapbiUrpRJPMS2yR6CLztjfFMBoztZ8HQcTmsBHHVacSBemjlNDfRG5SxYpRbLCM4fJ4FI8l7B";
  b += "+0KehoKkHZl2DeL9V5viBIbQkzDWEhAfgPiDeH5OdDjn61UlDhu6FQs02hEMa8lBJQhcIjUSRej";
  b += "dx1FO9NTGiwpDRIAdJexNorAWsJ2iuJ41tJLiwJWWck1S76M6PwxhqaTU8kW5R7JV+7Vb75l1+e";
  b += "jO0K7KMo2fDnlSzlgWyJ95AqVRMQVRmBBwxzKYeQMjwgXqmKKN9IFVX5iQUKfyUCtdoEmn355Qm";
  b += "UCmQuwnf/3CJ00GA4Y4PTMsSoqj16ycRYhhi7IMYuJEWAmlkH4Mh2uE1VSanqg6NSqr+oj+GIUx";
  b += "q0jvsUf9Cbk5SiUouSdudJz0PKJ/w5SSkqtSnpIq4Dpf6q43k+SBaTy1tM/qqKqspQJIyh3SYox";
  b += "tCSExBjaJQxKuoC0/OAF/fgedyPl1KZW0ZCXBb3RtUOXrMiHhvOUvnPJ/KWBLDvybSwoMjU3Mje";
  b += "FfVHalLlVkVd24/KE7GpeRNxWNWVbJ2TOFzJEnux117BphOvvpg6lpP9t6tZNqd+rvDmVnaLRGy";
  b += "M4cJ1nQXDqsIdpgF1tqpxHXXZUvyReBtSnzU6aKb0pDWjZf1corkeN8iH0HtDi7xRFHlDRN6AyK";
  b += "ttIj/o/Y+KvHqRIu++aJE7EHmDa6C+1Nkc91VIrz34I7H1Q+LUw+og8fLPJfFG3C8S79cS7+cGp";
  b += "ZJ4v0i8v5ORU8n+ZRp5dR6JL7xoiXuQeL+SOFUmJPH+aAn+2IGRxN2O3idrs+lWGrfZnozU++Oq";
  b += "SP3JuxbC+b/RtUjH5mIlH2TuhSRvsuR7I/umWpk6+b1NilvbvN4gAai22ACFBnQ72o96kWXZhZv";
  b += "T1PqYTzWNNtU0FDFz+19V1f9aTqHllLMPlVqVFdnHLe4+tHj6oLpId7zwTdTXB/X1/zK7X/1tyo";
  b += "t+UR2hPrROSgpUX94R0sp0MAZE8lwS9eFPq670i+8CNbgLpHpCJNcQskWxCqn4XGRPKPzf1RMKq";
  b += "VFJ/PyfWk34+z+sNBmR4LaWqTqYkJOnZVtVsqWk1LCqqTYbBesFaZOxmLCPOh4BSz6GCgIWtDKF";
  b += "m0nfXkd5k3lZz6tRU8CKlhHgqBeZIVGATyewucJLGYGlEVAjtwbm1hhG+jQqFcgL24I+SL6INrm";
  b += "s18hSo96NtToJwmqmayMPwzpVIEvXUQKSRS9Mz6L09LUXX2EAyyLWZT1dCyjSgyQPQcWMM9Pn9P";
  b += "ysap2nZ6mdni6T5joPFTSK/Z+5n/sv/Ll64c8t3VYqG/N2aSObqDwz2/lbX1sXjThCy5p4fbqJw";
  b += "cVlMrhoDfJI3nS5ucJoCN9Tn/mFdOyo8Qc3V9Vd52reG6lC3HXVCSFnPoBO3cCT6SVb//t6yejU";
  b += "VX9xnbqBOIT4Bor94oFchAMQYQgRhugXU77l7MiWYwBh+VOgfzzw84oyG7xZDhHaqqZanotwOUS";
  b += "4HCJczoPH1APNe6HPZRAtJZUyFItiufg2udLqnbAxLD/jjSbuxQ3Ly3B8lA3Hx9lwfILh+ChKxq";
  b += "IIg/ERxuQdPfzuRtEzrWrk8gh4VBwBf4g+ktONshHwkN67C4PfbnrQLAx+u6h+D5jyPGbx4Hf0Z";
  b += "Aa/XdJsNtLtpgfMeUa6kS4f7FaD2py+OKjtRu5KIgOD2g9TTZbudpsKqGpY2XGZJ57KIzUWMEal";
  b += "0C4uyRgS50jv4UmbuIxY3nDHRmAWioQnRQL9lULLIvKYUCBVziQC0CB9TMqGx8MH8oErLgdtL5L";
  b += "1A1FAJrktIVXs/O5Je1KZJbQmMeNbkcjskKiQJI4I5D2wZC8dFxNW7bGK9FlUeyfKYClIBAfG+J";
  b += "pmUk5LzyW7ISE+7KF2H2EbbhsFVaaHsaH00KcPG9J0AoIsH7W4IDb2JyYGfIvC4yqYux1l3XTw9";
  b += "hPxQc1slR48S/re81S59bbUfZk4VXrWWOZwRKpxLlUCPZkkItE4SqKoKM38o/rEzqSzFMF0QY5x";
  b += "BoVgsAyZf4jbRPAhk1wWtXzIHdT1/EmdRVLH/EkdEmggTs+flOmvivmTOhrwaFCWhUEUWbJ/br9";
  b += "X8/Z7JWu/l9va7+Wo3NZ+L1PbqtLafi9L+71MLexyW/sdbVhqv1fbpk8mP982fXLuaNv0yamjbd";
  b += "Mnx462TZ/MHO3cSqm3tTYaN2aFqdreZRCnoXsM5bk9hnKFRXIjt8+4+hNI9bzHUFctCBctiIfRM";
  b += "i3h76ImTdilZD0GscGLmDThYT091+AiqibzZightSeqcdkCxKm0jvDnH1pqt2gsiZ5ZMAgdzXVn";
  b += "lNW383ypzvMFQXY0cwf4609u6qRIX2xqwIXaN1K1b01GpFnptbzyrUGONSiwhnoLA62qxjiMjsr";
  b += "hxHt2shDyjpzRw1gMEHmjkT3Sm5R5dqWCDGW0XVxMvzxiE4LjVlt1wVE8kN2t65ZBaxeF0vP2nK";
  b += "QUxQPZi/KknSsheaEeUKgQUHCBAkDBLlUN8TC1BDHovVh8CvWwGHhcwvMRO16C5y437lHuh4ew2";
  b += "WiXxb0XaDrUYOaGHtOAYOMA7lo+U3YqSjfVTF3Y2DmwplAIb4RbrEVL8cfjEwTL4Q75E46YA95F";
  b += "DJr3c4mhXh86YH0yWlWVIQ8e2mgb7hjgYRAkkeKgHGdhwKpeHLCqssN0ModZjapI02gZsKqSCOo";
  b += "j1LrLfWY1asDHVMnHVNt85gD3JJNay4BVZrQt/mtxy3hVda7/qlaYQh6vcjGk8RCGw/ujPh4LiX";
  b += "rwR4IbkGGpARa7iNwikXddpMhRaMvo1Dn06L2ptpAHwaiPS2+j3AleOM8wYi0ekGHEAa2YAShmu";
  b += "VLMgChmAIrpm6uY8/b/qGL62hSzfH7FLLpoxfhQzAA3mPsxaN5P/Y1oCf50cfA6FocF/53iUBT9";
  b += "AI/9zSkTyy+uTBy3fqll4gKi775o0ZeyMoFpiSZE30eVdx9X3uzVAnFnbaIPf17RU+kT0de06Gt";
  b += "a9HV2qCz6mrb6eqvoD5gtonfmir7RLvqBOaJ3RqJGi+gH5rf61iHYXPT1uc0pdKMuVvyVrMrFJA";
  b += "3EjxEyDKIbMojerwbRWRXFVk79ybVyak+6lUNim6eVM8+X6jxf5mnlgHeMmE0f1a2c2vwjZnCt6";
  b += "YGj8w7SDVx4DK/vwp9rT+Lz/0DrK1oWlWFpZPIVtKlqLW3BWutITFtDpMQNkcJiIvsiFhNJeRJD";
  b += "sdoM5YA5x1Lczpbizmsp7ryW4l6MpVjFBS8ddeA+CR2UdB8G5bTDAiJuwR6zqFVQwt9/qw9z0a7";
  b += "wcXNT3TJMrxJVbqy5vJKGwNmYJcbgOw+sk5twVdvCluWzVV7MZKkx+7I0LU1emqM45n5cPlofyN";
  b += "C9jNFT+lEKRmXMjAYyEI8hBW6kuEJZmaxnnQzjyMB9upZgl9kpc1AN4JdVPr3qK1rI7R8bDdhqZ";
  b += "DI6fCijV1a6wNi5iRXBn8sG87Ay+Gih7JPGKvlgebkwWO6mM54MliPTDp3py71WMrEEI4A7LF6Y";
  b += "GznpMQOjYwewHgeLjy0JYqpwpXVn4vJ8jIlJtA3k0y/D4/nJ5ePJyr2JhZe7klURvV6B0TdoyRq";
  b += "JVkrYx1TXBuuWZGW0ajy5ci9qIXMkupK/8qzYBuue5ErkXk0frWhldNl4soaCJXx6QXIV8l29F9";
  b += "3E0kh0tUAlgQHHGnmrwiBGotXyhrEQf4RqJKroFIKxZDUQXM0IroxWjidrGcFVwLWOqaRUv52sA";
  b += "a5r6D0kCNE1Aq+LenaEeZ28LRDMa+VtIdWS1RHqz9dGsNC6MpIRc7VisNZCyKSZXA1K1jElq0HJ";
  b += "NYqSK8eTa5mSNSBqPTNJOV6YrAVRG+i9GwMrGwTxIurvEInr5W2xkHitvC0REhX5PUTdwhEqrlU";
  b += "isREtYEK7RiAnJnSdIlSo7CIOFa3bzGQdaL2Wab0atK5nWldHVwlBoJXIHmRa14LsIdYGZX5Jcg";
  b += "3Ivo5lRBK6TohZSpZPTAzJ2zJhYlDeeoUJxWCfMKEY7McqES3nrmgJ/S6IFjMri6BqYeVaxUrGx";
  b += "yISjeJmykyuBTcbmJt14GaQubka3AwpblYLyeCGGHsac3MNGLueDYvgvCxZD8aeznKujURP11KG";
  b += "gKPr5W1A2HyavC0XNpUIImFTiSAWNpUIEuKtHy2vOjPYR7+Lol76XRwtY2aX5sxu6MzsUvDr7U8";
  b += "2gNlBZvZaMDvEzK4Ds9cxs1dHa4RDMLtaOASzVwpztWg9+H7GXnhMd39yObheRW8ummqrtAI9yO";
  b += "AZ8uaJDJ6u1ckyuF6rk2XwNK1OloGSyCUiAyWRFSSDJJdBzDKIWAbL6XcptUQhiZ5cEoOdJdGjh";
  b += "LEB7K9SkrgKPksksUbk4xP7V4t8KsS+soAqsa8soBZdDklcxnolbi/TWmVun6adDnOb6Zi5zXTM";
  b += "3GY6LhXc46XE7Yqc20uY237mFtrvYe0vJZGDZ7KBxBOeV3UotdraN4DLyxTDa4R3MLxWePeJS2L";
  b += "4KmZ4PRgeZIYvB8NXsi1XtYPWBXZQO1rm6yqtfeZrpdY387VK67sRXYoC63GBTeboUhzm8twPXa";
  b += "Y48tpd0QbwoNlZq9m5Jlqn2VkPdq5kdi4HO1eJf8zoXCxUX6mrjiLV/S1ULyeC+0bYqOEre5n2Z";
  b += "Ux7NSt/1VZ6awWSQezanNhrNLHrc2Iv18R2FWha0EKT30ITKZ/EpPx3nW2jgYqGqCEHmFRaqalq";
  b += "gkDKNZqU9dG1mpTLNSn1AsZGC0a07ZaOsOKbhNxnXFRvEGEtuCqMDojWa0SXA9HlXB4I3uXaL1S";
  b += "Bq6IgNUaAogWSibwWHItJKZvhBx2s0V1lB0PWLCbkqel/xJQ5+BlTVgY/jOeiQesQnj2D1kE8B3";
  b += "iO0MHGpYfwXCJbc7CvDTt5sM8Ny98xEb3blMXIu/AMeN+WE13xTGuHyQ1IahHx9COfz7lMrf+YM";
  b += "W6qqU/UAMUCQd2dHcxa19g7RV/CpgJBAGRN8THOETbDAzYw0J+rVlRhFLJEfz5mXegPsy8Wzx5O";
  b += "OtQFSSMKLd+UWKO8xvgY7wdz76aeCrXPV2LT1t1xaZ6xVzv9pr0x8dFjRvseWQREU/r7pNLylqi";
  b += "0mTpDPODg38hdoyJlvnR72jLGPsoRYfYVno8TnkonPEFTppAIj7+ZoDGeShuedhycCRtOKsBRYQ";
  b += "zvIgzVThiqjKEKDJXNBMvmachMwhWe7WpDwHl4rAEIqoqJx62NSa0TipBR1ICiulkvbawVmGiHz";
  b += "xlkEJXg10QVBN3rBL1bdY8Iem0zwSIGPMUAiPfagXN6Xq0E4J7WAIF3O4HvYfAuwHubCRoT7yri";
  b += "22FzYsJLfT2C7YrkCXK9E+Q+6coBsruZYBHhdSIcRFvtgDltHKDDRYB5+TV1UlZLaV1JD2/QWiF";
  b += "lPZLlin2y3aiHHrz3kLevhARvn9kcNoZsXg2UB3dlQTx2mKrQRlJmd+gyG85XZKnfQ9xLUgqssh";
  b += "VcxIc6PmyND3R8kMXDb+0wh+y7SHDosVJRjW0eT5h0RnCabhqmx748o3pzujxLUY5tRalAP4Vkx";
  b += "71IYVPf7Mi8m3q+4Zu8cBs6aTss7Lb8DPXZJkx06sLRxGxd1REZ6X+YhDt8S5BYaRBOebGddkuA";
  b += "BCIBVzyPeiWCRtnfu4TPaTZH0/OPv66ZvmZTuhW+mr6M9EbGc6mXbJAMBYKVGiutqW3DN9YcghU";
  b += "QXiudtAhvujwmpWOYxd/IC9zIbtPg7pcmxig4IRDmltH0mU2yjpQ+j/L4C2wnPTv5CZn2t9la8e";
  b += "fAsKwoCCe9LUw0R/LyCTt8axB+2gfdIzwhZ4EHD8M4fuxFdkyGxHAkbMfYlEXC71auEFkwPdd/d";
  b += "+ps0oXevrkXH3pj9KdNQhnZN9Z4i2waCvNKYq9rRsbGXiUK6wYIY9u24YTMPLXvTry7EyO1MVOs";
  b += "NDLxarBONTV93pLY6bbXK1YN5TKJyPTReyky4SFPesWWWz4MOaiijJHuxyPrNZsGgQdDAIAUfoN";
  b += "UEj5K/GKvHKtk+7bh59bstprBgCBYXYlxY61Mec56L2sVuUhT68MOf+IiKYaWjOwThpdRdkcSpx";
  b += "fHVcNaesmMDU7Ng0uAkxBx4U99CD18AwZiRGYj2ABEn2Mesgi/z6DCez1FNVVcphp1SZGJKkFvS";
  b += "/gWoPG2bALBiQfhOXOFh4IkwnMgPHqF8BzIUISn1EMS9IoSBA1CKzgj4ODRLZBkk+5tDOncs0kQ";
  b += "wAZXWju3DccsYq32gCj2SfFbEn+TWrIScO2HZUdUEzLKyI15fgdUwfZEwa48fJBqgyoqLk3SK17";
  b += "sHK+n8VpFvH6K4SLgZWPD0HsQ24KXMCi85AC49gBe3q6ORq0nDxDD1jUI6ClvAyfOtVV5Ld88/l";
  b += "bhjxjKs6lEwboiZzOXNIfICaAzZWybYEL2XGuLyRcaqDpszqwtjPRoPQ8UjlLIG9mUuL2wIaweZ";
  b += "nPLrczhkqW1ZIgHYF2OPg8DZE7BCskayArVMKO2REOr32YT5G/svThiO++n93LpO0Whu2yeELrH";
  b += "QncgdE+ETv1lJXQn5v0YrOysNDsthTpXthZpzZwzkK2ZpJTP00zvEKY31qRSY7kSO+TwjVFyNmC";
  b += "xqVy+dli82Xxy0qFg+CcOaqiVloMGCjc5yhW8VzFVD/i7iX56DxK3mVDVuRvKR/w0igQXe/J9g3";
  b += "jNadyFqsBIz5K8YngN6OsH3k1U5nGAPfSGmWGk3CdeCL7EGKk5WLVkhLNothrhZ/wowCn0hgIZv";
  b += "sutOaoAcz7K5An2fbBsHKxgK6TZEgOckY+ZIzNHjZHzFiQ3ccOFcRQAcMUi2XlRMnGAkFXJIKG1";
  b += "A+ulL+SJRMZJaTR9eTNmuYgifY6P/FGSXyStAFbCSG/io2CV0QWEcXItXZFqpKpr6Zqupesp8wu";
  b += "IDYHYGE1CuKvGICinz+RQ0FGsRrVmMwqbowm1ocg80GtMTTJFBwiqGm63hqsQhEhH8KIQo21Rdb";
  b += "TZpCwk7snJSZO6UQQIhH6fCvQq6+y9w3FXVOZTC1ZZj9w7PMTLvbrokfJJEefvVQ7k3L3KW5zlA";
  b += "HW8KDUUkzpgGqaxM8DQtUdCw2RkhMYS+hiktRIeo0qacB4/9cMPuVyL6hJqoISSzRoF/1gsofBD";
  b += "BpdQI3eLhqpGIyNzi0ZFiiaG0vP6Fg8DJbSkrltw5FgMaBK3MJDEmXaoxVANLPIx9ObKmw+okTH";
  b += "K4zfigjxd4fmRy0ZBDrg5yh0/beo3abPfiTDq9U96NelwGXCOjmLfIG8mrXpDdYbQLJOK0L+JW0";
  b += "Jcp7hSp7RWfw5JJasBqbHSjC14YDbFqg/52MqylJ+hJHABCNloum3WrJPXKCE9fG7icYpUs6Jcb";
  b += "yKwIFWVUde5kj+o6EqNHSGByfyzHWnvnVU7QttOgUc+uw0YE++xW0A7r6gqRZXmyG2GP7KqTiUD";
  b += "KHRvz5jdLswCh+JUXJBKzEnR/k1VWhCSN8RsPomF3thorcxoLTJaDc9GYy2zXaPddi22XYttl6/";
  b += "/sLTtWsp2DfSpDLFdS9uuIQ+u5xUiC4Q/vnzQeogFOH8hZVIGranXI4wGFmn09Xn8Ng5v5/hdhT";
  b += "TbObyTw9OFNDs5vJvD+wppdnN4D4cPFNLs4fBDHD5USPMQhw9yeKaQ5iCHH+bwbCHNw4X4Ixw+w";
  b += "uFjhfBRDh/l8IlC+DiHj3P4VCF8ksMnOXymED7N4dMcPlcIn+XwWQ6fL4Qf4fAjHJ68Lw8/KnLm";
  b += "8BTHb7uP5X9fHr+Nw9s5flchzXYO7+TwdCHNTg7v5vC+QprdHN7D4QOFNHs4/BCHDxXSPMThgxy";
  b += "eKaQ5yOGHOTxbSPMwh49w+FghzREOH+XwiUKaoxw+zuFThTTHOXySw2cKaU5y+DSHzxXSnObwWQ";
  b += "6fL6Q5K3Lm8OS2PM0jhfhH7xtGJWnrLrKqJH1dSQZ5LSzunlx7UoZ/M3QtbKMWDuDeqRYuN7VDR";
  b += "L2R18LtCFyNAH1RD7UweW40GefWwhXprmctv+ei3fZzuN4KLy1YQWgr25ZbFRlKOGUTNMRhYMQM";
  b += "/956cscLrDF6eL0FBZaizk1dHq9FW/mQ2Qy/4sgpVfR5GbWPvm6gaein/0VPXkWbftOmBurrZ4z";
  b += "wOXFQ7eZV6H1Y9c5uFsySKJzqQsyQm4QLwy3+9UYPb+Z4XFZlm+EHPF6wRKGDnlT7qIwJJ1YZXW";
  b += "/ssTDETUXFEqrod5oa4C9D0kMmaluEHjYTHjkgnzIDZ0I0/dAiosKK5J5Efe6lM2ZzFdW51P7ZZ";
  b += "ncE52XgAqzsagfXADjyyDuK4IasnZ2BuS3ArHZgdQVsuhXYnlZgdwowjCbfVEMvALDsdli1imCK";
  b += "Sx0pcVoocTrlBiUHWik52JktuwWY2w6sqoDNtAI70hmY1QLMawdWUcCOtQI73gZMzJkBGhlArAP";
  b += "x2wGSOXdhUiOm596YKt30FJ/qBUi2GteG7RIuHT/TGn9Ox+9ojT+m4w+0xEfeKtLwkH3KkvAMhW";
  b += "dUeAeFz6nwAQofUzaO0UpqxHYBmIZ6bA7UY5TjgFVdoFUfVCRZeJ57h+QT5pbmoL0s6pLo6ZIY5";
  b += "iUx1CWxm0viblUSd1kYsKekhiqVqJjUc0Y9j6nnKfU8p56TNvqZoJJ+d5HqbrmQdzpma/f0RZsc";
  b += "UOmmWofNcJFfD0xckuj5AXoHDPaHbhLcWFtE5V/MYRpD49RomEF18FFbeQZlQsiwyxX7ubFWV0b";
  b += "1oCcBEb9opSj+Q+aQPW2R2xMMBxjDcWCoCIbGfBhqolfBcODCGEjBCxWGGcbwTWBoCIb6fBiqYr";
  b += "+CYebCGGZgQvogiO8X6K+1Qn9rBj2sVhRJx5iknyCTL5mq85FUliIiJB27MEnHrExxpxjD5H05h";
  b += "sp8GEpSmAXDqQtjOGWRegTDOcbwe8BQFgzl+TAEUvwFw7kLYzhnkXoEw6QNDG+6Lze+0nwYfAxq";
  b += "2QrDpH1BDJO2cvvTFjZR3oypPq4dzLimTf3hDNsODUxMugCMrHjI3mFrM8ZMEoNQtgwQ9N7AImZ";
  b += "e1cm78Kc1uANzwB0gcNO2dskzVlLhDr3yi5lBFrPMUBaqfKo1kzF/fy7mqlvhT8r82z6JLVKRJ7";
  b += "8UYAe49tqZrRWxHSNsM7a2r6Sh+FVGxiKzKpnLzYypCOIUgThma08FI0pqwqXoKrOPJCxmO0fZD";
  b += "pliE1Q/WdoogFO56fM8LKnMEfGVqHYjn6uhXDuTtsvsKMv0vNGRZMzIzacuyH6XmbN1T67FfUzq";
  b += "LhvoqdfPRFKD1ka9sNKasuMGntvsGCRNmR0Fnp4RksJ2DUyZuUxexmVuJdXrJHuyr8aNAA0dKnl";
  b += "AP8rNaNVXxKQoARagxsoo+bV+I29k3CHZ7byC5El8E1POBYOmv3KxpKoieJ736tVEu1S8ZFiKy/";
  b += "95dfAH20/+6VT2qSoGmX86ln2qSKHIP81kn8pSAPNPB7JPvqrENnP8tMSnPMuv6nOsj+2hqvvNF";
  b += "tfNR9m57GtxHOkJ8Titkac5cqo18hxHijVliqvx6g5ujz1sSlvgkFLiPnMIK0A4vIvCx1R4isIn";
  b += "VfieIesMGiOPMuwzrbBxoyjaF7iSE88GdazxLFGHGU/cHCotJftlQ9YjMjmA1RBwGtL/0WUvPcZ";
  b += "LOrBniQSEeg3bX3eQzL4trSUuZ9OOfCWD68oaz+xOMFuhDKbq//eDHZpf7T0jdswzymhza84NWd";
  b += "twJbfJjkr/S7Og9HNWB6W3+QNReltJFaW3eefK/EqnkpspnTxHpnQq3ZnSybsUtd7mfrTW0SGbR";
  b += "9vkh1jdamaY9Wnm+pQzrGpGZxMw52q7IlZjiK/q0Unl4GRHjlHGuDOJOAh/7Mdmq84A8JSNCf1/";
  b += "6rOq0gs/F+heeN+Fe+FoyfbpJm2/7nFPOmwkk05Lj3ugY4/7B8TbuXu5x+0rnxl1tKufo8eNnhq";
  b += "kgA4cqFI2yj22SUf32LY53GMz0pn7Ch0sn1sHEOUp6bFNOqo3kywYsk63QvztXC6AXLcN04Kvbw";
  b += "fJNd6+oCka3u0QT+gF2oaKDhGN24RLLdGs4O3Y86yj0XLa5lC9Fsylo5UGqyMNs0JDjn1WsOd4j";
  b += "xHSOehmW9HdKahIvxZ3aNiy7U4IIWWuyfLMzbm0Oh1pnfKQZRuElR4XE38COG5HOCcJTkcI2h6M";
  b += "zB4q3IOfC2QBd7ir0YK9MLT0jK90I0pS63IkPmxmOm2J72lmJpDFz2o4s61wZjWc2VY4sxrObAs";
  b += "crr6CIfuML+FZCs/6RdONUX+ctZoi1VwWuzjqZBaF3rXozFduAs0PV9UF7cXcnq8rbj5xV/ygL0";
  b += "X0gM+Hu3HX+pAvz6kgo51Hg8gEeD93Xa1e5O3u3AuflRah3wz/71w/NRtoR/WZAJOjHfre1PP2V";
  b += "c+bO96ARB1v8q+NrId4yG/tePvSfxMzQgbp+0w60n875Ku+zyFRbqnY6ZmksnTIl25VubW3Lc6w";
  b += "APZtGVgcpKFXNOadZ18q37kZan5ucgHMxGo1zwAmVYwLEBdkcVHAoTM+95WqHXrWPttJAfVbNWp";
  b += "PmY90a1iEdeSdRZFyJa/fmvdBV5tcDoPLfklVbASqHvlxWC1nSyLzvq646wuBc5ULKICrEbguEp";
  b += "8oeCpo7dz6YvCdFAzvPxUoBU8FnRU8FahidAhz8tSrDZSHzHu0CsUu7ePFVor9i0M+9WmCgqWWp";
  b += "VlPpULZzHstXZ3BnQWqYskUeyhQdUoWc0BXJ3MrE2lmZBWU+JnM7WQ1lPillvigmfmxojua9QGW";
  b += "ujU15TG04WZUc3djDtUn5lB9bD6qZ4O8hvG5i6RrN239ud/UDJxpZWBWM3BmDgNnfGBQTbNCdx7";
  b += "VgTr8Rtl0HlnLLTOPZAPjkdy8p6wqplN252oE8Z2qEcR3qkaygYK2amTG7lyNzNgXrEak3SPVCF";
  b += "pQ1G0LYpb07kBK1a5A9aODmPuJ24O43lLBHJtbwaj2rIx0HA20DKgI6CEBVe9gYWexZKoiJ73IQ";
  b += "Hlk6UXC10qHIujUi4Q7nuZSLJIGozKWkEWGeeSBLLInj5xx8vHzLHI2iyxkh41ji6MWr/6AnsBO";
  b += "LDuqU4/AkR7Ddke6JVOOVILbHGlxTjqqK2IPWbtUeIbChxAOB62TjvQrT2Dh4CmmgmSeSRubFg7";
  b += "A3R101bhc/on6JdtkGTfLtMTlsq+ZVbTUu2H9lFiaUUmGCrd53EXR3j58rydftRef7VDLzHaoZW";
  b += "bnrWVmUcuUdY+Vi7LVubnR3kVwOuv9L82C3vNyXdB77gQKes89RkHvs34Hvc+2Zj/mtHpM1jn1F";
  b += "HYoHbOuq/PrmhxNpmvymqLrstLxyUzHWZPtQKbb42265ZFTpTwzVx73L0s1o7O+zbmqrYiJqP5l";
  b += "n04qHUtHupmqf+nP0788F6B/ef/C4i5gewXWpMku4L+01BVElgQJEy5yShw8tpuJG9nYBXwpHs9";
  b += "PLsOGn8TCy10Jb95dVdgFnG0BMpHgluRybMa7QvYFj0RXZLuAbewCvgK5r1QbiS6VDcEBPr0gWY";
  b += "N8V/HmpCDb2IWzxqxs36/aCXWl3qqGMyX0/ltGMJZcCQRXMYIr9IbgIFoDXGuZShu7gHlb7jreF";
  b += "uVl+35DGEa277dLMF+tt2/Vsd2spjaJlfNtWVe1bMvShEyaCe88Xqv2I6sNwaDkCtkQ7EWrQdS1";
  b += "zKSNXcDZ/tuFBF9vi+3GmF6273eRkHiN3vXGJK7Te4L5FGXZ01XH/l8iNMx3s61t2a4c8u47pnW";
  b += "bmfDO3muY1qv0huCAyF4jBIHWK2RjbTm6GmTLhmAbu4DX6b2nCwr7fnuiCpgY1BvcmIkN+ZbSIG";
  b += "OwV5i4Vm8qrEdLtJxD3v/bhf2/xEp3vpHwmnxrpPDRzVsjmZspM7lGb6+2orV6Q3BAjKntoODmS";
  b += "iEZ3FyhNwSvA2OyIdjGLmDeVHs9yznf97ukZd9vv7B5nd4TzGwO6Z2GzOag3i/KbG7Q+0VD7ELU";
  b += "m52xC7GbdyEuwv5DtfdVMbu+M7M9fPLC/oT38MqW52v0huCA+F4jHHrEt9rwCmav1BuC14Fv2RB";
  b += "8Lfh+Ou/7dfYnl4Fr7B50IjfbPbg0cgv7ft2Wfb/LRAZP0+pkGVyn1ckyGNL7YoPCTuhLSAZxLo";
  b += "OIZbCcZTDA+2L7WRJLckls6CyJJUoY66PLhXJIYo1sUgxk5/MGlgTvAx9kSazTFlAh9q/QG4Ivg";
  b += "yQuZb0St5e27PS+Lt8fWy7omLnNdMzcZjoOCu5xBXF7Sc5twtzmu7+XsPZ7SOR6D6orPK/sUGq1";
  b += "ta8Hl5cqhlcL74Hsdb6cGea94GuY4WvB8AZm+DIwfAXbckU7aF1gN2hHy3ytyfenBhkny4SvbE9";
  b += "wHbuba0x5yPt/W3UpDnMg90OXKo7cdlfEG5U1O1drdnhTs7DDe7uvYHYuAztrxD9mdC4Sqq/QVU";
  b += "eR6r4WqgeI4N4RNmr4ymVM+1KmvZKVv0orvdUCyabsSNbErtPEXpsTe5kmNizQ1NVCk9dCUw9OA";
  b += "dP+u8a2UUdFow5AKLdSU9EEmbL1+NJ8Q7KQcpkmpVbAWG/BGBCynhFWfBObGLJzI7xWXGVGZ8oe";
  b += "Y0F0md55XAW8y7RfqABXWUGqjwBFCyS1C9jFLuBAdgHbka13Adtopx3BU+aJ+GLKh9XtlYfU7ZY";
  b += "H1S2NB0zZWvGQuu1yn7oTd4+65XJa3dbItzeW1O2Nvrq9cVW2C9iefxewrXcB2/PuArbR0raLu4";
  b += "B53T8BDENk4317xxZYiyeW8XHMJjfDuBtg8UbBHl5Wv+v4DWiTS85V1g79Kovup/QrhSc5PPzxn";
  b += "/3ZY1a8FI1AO508Tv1a3kh4rzU8I18QH/F5L7awiYbdLQn592XDP/rE39zrjCe9fDAzRT8/oWqk";
  b += "b/jIx79xvzue9LOqIr7d+QWJtz8ZGE+WS1yfzhrprM9J/P1JrLMmOuuy8eQSCcc6ywqd5dlJsD+";
  b += "5VGe5TGfpI2OV8KU6y0qd5deT0n5qcqosV+gsMbUkJbxKZ1mts9yQlPcna3SWq3QWcu/SoEOa1W";
  b += "TVFLeKWmmcbY2Gsi5LspIKGZ4rEhxQSd72muxTRIVJWkx1PqeixuV1LRe4OpfgdXtVfCLNmVp0N";
  b += "RcYpKxGq/fm8VfpeIqR0i9nHSBlJVq5N4+/QsdTy7VCFD/46SPvd8QTIonyhEjT4LxE6FpOy2cK";
  b += "XL43/7Jibx5/mY4nZ1UhaSqoq1SS7CiKCtqTEe70KcOXNUZyEIRofQ78kgLwqIA00fHkzhqkaYX";
  b += "oUpUk8xMNdklgsYT+QGWkhaPrcuDLC8B7C0j7M46oVUpWqBDFmqM4l1MUwE0JLwT8GaCNrf+3k5";
  b += "CMW6hbGA1o61jFtc4ybVtruOLp0xj65Kwe9H7CHG+vmE3vXqpzB9oi47aSN6DfB9gql+nky+Rz/";
  b += "15q7eTlKtYlQCxYlSB+VPgkIJFImWW0kMXaHS3kmrmbWV5MtQuR32o2Ph88oYUZF4Q8UBDyskK8";
  b += "qxVbQd2ptFFWuB1uUbDWl3CEJ52cJkppxqBiJYgWwh1p05DITNxiihHZBHmmzPy1f1KJenUmJaT";
  b += "+Nv/F/iwXdFTwW8qH1aIGKFMJLtGaKToz5bVEdFSgM2zKp9UFoPJqFhe+bqotlcvAMTdKx/g6wM";
  b += "7CYidyGZtUnVPCQVhRX+HrCu10KP4SVQMjpsYxSSHl8kLKSMfDPRWMis21PhItUxag4XTlYJbux";
  b += "XYuKvqJ1Zt7t/69udfrLXi9NYX4BoxC3GMJESlLCBvAC4BWFTJcWgBU0Z6ujqYCZWZltGWOC5kX";
  b += "qmiK8Ef2R9b+McrEfKpMkAVF4hA5Zm7/GDVml45H3RRY+kxpMWgtRoso5VI+nG/pM6VRoc0hqhY";
  b += "/7ZNPIs9ocfETN02WkSUV4rjZgjcyYI44mEXUJOJQFlEHgc/kFpC6m3vabIYHMWBzSJ+EYOPsPR";
  b += "3MTk2w8Zg25ZSR/IwEBiAtGsAzmxuw6VGeWyMrXf47DzEJBuPfG1utbZ1JPjVBoOTj1hIf6viwN";
  b += "T7Q8dm4ODf4prH60OTW0qnsJmy2wfBNODpg+d30lA30FNisTkKwsXybWlQfDq1ABrbWPsG103Kr";
  b += "RTW71aKW3WpRx60W1ag+RqZQxb0WVAEXLpmuDz+u/i3/zRrf+Hm12ZOYOIEPZ/vVtiYNMIODB1/";
  b += "IjV199YXbm3jpXThVp45D/esRRcjHyckZQ32/R76Hbd8nJ02VYEwSBHMSaAzjksCZk0Bw0CdLfQ";
  b += "qHJ/5v4o8m7uhhymc8u+ZFzvAEDhDrmiLeG/cN2dgRWv/Nmg82FYdy0AWJhj9X8TlIpycigpIeM";
  b += "+5MD+x1m+nfh69IzPSLhtyK5Wyhlx2fP2xA04kIsHEfn5vVNfys+5KuB5IqaThZMJ4sxLMbEpoi";
  b += "T7dgfAwdRZ2hOp7wh8Vj8ZJooYrFkNA4ClGkAY8xywGuA4l7hk3eh22mu4D/atNojqbP2rQ/qT+";
  b += "QLB2eGIsXwqNHmoLGeNJVgJsjZgREynhS7YBlGX1qjMeNCEDiXt4GEHcR0rcrpDgfk9KEkb9fYa";
  b += "IKoh+duXFSA70OtDOKmiiJxqJwDpvL5xKQxGPD5hiOsMIFKOmOvzdGZP3ftl8bqcm1AJOf+OrVO";
  b += "I4jSDEIz3dyjGBHfcBfJAIb691qvZJ6KS9S2P/PjkpDgPhVUiiQp4EltVKbR+lVytMGhXWytMyb";
  b += "40sbkwAR1eySh4e/1nbJw0Nfa7vkYffX2i552P61tkseHj3Rdkf22Sxi6tMMdN+n9VG1DsbBe9T";
  b += "ZTPToaYaHnQvEw3bTY1/VN2s5KSZvpt/oKSZJwHgTNs1K+tAJJuCkJiBaEvXARpdHC+/DsmE5WT";
  b += "QuUQTZ2ljUOxYtG0uSrdQeIbV1IVUjPxZf7Vsn8K+UI5ZwAkdkytnHJtpKfkpt9wpOEcW4AYn7z";
  b += "lHqkEVk02QlY0n4m+SuCOnNNUsdfzpsxjUCWcMWbxgmTiK1GBoZXZmMGpYDoC6AqiNTQ/oS18iY";
  b += "KQGZNlGZVF+Ajdn0spUcxNLfinHs3/JoyVYquFFtLMZ5k0tvISe5EH5wYUTJebSqmU7gEFRAotZ";
  b += "NdWxrvIieC7fGJCCCFS8Y5jsDeXXr0jFiYuEtxOwC8sEEvTr2W7yKGpt6wSvWtDCZi+CjuzQZC3";
  b += "+L3BSh3xpTtU9Cx4cadjHLccrbT2QHrNLb7vxNeHXT8kgM4OVXxi4v46uk50j/6dL01Fe1Vruic";
  b += "CshdFnS9d+ihOA9aZAScRtC1CCHQlyHJCRKWwcPXI+EUfdYtHiMbIJoXhD1bSW3NrA1irZG8VbS";
  b += "xkBE5Twei/rH4sawEWG4vjo2BqlQq418Rg0vy1k8tSikeliLpzFGEV0QD2eJQ5ISH+pEzWtIqSL";
  b += "XTNbHSBxkeWO40xhyR4YQ0SHIHCMSyMtvJfdFEv2tmkkSQ4DYE6jqEApqsDBnOD2Ks5PVLLulhm";
  b += "OZw61o5m79LT6wguzGuoWT9A5vHXsBH5fA01CYYlYh3pJdklNroQFMG1K6alzTyHqiGpDxlT81G";
  b += "EU16gEyigeynhxZ93hU+01OFQ6/YJzYLKK0s5BVRMmzYXJSLpzAWrQd9jcsN190aa3AmToGzp6y";
  b += "hp0hq8pHYMQ2n5QRO7BqbLEnSGexv9vhu7ksQD7NTzKy6p1NbLw8R+8YzgmaJFEr7VOnExTLujR";
  b += "I9PHmOAiawZpy+hEfNnzaboZ7AWm3Ra1wXFQ1+aYZI/yR3POhZhwtXqDb08TRKUiyQ5JQ7btWT+";
  b += "9KkhCj+Ga6sjU2wEgdtQizWGoQWT28j8zCamEBOq3wnjQKeDEfaq20qrj2EIHudJt1ZzN8wBbSh";
  b += "e48+RmHyfTQ4lMEIApeuCWCGomujogsWdB/xmF5aqQKvJBHecK1wB/FTEYfKYwePXBD+Ei/K5rp";
  b += "WU3GcZ6yzaja5zEJVrqexJNJZh+flkKB1SSeTDLWKmvFkL0PTdJtflNghf/qZ/RQZBqFExR6KFB";
  b += "Uhp/GXv4TMgvPkHCAH0fg7DEdARs66cs+/hO+RmWdymELRMoX/ia4O23XQMYRjyVgZyOOnERUG/";
  b += "65KblTI/xKrhOgjrKs+Dz9x5T5x3bYn/GF2AMUmx7Hp/9nZ/hbwJpFsPS9DezpAtgTGdhHAHbXm";
  b += "1vBQnDkb60Ww0EEThRqEef3bdRhuTTmyWZ2znbORpeINWBK4U1PEilSftNH/gjBs7amH0R+2OEL";
  b += "PqlMOIk/ZJ11REfaHu3I527K9x02uQRHhYkNYossykTCNhnezOeg8ZV0X+e03VhDgdJDhQ/FBqc";
  b += "WY0LfBHg5Mp5qJjXZb0nxgs/sVhb/Mw9x52wx9rO26pcJ6ZEyTjFzdkGnbWXnYtpqcYSVPmo3s1";
  b += "KgIyMlHJDCns253jjhSGnc5w2JiHpwqOKwKVAsnN5npYfeNMNtKyttDIqsmFic8GeJvkR0Qo+YO";
  b += "tpf91u6eIPM89qUq83wMS9Tbk/hC6V1w1NWZrAE40/y4g6N/7kud1XxjJDZblfFZUaXLfPjErfN";
  b += "H7Kl9K0hfq83zoG8SepMhA/aUjFEIgQSU08kNIMhPuRDTBxo3mrJ6fpM1s9wgpaYhCk24uB0e4M";
  b += "dlpw7Y8pCDr4gRYo4KddGTqwHCT9oF1Se1wlaOMpkoYnTdlGMh/6Q7HfWyaRCxNzryLEqqygpFG";
  b += "ekuoRkkoAJ8YKRRqXdENJtO6jsXqkyzOBlFvXCjzkXoJ4hqCf89ATFpkuVrFGq0kd0uvQYUZUOK";
  b += "Vc/hW+n/yiHQfh6cjSk8QMIn9uhUvxl3XKkusZdlll1vUKq6755q+uHHamuDzmC46CTVdcJ7HDG";
  b += "aauXed+W1MqJy/nlbhWplw86SgdH2TD7mumJ3yMK/50q3ZXWMyjXET7jLPwehL+yKQnTM0hzqiX";
  b += "b+Twb/ACfSxj+gP3DUfFY07I6kH18oX6a1qUZgLubLfHiGu22igu7u6dbkO+aypCvIOSrc5LPGh";
  b += "r0vilN84zNlX2fruxXpCcMquyn8G0XN09WNolv3TTgGIKTR+GKibYoIYUhKxiSCNuVVgDJcVsKz";
  b += "THl5kgotsg/QltEgdnhNiUSBnOkUM+LiE7ZzazeRWR7vXvCFQM/7oqkTpARn3SFCfKk4T6XHaiQ";
  b += "hhr/fXAtj7iK3vBhvE57ADys1cDutPgW6Dcei0O5DckiSLrp1BtIxO/zVJ3AlQWYHZ7m4Zsha7s";
  b += "q5Ns89jgAFpHJTmavg9aUp+jDph7yWF4z/IHN/UlLrAFkvoHNKsBqNHoeMRN+nzUTe0SiqsDOh4";
  b += "/wvCvXOTNIxiXExIl7JpeJni043PQxe1MabNmMmupufsOXuzdvZtIwk8uEUDf65APE4F+7qnqa1";
  b += "C2raa8wDCjxYTOTXUt8TzOTcLFhOO0N2ZNephqwrXWRRZKawsMuWHmEfx/l32kW9z4v/KQVqxzh";
  b += "TxUkoQ6GEuTl6oCpqBOraonvaWaGVSxwx90h+wCAH2NCyEjFNqFcst7HzU2pcTPJDAHzpldfb+y";
  b += "0FL1MCcqGHX7fygoTRUgdd9DRKmVD3O1KBXdQV3A7XMXDSau9gjuJndmuVHA7reuNfW57BXfczm";
  b += "q4oxwEXjhMruOyklao40DXT3Qld0wV2KN2oZo7bneq5wgW5cMxox77o/CNtjz/CUTpi0xU04saH";
  b += "Ttd8eE7dGF0Io/bXufYkA+YN9Zy9wa9nGBPIM2wFdIMi6QZxtvqTnK2FaoZRnUHOzTl904oL6I6";
  b += "qiuoqtjShOY02a5ubwnXWIGQnn1A1VvAvuv3ULanWqq2g6Z4mva0+5D2RCEtwTxI6Y/aeTpQxTB";
  b += "nW2F2THNIp3lj1SpThUlCcPjAS0J+nWhiLfrI1xt1etxrPd2sSs+Y1CR+ykif0VTrSKlnxJ3mBn";
  b += "Y286nBXEU6crusyceYB7KpusSXzZqxHFZEqckFVeS0bYweYqqFut7P48PQSnyjD1l/UqK3Ct6SC";
  b += "rkirI+NKjcxaFfuY2dwUTUuU9c+5QOVAKcSuTclJRwLishSb1RtysHi6N1Pn9GDPdWIHAdnKI8K";
  b += "+Ujh8X0zI3KzFMgOCmT7bWQHT0T2xlay/Vaygzay/SdHdjDKIm4jOyqrm5MK0xu8mJmvWUoqvUk";
  b += "N48Fu5EcUrkS4JSCCfHF+78aapUYYwUJUC7/oy5iLE9VGk2AjHzxvb1LnpDu4MwuXY2G317ARN9";
  b += "AuddKxTSw4jrFvGDYZFg7oba4zjAeGMQhs5UEzC+IZNbbRvxj3EFRwbVaFb5MjAoKo3IvT7eVia";
  b += "UDE3XaFbLyRn28NrWK4q8r5SiLuCaK7RjqeiNUm/0ApFHS6XCGWEggW9//gGisHV7dW+W66EmKw";
  b += "kWji1RGaF6NJGTH5WGyr4suseNz2TSyUMZ3GKi8phAGpnUflcBUUZXBHhRY5xM+TyFIU3JSUYQk";
  b += "lzKmyJZRwXrpIo41+v0h/vTP9QUa/r+gvXZj+jRegn9f+14VU/79BP0565/PM/I29oxA/ds3VDJ";
  b += "iL3jYIQ6rA0NhxSIoUBU0lqkoCsjRgrxYsrfqkLQ2XITpy9TQsRsyrOr954aa4pCSMoPC1OU8cm";
  b += "7hS7t9aIb4zklHHPnrjU+z5iMVuetRwir0RNYbsAOdnilN9RlMqwoJ7RflLJ8/oq754uz7e3mvz";
  b += "KaWOvPE30nZ64Ex+RZiTzmRvF/i2s2KZEwO8B8DWewBm0NjHhmpnGNOiOEx02Aj/0VLbA+hTkHj";
  b += "0KYs9JbFh4hdjz0lsTxIUYzGRq+AGOVzU3q0gKaIF2g5q8rQA2pEDCnNAM+2AzrUDmm4HNJ0D6i";
  b += "lw2g5o0moDdKAdEOa4V9k3AMbwvdRWv0t/iMh7DEcPoJitsp9ProZlLG3dMRn+nDTHkvIYJN6ad";
  b += "W1TpC6JMc1zy/4xLK1fZb9wDJBWUZNyDHsk1HQ6UpUjj1IpyDsAGfincH0Cx5M9EDljcwhFwb9l";
  b += "P9a3r7JDTMCwahVQqjWAuo6PdykSThHshqhPpQqYQNQ4jIkJnFEE7uhM4DR9DkGjAxrdjEaXaZw";
  b += "jkWMaStwl6lVvC8RI1NtChmzF3SxcK17EalAfF4s61dsSMQr11sMiteKleK6Nl7EO1Lde0bp66+";
  b += "Nh67ifF2IiNJBJcDk+4c5FKQaKa/KdkGDMWrFYlLBz9bXB8iUxN5h/lu85Jd+ZC8r3mJJvtowiC";
  b += "nP5olcpkbWoiqxUIfK32hyzcJVZVPn8OCxNqQFOEmIxWLQwqkcxACg26tDRgnaya6C8q53Mxhhf";
  b += "RR1Fy4WCSIgH2S4Elmm/Grn8KRqyZ0FCPzbW3bIfp9MgVTVaGvWQjEEArp9EXIlsJFpCVIEtRQ7";
  b += "T4Ua9mo6yosODxCLBGPBpeDYWeRMCjxFTnj4lDrhezuNEAwq9gkZghuwTyOogE/wwxfL5e7yuZo";
  b += "raUGKyOEFL4s7jG0/Y8zyKPTwxZJ+xeH3LjIUifsZqhq+FBfPJH/up9ThBPvmYwWNaT+bMTTkbm";
  b += "qry+hJDH1pXKleqtXoj7Fq8YGH3Ih7Qu6447L2WHtv/BQO1q9H7+2eE1vPAwepm+DYvtquLO+bZ";
  b += "c8E8izrmefiCebrRh8GVGoPWczgUcF+LB/6+Kr1WfobcEV0ho9/o5xhNvrqAAKXnCUNqySyVFf4";
  b += "/qwXBQkFgKrAnWmApADtPEwBTAJjtABZ05OrQ6Qtx1dWK9GudkJ64ENLwIgBMfStnew6ARkeq93";
  b += "3rQlTXW5F+qRPSo9+6ANW1jkjPXhBptWOebd++UJ5KxzwPXTBPOTc0MPePnZib+fYFmCt1RHryg";
  b += "kiDjnl2/uuF8vidmbtgHq9jntkL5nFzbVPJQ11pSnHryUJfN9DAZXgh5vXOzBhyX4gqfxCkfb3x";
  b += "bIwxDlq/HlnD0ZD1DHpghRIF18u00GrOsbrJE0RZKRY5Cy3OL8AL7PwOKc+exwvYrdo/2Un7J//";
  b += "5Atq3LqJAHv3OBQCYLSxqZVE/yy6UlPkVxienkJc30yWyWuAJaJk8M59zkPmLPFOLDM/MzwFyUb";
  b += "sUHYbKhytWZcLhTkQXL7hE55p6GZFM72Njyu533iB3ZkW87MBH3M5CHBbZI267jqPwNoQjdQkxG";
  b += "tF2+A6bX1Mz3fPOGSP8Izcp8cHUaqSVL6rGoTZqRJbfcQ6VGrnFO/doEMIVLUmZ4MYlhMOkQhKi";
  b += "v4296XgzruKuDPzR60QT66Z4XZKL8UIn7cYqdayvcbc0wzfYyN/HLO8Km+HXsVW7JJ3zdLIht48";
  b += "R+aWmJNCTliUcfxeXZPUsX7PljvTGkP0UYeTBnwagiYQQZ0sQ2cp8ZeDjZhzkk1Ryxznf0ObJlX";
  b += "NB+izq3af2CEf+WhOLHrkfje61iUEtpuLOJg/MVaPSTVj+CfZK6XFI+A/duB65jNFVl4Bjk2Jqb";
  b += "5FG69TetLEpwRkyFWGyzuAiN/wCloea+NvYK0Oj6QRfqL0lnXi1ut/rWRvlHnYQg0JZg6jr6QQV";
  b += "3NJoUuKUflTaH4c59V2Rtz9ecEEWXM3CzncxCxm91JdXX/bIF+rV11O+OryNR44XHrum9kb+Jly";
  b += "cfF8UPrB3M99XLmsfGxtrYr98lKFmG1vdPcW2yYcRhemRd+X3ve3iu+Sg23/zJdBuFxNNuZu+jp";
  b += "O0dc6OrFoZ4Yqx05nWwElSg75wd413MVqKasocNVXYI4akSakZft7hMSMCyMO4uEGQSgcLQKyeR";
  b += "xYKfASpg0s7gnRrM3XUhfVkir2Ew8KSu67n8UnfbhrepKFImUjqmSgU8C84he/qOs1MbtlX0FBv";
  b += "pQHrBFmrUyxTUkeFtBGm2zJ9GAIqh9vdDE+77GbCb+K5o0smHgCKcj7yTpWTF+K5cjFbKZ/q8dk";
  b += "FqZeA/Y96cdQxblFmA7wF782+uDg3pa7lEeXW6nIRITjJXFtdLiFEXJjHBTouc3F1zGbuCsX7sX";
  b += "tzYdQuGyOC5LcOai7eW7H61Ho3g68NjLBMjO+4SdQ1TdQ7+b3DRloKu1uXzq+01vJlU9c15UIck";
  b += "4oodTxirB47LXd6eUj1QirDZvpMPdoYBzbOwrDzQWp9JR5ukYMlRB75TDQFSTLN1ZTr4xPPqVXk";
  b += "NUHp4JHKGXLYE7/BJlQij63iqukNzyYY5XT5Jp4d4K9b9dea/trAVwvlaYzp8jel3hbyE8/atFk";
  b += "GIXk+ruaiLVXGp6p8Um8V/SbJLIqdnDyCQxTTCb4yk95x32I6TtKgcIjw1nSM0zlUBPh6TaeJ29";
  b += "FimQglQb0MZ1aopQJJvUneisolJsj5/tRR8oKQZtIVUZg8YFQfjdErr+BvYy8WzI/Gi3jaioW/m";
  b += "IKzElxCwWNGpqdcO+lxCfZg18N1cX+27rhO/xfjb6Q36kknbkqWcj0YRAsJ3+JoaS912etU4usb";
  b += "e5tY9sqZnKSXaMO9eRh57o+6iMV1hjE1bN6HjRULol4sAA5wOhzLaOJmWSFK1Vm0jCS1iGy1wZM";
  b += "tLs7zLmHCsAxgfl6QUY4JcLmJY8Jgbn08pE5wy3iUqQdfo+ib4Ot6oyWjxPBSUtCSeDHauEFUeR";
  b += "5vZCg3ARfLpsuAW8WjBJIAokQAIjeHUh+lz4AOWBSzkEjOYioE2YJMKiQVCqOUdZOF7Hl9PuKKa";
  b += "wf0G0TE6NPjhRSV9Ej25qQlajbxGXpYnYkx5fTsG+jr/bYueav5oM2V1koY7/ObPGdcHkFjDis3";
  b += "OcejkgOpIvysSH+IYhyE/+jeyBZLbS5fTYKgAYXh6XT777eg6VNoetrRYAoCTZYRnOsPv8SHraa";
  b += "7kf2DlvgQyscW2x2+kw8BWltjd7Ce7S5o8mWbbvpQW5aAb51rz4JpOsxSUI3iK5eBt+dy41ecBJ";
  b += "VsvivRwQ1XfkU7PTQ8TpNo07Xpzvv0Gm4xlarMqZRQ+mSUT1+axQvuIoPd9VrexbO2GT5GRKwx3";
  b += "jA5vEyvJzL5HmTrhrQ7dcI9XoIzA0mXfA5PWSZLy7zxpNSL9nWZL41BuIq6EpOrJsYHyemWG9hf";
  b += "0B1+1ucrzzy+23MP6H2PZ1RmS2bvOOYUNlhOQhrdQF7ZGccrLvqi12rijY/hPcCxOkgVyHs1KeG";
  b += "dnJ+8UysX71FSHY/4y4qkJl+6kzre+5KGvPckId57ki5570sW4L07WSjvEfkbEwAXyfuKZHEEIk";
  b += "oRgfYjQK1EgFWPACGMkG9BhNTdnHBx5Ixj4JCS25y8xMkrnLzOyUNOvoCTd3PyxREYs5HJ5Uw+Z";
  b += "ypxpgpnqnOmkDMt4EzdnGlxRDJIlgwvmxpLevh3Kf8uw8Dc8vuS3uHyA8hNoCsMOmTQCxh0N4Ne";
  b += "zKCXtWTrG97xU4NpCkCT8ARpL1UJljLc3ixZGclAUI9K0MMJejgBxkPHFX0EgfMoOnv5t38vbtF";
  b += "dvgk2xBdTIssiRuqwIAIWBAjoY7ghGKozQwuYoW5maDEz1JmV/jZMIWNaBEwLGZPo2WFMAYs8x7";
  b += "cA+ELG1834FjO+i8PUzZgWAlMXY1rEmDzG5DCmgDWT4+sGvgWMbzHjuzhMPYypC5gajGkhY1rEm";
  b += "DzG5DCmgAWX41sMfN2M7+Iw9TGmBjBVGVMXY1rImBYxJo8xOYwpYMHl+IBE7/5aDLSJrRA6LQjd";
  b += "DGEEJ0h5oyWSkIyOUiRqAPo+lcvlXA7nMjfJnKUzvHiKEtcfAJIv+uPaRHU6QOdFI8PeA9q+xyh";
  b += "XRiHyLZsiY5dPz5RbFLO8TuVNZcucqPJ6TUut15Q9mPawMfzYhx77z3868PjbTJnrsXhGjeLffe";
  b += "I75/e///D2Txr6QyQfgPRVOm5tHtfQcZjK5I2dTifwmM10OsI/pb60IDhXiMwwYD6TN4y6nTBgk";
  b += "tLtiGFafWnBcKAQmfMgGHow59qBB5mn7MSD+tLKQyEy58FiDBHmbzvwIBOfnXhQX1p5KEQqDIZa";
  b += "/acn0mR8UQfDPMhPHArD848lnrXByTY8mRbIvE0Fr2sRzfORFTI5hJLqGF+0nU+32UgoM5UybWU";
  b += "VZjMZ6AuRF0CZunyWlQl4PlAEMntk5fO1UWl4/D4h8YYxNa1UYyA8CcdPW01CMRJMz1ZE4UXCMO";
  b += "tZEspKYihF5Ji0tQW7LUamJ/Ey7JOmRl/P0JYUGZZMzZbEPopoMVdYE7Q1sS31tQ7AnGSGANsKc";
  b += "E0BtmTGsibGUsxSZ1qsMZ6Toyy8VIyvrMO0WpnnxrRu8mniiog9UIJyeVcPT1RbhSnRkpZAga9p";
  b += "S8SZTfVGih1NbIkXVfCd5KDAFQpqzEU+XUyUuUJBWc3yQVUWk5LPBqN6Ew1V9MRfqO6IJ2Swap5";
  b += "JFNjZzLDCqeYUCfaQLbVNkOXBIICFqb8VRuWbZbOKyb5pRy3AwDBr+PuuOqKHflh49HAllp0afn";
  b += "EQEz99+XDKxlZzJ/wDvOB8ZCty5QUrquU7f5Dkk7L9KuBzhrKj7SU+5GMH8ai0xAd8/B0eNR0f2";
  b += "RyadIoYmHjBLRv4MwrC7ZpU3BmbkepG/rykBmrBRE++4L2sosJ8UXs1W1aR1Iu03dBCW6ThCmZz";
  b += "HtrMIm2Wpm26kxjVsb+5/NT5wJWWCOpbtEvslI3rITOGcj46kt8uFyGI6ReyZoT+JwESdB18x4x";
  b += "R5GbGbGZwWyTCn8J/8kUbZmFxc1lFZKNe1XzJQgHrjKnRmh04mbQy7dB3QTvdGvcHBVIMRcrFi8";
  b += "/qgHQmFwCOzmBTK2UQKxnEC9i6wM0gnrLmMSj+pMV3ymoT3ymrTXxym0oRLW5OYryTnQyBXwX8R";
  b += "TPQ2aLsnAFcHFRgQNRBxTlzH1kJwtUxv+9GRgu8OVlJx8WsgkpnVXruwJayjUmzJbc68UTnnjE6";
  b += "MePAwf64ZJpwsDOlrMWZmuGnTGlH0lvYUE1FaVry6yn1CktrqHaeahny+7R6B1UN1UpT7Tr5Xmq";
  b += "q+tUSVKdkIwtHtyY6lSeatPJEUTENal1P0kwX0pxqAYR6qy6JZgqJcJlTgSRK1KdIKiSaaUkE87";
  b += "tOkVRqFqOLNJUydKeC+dDRl9RWNBUSabGqN0rkKO4KiU61JJrOE03OC4m+pK6iyZ9X4H4GaWbeR";
  b += "DN5oml/Xpr8DN3kvInoi9bdKa9ZtI0iTV5OkzevnLxMmNPevDR5OU2FRJMt6LCJRtPkzoeOvqRl";
  b += "RZM7Hzr6kslp3kT0JS0pmgqJJlvtyc1158xHOH3RhM848+rOyWly5pM4fcnk5MxX7HJsp+x5VWf";
  b += "nYpo3EaoaTZI9H3PYrKfQTWaJzCI9aEkggdHmAnDr0vf88M+96w1uWZbg+A6U9ebIU95o4q7AAO";
  b += "8ZFxXF71PbFKspsGsWUXltxNGhjg5bogMdndVMLqrdMy4auG56nYJHBpjluk4B29Uax5B2eC1gp";
  b += "qh1fZ2iEC3g96iDUDAQf8bFzoX0ZybavG56L+U0jCEM0qsmfYKh5EfdHMnXbVyjZKtEs+pKBZ0L";
  b += "ML/rXm98FvPu7tXGd9ynm7Mcxn4rLHmmbsQ5EyO3Q8aX5cNZgW58zlZEClhs73cx5SKx2N7PU7I";
  b += "ssvAPg/C0T03yf/GwV46plc/h2/0MDFjY96czRvivprA75aV80ItLwgt/hKvAXeoRD2GzFC/Gwd";
  b += "xwxpRWYOJlzM/aLTrMbrOSLwU1JkG7ImdbuAsfUtxk0mMo57nlTfItRuACAR1B0AxAu4en0lZZZ";
  b += "924lK10J5lajsyx7dLiIBH9u49jvLaKBM6aiZOd76UvFnMxJ6vFERTEYfJs2vXGrM2bU3gD3c01";
  b += "I5M3oQn/NGeM9DIJjZ6xcgGSphKnWAzOWHISRbEMnJEbWZ1iAZAW6Bkrg06JxCAws+umU7bG8C0";
  b += "/0xWXgrko3Q4o3XlRgoV9do4SOBglFHfSK+oxo0PkQbnCS+m509X5vuNnCSky/LrsBnJXWrM25L";
  b += "jKOmrzPLJAPE5WdFRNsEObMw5FzjgF09JfVQa4at7qFj5mClwu0VgApXKq4zfyk2GIVpenJm0kJ";
  b += "wOyxGRm9dZ0+UB0WeoQFyffS4Fj5bRhAOIZHAwoeWepoCki9/wZlbmP4TwHF/Uvecy3lUx3Qs2F";
  b += "s78EmCo9sBNOz3un91qYzp20eBWLsdqYtNKPT/xGDbPbsYeIx00V8ZiKeExH/MyUnSNeNq8NJ+N";
  b += "h5JtasYNWmLqxlx47c9iQ3TYuNpdk37AV5/in+Bvu24hMnlByeI5IwPShIz1o9RTm6amBuzHxeL";
  b += "6Ml2uQFvRuL0ttan8ebwW09DQajg2OGTlvYjFjW8Dwhi+qXbZif6kdWRt7eeADTpkhYjriJgblY";
  b += "XbPJvcyKjIi2ElJc4ztQjgJio8njtQVdby5xiomGVdJgjzJeFuSrXOTbG1LMtaShCJe14z5BCm7";
  b += "iUVs9o01R5+7A+HQ4+aayWcUUQoB9Bs1PibI5JGZTNhYAO71YkWkHILzMJueiwn1LLwWq/tc9ji";
  b += "D1gs4FFLo+RxaSaFnI1Ez3f1vh7FY0cV0PTXwvmVxNOHiw0Zwstqxf9PbflzM3mcY2jGv7YD4hR";
  b += "liIaGakRDkJJz+DpHgKBKcdhKI99GYT1oyb8yvaRMdQ9yJiaUYBnYRm+mzNsUwzeWbeKL31o182";
  b += "4m3JTI2UxkWm05lyiE15TZKA58pr8XLKgwuZHeJUXppdctmKfs6lY1U9GHBlnRy8pyxaXNiqdUX";
  b += "2mYZMLeu+Gw6CfMaDDvFWJqsweBaw2YNgsEm1lq6fB6Blmi7pD9WkPSGDpJ+WSbpF2YqFpmvyGQ";
  b += "e5TLfBZm7SuZum8zTo187jE28Ds9Yf7isdgTYvMAycsDmDamZPvw27KXHCsPrUEugAf+ffmqEH7";
  b += "fkWLvn4ES7VfZ1Q9avUwTPeHCiH/DSJqrPzM2yE69w5pzDVCBx+COuUWWlj8M3vWLOm+fpw//kd";
  b += "Y8nTKwmcPjCV06Rbt9FJP0NjltDRWzdXMOyxe0Y8FtpnTbxe9ZMd+/CFuXwY/S+xtiOYsgH7+Ht";
  b += "jTZ+/9AO/x1xuy11poyT9g9aL8Eu40FrJ2PchVWxO3BCgXO12fN045zJx/edM1kBCJ7CatZdlmL";
  b += "10V36/B4HVKwftH5bMeVAveH5jCFHciiGzj+IMy+cjEncDPtJJZjTvOmdkcr3dOrtwr6CsNI6xz";
  b += "yfN8O/YmZ3WLzGcjtXtof1qjPBRpHhp7CxhNJN2Yl1vfEF9rA3Y82KzEoxJ+f1TnYHh6xbeDxbV";
  b += "qYe4Vt7/pEZfA6cOD1/nUDwej8Gka10Y9fNFgLqw8c9JYb7PV7D4qgxdsVWti4C9kRsD9mQPJan";
  b += "iEAedmRBG+FbiZ/V6TEI4j1uqw4HSGN2QYmzb8+VuMqOhoqK286SgFAKSjz19kyJOYEn5hB4QhM";
  b += "YFAnkRb/4qaYnHrwI6o49WKTOeGLqzjyYUwe4stI4N9m3aXjpzE4Es4zbH2xhSwCn9uY0VgYyxZ";
  b += "Hvs5qqje3wYJGTvrsQc56N8ME8hqg23mRxV0aDZUOFTcBAwiUtZmWE/+GoYzC5A78TQ3pYG42f7";
  b += "vARVQTEVMjSwlOucif3k6uX6GO2LJfsyP/ud8zH/5535PwLQTt5DAo3Qn53Jx9nINa76y308tDb";
  b += "9JEH7OReyMtlvoAjjuirSrjzrap1942S6U1ERvgzP0aNYoSf9hMz/KkfSyPICP/OR1XDTUp+/55";
  b += "qLTX5wFYKhv/lJ9T0WWnt3DbMB0astLAbPqW2gpXy/t/t24a5iWCFH3IbqCcxaonFjEb4BlNuGj";
  b += "So4uUjg/Qio4QXj7pYCFTFXjKsW7IqKSPatm04HScg9t2voYqS3rDP+uzkJ3j2fZSrK3TsjPBBn";
  b += "N8ieXaDhtFBPBsVad+Fh/noRE0ZXzamm4XIsmvbMO8fULxhqboF8WjmC4xYYISbAFbGiKUYsWQT";
  b += "gmIEbWXeFt6REW5Khfd6US5QJ5NhA5vJYRaUi7/vIJ6ofUlfd4iEqb6Sln5GMcsMmXbqTNuzTEo";
  b += "thK7B9HCMBHaCFBPJ92wbfm7NDN8SJFgdN+XFZtotASsNJWBTHgmm1hYscFTTdP+fvbeBsuuozg";
  b += "VPnf/7130kt03breBzb5zQfrFi5Q2xHJtlfHriH0XxsjPP7728rFlrmLWyJuS2F+OWFcGayFYby";
  b += "UaAgQ4xoOSZIIiDBdiggCF+IEgLDGiBIEpiHgYMUYITNLHBSnCwAIFnf9+uqnPu7ZawebBmMsFa";
  b += "7nuqTv2dOnWqdu369reHw/nqxNO/O6xeugDJE19csGmGb4Sde8Xq5Uau3FgpuO2TwgKT5QbzQyn";
  b += "sGo6OYL56+ml524uL2xdkuyg/QzSHxUuJj9/60QASExGVAdfmzRx2TwCCTg5MYHgD8FpIQvwJ5e";
  b += "4hODzV8YTJ0Gwr/lC9ysnIBqov0IKBr0f/vSUBLzYKMijIZdT0JICK5os9OTyJEDGog04LkxEZ1";
  b += "wM00gFqn7jvOqqPnQWafTITaQ59UwIfIl/pwA0HCN/S4/OQ3laOCHRz6DrVdnPiujnlQ3wHPo3R";
  b += "xaF0rzYKlNoXYQBww1O8GRuqcP4qfX9L2kwdHpJ4B1Py6zbu65Zi77Cf372SXPYw0tx70TB5828";
  b += "250xijL1soTopvTnUCcd+FYOoAq4w2rZ1oNoNcDHRYqDi4NrCr6UM+2oqRLBgGSjsK9QfaXre6f";
  b += "xFHuY70ltWIzbvgdi816Qq5wuKwNSthOXKTt5rsJMbsJMjqrwd+PaZQW+UndyAnRz3i7H7jp3cg";
  b += "J0cCfIVCVwNt2iCeEUCy07eAzu5vbXjP5KbfDVW8fDUrOKTkl3y3jb3wt23SyHl7kEBUm+w5iMw";
  b += "URYEXvU8C7mSim8vPfG3lHBKQvHtAJKP8YkPUjKKT+6+h3D3Ec7v3pwpJ28frAUzcLFzMHEd4at";
  b += "Ve3MPFtrh1urOLx4kDrvMJAoDLHP03ZnSdyeMa9J3Z6el786Vvjs7NX13ptXU9N3ZqvTdmdJ3Z5";
  b += "6+O/X03fd/yTFtL8pVdV51t4sYZ85+CluZfnX8iy4DqLSzU1NpWzXQpLqUJW32QbAWHBwY3dXLj";
  b += "LgAnHYZzx+k1b2Zl1lrBhYBQ/ogN43tTAYK7VTJs8OSk8AN8/1Mia9T2esoQbLcxYG8wSLY5INO";
  b += "HR902uSDXv5i/axMC+i4GigpzTbNQ9bsvo5qLn0aZdyOtOIJEGpP0IJKW9BTom0Zmjv7APWj3AH";
  b += "UmFRvgfkGzyv315a94v+YVELrI1886O1Y6jTZfTLcwJud8GItk9NNxGhy0A2B4WeuvVgn7XwwM2";
  b += "uANiZOOFSQb3SLgoNjxQAn8vUQPJwq+ji7ZfucuV3xwjkhjNKIW3DWDXCwApZbtwASQ3ByW5PL1";
  b += "vcWWtUDGxkxU4vp2y5pMOgw6aBLtGIP4EJZUlBywpQZU7aYaLt8wkg1afGRBTCQWdkB0llr3F5O";
  b += "ogTZZ98ixeTMG9m8Ltcai4/soNq1UjQs/W6x04Dcn1BUrU3Vs7E91LXWJnS3COjtSAO05a59Bf+";
  b += "uHQPydm5R3DA6psV+WMOaUjQ2RGNxJyZKdHLkOV2L146VC6gSylDMccYyk7LT7IkUoOUQZa7aB+";
  b += "MlThHa1QZgu8U3p4VJ2Zlvb1ymtyAuLMNn3NJp19IE/R2xtJydGY+2N9TCf3CJAN3mKCxhYTELC";
  b += "117I442be9kA1+bAok7CG3Z0UjZ8Qi+NkJru3PfVwRsCHxtOIqvjZkrGsHXRsDXhsTXhsTX9ua+";
  b += "p/jaaARfGwJfO9FE73p8LapSdxAeXxs28LX7cpPtsGrqp1vUaFbJNhU8VEDcawaRLj87YL2C5ae";
  b += "U3dJ2WMHI1DSsw1ibzt/UjyKyn4Y0tBhk1SymsBS6d+62U02aaAlgBsPJjXIqmaqEBaD1PwzMmg";
  b += "9S+4D/N89I+vBKF5+DZ8yHZDtRxT4k29Aq8aEpCaU+BPcNmQ+tw8bfh2Bw1/Kh8yTU9qFZCXV86";
  b += "AIJdX1og4R6PvR8CU340MUSmvShF2DX7EPQoK3xIejd1vrQ1RI6w4ege5nyoeskdKYPXS+hs3zo";
  b += "1yX0HB+C3mrah14kobN9CCqyc3zoxRKa8aEbJLTOh26ETs2HtkL/4UMvk9C5PrQduh0fWoQ2oe+";
  b += "DuxAc+OBuBH/aB+9A8DwfXELwZ3zwTgR/1gf3IPg8H7wLwVlY1c3Kv0eeqg2kmqGsGapuP0GvH4";
  b += "zg+swxLwObdnlQSw8iSu4JnUAGdquc6MB9Hj6ZpJ/TLDTcyt0tjHHM/MBsA4Mlj680GdS/kkRZu";
  b += "2htlFO9feqm2o234XH1tT2rJTcsBx/dy+SLhPGbCMj4zKAbgYfxMtoKBUyA1XbbFqq48LXF3g/G";
  b += "Jn5tpN3eCrQoEksmnUxy95zVjmZb3pOHmTXaj3nY5Wy+cho4K71xpseO/a50Mg8lYXSHnwmeHkB";
  b += "hmzVPMHMeYPZ8IB+qq6CknAAsF4ZNydZhzWJnyZXlmlugrMxx+hLjuCabl4mrbF0jYwEmtciGc5";
  b += "vTNWh2ZYNmmw2aHWvQrKQth3T4wYPL2WHxzoiW5fAzAuMwGYXVQ293psK2hkHmHn6QW/ZZWxHBC";
  b += "bmiZ5t3cjL+aYcMOu6OnmJHOEDaH9n6X53x17VI4/Nh8RdR8ZegcsSzDroK78N5/4CP1iHoT8HX";
  b += "PMmfHUxqfzNpqh3QKm2CSa2Uxgk4e5B5nkS0xYcSB7nAzeILGa1b9SGaId/cX1EoxZFokF0SHDH";
  b += "cUVjkgny++0OeugKCbk9dgZFunrpadl2W2Djhduy6Gl+Mxk+7+OkR+Mj+iOy6euvJP4XPU3cGDZ";
  b += "OEWHMXr8q0Rf4p5GbxCzZR6MiimzefMrbhrHjJjIBl9oe2oUtmtKGhA7mYcbjMkpGG4qhnyVXRb";
  b += "JoN8pYk0KYxZBstLZpppiv+azjS3A8ldX4p9M1k+AiqR9++HIwdkVfn2CNyewwvA/XR5im8rN+w";
  b += "gJdyCKN8Z24ino3/vMMS5coOYHssJzGFjCUfc8JxITc67ITjTS5G44joa4yAveEo6KHaF44hI/h";
  b += "Wm4Mg5NUJ4xESe9RbhCQ9q/bhK8ED7LsT2p9nDYtHjU0jX3Q454o/i9+xaYbl641sGD/7z0Jh7G";
  b += "otEoV9zpS2DNNwttfMcXIsx1tR/YFYv/Rq/19IOx8IeVZ4gK46fi8tfj+61NybMu5kM+7d6Q+qb";
  b += "H869I28N3VV3vSDsh1nUm3puxvZ9Pc4h1zmp6m64CN4lvt/xiU5a+gfTUvBLZdGXknfvpEnLxj6";
  b += "tiLJX6xM8oH1Q98un+TEeu0wO+aqsh9Gusb+XaAAIMlWnQvmFFaCy1RSZXbhAcltFbtMVLfs0AV";
  b += "Bnk61s/oY1ISG1UeDK3uxNoDcuiHIA4pjtim2ZZ9xKQwFapvCAFHKk+j+sM8DENQwlpFMAJqZN4";
  b += "prmglqbxfSyLCra752gv/mjv+8Hr9QvI8UaZGOFIv3xjeCTj/9A+gbZGJ0v0/8A5/hrbnJMVccj";
  b += "TzkuvhypoBrWrREGqxNWWKN2EvbiwiYbo+mjIibd/divUd89sg9fL3GmmpNN3wdWNcIzlimiYdz";
  b += "7hFgWuRsR1pNyvbLrYuERWcoEDrEuUWEW5wmDsvuSHxwUS0ljDXd8nNUaiMa/CDeuKtR66Kx1e5";
  b += "tVIF6X504pLk6dNlrbLUKKfVxTGfR3ZHDor6qbp8WseyexKYJbF8uu76su3BZuzAps5GoHL063m";
  b += "HLUY12d+4cbMtD34vWisBwcajxiVwXPCgx5ZIw+kYCW4EWfdSMVKDw+WX34M2+WQzrVxKOyA4aU";
  b += "Yy8o3DFKwldveEqD8agFl8/Sv0Uqz7A8moF6YjXW0dHX679GMJh89vw77huR+S/kHDF1+OafzS0";
  b += "5hrNwdWoS7OWI2PGFqSWFozU4MVDz6gVADeS+MDskCLqRlVpnB8uRxvhLgd4aREnvpkp1G5v2jR";
  b += "7O1smrtkhaS8G6itlkDDyCGeKI9bo7QiN3hB/AnhmZioeMhQ+hhpbhcU7QpcAZbIMTaTmTeOJmi";
  b += "kOjac4kujko5UkalvHwD5WcCSxGdiq48yud064MpEENm++CNi8nbKIPWFdBL5pX4RpFhGerojlR";
  b += "hGHXBHHQkcpnBUP1x0EAtI3Zc0ibCQzLUW29GJX7O8u0eMXe+eByHcyKmeeo3UcBFnfZD6aq3x3";
  b += "7PI0CpZIbcu+RlsQ6fuAtxpZNPn+2CdvVrd/teL2u+IWR4t7WK2akrHukWi9r2UAsT3LFbdRgPY";
  b += "De775NmBZc3az3a7TfFW2ax9Sh8e+Ks0A6wJXVbNYV1XzfbmqTjSa5Equ306jp/EmRgs/4SptFC";
  b += "R95VM1qwNq6JTVHQlG6ttLfO0b8zBSpcNepRv3MFRCMDE7R1sH0gG3Y7OpSpaw6SukMpcE9OIYY";
  b += "eNaPAwd5cUiJp4f7f2Ty9XacgODe1yQluaIWbIxkHEBa5Co3X9ChkEmOv7HIkauKZYMZcGYGtIl";
  b += "M7Q3A/v4u6SHXw/TsrvtBQy8qSmV7QTYiELOI0sAVj2I6/C+QTZ36e1lOte6XcSMbC66fZfELH4";
  b += "/2jk3e/suiVhcPJntnJu+nZeLJyZ3zuW379olGcztNkKuJ3drOsSfu5vZy3zu4t27du0iVbJ1+j";
  b += "2Q0bWILmIrHgylFY+EtO8FzJpkoMNq79vgujG2jOWz4TT+rCtel+J3CjpheBzSfpAp7yrLzhVWF";
  b += "y9UF1/JjqHRBd4BFspq/9voz0fCcEyTFB8mur8OWePHL6fWsPHiZublkcya8sMxsgeXBCfwhT4U";
  b += "Dr3vI1Que9PD2s13h+r6CFzRs9LfwB9o9EXhkdCbYx4CvwHlzuL76vBcUp8MRcKR38UIfhMi69f";
  b += "lZEjrZpvVFMcSpMmp+cNVV1/wbPgkDp+tgvAHO0A6BARZaJ85rp68u3aAxDFVle5pquW9rj/USt";
  b += "QmmAamCwbogTcXtXcK3snqO7m7k/NO7gw/g10hzFqOhuroRS0xAnyrrWGZwy5GPoBhmenV2bJ68";
  b += "6qMLgyWzKVBXyJ/GkW/niMd32FCBE3tLNg+UFmjROOCCl8oNkn6ZNMEVSi5OmrAKfPCBzLZL1gA";
  b += "yyBSyEq8RacFcj2pAtdhqOiPAR4wSvJfgk9OysdeZ0A7mxi8fIruioFOblVEg8fU0ZYtstC16LP";
  b += "E4pXbEnnuAsqSi/9ts1Jobi3bW8ANWoVDurNR6rfYwZTbTEyYcluSA6aMxNFYYkUr5w20cstxxV";
  b += "G9289JbDdf5th46j355GSO6+hzBO4pcsVY59WLlM7zRpLlaXNsZXgYtKRZMUC4vnJbteLAuP3FT";
  b += "0mDhoAa5dBBqvDGyqxhE2D6MZoqQ3kGmz/MDTMKCo8UOUQWX3lH03hH8q2sybATBQrIOvsQ6X6T";
  b += "vszi3/VjiybTmsmIC8cfqU0Zq3sZ7MFbenP7At3eMAYoZSmnJZsFC9Ifkly0EQibAY/lV7V5C44";
  b += "/WnpIpdpuMFvmLDVvpMx1xOjIQmrVjirxmPyoI564pl0vJ+IwMCH8vLChtD3IKrMN1WLylausoy";
  b += "Mxdl2F4wZMuSk7UR+OxxE4dQMXaS531yQB8QdGu3TVvoaXU7odwr1cY7UXLUAs43SOtmENta0Yq";
  b += "4F141VLizfx95Q1dhYz07LHjXJHJJXtC2CNnB9E+p6BVgcLaKDeg+hsSdEZKOrKQcbWGWunEsBv";
  b += "jfMrpBBCvhPIRbk3IPmVIalNG4GwGWi8aQMKUhkhfM2ZChPzgL/hW2ux4FYjsaV+5flMaE9U8DW";
  b += "Hl6u365wujup28NTTWALQCwKj5SAy9JGhjUSvhtugkAGyMuSMleqxKrgS+GcTTkLRSzx6Uqfvcn";
  b += "nSLAzaypNL958ys8i602dEmVIxZSwiM4fJXLaN/L9bqltfvitf4Kx76nvxqe+d6kZrKP+BBZbq0";
  b += "TLQryjCx4DHy3SKlRXw6VtPZguYbfE7rG5djG+oim2YyEN2qH+WQUtXUa3L1HX19bSNfdwC0nDV";
  b += "hipSJ7SJcsz2TNQaS9TRhfnpW9fhyVdplU5IBn1N3F60oOzK6CcdlKF7CwazUeRiIo5ezEbGj0T";
  b += "THKOmOUZNc4zS7UpjNlIUJmYjahxL00hpkUY55gYd1GHndVk4oTa+JQVqnQKcq+GkGlDDwsNDcF";
  b += "xn8pFbec74JzLWmkwP5uRJau9LVk/aGnSwAnV1He3oh9LlOtqjRya7jk5IpKyjk+DK1nV0EivTx";
  b += "JZ+D9TaSsFbTpBC1a2jE3D4NFQXX7qcTkguLKc9nxiEnFzOJhvraM+vo/AYBkdTEQ4yeninxUUK";
  b += "Xl4fxCIQU2hdH0ziz8S8dbDIdVsWvqjegUgXb1KLuCudEZg3iosxNtqarq3p2o10bW/QF7tFApl";
  b += "RxXyZuqnY+WOhV5e4YbNAYo54sGZjVEjeNfewjYv0p7do+hP2NUzYaPs854CLZ30wc20P0A2467";
  b += "okOEd+26A4pXTf1T2JTqXoVq0Mq4z1VlKoLVumkz+lDpYcVuBiam8GITnqANGTvJhQIgoZmAXkB";
  b += "O5vMFtOsF5E2V1FSPJafOflJLhUbfGk24yBKTSApMirchZaIa69hVbPWmiRZr89xG8brKktkrPq";
  b += "IXEkLZVHre59qoa0YYGSmEctbaaXLkILfEcCtfKjlBPXLxgvLgJGLpxXuzC+PNN4c/iU8Bj9WEV";
  b += "cGGFNukpNdZer9L5c2UY2PAvXLeqwZe1Khy306Qie/0sCqIpfa5yrA1juFdYh8r6Dyu1fQLPw1d";
  b += "AqVcHSH1jXIzxnRgGvW62Aw6croBgtYOlZF0CXncHPRfkvsYDfW62Ax09XgPohkdkfeoBQdh+rF";
  b += "LD7HacpoKePEMYbWcDEKvn3Ir85RX76JDmv6U4Dns33SRb1bP7APQcJMmrm6aya58Bp87RXzXPk";
  b += "tHlaq+Y5dto8+ap5Tpw2T7Zqnl3vPF2edNU8S6fNk6ya5+7T5olX7+vT5olWzfPQafOEq+Z5/LR";
  b += "5ICqoHYQ1+il2SnSHZIgygwSdA5lJd4zMBWHV0kUoKn5b5FADYQTWDeaU1g26jDcNVDK6IJDt45";
  b += "iBimzoZOmaKaNrejJP6xpks/2ubO03z9g61FoKCjkDc6AE1lLpuIWB2kklcCqJzbczJ0r1msY5I";
  b += "hAWB9OeyKkoJpP2wMZlU6+lm6ccAPWQLkjVTIrVUQBGdK57LWnkJrvdkqU939RLrAWKUSE1nYft";
  b += "ux7sAbU25N3iLjyKSECmeBP1NzmU7zzWKnHkUN0oUj4MR+7M+7ol/U5WEiJh6NtXgsQp1qYrSZn";
  b += "NDweRtV9B7L5dcwPaBmJdvAhBjd/L+Iim9hIvQfm4iXNSOV36w0rlqd0pAOrYggH/uOVU1rCcos";
  b += "8MfV26vYrxXhJe7E5w5OR+Not018JHK0+LONPLAdy3tlHuLSRuNwvjBS2XoDTmsVu1RIcwapJMK";
  b += "SrM6gpTGHJlxUdRNgB1NMHCY9AEq5d1led+fpCsbHfqikm1jfjZLHX1EnrHVdsvbepmqiQoY6sV";
  b += "frRpRoEqRclRs7JEVBqraVBFTvAl17Q9bBpUyEV3QOVSTDueT2TVy6rtHNYzQ/f6WI/sa6SiMsJ";
  b += "Sho2BpDhH/p7MOh/C16uyt6HbG2xip7yf5O6wH43ZVmOrJqV9NgS9eRfkA7joKVBXEdYGLig+F1";
  b += "NQGv/mRH4dEGyJHfX6KwkR/BIUOtwq/kNwpXOlUH0j0ERPBuqA5ruELsQNFndY57fHq5T1PijeB";
  b += "+s8KFyrqLg3RCelWMftjZ3NGwnWZ3vjdtyI7Y0Y667eKG7nB0jvXpQYF+RVfzTmXXpEjvt45wzj";
  b += "7xvMIO611NSQiDPSxUfF62N0QE6wYI7LVj/pWOURBMuO36/EE2FgGJlS4uSObaTj0xUymL4GkUV";
  b += "j9eogYxY9CwAI+s5Ur8LjzVZLty47yw99G1+2Pfu9QN/HBTLv4WuLICoajL3RLu5ZtxFS7FU9+p";
  b += "JS/KN2iHKf4PaX5LaxfWj84wf146vz7dg6mSGEssrGmh/Z5oeu+Xtd8yGDNxoSnHZoRiuHJh+/G";
  b += "sC8v/GaOaqeVTl2WFeXXEW7xffhjYV8JlOl48nlfeen6NaIPmXGY0N61ih0jFB4N1Z473wqU0Bb";
  b += "6RzfTqHZbxn5YrH3meqdQozHzTNlALx+x3Aiz4wxuWm1ue2Iqz+SuCSRuJQatYF+hBeq1vcR5aq";
  b += "Iqq6lPEdzH46tsFsNindDd6iSqyR2QQqiF7oQRczchSg8dl2IYmHbhSjw9VyIolzLhVI2Aw/+gI";
  b += "yxC023Z+rHu9BgfC+eiDCaFvdHqoyWyweiq9TME+qrqfGHaOOJF/f/+Y6bqqdfd2DHNdyNWsQ+N";
  b += "nwpe2ixUP/pMXTWi2bLJcGZDKXbqmWEpuRT5JM0k5zFUHdbdZRJXAZfgnx0fF77Mj8R6Qvkz5ns";
  b += "d6OTv3yoxdsj1yGBHjkkPAPKx3Mb/7Krf+GsamAnzQJKMuIUF2qtRIQ3S9A+nXLO1S80Z4kYtwi";
  b += "kESzY0LOqG1084qLaPEk6ZINb0O8wd42d4p49G90kwQM7htXi0oEdm+zxleuD57BT1m6rjrsuSp";
  b += "pd5Huw7rPY99n4m2Ts5HhsNvqkzxm/n7oO9d25IonIBTh5VOmd542UySOweE3JBADJuVraCwaU6";
  b += "o67HZQ/dP36gZTGzG4jHnTuzBya/egPiWYfR443cewNzHjw4waxH4tWotiPRU0Y+7FoDMd+LPJA";
  b += "dr1d3Hd6GLvWQRw7eeOikXqIVS+a4HatEf6CVwDYA1afVEeUgixyNGdAjrro4i+j4r+n0A179Lr";
  b += "S1Dr0ensUvX4sAnw9IFkO+qLrA3Un8Fi/AWgvPZucMsGST6w4YEVcMsD9XQ1gL0dCbCziNsnPA8";
  b += "Y9yOHQXpBL7YgFkct9ZVl72CXUm8W/t6FQqeaOOMT4nlHE+BGHGN8zihg/4hDje1YgxvcY+ip2B";
  b += "G3a1b4dvuct89u/9yFtIdr2xpGEyvZWt/xA4oPop7coZ4SCwqWfnxyhZjstmtxDxo8SMv7t1MSE";
  b += "jBduid0/iQ56DdSES4UiKPzZ/iMTukw8NKEYikIP94/44EXhwxPOJzoK4l/lDT4yMSxujQgG8Yd";
  b += "dkXLjyM91dkM9G15/rddaXhT+KoEkngZHbm9QExqcySUKBJCtnQcBhB4EAGvihE0LYZ6D6qu4Ov";
  b += "ye5rF+YU/ilwp7Eq8n9IU9ul8q7NG9j5520dM+Gqf2S8XGqFCeCGKQF7tYBtgNMmQO3FdbOhBWa";
  b += "YHBxME0bzLiKFF0PuY4PCRB+xo11Q/FVVRU7++uXkAfR1I8nYjU12a0zSFfqqXeWItwdLKwDe7W";
  b += "KOVDtItGalliZ6AuX42+Wr0hBRYzmsC+bpuMJE2N7MXPNnMyJC9F4xg63nPj5Gd9eRLny4NFlVF";
  b += "kka+aqvH0Jlh259uUi7J4g/Imuce1r8zbmqCDOAI63LxwxLDApNq7Y9WHNMUMOdDGu+F44ZDcmh";
  b += "bvuzIi+QQ3yDN0XCuSZr/U1b8mU8KwozPu02taa0QWl9y0zYgsNLlpmxFZdHLTNiOyKNZFgvzWN";
  b += "iwrHLBSOcHlVvGo5XvXsb23ORNqfOHii9H4fFg7tG9Ql++VmfCoUUpwLVPmuLqtDhZzZCwytwjI";
  b += "FXT0ocJu2DtqefG6mLMN2kAriz9NLgn+KGLcYtiIe0tkn762GdFwbTOiYVkw44aRxdG1tR8BdtM";
  b += "fRa6z9o1bjqzIt9ygQ39LM59eHA897DIfLfqJsJlkb2fon/stK9J4m4uoevs5NU87kizFK5J88p";
  b += "wG4b1LcuycEbMMveXatj74xDkwImAym+szsU/Dxq0PvrZKmqrEgXBEEkIDsw2dEfUb09ySvLimm";
  b += "W0Vm4mR1vAZDU5UjbNuOF3D+LynSGkNMvTx6yefwUp4PA2THeEtPEvOFgahc3lpDbKr86/l1ipy";
  b += "bBF7jaqow63VHnCD/CIczdGoA7besjMY8OBN8QKcTwGbmCOURFkWZZaWhNlCP3axPE+GzzhSM2w";
  b += "f5JdRjx0DUp26aLKb2Dv5Ke90T3EHl/2cMwjtQ7ZLE92pojM+fZv6TgUC4JQtksy2KDVw9dCb/B";
  b += "72nZT2PPBKBrRfHwIjiktDTs8ApI57jWIQx61vTZUveArLVbpfFlr6B38GXZ2t2tXZSFfPgZjll";
  b += "jLbPsjGetvdYedlYx2+2s3uqW/iEoQmz7bbV2md5Lel1T1fZs1eD0/b68qOVCyoCHn0EziXK37x";
  b += "HI0ubfQxRMc+ejmw8ScQn/n4RWPj7/ykxE/U8aGNP4z4GcSXulI23vbnMvniUjq2zZUz03wYIAM";
  b += "FGv/v1PRRud1y/EjZzkHbMRHluyTe3A6CB8sN0Zp7/u57qqcnFwbpzKAzZ3b2u1XkqDMrU0nnSR";
  b += "qb/cTTwc5B77pBNlP2GnG/NsPjbYltXwd3qhNxhDPfTgUFKPWAn3kp4DPd6/rJnOlPSPNc7pKEJ";
  b += "KUP578G5pzOXDhnwJozUX36pdXhl8plmboSgODKLzXHcPAhG6Wj8jsni97DCHdkR4FfWcn+MR/R";
  b += "adH4XPWH2MaAVQf7gWrpy9LXvyd/5CmD/yCVawzoiFFrONPP4Mu2MnL/hbvvQURI4NxEJI8IrCW";
  b += "Uf3sAonr9l3FQdicuw0vNUo58oAHMLQDFcRzHzUxvGMvkMuCwIFTMFKMjAkDpRyJSU/ngUnMXs9";
  b += "mS9jziS9ISQM9Xba2SMj8oTx1cPVMmN8jFn38vUPfWS+SQPJKrAap0SrytOpMO68sIdGTgt1tcD";
  b += "KWnkqJfJgct2jGeDZdyFrA8WoDMagWdDPOOZajMxxksl/KN0XJObeLPm0P5QHIpiDUngeMyeSwf";
  b += "zEGyY/PHxW+R2xK9ATKx8b6xM5z2tnG98eWx3og6z7r7qj/AUPiZavnLB71u+XR1oIbD2Ozqw+Y";
  b += "XhYdyJQ58EL/ZRXg623HF/8yijudQ9CSd16ZhVxZSWBAYJ9niWsSRGofJWT0hqpUj+nw91uLeDg";
  b += "C9K6jVN2rpGW4lCCr3sNKcydrE6HXKdh8HTim8yuO4tN9W+FOuzl+7xNANen1Tdglp697Xn5RVo";
  b += "ChDudeRaA+kglGTQs2LMpLJd3vZxso3ecv2QYHZt8C0q2ey/ahmlWKVXUzpXZSfyL3inoFRJooO";
  b += "DsgipaOI7azMHXnWj3Qv0+SiMCMhuNPtgMm7hVPKfqvsWXB2Mr5kaP+FBCXqtmPCkV/0e9JtHTw";
  b += "kuk/Zg4H02qpo2o50Qi4tbpc934E5kUroWfVBjUccJPKQqWICXQfiPK8r0YYltZUQo+68/DSdZz";
  b += "1B51odGGqI3pV3op6NpQPpqrcLXnIrSrjua6P7JrCioYO6zQ5K6Bp8vFfbI6GRzqsUSRcRaprqt";
  b += "t3w7eLR2zp2wJrI1rQodAwM8LusL3doeXyQRuRJtIVsHgjje4g6L88UblR4c5qVB1sTs0lu/zNR";
  b += "nof5Kv+l+JNxkEBLHlHJWy3Gl5p2KcLORoOTzUeOmUtNsPqtR3krXe3WI7yVrHbrAd6KV7t1NMA";
  b += "tSsGLizF30isTPchERGZ4qWA8zWeZxnRGMBYqWpji/ySyvbjfsHxnZUQbGqqmq3RYYd9HmxrMhV";
  b += "D3fE+Ck1S6Ty5Uj39L5HMaREwwKt42GttjbD4W22Vsdyy2w9hiLLbN2Kmx2BapL3+rCreBF99UH";
  b += "U4u0l5wn8qMdmGw76nq0oAf7hCeq9/5VKVWH9H5Rk07dJuYYuW50ASXMqp9iULppFqVg/8tdwBO";
  b += "D6t2tQcf9F6dQpshKMBkc/fy1JNuQVL6OZ7VYBVaN8ChwMDMEDORWMsQpQri/X5are/rKb9MU/H";
  b += "CKFoxUnMJIIH+Xd+S7+oWxW5uZEfSsiktQNkAuKs3ty/0Oy6GExCglIOuhyF3mwDlbhOg3B0F0X";
  b += "d0im4rQLmlPiPaw36XpXYbKTmxd9WXQ0sZwEqu925ZDih+EBE1NejiZ3rQpk1JVPxRLK+PRMhYG";
  b += "dSgQXPFcAW7+dlnTXWvp8YVmGI2kBRvfVDy4MaoOWF56iKl2vlKmZC5fmN2xjzRrTagoqZNBssb";
  b += "aQLnE/pjCsqOeu/ga0Oh/bxhMjIwNBoJZLDlfF0cJTlMRQwtUHCVe6JJZzTS1edqqdFIe6yJwMl";
  b += "2V2miyBL1EwLCjBZ3G6Yiavcn4s1VNHnIN03WFJejZbI2m6Dz5iQ0O1q3WN8p5HyAxhKm4YNV3T";
  b += "Ij8lbZyNxoI/GJnw+zL+sOdsP2wXgSCt/wrdrwJQz3sHCzCm6s88MCnlyjufL27fTHPJKZPqPL3";
  b += "c4jbEYXviJVS7Zp+MqNy5TloIiERaxoYoL8keYf8wqsjmJTuqqF4100jXzOmS9U25XNme2D/Lr7";
  b += "wAXbkW+Lbcp8m7wL2VbtQlbLK+BmNlYnyFJewnYiUayNRJNQihQ898JXDIhKq50rR67AyBdYosB";
  b += "EG5igA5nbZy3HsiaaNWEu+uXVl+r8GNt6IyhyksvC62x/XRZej5friHazss2G28IuC3/dp/tfca";
  b += "aO5rhXJG+ESV7kk/wmi+Ljyo58u0sYXRa+mHeQ5gbyGsCS/93Wa7dM0R9NwmRHRL/jxg3P83j+F";
  b += "JLIHhdY/H+TRxbHuMIMImu7S9/YOQx4W8/CgDdvGPDmDQPe3BvwtpwB74u5voHywJnvouWPwsvA";
  b += "dqroKZ3KRPDQq5eD4p/0xcLCYxp/aLoLcw/ZKIW0I+MnLGPHme5G3nTXqA9sYITxWz36arU2Dau";
  b += "TdML1IWuI50KWzOTLjrnk4mbmJ0cya8oPxdYmVF5I9WTQtNwNlYEw1C7n2d6L0eDfFEHfRoKT0D";
  b += "GrSB0g5GxY7Urau8yAz7rXXEsMRsqzu7sMPxybNcWBXUg8B2bCEDtipJWLO+GKxtP6TW+VkLfaT";
  b += "b3Vbmqtdl9cKkMJnjaudr+2Pt3D4KlK9yDVk6/Ujgj0SOU8d4RHeaKwUUUdlduo3EfJ9xict5Gy";
  b += "yrLRc59UZa6Uxq6o9Z8Tp9FaNP+mNVovU4XWjarPerGqs16k2qz/63SKrOyZKbLyFYosEttBlRV";
  b += "GARW+5dD7qZgcVmuKNU7jU1JFo352GvfV2tj6mGf+MW1PuTG6zvqluQ5/rodPm1+naqf0mp1YNT";
  b += "vQjUVWNzbr9WnnqZqntLoX4EFqZVquemqb4Q0jGWxiIG68sqgML1cqf/gC0kN+aoIuUEXQrNcDn";
  b += "dfI7ZU+s17n42531LeM0/hkJDSFwud61f9cV9pus+qeRaPqng8k1ndvND9ILapHPcfBgFxF4gRQ";
  b += "qc12qkuqoy/cTI5w8MOBDGe2TNcH+0NlmYWl4LlDUOJGRGPLBkKTykX10zyySYFB6pIYvNgd611";
  b += "MgIiwaeVrv1O5KsDXaekiyP24Feg4zijbtlxq9ofNXGHB6Uf6c99rlkX01GBXOciLfRFnu+6weE";
  b += "N0STCa0ybFEzG/paNIed6qDfwl+QXLE1u8zGgcn5aaE36I3zFeKZKvUuuyWbVaFFHXGzXr1QTSm";
  b += "efZ24+Hrn6dB0kT/KiPLOrIR3xkXkee1MjICiAauStykUUdeYePnPaR8FO512wMHwp5He2NNoKt";
  b += "wQ4JpTgE9cMlwW9DsMVKZcibCw0FO70mL7jz1OQF6rfMjkJPaJDiKFTkjY9DHM6IRzOeAg0eCiB";
  b += "T/uWn7vjqex7+50duasi1iN/14a888MXPfeSbB3aMyKzBnA9v0PBiU64lh9r5Ub560UeCU5V9NB";
  b += "gr/HiwSulYUKX0YvXSSZCyaul7zVjp+7Wg6dULWj5lQUc0X7kyV0ApGyfkgZObwRllJWVI9yI9w";
  b += "mwtGBWEY90uqATMDNep6F2L8yqe2mIWIbBvjAqW46Viu11o2b0K9ywv2u7YqWwilevBaM7iWNmS";
  b += "0dos7xvBcI3a9mtt0/p4YC4+P7pxO/4uG/4cwY/f/9idwnZ9oTYutRsDNnG7vqdVW6TvZbQZwNK";
  b += "RfUyG8d5UUSTPxphx3KzxOSvNGteeMXXmWdxAfuHryzjxg1FU9yxEHG1EnImIryGirRFTiPgnRH";
  b += "Q14gxEfO/rNDtgxFpE3PoNUvnstAaQpnr9N+oUBSLe+I26UO5v9zYiJhDxTkTkGtFDxHu/QauHn";
  b += "dYi0FTvR0RPIwhW/ygiJjWiTR8YjRQtRHwFERMawQ3944hoaQQQ9dW/fKN+/BQRJxuFkm7l1U/U";
  b += "hVLW3vNEXQbOYdcHYT/yZqO6pZTJeS5UGbxEoHqMkkdY3f/EcqB2lY9ztQ4rOjwFFCTaWh2Vu0M";
  b += "s5zoX0VxSrrKhM3PLa9O4Z1fvruM/knrNs61334+k3ob93t2JadsvRA+jzrMnMFLgJcEFQChfFK";
  b += "4jm0qkfPNRSStBi4jnT7dWTMNIP+kF3slWYLcwOTU/InDA0MZCE2DGjrUphEgYqAcoy+iQ8bh+N";
  b += "izVTVOG6/Oslifu6ApH3L+lgAAtQGQXOW5Q+lgvX8ZzE+IIwmpKuY6uUFOlrTgBsw15Yd2OHAQa";
  b += "bA7Q0SNNMqNNMs0mEfqd0DxPZmrKxeu4J16nqt4LGJjWO7OO74KHTtBxZt41L4XqicgEISl4pL+";
  b += "65Alq4SSnC7dtHzRXQYNHDhMpAVJrhtrbeNsRJNOu65S63EahGQqFJqw9HLTrAtu2QNq2kw8Dbn";
  b += "hxxIa33KJFCpiLoq3yjHXvSwHo+tD1ec4N7yC9ShEvJTs1vtb1HLoWYrwrxNDDVt2PtHExKosbB";
  b += "YFim9h5NDYditGBG6ZEVjucGpHVjUA+bCDPypFzk0Ua0IeQoGNGnLvA8WpIWjJIcaYaVzjpzTfN";
  b += "4MTQVC8iHgZkuVf0uKEeArsZXgGrDHKWEsOb6a/bE9kRRUQKMeyZGozaesAEoBaKZTgPyonOaK1";
  b += "dW2vL1gbTT8uo0mUUyR+Gg55WWSbQtaZlfm1PScxTPGVPPmbc7GwtzRaCQ6tc/p384LL3PJBXj7";
  b += "uQ86fceCZzUY2qsft409FC7viQKyRqvIj6LYy8AkzszPWIr1qetDr8wWYZ7qVamUjZ3fTV+qh86";
  b += "F6wiwKDnew9eeQRWRE60NK8SB1oUUUdzhVjaMMRJCeRFn4yyn6Eo+zRQ81R9tChH2qUPXnohxll";
  b += "Dx5qjrL7D/1/a5S9N/Un3j8emXT3P9aiH2XSJUSkDZn0jf9Yi6BTtEsmmQQWjrfhVru6lym49lU";
  b += "P4PoQ47msVw/JdfEdo/IrMhub+VEkCjXRMSQ6apxMewK3Ci/TNnPtfgzNq16Ln0gz3ynXxe2h5+";
  b += "/wae9Gou4p0lIS3v9Y/WwTo5kPPMZn+0Qj82GfmULyI7jVaQjJX3us7ksKyU88VgvabS0+tsV/u";
  b += "1Huycfc01NwvuPx+ukpON/1eP1KKDi/7fFatKbgvL+RJRmtaBm3etVn8JPz+aqHcX2MhTZ6he8o";
  b += "Hu2EbzzOTjiBn9g29nHXCdHoYLiDW5VqD/c0jcHwFkS0xgdDONrKfV+va7j36647zNgrQaJk9ff";
  b += "Z4baXUup3YuVjLxqkqzhXhfk71XaBFS0gUVhJouHpNeHJIHXL1KtD1dW9YUhEMnBnBPv4Lyy90I";
  b += "i0JMKShdymqCmsDtKfoRPdEisbLn/1IBaMMpFKbWPUXvVynOEvA4Gn8ucVEBI1Pc9oWAwzhcxEM";
  b += "h9U5bgVRtIYppESpHFgG8o9oEF2AyPzg7Y+5HEsSqIeW+PDQQIfiXAZQLftcNE4029h2jSAB8Go";
  b += "PqQvRbiO5y0WIv2TUFFJ7oeKJAstEHtogpa8wMVHLWRIp8/W0LJ4tdQA3ir2lRWQexI1Fn2JtKh";
  b += "9w3y1YQu1Ty2ltYqrW4YWg0zdKPzGStJ21b5RUxLEhZPqOjM8OwfwcqgEqFdyWbyFcOIrHBceWz";
  b += "bSrfq++JCEJ2dXqZ/ZxGEjygRjr71yvuYmwHmc7evQ9Tx29KgUqvlmwu0aJd1BSr9hasyphmc4y";
  b += "8/0IDzXyX1dlaPHsBHJACpTox7LX5iO8hdy6LQtDKDagLN0YgQgROtxFXoBCnSpjG5Z03mAsIkH";
  b += "i7j7RLkADpSmmHNDRUkl5AtR7bA7j6g/C0BI+RWk6jAqtwGrzg4BRhl0GmOtY8daqqJ9KhFt57e";
  b += "zo2MtRUFdkKSmSokXV1sJA+90nDl3aa5Rx9bzHirZ1hMSD0CIPaUAhKNtqtAnACG2wJXEAxAUi4";
  b += "FdnsWKA1aZYoR4jIB8lc0+CtlHJDEE4cocv4HEmuvFPK8s7cGRrWu0uA4r6iupyKY+idcyRVjk8";
  b += "trsGYSf95LOJ+MwVna8owH4QB4OrMDDswZ3echfkhsabYLUxzPHBH7PjHo5L8m+nsAYo0zvgz9B";
  b += "XjdsH+4h/WNsbbDonkazqkeKyFZYuNhCJjkfm7vYXHZ3LhZ+5y/3vlmC1SyEXIPDVRsc2wZH+ns";
  b += "zhOnfuXekzeFom9XodpVmqwGub7lp3mg2PhtrfEkLlGSk5VnzAbRN6FPtw8qtD/IwZIXQgpzQ6J";
  b += "rWFBxdq5rCY1xrdDeG6pPedkquR3j6+tg1WDDShftG7VjqbvlCrEInrMsVPfBATI7H4j2RO3tmT";
  b += "HG2vaIayt7esNrtDcMq0tsPB8NGbCOJ3HBp9Ex8lTRQI4eaZl8jTd5MIzdEKmOaI400+0wzEdx0";
  b += "naWJTjQSHRlJBFdNF2gidSXhoxuJ5I40XVMdaqTaGzZTgQrbFnX8lEXJHdcDe6JT9IDcqJ6jaZb";
  b += "iUzVc7oi8yETHohXdpN40YOZuu1LvLnvu/dGil6Pxoknp3yzagAWfEcUrwEseNIoDtnAWOnYaSf";
  b += "9kjvrJHPUjmaM+BvWLk6eojIzJwuFplzNn5sCXQBp0y22SkxeTeE6ReNuWjzmfFyEk3+St5dqW4";
  b += "Tko21fyidvzA1g9VNQ+lyJIQVsL56pJ2eUmZUB2YAl0oEvuXaM8XgjQcKDbYbauZQAG/7Nke9Wd";
  b += "+44EN1VPf++7Lx0uVIu3vnzXyxYAxrR65NOn6uLldkupShWoUvVVFKBzkUX4vtrKiloBz1p2ddP";
  b += "WIXR10L1KrQRgBKM94PKCkWz8IYGMbTxkqCAL2VBKDCG+EEjLUG1PAl8neZvzfk/+Z93S99dYal";
  b += "SIrD0pKFAe9tAyyUpOlSifPAq7OVIQ6B6NDO1AgpbZvGrDWWem5LayGdxhGwuVtIiR9DMO3Zn0S";
  b += "9uVI7sj1i4SZNo5EodmR077mrDpmOdF9OUio5QHGRt4RfcXoC2HSgebwfOjXEak/EzLo0Dl02+X";
  b += "SsrAr+1FGMUbI6JaNkbXQem+Mboa+EL1yHGMzB3wQ3WOd74hccUL1LlFyRqWzCC+uWQte8wguXn";
  b += "Q0TPNQXYzgYud6+8DBQtPQG8GIBEO3yOcpA7ym3EEi3B+/X03W2wmkkDKlCT7jBQiXxe6BgexN1";
  b += "P8zJA251GqpN1e7DaqzwK3Dw5l8fcQ/x7h34eNTzI9aF0WnrCBYpBeFh63gRwWl8dsIMAHDbP2s";
  b += "kUE40lcprx8EpcZLx/HZc7LR436bnFqvKX6cnfYVOkthg3iiFINUOgky9mfh04VWutAVUW3GDZ0";
  b += "dNZj1oiezjrNGtHVWb9ZTl8n672sb0/Geoa86IGX00Me5nhXYmSRKOowmQoa/reMv8NpvwrOD3c";
  b += "dvtzHFIw5+ek6hg5fwiddjFw//unL9VxbZ2VE7fmUva2TMqKWmlFayO5P1YUs4vpye9Lu1KkaKk";
  b += "ZCTq3KhfBF2v3F1zM34TL4t2nxrhQxPOATAeLeyDph+9u0by81NtJUrl13HF4OivtcisVPMYQXF";
  b += "znteTlslm77xFZwtK7g6EgFnJo56bGAnYyswk02v7T43ZH3u4dmvjtSdReTv9u2x9bw7khtco6O";
  b += "tPfoaHs7CnF4kR9ormObA811b3OgNaAO6lzMSOfK82InGCp0rPONH8eoO3JgfNQdOjA+6pYP1AP";
  b += "mgQMrRt3xAytG3bEDK0bd0UYhDx/4Hxl1XxgddV/MmkPuHW7I/XVzyL1jxZA7cUBe2jtdioc1ND";
  b += "7kXNF+vL3Djbe/bo63d6w+3r5lVoy3d42Ot3c1x9u7RsfbuxrjrW7s0dHG/ijH2xey4u0j4+1kb";
  b += "OIdvPWdrB86HVfxyUxVXAEsDyVMytyoVJsSzLTFd7NBYPlyKWzgSDlaqKKrevCebJRKVQlq/yyh";
  b += "WUtEclxwJb7S9mHg9GaOZXiQXKmMudASx0Bd0ky3wSsb1byyUJuQTxfmzDiXp+QcFH+QQ2/q6W+";
  b += "DeTLfsglhcVBJomy7uqHzbe5YgAO9Jgsw0nwCxov62I1HCPEII6rmmF8irujQIXSPEK6kxm08Ag";
  b += "22wEVbd2Xke49PDtDFHsfPC2ZZkdsMWWFJF0mi2EZuPjdz68WdeHAt5U5Xyh2+FPuKpAGTnUnHU";
  b += "bBJ+6e4w/Bc5WUL1clbPwp+JsKr9SkGUWXIoLR1YD8dIj34oBgmW/h0IhGq2h+qUIOfrvpF66rF";
  b += "Yt75izgMm14g9FwuKP573OSqLPTgcGpY/ENtY7Y+WGMZZcnKuN5dnJJL1sZ9ycZ917ISOl7Za3u";
  b += "5rV0+9j+nyFbMRb/mPBJgLPxL2I9J7Ahbu6KOfyviSTnYWRmfWSbUaJSaFqiN2BZe7IFtYrYyb9";
  b += "rIu3M8b9rIuxheasYzJ43MDYZbzZw0Mgcr88Yur3ZI0OwQM9YhkefRdQTCdGehPMLFvBKaxernJ";
  b += "Dof2zpJkPBhRaomlKhZdURexdxfTSsZalQR6KIjhBSptC8unsqajg0698fKjVrru3LrlVPkWGva";
  b += "RS+cMYNQjoCidkQpAqeLTrm1wfpTdHoUidXbqjGpIx8ytQFIRN+B7i6sS1ZkWTQ2y77VskDvZTU";
  b += "zqvfKXdOY50Qd58tRrVbeUDIted3VaO0aVP0W6mVwyam2Vjb1UGir0KBvqiq/oERiDwWnUGAdMa";
  b += "vropy+bE+jquNh7fORd7Qmp/KyL6ouJV7txXldlga9igxBde+oijAWraqsd/9ES/qvX0uajGtJm";
  b += "68DKlJb03J0in5cdmrUoFEAVsJXyB4ibao+T0TmuTvA/nxun2TRzwU1wvrgp/pkuj4H1Pbrgxnw";
  b += "uq8P1sGGen3wnD6pr6FgkJ+zQaKwPjijTzbqKdBxrA/O7Pfwc1Z/Aj9r+5P4WdMv8FP015CMur+";
  b += "WpNP9M/Az2Z/CT7t/Jn46/bNIXN1/Dn7S/jR+sv7Z5B7vn6O84zP4Sfrr8BP3fwo/Uf+5eEp4Qk";
  b += "q34jccnFuF27YoaffE1i3AmwbluZDupreW68qfotnZc6tiK4zNcIh1ThVuLWfgtqo8u2rLzelqL";
  b += "fKtk3szIOyd2lqeVcVby+dUsaQ5E16StgBmGEjM5EJ11tbyDFQ+xXrXotItyrw7ZWudLAvWusbW";
  b += "ipWgh1onWGuXtXa0VkgXE7bWFmpts9bc1gpcfdvWmqLWjLUmtlaQ6me2Vp4pwyuhrTXoPBibrj0";
  b += "UTiiuwE09zrdvgh6pjD3BCj1RlVGfmkKCOXuOS5/8J73hYIJqOhVLyq7KL13l9e9eo66RvI8fWO";
  b += "R253XRM7wjk9+rUzXhiHmInlSWeLEHJV6vnIAp6GR14s3KOzCYUJ4X+Sd1t3HwWVwLgmfWqW1QO";
  b += "hbwdCqpcdc5kbJiclHG6j8qG/YiPQ+VhvR8K0NHPiJt2DEsPpAqUSm0dnG1dP+yehqyMWgHgLh7";
  b += "fTx6pd9ZgXyaUKJyk2VZmEWxRWdMKFU5+D9M0Knul1Lw0JAIU/l5JLiql1UfYCxI7T+oV0mnOqB";
  b += "Xcaf6iF5FnWpZr3h++8g/Hrw1uihog58Xw+TYmx1xwySj4m2NqImS+Amc0cjTSkkPsCT0gwxPxE";
  b += "FHeeK9pLBfvN9S2N9ppZSlWO0hY51uiz/BsTVmwqh4VcpTC1XJ71He48ju7HmjcDfg3755I3c3w";
  b += "MrmbsBUb08Eo5JYFlct9Ug09PlmbYGHRuNU0V/HoZgHpJhZ204kKp6O9ZzHt7V4bT5oEHTqzVGC";
  b += "To0bJeiMLUHn1XL3cZogoleYEozBER9vrOykWWi6Wml7kO8OM/QttsVpSx9JfTV6FxUbzVH8DOi";
  b += "ejG1I8Rjy3MugRBZfy1x7+pHPLbflJarusrTRxVuwd46Lb2Z61iJ78Rh8sh3dC5Goi6vK7thklt";
  b += "e/CTgxpJ+wkqxIxsVTBFd3da9XPfItB3PETW7XjYdI+dM2q0qFVlTy2zknoS32umt1/zY9yBQ9Z";
  b += "VFTSujIjQ2txLgdAbxhkAMwIY+PQx4w6GZ08JJgaqAupZrc3CO2JsPk+nSwsEXmSMj92TId8SlA";
  b += "PKeLlGtpFJmg+IRuX+jJxtEzW1obefKUSJZ+gi+YwC9gX3SjornDjjVIc88Hy3K7NS0w/yXV7Et";
  b += "InPVUQApGLdzQKr/wOhNJdaOrKlYG8sd9D8vz3TdX3i4v0EHK6oJ5ovYUmdd80aZZ7EtcsWGzII";
  b += "v8CNTCNOQ+prMz9h4e4iZU1CKIpF4i0nZgMeM33yYzxu+oKW/uHCVa04cGCi4hTs4fr1xl37RRm";
  b += "w5DXR8XE2vOUCbzZbQZnjLUOwZq+VZIFnwytmE0JCDyd3WlV/Qib9SgRcDN0TVKZd8tU5SRKHMx";
  b += "zL2GwEZNKWxnaugqSaQSuAKeGqRVDCsFQ8AOfd7GK1qrELp4NjjzInqFxsYAe9F4OBsEF9FKPdV";
  b += "k1ePvOyhrtzpbOonrffcfDIqnZGGv/vReCf50deg+R9rP9ib6zMojHtNjNIzshrbROKXmt+4eVr";
  b += "a084NIHcA3e8zY8lYUBsciHfUI5dwOxDoI3lgPAt2TqN1FIDvZz4Y15hyuSgK96HGaoKuSiIYv2";
  b += "CdbtpjAkkR1406dE14yLnCKk++piwiRC3v0Mnf6YpRLa63lzmIuaAXflzJHqW1EHVOqb8MEY5nX";
  b += "8S7Sjt49k18ohF77BSenr9Z57rbOKmPCwIw6FjJ8BOxU1/zAQiLVbjiNhbaZti3QWNjZowqtZnN";
  b += "aGXD4Cmr2iicNex9IfdJXqDPSizi7WxrcM0/fENKPIm+jZ3RdkJd5SQCUmbGcTkTF/qsZF8W/5X";
  b += "GxO/x/ZVy80o6LZc8vSdb84vGspjYH60fxV07NH82Gi6bnTVzk907ohSE2hd4KRn7vAo2wi5XwH";
  b += "caKnLQKFKl0lyx0pa0wXK1CW5XRY3Lq+3wty1Zy9BVo0VfXRavmvRy6o0ibqxlcdFzt5XAVZnhn";
  b += "6DFGDu+MPVz0PmPP8ZuR+31ko4AHfOT0CDl7qfTyuLx8I4yguRpphcsj7igiRUyrVIiD9Y3eLYW";
  b += "qO6fre9ONe0YRyv5eUd/r0Bs3hsJ3I3uIGLmhQG3GcqLwhIZJzZJpGjepuXXjHH4Jb4z29RbWEJ";
  b += "Pk/LyBKXZic3yCkZpA/hb3JYRbNO9oHDRLJz68HDTjHmISl7p4N+LuZ5zcqfZ8RDrs3XU6uVMsY";
  b += "EiFzfYfDZvtPxqOtf8o3ZQraiAcurLWB0+aQdx8AklSvCZrtuZ9oUIVXJwWgnT7ZM9xE+j096W+";
  b += "CB1Nx0dHzgk3+I6PDp4TbqweHxk/mL4eCHXw3LgxAvzCN6d6UAePCD9w5tBXBvFZG4954Jcxykj";
  b += "h8LZ43LefHtysD+5dnNNNQajhB3bNIYj55QF3YHRAz9XomXMWIXgLtzeUWSWCOgkAdHI7wcGvTK";
  b += "00YMYZC3IdW5yjnW+Go6HiRKbey2JNirkU+hucWVf3vv8gzgMv6weqpVJ/U4EexsZXquTX7Qfqa";
  b += "w07v1gN7HDMSIS2iLfeUhemIGvCwBmJ8KQPUGwI6sVnSfHZrWK5cuIYC26WaX74Mh2AfrUO4BQl";
  b += "XcWzI3nNuetbHJVG2reGR4XOTI6sT7Kki6Ruycqvsv4Ei8M02wi9Qzi6doRzV4jED70LmP9Cd1A";
  b += "0zXr/QT1+qzLFCRTLcdB5IgrTsXM37C6Lr0XNc7dc33aL3tISFquTz+djhdrTpwyk77lI6SxiPe";
  b += "10BbQH6qdvA091q2v1qK1Fz19Vb6zAsVKsyom2FDTv4VaR1sMxdy+1Q0hj3VnPBcWHrSuUZuGfW";
  b += "1m4vn9XMCjkynTzDHeH1w3vm3va7Oy3VI9nDYSw3b2SxIKucn002aA0GlC2tAFqAjP3B+/7h8P4";
  b += "/+zrYThTB/8XOI6tks0KhIvJ0o931Jpr31ImrH47Pc53/NmYlHzSuEW7oOQU/Vw0/UtRPheoc3p";
  b += "1jy7FzEVwKR8AnOY9jXUeirxuITkvoCmG7jkGGXf0OvRy189I4DecslPHI/9HMqIHOJTGVsxAb4";
  b += "r9itpvjA6ehNInfnqkrKb0Bg6jKb5rpROl8UvH+2KCKURsTUngV1Hfr7SvTS+6eKUjZazIqM+jz";
  b += "wDmzbIlr7Str9EhPtpljtfYsc9k62jpS1Q7KupAs/lBXp37OxU4ZV52EzyiVcGv4O1ffdOMNl/S";
  b += "DFemudqncUMiKvPiM+ojmKSYtq9pR/tpGQ7Br1JtgpEBv5llq8o4MOS5b4A9VcZxYMu6rkyLJWo";
  b += "p+VbvjUyL4A3OVJcE5+p1MYguCdbqdTmQeTdRppltlwTPVVIZufopvR8P4GXvkmCGzNgTcnWO3s";
  b += "ix95bgNBmIutvgoE838QMozOH1EO1ub4OvPlytlasz1NxKrtboUe02nPMy25R0FioCBXfOinp6Y";
  b += "1q6HxVxzLKitt5YN2izIlXYo6KMV6goJe8WKop5hYoizSbCCSsiLTIrUqKd6W1VtED27y2XBOv4";
  b += "uGeBmReGbog6mw86BQeDMHHeSp+DeAjNmGvGSTZfM7Y0Y5cN14xtzdhiozSj0Yxh5+FIBfQNbuM";
  b += "Wj23cIN7HbtOmZBoES6iVmdsohDrouVEIG5u2tLlp+/Lopi07fTGkuKZYGo/v2brNPVvX79nszi";
  b += "TUPHabafdsE4092+lqjRp7Nt2xSbO5s8L+6PSP7Vp2T6grc1cbdn7YkIflZ91QbUvXDe3uAiAFj";
  b += "Zqqo7o2qmuj7F5r9CmNjcvrOEen0vm4fbPHI6+6lfnwiYxLtrHOlCXmOGOKb2RK2h0VX0h1rxdB";
  b += "Oo+sp66b9fkgahdfQidAaDVVf6ihe+HiqZqlH6Ow2sXD3Hv5F6eY64MLRDh/FaEFYTMh4bOIswV";
  b += "KypNGhh6TnmD0ovvLQ1Eea58IPRJB02h9u+zp66Fo2LzDuCMMyZ3qgc+ICP+QaabwUAAUPGur85";
  b += "FaHCs+4lAHh9QSJW626Ij1fQZ6UXSZl4l57s67A+6Or8e4viS4jhZ2NlH16OHlQP0sMgn6+jgl5";
  b += "w9EYVelouOWCQIynyOqSQh8o6Eq0U5YQQP4yaQ58aOBOgFpuT0oTv9029nvuJ0mqafbuj/p6E+3";
  b += "ySUh6R4MhpxOkq3D4p9swTY6L16hnBD9Htb6G/oTlibbAqXLiWupiY02U756lLgD6fIjt8lreCV";
  b += "MTfqTZc/fOeqjy8m58vZdCsgMYTrbQ1t7lj7Z+p6aBsN/u0GfMOiVnQZ1wmCi7I7TJmhdxd9BYI";
  b += "7xSAOFs9p01Nf3fAB+MV1A2RYiT3XRwsrZUjvdjgIE7V5S3tv7IrUS3x9yy+PoEl48ILnSbw8i5";
  b += "RiPdZL7zVLtiJVAT5050lF3gF6W5bAsluAMGtRuAWiRqDSnWNEtHiU8bzZ8CHyu8nvEDCAqAGe/";
  b += "mQf+s+EybRuY/hAvM76etIwVcFZeScYiHLcNnTzJ0xT5vUktmvHI7HZjyRyNApcKS4xo+HiXBMv";
  b += "G3Vk2lvYw0Dz7YP0QkBxxlUT6cKZByWhIfMf44pfUq6xpECEG1rOsafAgBtbHrGnQICJOXi94DP";
  b += "UUYX/ILUoZbZrsVKX82/0ae5iyJwo76hCFtCvPgObj2fGyYKcFn4809/AGZzn3lJQCBhm9k+Ejy";
  b += "stQPtyYZtcQb7tM3dXUbXgrgU1KtnlGxnwPBl/5fdvLFi4mbtk+mIRV0yStq3Ja+0hZbedyJcbn";
  b += "r/zy9kMCm8sQMivedIzBTUv71JoO16YMFrTLbwkwi2fJOxKo9qBsIoDVB2k5AhS+eIQbJYRUSZ9";
  b += "vKqno8TScF2PDQKMaMNIm1UMfkxd5UnleB4G6RInhGiDDzxQMuaEgzTV3SHfOjyLP96yRV6LJQ3";
  b += "vyQ/EYjkyQm3mL7yYVznXC2QFPm84byEBhI+RTY/HrsBBvHURgoGI2uYrmnKEY+eQjul0pA5rnt";
  b += "bbDsIVHZ8oXFiOndb7SmitfIVsp57GtdZ1zWpSJ0H0ymdsh7zNWTubYnrRGNE6neQpsb2ivyAqa";
  b += "RbYtr/Hkf7KUEO3rYLmkHnxsIeoKcDvyhGqibnlxQD7GTDElDfmInpQ+rJ5f7XtQunJnEnT+KFr";
  b += "t1Nht3uJB5NxIU1+jvuCanhfgcTnVA7h1yoyxfYErWaRMaGVGIrbqZUP9vdH+vljPu4byX9/7cc";
  b += "45lmsaMHhtk6hoq0xveKDMlRdppnw44rCNB2nEUyviN7ha0aabSCJ8xYI6otkKJzdRj0bzGf3eU";
  b += "Sm641dxIr4+eOXiHMywTHF3Cjo5ylI8MAyhagEzXqbUeSE1UdM8Fq92P3gQotlloOU4JtfV/wTD";
  b += "yWF118fl+sGP21PC4r/F8EkggtmnskBx+WG3gbfvNuiRrVr+fVY29ORSRD5XpjrwJpBvU5fvSfX";
  b += "m4o0QfKGm+Zb3C+V5BowKxxCUbxlOhFFMdI1V3RxQ3jb96KeHxQncWaf6y+ok6joaq/pgakC/wN";
  b += "aRbReOrr9A47ypvro37ypNCpKdH67D4yU6t6xrPF7EHDyynHKOFljxbamd6J6P+ViVVxeFYBR89";
  b += "E3LyiRYLd+Jqw3auMfRuA/GVFbMWlVqd7Qm9HI0Wz9QsdZ6SXyGyc/QKVUfJljlYdDjt6Weq+l1";
  b += "URipJHhEXxvEB8f5oGs4JqJYz8i3kG4idos2XSxv4JuRlfhoyr1MbQjNOtzlxc01a8NqtdCBLiR";
  b += "7+fOL5B+M1dY4UVvjFPNNytVntBXeNfOGMd4rXTc2jFBfOafPG8bZrzaoE2dLF+1MhvXgwdvZFc";
  b += "NVlqUVK1MxYmR3JHBugikJSeMTOxqlT4sPZvX6iMd5Z6QI3b2R2zwvRhj1HwEACKp9o1HFOxCxz";
  b += "O2GRPM+70Fzz3uL3GNExYPG2us0M+rNEnAu3j+qOyIbO1a4K0TNeRjdLAUnVNq8YOjb27hPe52V";
  b += "1cAsSFMZV8+kptprhr424L4bZeF8ac14WWa8va8ztqDQNxiF2oJCB+690BZkhr7SRdd7y9ooopI";
  b += "ftOwAxle1l9uo10Ym3jGyEMnC8OvQcpX5zbgyPjq9uUz1Tjpnbr+Zvid+Q1FIqcsjFzcPNGPo9B";
  b += "ST9H++uRfhkFmvaABkYZcGKEIuzjR3tm7VOlhnJPlw0IXu75eutHhIBLAdwIhvw29OKRuGhEIb/";
  b += "OUAyShb6G5i1dqyav6C+ioy1S9IrmoDt3rYGPLSaL7I5iMhzfAgVl/YVMPUNzn4q/IrQqJSOUFB";
  b += "oEAm+2jNZ6we/ZJnWILfhmZIWXFkO+8j5ZO51OTq0zRWbQnkuSaEiMcLhPb+wibqoeNNVNGGlxq";
  b += "6kj0I309X85QDuhaKCuRiiuiXUFIGl5ougHdQWXNXIHfmL+IZSUxnDgYoAJY4TU2lamMSzLhvIv";
  b += "k+mc18glDLi7Q8fpL4yl0evlgNTPmiCl9UFUEgQ2cAIxvOq/WKL1wbW9nGKvd/bKupa/CFAq40i";
  b += "EaKpVcZaU8Z4ToEVSJ0V9VTXxDJoF8tet+Rhx9hxPFHXMQfImJQHXAR2pzzAAYbcgdbxTU4wELA";
  b += "OvujHwDvWAXaEa4CJziFlnDi9FrC0xUDLSFX9JVawh+A7GhqCZ8RsuMZawlP/9iuZXebBh6QQtu";
  b += "UqgmDi2oF4DorDHjtX7P1ZgyRYbV/lPBui0wq811VVHmxOy0D+SztdV8kxjfg1JKBqJrSi9jdtu";
  b += "DMyqWXHcE8ONbxNciaOJyvTjz9u8PqpQvVzcMBIJfhppkymFc+LADZQPjr8v7uEO4XeT2IXOxQN";
  b += "hVFV70gh8X3MmvHCCpmUL4DPGHZ+cBACkPB+QUkS10TZfUsPpHBqQvU46WZl8l2Zgjt2vwgnVfs";
  b += "m1qHooLdYDBN3c9meygTqG7OTknyAaH3arPSAEaWxnVfNLxGRQwYpKa82E1uMEwKxl4Xm2F0dpI";
  b += "JpJBzwACxz344RwPvuGD8swncZ2PcZ5OXauDzg5Tr4ek/m9MVcxrlet78bHL/2XRXUa637GfTbn";
  b += "w2p6v19J/N6R/btexNVrmec7Q5qycZcQ85KItpfi/dVbTl8ai2/Cil6712y7rBszpGIwe99D+WO";
  b += "H0aGDpidTxHNRqVMpke4A1a1R1vUyx+L2wesHWtmnATaXRjNWExpDkv/kBfbdmix9CAVwoUKx0E";
  b += "U4TS8SzKrCKN1K0phFYc+clkfuCtMr+/AksDdlXcFhUfSBul+WlJjw9yy1ppXxP3b66sw7asGhP";
  b += "ULCZooIN8lkea1U/jz7rR6kUgkU/zQsC2g079snGQ4ai24bZJirr3rdYd7Ft+NItQ+KNZhJ7h13";
  b += "T6RSh8totQ+EMvQuGqi9Cr3SK02uo4tuaEq6w5YXPNeTKUTwj6j4ZMB632VnrodK58rDgcoMG0R";
  b += "DLQ74NCB+ZeA7nuKbImgPde/QRam+U19OC7mY4h5WsLvQ9a+EMm9XMZb1al1xB+F5WtOoRSjeZw";
  b += "gZWC6XqxY6k1M7w6yV/teUwG2R9DHOrBQOIxJ7s26lQtv8PaDOkDEzJoH3SoGRW5xtE9gWVoEC4";
  b += "PetAWBWWbQHc2tXMlWaqfDhbo30ieeAvpuMIh01SHIcD9XLX7MY/4hpxnVOuUVQYmXYm2H8fxZq";
  b += "HzXrsLXQ5WKtvIzxyDnzmgzTvnvtwppGTpp0IqAIA9oKQ5G7z3I9VF1q9aFZwfvPMjlbpZk+u36";
  b += "XU4dyfc0IUbqbeiAX0IpUftJmKabiJ+33JpR1C0yIbgfQepaAmrOw2s8EImhFKCCF66haj1X4Zl";
  b += "0kGE+nEwFrrapQnsZ1PrnsPgPrQ6Rqs2WtnSfa6yNxjVr1EpG1QnPiIzs/WJgMi7ll142te+wbe";
  b += "t22yHpT6NqVjmlaz5hzPrOcPfIJNnrDSbyhtM9U0JPamppqikOxGaZIfU3tmqZ2VVXwSxvurWFB";
  b += "RS7cAmbBsIz6GTre79trZTsoD74Sqo7DbNDCwGK7HQJ04CT0uUdckOElJsP2DcFjr2X3unwRBfb";
  b += "rYuyWWg+YrO3MbzzRL8DedKEz+fqJmINLY6/K3aDfr+RgYcR4bW7y6T7mAbwpEnePppGf19x8dF";
  b += "O8WhnRjZUqmJf6hQV45SFEhCtfhKzMdye/93dIWFCMqzxcRilq5Sx+4xt7gLZIv4vKxHrsH34Rz";
  b += "BuBMeCzvSLwWzdgBD1Mwy6g5y4D1a6koY6KQcysXvgjfshPxRu6JBNkPm2GxG1rYmHa7xWQiTkY";
  b += "vpFXeqQyhs9CbAOdTpY/xYGluLKa7zfQ/5ovEacW9dv6WstgnAfTPy8/xh9chRbkulk3JuM7C1T";
  b += "aoZqkkZJ6v6efjFLJnAL/rFiOc0fwGu1gflJcELwHK8UT6chOgqfCiKsipVb4uAfSLV4+pG1j4L";
  b += "EsyGG6rFv+Ujy/Xztd19AhaNIoJSgGcS98l0vh9aFVvoVWyhU7Gpei0cFu+sVUXhqApNbt5T36T";
  b += "vv4Z2rByuTEOgtdU1BcNmdDNVU01mhs3okVT0GacV+lRmpDZJcTRoatKaSZyuq/oKk1iaHUWVe5";
  b += "xI4eKKOs6xMFjgb2j3l4t2jrSQCuN0du9UKJZW/d1QmXiUb+yp0H0uhXsBARUw3p5q0SgT+WKhJ";
  b += "leLi/G1/EYNrJ0XzRbgokL1Tn4UIZJOV+k2fzuBWkPpiGA+R4ME0rfXJSQuzzJLoDrHjCbJxov1";
  b += "tY4WsnZblS1Ux7Ucqjq4sQC3o0U/Ff/B7n1kNiS+0rFqg5Ev8+uqiIvE6MYWoxspRjeyGN3YY3T";
  b += "jEYxu7DC6kcPoAqi2MawZ5qXWqzpPhCrs7lfvpA1qZ3wc1kYu0hDO7mM6Vp1WvlKeXHuj1mPB0J";
  b += "/KNuPcyawzTVVLXngADemw95JgN6ABS7QuBXXg6zO1VNWgvRUVu0I9kkS9sJi4eqM9vPAGtd6so";
  b += "hh6w1sfNz30lro2LuQCRX2Y5yjV8lNtJN0VuoNnF248IsONx6MirazPsWmeaE0fYhhTyEh/kzVP";
  b += "KP3+z2NNrX1jUL1/10fdvmAd3RgagPYi+LiMy5gICjWyZEorLmPzyJXpCj2e0R2OqtciBaBzOwg";
  b += "Auj0FldbdCRB6iKO/wOKeYXSIj3v3+1Vd2PCcaPdlQW15ryholxUDeTO/0gacPKydSfmh6o106T";
  b += "3arICTkzVnYPSZdgwHOheUAcsO0Bm0g/QQXxF5jn9ApvufrR74M1mA/4Y6YoWFRx4WHiksPPKwc";
  b += "LXocLDwr2JXUUbQVTt/upaBPVQKVQjI6SauN+CUl897kM1TtZ1RmdxPQABFVzQUSMC6j70HmBBw";
  b += "lpyLNA/j4RYdzsjIIX1CBgQMjFFlZurQZfRxuBXYq0IP5KxbX74rv8ECaQDXTq5RL8pDERnswfR";
  b += "NgxwEq/kKZtVUHWG2qu2nS3iFPX8GRz4ltB3E8LD1rcgCg7mNiTt8jLHmt7BP4q4FtibOK4I66Q";
  b += "rK1PJK4H19J6yNc54VWPCBaBWw4H9W4W+/2pQAJTgwFrRDUNV+NUIxFrTj4xxrYOBZA3G131gYI";
  b += "dLAXoguGIvfS6ybTfWc6ZCG5xV/lVoPmZEmKPYlxX+WywPgiPnAcuDsVhzpzIHQlo3sT5ri5TFl";
  b += "fks94xPvYTKU90imKfGsrLIB9RsxfxlB+NVV815HD8RgI2c3cMD3ZeeRrhbfQ8YzeYCwIKVlxAn";
  b += "UGzuMgQm4h6ZPowf+Bl/OtKyLlLuz6oONCOK2D9iIDPI4a1hnnWgo0lvm3w9xv5bRDbe7PiC/L5";
  b += "D0mbyqi8KreYWt2uW8whbpYvkFadCTf0OJNINX86j4+1Cjy1QP0TNrzZfUi1BmWaSTeg3K1MwuK";
  b += "uXmQ41WjLfuw6u27jrfOm1nuWo79yntL9sZj7fzb+1nYIUdQoKCFcIOZaCuk3n0xiItQZoCycSI";
  b += "1NMdF096DanHR06Op5oYF2J640JMF0KMZS6EtpJAptieiBdPGGWt1m/U6ewU7FI6E85mC3ojklY";
  b += "XkpYtOrblz5fmWi1dPvnHGuXbUlUvp7pYsjPSHENlmyrovC80+S1QRNHLLoWqQXzzIFGPvvQkGw";
  b += "yy6+8b5DcPWiAeBj0x/aySgDhSB7rqmnaQKPVwArbiCGTDsSUhjtQ9LpNNjydrjyYrNVk5lkxd2";
  b += "8KlM3iM48soRcekDKYqVPFTO8F3vJ3KYTh8RbrcpwMIPwHZMUrFXdlJMUnhk0yxKNA93LizbG93";
  b += "CaPLSEQUMc26zkHptB12sz5JQ37rMYWHIxWc0gy5+ebaHYD5iUtbBHfddM6jvsw4BOSZQItBXbQ";
  b += "s8zLpgIc895N8GWMFi0ihmOPYFfYf0daBiFyybceatTAglNDwZBKxMV02qvcSHNpsU8WsSLvgPq";
  b += "JIO+RmPiaAZ5PVROR6qNuivo6I1mD11NR1RawdnOqm9txWQnGmkDf7pB7203zSoPPwyKf9r/mbP";
  b += "v5j/qa//uy+6c63ocyqFZAiXli+lynZIj34lYPw3Wb9jQ4SmOqkUFYEWolRd9Ld4Vykov8LhvAa";
  b += "FDiVoguQKCCs7v2KyozqtAqzekiRgUo7rgcXIMa5nZ2lLjG2jDzFZZaEBAoTdaEaV0e+QnUE26R";
  b += "ZVpAZzw5PwWc8a4ueRdGhdSdGidrqALtrYnWsPXfwqW8fO/z77/3L6jbnXnvu0a988ralI7d95e";
  b += "bbdl23si1GBXDrljT1DkmjWqMYdb7kxLbYWUzyPX0pUnNwb2nhLKXVRLxLc+Pnq0lGVN0f1qbUS";
  b += "7SXiBR/628w6igTXFxbUJAfXW8UV8AoPWpWuBuMUYhz6dYH+8NBrFU+rNGRyGahr0gi1axjpHpN";
  b += "Kn+LL6bWxvne1DdckYUXj5Sz5C06aNe6K2oU6E4JR22WLx42TC9gs0zqo78JTatBq2acAZrMKzx";
  b += "d5dtxqPqYxxqZU986/2ewxwPSp2xdS0PNjAeEHZhqdqk97MHKT8QRaDBhTRiXOvHh2CarD+kyHN";
  b += "vQnDe7wtoCitRPo7vk9JmSjk1ddqpyS/X3YJ2ozQAzmAFGzfBvOFPRaG6Psw0F5ikaNRXteVPRt";
  b += "lpc4jCCUF3Yi3atvWjUtBNkO4ovhI4VrvPp0DtE9470FMwXKcuYAyRON8D3o4j6vHYGfQHhiTga";
  b += "Um2xWlH70uCMlFBu2cJeAJOPrRDAeSS1dQsNERmiTd6W5qJlLR94wnkB2f7hD9UuNqqqUEJsMHQ";
  b += "0wKXY0e7/zrLd0d797WW72ZW2PPAdBy71W3eHWsxXohbz4Sp4+iZqkeZeR0LHWmxZ2kcx1+sGUV";
  b += "UoLUWJDWgguUGXXNxqvSUGdEdhHXPINDasnpb/N1Sfl9F2TzW5IPnbm2ZkMaDpIjaZEGGK66Gxn";
  b += "4t34y3Yo9xFLLzyF2d2shhXh1ThyzKhlITIUmy0xyanqHXjj6vSjiMZLxXnuWiqB/7W7etHg3/l";
  b += "dZ86QKvnWT+CwdzSZ4PfoKBFGu3nAYkqmVvAjA4S2dODaBiJFgc5fm65+R6ZN+hl8NHgJbBu3lp";
  b += "9SqoZXhgEl9Jk5ZYh5gq5e8O8phtLEQOHD4Pxpw9+/sL/1E/g76R08PT8Hqn0qwGRd2yEFDeAHY";
  b += "/EW6eFrDc5Zfn2LEatmkfKSMZS6jETE+ywCTYMlfEFlv4AprsShtXz5JuTTo+d7+y483+HJt5hE";
  b += "cyJG6P4ihb03L4y2yA1boavPXWyg3ljpq8gvDlYNZdU58Gh4gLweNOKCcQ5Br5LnOsRypZYlpwy";
  b += "HRZHQmtpLeLHLw949nD1tT0tBbLMLyuWnPnC4msJEohU1HNnL9JhlI6sxgRmMqTBdlCtQJniXBX";
  b += "diTAJsPWXf0tv8g5/ZcooXgs9liR5QalLopEYIIq3boGpdOCnpG1ltkUmeIqurhZjGeVGI5TGvV";
  b += "r09SSKYu4shw4uvkxXWBd791cb/NVs0w9WubofrHLEDVbovEqlivTOsC/KTukJq+ne2LrBaro3t";
  b += "j6wmu6N6UMKdnpz6mNppV+ooOEXatwn1Lg/qKYvKCiQiVdb6QPKPwUtP9xD/KQH/0d78LA9xXhm";
  b += "S5KUOrokUf0CmZeLQ9RYkgIsDjEXh1hR0lgcwCpfbKJNZbwNSwUXBzIdDYLVFofILQ5RvSKdotK";
  b += "NP6Y6RxekYHRBGg1+9ln15i8EY70JDEy06gIfjT+ZXWqJJ8A51zaeyxfX/hAL/Clq3fjjqvRZLP";
  b += "Dvj561x3OLDJg4+xQ+z58zTciObq3VlKfYmfLF8mjxJQQk3L9T2j6tN0x1GKEZF/oaQue40K27J";
  b += "HS2C/0hQl0XejtCZ7jQfxsJHUZowoW+OBI6NlLKkyP3Xn5bM7R0W7PMP76t2bIPI3SZC30XoSkX";
  b += "et3tEnq+C30MoQtc6AmEznOh339Fs763vqJZ3/0IrXOhI6+wfdb5E/kMqEGce8/7v3nXkXte88f";
  b += "d7TB8vv6+uR3bB9hqGP5cf992SXPyo2/95J+88+AdHwu2y9xloPjbQd0f7UaRMNKEch1d17gb69";
  b += "1Y70LyKODxbKQEmdOh1EPcwMz95afu+Op7Hv7nR27aCT9p0iYl9zFzuz78lQe++LmPfPPAjp2Dv";
  b += "AzRkJT+0pAkV0QnVI0hfKlBfya3eI80Jaz7RpQZI2eE6nCiw0RmYwRFYYjiSvvQyXZZijqfVIwR";
  b += "CQG9C53dUpseI05VBYknBsrpNKOH1nQizDOEoHgloK/IMgiLN+ZqnhjzKnee07E/meFMGcHQawB";
  b += "UIb3OFIR9SIEz9FaEymJXhdocWLi1uaLWyawDTAjOc4Y8PS/1rLUqqikSyEh4xhpIhOr7MHahQJ";
  b += "3I7KYrG5QEVza74WZGtUHTWkHhzzbpcAS5pzvsBbZMGb6m1AzC3p7sQGO9doeawKpKBo69seNPd";
  b += "eOfKfVCrlzHLYLUlOKn2+8o22KXDwB3hDBonFDq2EllayzIN9NfQ55GUOnj5wyEyj4fvOyfqZjL";
  b += "85RJJrypsrPk/MDIhvUmRQWfWU6VZ95UmoWblP/+jHJteYYNg1lmTVmUa2wYQ2aynCgnbRha6B7";
  b += "Iz20Y4w7AyI4Nk00G5EU2jDELI6jMhmkoAvnAhrlWhU2wrsx9o0SggYJdDZVuiTrj8ehvy2Ssli";
  b += "gj9hNmhIpdUfAKe1tPXy5NBi6WeO6w2n+ryMa/qvZMxoPcZaQX/4XnD+pARlGIxQnjweYAGv4XV";
  b += "GLTBKNpxm0vlPJ3LM4htAPL+hxbxb3DocPStmsVMlHxVGYZOTvOTsphaz+Gr9lyeFuHSBUdPQBO";
  b += "l+nhPggi8m2/NQjnt1UYGLJ1m68uIwKPNjKFGjysUzwePzSIL/JJ11a9SpYnn47sFqVPtg5SngN";
  b += "EdtgXi7C+SCQLDDAMuKESzhcVTzq28KuDdx99ZZEMNeKUS5iVU8kfVT+1rYoXSBGfEodwBancYE";
  b += "FdhqzDFw4xGEHMUdCCx3YSIiGxnpLGaqLFPdE0EeO26oTfduwSI6sI9IrxLxqK6lpV/TynpcZEk";
  b += "ShiTfW51a14p27gigxxleU+76cSAPjXcmdh5C0qGwuI5vjTuZYWWmrOB9xz+9peSrkFopG6p+K5";
  b += "vRpoc9Rbr79ov3Swdf8OHAKLNRWgzO3NM32tQFYGGB8YiciJZ6D1P8Wk4SCz1FUACYUlD4EyWpH";
  b += "hZMiXrdb8z2NYVcyEIkWUXNrVvU9Z+ORn7P4d9iyGWCVp9fOVVfwCCV2Mr+aCYXX0e/LJHYqVnQ";
  b += "b62e0codymYBlGGm/obKBOvwDHvkxx19PLUifNBWC6HQ+iItE50iph14GZ7nLF0rxAfXhdrOQlr";
  b += "Or7iSabGmjbSlp1GyUhiy9iO0uYKgRah1T5dlQZavBidQHQaBs2UxcrHYuvwJOvpHyY4sMZkTu7";
  b += "eJgUFTTEPKrWxNUJ6QwReFnT/u/L9R1SHU33P/T/m0Opv49XHBpZ8uDAk4g/k3MpC+vsDqu4uuO";
  b += "d0k3/NbGWKfw05BX5c6fDdixucBwGRHyDYYS7sWP6gSVEV+Eg6AKvbVoGhzwxQ44OggwoMW9U+9";
  b += "8q1X6T5AMl/pwH87BqGbHvTSxgrbgvVXVwbd7yKZymwvqM1mQKLHzhQp9qqeryBXx4EnENrecvU";
  b += "NvwdJvkUo1a7qs/7qqnyzGlPpAtzdsk9o/JkcDZOGYBS2/TRiWltR9wGDuWdOStPo9aANGe5qg+";
  b += "COn9QTdk9ceH7Ny4t+HjcxDNeU6kQTznKZEGo77Jk2oan2p176e1NQ6jOkg9Y5KDqBIh2IzKIS8";
  b += "mnmFJnaMvGo/ONcNiKfNOPweZa4R1SZ43w2MNu9w1THJWB2zbZPbzTAK5V5iMNOBy24CjwUgLFC";
  b += "8rn/BhFDVZBrU5PFytpYrVlZ7cPwoi0Y/42SFmn8EnHXnEbBcL2Q/+tqJxxOwPOQdEfgbgySQPx";
  b += "YJ5mKfT9kHmgsf0qKyv/gpkBhg6ZjwlSAtoO503MSFhvCNuMFuMc5zVLGcBcJzKdKvsXfzegvnq";
  b += "4eAlfSWmoKqB31hqcXiQM4on+EVfQGFDfdgECh8dZP5siY4FefI7yBsHTtzKI7KlAyfAdRtbN1K";
  b += "HZXpyLZlzvZIcLV4BLg/sxcOBfv7lkNRCZA8D38/AjFKHef4JNHUDTHU+s1PWi5/ThpzA9d7b7N";
  b += "rxiR/59AcypFdJ6f80Pvc9+aofMPd9/Iea+z7emPuk7rtfbesemfjuR+xbxye+B199uolvV52nM";
  b += "fHd+epVJ773h96sUCUa+IksPmhFQ0t+OUphtD5IZKu7QdmPu+oblG7O8D2vl8+z9t+J99zTDZax";
  b += "1nhhl9gJSzycb9a9LDeIIf0TjGT4PDIkaic3VVc11aNV25mNqgxdXlqKtpGkRCyfKfukn6fLUXn";
  b += "yj2Nvje2EXP99cFWPvjW/baSqqKOyllUCvNoiCPlBN/idO3+Nb9YrxyOK0/GYIU3sFWYAfqwDee";
  b += "sCgQ7qNpl03Ym3qQlJ8ebNWa5wTo1jb/xiU78Sqj8zmrrHU511/bRTk4DPkO/HG7+QxJ/GL/gk1";
  b += "PiFcTR+AfKQ7tJSSJMRmYDJEAQjPRq/RPjQ11nPCypSkswntPYthh+ts2+JavsW5QEuE5eS7NTO";
  b += "4IXYcUfx8/fW3GXDClO+caO+dq2AVNM+ilhdUgY0bOGAmbnrn/ToOay+ESg+xgFjnMHbbKkwHDV";
  b += "za+Et3y2ZqHyTiBwRy4h4rkZkiPgKIvoawVH7NCLO0gi6vnjDP0vEWo0g2/o9iFivEbRefQgRz9";
  b += "MIDq7vImJWI6yOKV7xXKE+1+Fvuud64pk8lyNGLZsnu44Ai1p/7LwT7WC6K1KjvhQjN3NGYAkWE";
  b += "ztgb5M3XcYw/5KtyAxNEprGWEYZ2fnGrf1n3Czjdh0o49lS8tWpQ6nVh3G6yjBO7TCGc7U+EJOZ";
  b += "DuPUD+PUD+P8tMM4ONUwdjMn8Y0cboEbuNKn9/xkKzO+lXE26o1NS/WTjvpJR/0YOsqsilr3AMJ";
  b += "8yxW9FTuRwHZkYHciQb0TCUYePRjpv2C8/wLtv0B3IhZ9Gow8SDDyIH5qb3Z4gO48vmolvg11rX";
  b += "FfTeNV+jpfdajQ+VBsclo8zLymtqvrfDw0PShRIflYtyBP3jpHIprq8Vs/qgeVxh1WDsioGdJ+T";
  b += "4lBrddCqk6tq7ltxR+SfCMuDsE0JgUtZybLBWljsnnZsRafyPo5GHdaSl7Tdow7HUdn0y2z4mOp";
  b += "cpEBB9QCXKBddoZldzg/3GQPSDI0985dc9gFZcUrjUV+XBTe4dykyM2Oa50IvMUf5FpmcYdLPBv";
  b += "etWtOhP+L+BtZuqySjMpg2+QIxfaEhyodaHWD6ulz+WfzzEXhvfAJ0rlTcRFq663wF+csarIzKi";
  b += "erh4ZAvmS1Bldtr+Vw5quBrrJjNyatTT1/8n6FCrj0ahFXLZCpRffNtW8ZkFawgszqoN6W5CEF3";
  b += "Ckm6NueGYfNhtmCR8p0TaF9V/sGUp2ylT1LeKua/IAFaEl1gaMVSK8oDPq4V6Achqur2oCIVrkS";
  b += "V7wqtPZGEKYHUfFnkbdhgoXT6zKbl8w2JdzC/1ntRxsFvC5bDWiiKRRkotgSW6ziTVYiTNLi9/L";
  b += "iQxkdV9JOa9Ss2IyZFJumObHxd8ohoZ0J7K640bj8kgAv8ziVIV83srtyzhuSauKl0oCzX3qT/I";
  b += "223aSOH7ndG1oz2WrypdL4nqRIq/a2m+iKUc0oaJuYoYSMJWQogZlje9iYIHPCzIlmTtxRlfqoR";
  b += "GbDzMZnhu3PeKWOFAoikeyaJFfEXJHmitnqFbXhuOb1+DRIU7zXeI5Ox5WqhrvOA9kQjnaIHIyt";
  b += "Da91juYsU70XMutaVs+TI2IM6Ud2kHka1LBp6drwasuwFJGqF7Nso3J4qv5BindM6nWhPktYD4e";
  b += "VRY5WqSU6kui6/aoPe/MKmO/oEV5VbLLsRcXrk2oHMcD4s+n/Ye9d4Kyqyv7xfTsXOAOz1TFHod";
  b += "xz1ILkMjMMMwOaupHhEiokaDcLh5kDzJlhhrmA+r7kjDoqqSUZFiolKSZ5KSo1LMvBMLFI0VDxD";
  b += "RENzVL786bWaF7+67mstdfe5wwzCGh93p81nL3WXnvttdf1uX6fYejkJnrU7CMuGQfQ9BBhD4Ap";
  b += "gN9m7E4WJG9ej0w/me8CVDnmbudc3IGOPh37nm76nt+7XskJ7JGGW4VL3CALlSMJu5VhxQ3/EMK";
  b += "pVulB7JSMaQ3ISPSQvwHqBbsTaLD/EqTAHfMyZbi7AhxZkZHGwK13Tiq9MJ2EZTuE/JnFDl6K1v";
  b += "Vxf62ZDUK53OqeANT9WlPMVWsKFq7O+mYblRMX/ss0InHPnmhUg814h7QKY/9RjIxbnaXXlLq3W";
  b += "PwOSLvfMMkYjaorDkbdlXlukJeUecHsAKZkrUkT59wsIsKq+RIXXw2HcyK1OqIxJoOZsNLYIc1a";
  b += "TCqNXcngaUrjJCmNjbxKY4xJIoG1UDm8SyqHTVYOm1qgRYxzZGKgRVTsQvdKb1QgNkCB776EuDQ";
  b += "IFMVEHqly0evTCMMuoWSzqFLh/LEueKTlaMgNTqAbU/rfD6l3tu5376z4IHpnbQ6rQFInm+wMgD";
  b += "D0d/Wi46eps9tIivqIIcSeVAzRV+TvzlOcGQiSXRtI2iIchvRPvgosy1aZJRSDVbpBGWmKZwliO";
  b += "mNqiaGQemTQDixHQD4AXEbSMYxyNlyKHSiQlr+cJF92WGSQoptbn8m9WRLASsDhRBLjFYpCcSWC";
  b += "ms8ntDPM/WnMTxCQz2jD9akpGDz0kInGLH8QiAEs0K6fRrYyRJGsjQVzCMG8/UFT0U9FPFfse+4";
  b += "/MGIylX02rhFDgnD+pkPifAR3ApO/5beTcBcoUSrlb1RxKmHPt1ERXoxy7kFQ5MisP44LACVBvF";
  b += "WMI3AZAN8mRW7ANrgXJYgyEjPnYu4TcL6msAKoG0jHvBCGRpLsFcIgGqgbSCfyoWgkVah6zW3My";
  b += "XUuk4HvTe1lmnOZBOKA6PNbDQ5tf01CWv0CYivmIwgHEnEx3Zo3rpvyJlTwBoddThwOVfK6GYkB";
  b += "pTnfWNqV5nyDCjaAIhieJaaJ4BIFIQo2ZJ6D9geIiOKAp40TeNo4ytPGYU+bUWxtk/VhIY0Cze/";
  b += "y+6TCAcMPkCcO0xdgjUOHbXFWthU+zVBoOMphxlCbhnKYMQwZH+nf76tf7/m/+NV7Hv6/+NWbnj";
  b += "r4X73DBOQUOmREK486TzTocMGuOH4CmBnkYkz5bzJN+ol0XBRo9WLtsLMBz4XYpQUyoN8gCjk6u";
  b += "J1igVqtABneKlL+x84T/xx2HlwOPq8d4smkGUJ6kBdjHi8OKCWe094q7iehQUlsUBIaBN5ExK6Z";
  b += "UJeJdZlQFzgZelZ7K/wLTzrIar1j5pF6HSxtuxnStpsDENYdIG27LvSbyt7SKMu6LCAINbUlA6F";
  b += "KtSWqKvHzrbAO0lChTCFGn8V4pxYAoEInfSRaGl1EA2EliMiIYAvypCoUwU5BGQpSFFSHMrj7UA";
  b += "2i1CSI0nCD8rwY5EAmRcT6a6CHNJQe0kgt1w7wABbWfchRQhRBn37f0smT04awxQiYXCN5MTxw9";
  b += "q4mA2bILQpyS5E9xtyCwAtcUKaz4KDGdzxgp00ExRHLd0QIyRsCfqiTGMyLVaIgOLA52J/bG1eR";
  b += "1mdFsL51Q9gU7luidIpAacRyv5xnxAoVax1pDVEVE3UOwUFJos6GBBN1CEnlAFFno9+cRtRRdBY";
  b += "HCTqqgAg6zyJhBpN0NnmmYpcDSRfo8GHShkg6Ow9JZ6VUuHkk15BIBhrPklx1mMaziMZzgmD0KX";
  b += "L9Fh1xH0+J3OhD+eIg16Bf/QhrexeFle6shEvPHuKES4Np/Ahrtyjl+DgG4hJydtFzYH4hLiW27";
  b += "iRD6WBBebl9A0FbWQr1Cnfst0U2OgJDQOrYQOoHew1qb248Z4qavaNrEguGxWdYp3B8bI/x6EjM";
  b += "ZlKeGaDRWYzXZaT+Ed5X/89sqN8ELQqqRTwMQgVwrQqZ/j2DNSVdzvQhMrOrK0k2NIa/dUO7YJZ";
  b += "/fjw/iXl3Py3yYnrO81d2ZP3nU3rWjetE1o3FetbO50XWUD3nwlb/u3sGT6UckT631d/1+8EAzE";
  b += "rpdS+Dh43f9QqEhTL9Ta+K3wdsdxEKvYHP/s03lmT9uPyE+zqz/p5LOqZDX5hYwWX/K54Y4T8JP";
  b += "zda/huvid8fWe4iIJzM/zQdHOyQ7lpnPxRq3+CdVJ0pbFTuo98/2MyPNYjYGI4YJU+zQKQ4SzDb";
  b += "lv9Xg+CMcRfuaHO/JvarsXBigK8GiGfGZskQ/xWxE9rk+QuYjFzRLiM7aQ14HNEmsl0kL5auz4i";
  b += "FAjvJ5j09LHywAPzKgnqAKU8CAJY1SRQWp510ma6mYgRtXJolCwoHW09Nxo+RiMeORF6mo0Ucs9";
  b += "8KhLj6RCApi38Rzin42HcB3FdMgk3GlGESnwxjnBkKf9qRCNESLjqpA72wg0LPhh7CZPbHy8BoA";
  b += "UQ0YiVSb5LbSHGA0Gz5x+qbL9S1W9W1Bq+80DNm3me6793LM5opyWsmhfnUJE9ITNscSNlJA/Ii";
  b += "qWtAOtCYjgMFjHHdTQ46l6SgduikyyCPxgkmOpyfYFrkQpLwYiSWA69bIrgwNnoMQ4avXktoyOl";
  b += "BiP6Ms1opMWA0r+cANBDMEWNLQxTvOEVzB22j47/9PQXpTD4Tlu9EqlCW15co2y9mqJB9YXGXE4";
  b += "T2s9jgP8bzGgx4aAQBm20U8ULrbgcrGvekowgJKEnBttIOz8qRlkeecGQnyBYwjJeK1sO25kkAE";
  b += "4msZEZi8Ed0THBUBD7LAx2KoAMAz3JtHARzghcroMB5JlkfYzWkj+JVf8e9jLjpMaI5cldi5J0I";
  b += "Tyn2ke87UpCaRFADogIFV4PGSzjZRhuDUM8IYh/3evDKAEEpQoT6nZ4zTPyA+Cg5Y5hvuNfZui0";
  b += "siKVos8DgcmmbSEJ2aEOxXAGtLhYzqbB/xX1hGBXTDohz+wmLAUbkp8tQgqm9f/Qt/8kf/WS/Hy";
  b += "0oolhAT4IemVWzqqkF1NQkwtjJMLRSrBcKVRsNU6tC1Io1QZj0DlmwYfCHmH90liUP4hyZgjDnt";
  b += "ugyOIXinhNgngFutgohytG7ZNBQC53DVegJgF5NuldK/DgaJ4e/V7Bdb8alVP0907JImemicDRq";
  b += "BssfLEZqJq952o7Eeh+DbUUzUzDrBNQhKzUJYMnJ3YsgSx3SYIluvBCXG9wiCpVaZYsxC5f7Apc";
  b += "zc8vZqUmoEJ8kFv9XwFHg80OMSZbY5ED19/Nf4kGI/3VeKt4O1g6I5zyJ8MdBNQqyhzi5XdE+94";
  b += "ZpmWSXDi73AAKFEcY6CHJkMdltL6MwYecLahE+FRigGBybaKHaC7/uq5aEBjkNYdKPz4IiMRawn";
  b += "mKHwylxmMwtYMN0zB0mc4vYMh1zB2Ml9CBYr85KD6pCq4fhnIu8JguSCsBKHTkmUchBH19TGjQg";
  b += "FTQR60TH+dTL8NlJ3RxfrJokTHH4QTVxMeyt8JPA+Pbg/Ao/g8CmBI3jcaEtS6dIZR0D12UHXEr";
  b += "B6Rkt5wHlHkLfEuKhR5iMohBu9eCmAY7Vg9Ah2vEG4b0kLFybERWTCJSIMZVBUjdNoiiChhtzqi";
  b += "VEY5VdKi47gVE32BrevUAa26euzEvYKOLGXwYbDky+2PRhQ2NodWv0ZZjKBrcrnpGGqb8dkMEt2";
  b += "sauEg+hf7uyp+qj9vWq9t8NqHaUq2yA2o9RdrWm/8dnlG2uRs28Y4ag/Ii+H0GNKSWgu1UIhe5z";
  b += "wAyKYcssIiI8oCzkSQoZTJjXuJUbvOODWykadfDTw4OYHXf0UiRWJBMqoFGSWPZUUI7hWUmKYVA";
  b += "O3GQ6UeVNDiiqsg2qMoMqe+WNHvYD5GdryL2UDVjFmpiaettU/qGoCxJH1dPkB0D2JRhIMK4rTA";
  b += "Nsd4IoB59KEKkixlM66f7BokJg/XWxIIqnonbePF1sdA6oCAdjqAb5LIZHahMP6Y9MGWKniH8vS";
  b += "CPWmw3xGQyMkGwT+M+ubgb/QcihPTKFr4Co3x1toLXD+DEwZ9mO16RwC4bc7Z43dbgbGv5qJRov";
  b += "VVcjdAm5x0GZHT6k2BIJjIIoSOJ4tBLecJ/oZkS9cQj1JgZ4MTG0SXI4MnUBjUcxu1kp1BuLZN4";
  b += "66g3rD3XUG3Td8hhxAUOEHL0UwAK/H3cvseQwp15i+kUFPgZdn6Or30BqBqdaoKMD+jId18kIm8";
  b += "kIg1DmZPRZQ8NxG3BEdLagLuQo7DaEtnBU8HN6X0zFR6d0XIVQt1RQXMujjulkPLr/gC/9RuKAf";
  b += "OnBnLev/O7Dmre3x0GnK+ftayCHYR2MyHws0QTHkjjdjm5lmfAI5KvjAHDoH7U0m7bkXQeFHEch";
  b += "JG9Sy09q+QVafoGW72r5rpZfpOUXafnFWn6xlj9cyx+u5XtavqflHyu2qWNTe1j4JIMn6iqeajo";
  b += "mShExFofZX/de4HMOue7lIOb0e95D72uk2HvhelsXB06XI0GPazHShytphC6aAMqmFAgOy7+UxL";
  b += "o45fkow5PXVcdVkqBsVy5HKxKsyHafJ5u0E5V0xcu6/4jJEITi/N3GesqtaiIXgtVXCVp9QSvFi";
  b += "XQ7hGMy8Raw3DbJ4wopJIjJOkoMfVYIKsc0ivnFUYynjGCz9pitjTLGL9/0nB7fWZoN0JM5WLeZ";
  b += "5ZdmOd7JUgpI7PiFrVSFRcrLTk15CU0uYZNXIrGeha0IpXK/iWHgP/E3A2JXdaKrIkfTAvNQ8Oe";
  b += "MS3NJBOizs6i2MPGE7aQot+BXo4cBsSJhQKxIGJDAUhHt3N7vw9wAkQ0uqDKUCCAhv2wq86OYLi";
  b += "Ulo/vO01hiDKaqHM+DZls6PkQygjCr3bvQwa0ArHTRLghZF3RgxRhLV8URIgMIEEI7dNfhAw49Y";
  b += "JBrLnN6bLoMSleiFizCJzFVviVj/PlGOE8yhg5IwMksS8YiRu7gwHzsPfv6sbd9CB/7d2SBlwUo";
  b += "wPbPKQQQR/508FwAnXm8MR3377ZAJ5KYbPB/tUNsNPzt/DTO37ssmD+JyWs2v3zpa1ue67wZGVG";
  b += "Qyw2VojaE8X3KYQ1Y3Lc7/J4rNhrZ420Dwo3KuhJe8mYy2xRXN6UT1/Er93TOQ5o4T33oGEkWdQ";
  b += "kvcb1nDZtA8Lk8jQ/4AG/Y1wFe/yEM8P+YIaVpyFz7AY6zRDbaD7CN9h4jarFFeWHDLsoLS58kM";
  b += "bVY3H0UrLYwmsjDILAZgibLmM2bp+OXkJW2F+zHVMoKlVBW10OyoolseE160Of529YfmRtDqqtQ";
  b += "jyHVVUgxpDZ9BBrcKzGypfnZfUeIexsQLlKUcDdB0Z4jOMm3bPdbsBi6C7N00/0x0DJOlqTLItv";
  b += "vSWC1MXEBUmiO8gSvk18oy9uRsipsk5MVTZVhm47EAGVmfvadmPcLUVoIdJpg3mUcTNPv3iXIgI";
  b += "8PgNfesGvfOHnktXug9uP68WHlFyx/Tr7g8X30Yd1hGvumlLVCWjgjql8zQ0pZI59S1gxp0Ix8S";
  b += "lk7Wq0VVduZUbVdNOA8hpR9yYw6QqNjOdmiGn6M8LcTA9Ekrf7zxkBYAT39DOss0Uy2xIjolhJZ";
  b += "xnYnurY4656kKYnMkJJou6waXllAb0jmrTlSnzaOr5gKXc5WehPyODNpM0Qb4QRZvpCVLISwIpA";
  b += "5RJdj8IACQpcbQuhyQwldrpC8+V1ClzuE0OUOJXS5wwhdrkhHl8sSmNxhXlGWSPJDvEOzRLQXek";
  b += "TsAlTc0CwR/imPyF4w8hqcJeYBvNiIvYhhWHWMlsJGW88wgSsxA3K8Y6IuMeCYYilvIyvip2RF/";
  b += "JSsiJ/SB+fq0iMtaUPQL6Q3ZovyX4FFeeG+WZRv7Q1ZlAdenWkb1SxsU26SGbtJOdKunM7mHLty";
  b += "Q7MrR6hSZVduRO3KDc2uPHQz5FYpB9XTjhkEugX7qumkGgBsSLMDVDlA1CP1j/wzXoE7CmCzdnV";
  b += "5032rg7wsKcCL4zsUwsMSpWAeOhwmpghF+CiH5PiAcYwBWwQ80ha0bCmgkDgcHt0hzRD7MhBFYY";
  b += "KaxfBBcHw++bfbDGZYyWNN7Mv+fV6v0YTfd81Nm5J7+T5R7D/0A7st+sDnru619/KBoth/6Adu5";
  b += "xFc9fPHUnv5wO0f1gju3N8PtNUKFJQEpEIfmJQfaHf8h35fAY3f7U/c9oSxlwEs+JDG78DuoH0O";
  b += "X+w/dfisYHpaexk+a6Df57i/O5Df94Jp5GOR+2CTTQp1Qecv+K8q6xTfdNfGie5GRhlkZcgomwQ";
  b += "fI5+xcp9JwcvNXJaYrZAL2Xw4fMeUd4z+7pg6Ue5KXbghg5sbUZomRqSwoLNqgKiJUT0xDOwqen";
  b += "8VeLTFgKKxAjMyEztP85IjxzymaFCGYAWecjGNorFCnnKWRtFYUYrG0igaK+opF5Oect+y8pk9D";
  b += "hyHCZiAHa8JNpBc3fzd4trdZUpwpdfh1iEauNKlr4sMVwNXulbLQHClWyAjpoEr3QYZcQ1caT1k";
  b += "JDVwpQ2vBxplZEy3QsaReRhT0/8L3DrMfxvrIEub7jdEmy+zQh6Eu3kGrFDh2JcDjIF7sS0NgJb";
  b += "TKG6laKpXmsRpWmONr5onmI+Y9ATFHS4xlYk+hOyaSDJjMX+Nx+DOE8r5j+8QRfyImXUfsaVhC0";
  b += "KN0Q0HqmW0BYWq7D5lRRCV2Q/2KqKWIxb16IucesIMBcMF1TREfQJptnsGuHlqkdUsfzd+wVXYW";
  b += "ignPnublbYhRJnl32WSNEwUco8UvzsQ9QGDy8qsbowrKwpCDDPseby9I8igQhzTDNmEc2D3nGic";
  b += "S6/01zwGag22p5fNIMTFSxwVZ/ZJ/qxdeURdCGmseK8uk0RdPWauqKvHzBV19Zh9ibp6TAqFQYX";
  b += "cr2IYsCzlBRG4gTsLi7pIzhUuoJiuLpOZrl0SYsLsUwSkpD57FcNs3rlvch5cX1t3RsDL/rlz4I";
  b += "Kf9c/KNz66j4IfKbH0JO4jWsGqgOIFmhuQDZCE7LQxBJ01YsS22+xf46hgb+Cek0bbU/encQyqZ";
  b += "ihPb3QJISsit5EdQghogH3gGAWy10pbQ1AwC3mkqjFQSer3kB85iV/B+5scPEBs4chg4Z6T+p1S";
  b += "5XqB1nqS0lYHUeC0EHA4baVsE05k0OTiBIJIpqDGjd25DBSrcL0sHQcFLmLIIBCBo02s96vXJlo";
  b += "AgJ4ui000PP6c1IOsgd9jyW8RJ8GabWKOsIBVjHSPn1iSdtohOnkM5PO8HAeRDW+XOAsToA1GXX";
  b += "OvyaHfeqXQgRaWyAeRLDvgQJ7jPohCl1DhPZZUvqOEXnx8ezqOEVzbevzOT4PO+UFHimNl1DvRM";
  b += "1uD+bYvxBsEvUuSlq/dP3opo7gSxUYo9A6sheK9kGsxVDUiuXZAydF/iy965EB+0SOhPYHD+Foo";
  b += "OZtOkVadtAnfA0j04k98hYXnfBKv6HucgIbF3WQ4xTEEkzsj+B6bv4dhWy3aS95A8MuCEpO2hyQ";
  b += "ZmwZG07RB4kegh2EN2bLT96L5tXuvY8idIPVu8D2xYzm4x0tdkzD4ZiVcUXRN35gGp9Zo467uSQ";
  b += "wSiiaNdxEi1ghrvbiAJ9YD6pVH0eL81+8lD6wY+2IBtepMNIaTHWcR+4KJdwk6HqLZ0UvRmYr9s";
  b += "WpQNY3zxIUIrzH24ivg+6JqsENHby6xV4oiXCkokOOAqhXHCn10fhOtBXfilEGeKy/H/w3G89kD";
  b += "O55/y5GL4snokGD0HRCMDoogc9hKIAqUjiYlFXvaZW+KB4A7eQnEo4v9b7yJFSANuPpNyILHA4G";
  b += "pRcdfn+JS+kjBgUg+gtp1CUFgggBdSj0lzJx/MfEX+j1NIrolYHiVVwiYW2A/4ejZNHoYZkiMmS";
  b += "CdgHzCK330bNJ42MpQsphDUvDoWTx6Fo2eSSbcbxB0FXpkWHL0WL1i8+jZweixh6CVM3psB/4hf";
  b += "82zB/ZrdgRcbCEZFeXhYUssr5CmXyHYRheIH2RoC/GQxbDPcXcxqDpA8SGuUhA9xxsqZp7pFQaM";
  b += "bSHNvD7ZWinNVzJ5ErnzzDOC2SVj06mZp99LiXYxh/YYj5WLbuFkpRCQw8m0xQM2UwLcGhTMVgz";
  b += "hVTeRExGtdUalROpsB5rx24AMhM7YvA+AacF2gqeGUaUII7b/ivIkUtWgwt7WMiD2hoXAixh6xF";
  b += "S+RrLOFHIYiDT9qql7uuvOvKONrWKjtnyLfBEvzA61HBMEKgDMJ26RxZglPbHBl1wKTvyuJEpO0";
  b += "uh0gFvNcPopBqe5ZBXacrFemFx30UNM1G1j3dIFvTDl775DjMjx/q57xHe/R1a4XUn2KVKuwCa5";
  b += "Apv+nl9tZDWhdAUGvsnfeg+7Ar9m5mKkwUrYdhfy93+MMTrTDkinIE2Bjv4M6UJIk5XZP9R9G9M";
  b += "X3S3SCUjTylqu0gTTfvXdGHZFpOP8xuvuDt4oLiYaJkgrxENwlUgx8iNFQgVHApgHhImIxhnQUR";
  b += "Rc2nfgCo0zwO6YTDLi5HqA7t/AcoPzbX4pWh4ZmiNlaJ6JcZ3ksCrRmaNsTAiVVRYNRGeouAbZW";
  b += "X47k4jwbN8sTaTEbAOzAK7yHIqanBpsakrmpdLy9Cs5BqbodeRIwMZoLfDYCOJB4FfwE20R81Q0";
  b += "cHffSNCEFozcvQmoyZZOr50ESVUD8YLN1mGppyK2l4JHBvfUkVbPr04hS9atlN4s09spvVWmw4I";
  b += "DKyI0sKKeWSD1AMmIBrkg0qU6MANG34l4cvGVR3aZ4v0b4P1kArr9Vz1AUO1KuNc60sgy9Rw4t0";
  b += "gWM+TTDNIC9lgVjx1vJ90uxR+bI+1k2qYogHNYc2rBpE/ClkeB+ti4VwYc+7Yt8ac8+yQK9KXJo";
  b += "PLVChLsfmtEAXDeWtUJ93seO4YGMSRuG0YEkKgfRQwri0EEEKTVxPUoCqcklMfPbYbykFgiQ7Tw";
  b += "akZuoAIQjOQJVCDfEoQqoEaB7ZtEEkELBoPJq+IQwsfjwYGd2tuBnaIDO0UHdooO7FQfB7YYv1R";
  b += "wTKc+oGM6JY/pN8y9C5hJuJyUwmVNfgUHx9Ze2Kr9/4Ef9kXs6WVpLcmPn4FbgzT58Yu9uNtL+X";
  b += "EQMMD0X4VbQ/y3elleLViXHVL2S6LlrjcD4TOKvi59MxA+41F9JWQM0fyLVr2Jp4/0L+LPvsekK";
  b += "HaOz0w2RdJKxxvTCXBxnjGMzF4MiCKSQM4LQpqpXhGMGsIfew7SLHFtOtqiNHodxtnrME5eh55D";
  b += "XDNhZcbc35uFQdJxLwylvgChRsUUoY4OZCB3A1XFaKWFMzDyu/SfhNgzdmsaQHWBk6+hm7A1E8Y";
  b += "3m1nHpnOkF9EgiCW9rDVtkcu02Eam4WKCD7no4u5kU4mFkfLYTBHNVWx63BGvKqHzjKncLFrw5X";
  b += "2XkXpU7XW7DNbZoLW8Z7s3kRFnbLRxIlptjsYH/SeMwD91BPCbGE1cOmeAf6LFGFNoOGPLwlDRy";
  b += "WDtJa7GGp8C73UIPb/ZkMC1HixA8E+E7B6q0rCR4b0a9ESO+zxulrGR1ikl8UAyH6+y0HGdNu9f";
  b += "87LZqoH9uNfEFI0kpq7nvmiyKmlUVmY9ZkmFwagh7OFbShA9EPgAvNCHB1DHRZxVFGQVcFYBZyn";
  b += "9gv+DO0Fx4v4kn5ohR72wdb8+4vF/p4/4SUhSeyCktCyh/Qo4PYOnzQEX1IJUJR6WqjBiAYhRAH";
  b += "qchWwgjSGmUhLvNhHvtv/22z14rNj+9rdJgI9C1q0Q7hCId9FQ0E6TIV/CYqcp3ylJegnfEUfQN";
  b += "XDq+WDdB9sbKa3TjiBU00nU35okZRGbUETq52hSP5aq/EhTq6sRcNQIOGoEHDkCMRU5VgFOHJCo";
  b += "8BjUHjXW9Ju22714q2e3yy2MbHj/4xr8sLZUCWUtzkzcXcjEcVTlzwGFwOyoL/hgw11NKtmuB9D";
  b += "F1UQYQVTpEBk8AuijDqCKXED8wBNTxv7CiJMuRcME7ee3TEK2uFb8TsaqwL9oGl6BoeUpWJ+/9S";
  b += "4SViFouOXutih7113MVm4OKI7E3qioBFFRCaKiEkRFJUJUlKCdEgHtlPiAaKeEJCJuNc3BrO+jM";
  b += "YEAbW63Q463DGRrtVG8T7uNw7vib3E61kYRROP466UTbRRUOYm/I9KD8HdUenBbjQdmqgBnuDUB";
  b += "2INgffIxcQG4jq1erBXmS6LVS7Z6g1rRh21KG2hqDORasKFPmcZB4OMvuQeJMcXHB3x7LC/fHnD";
  b += "rccWtG4pbNxW3bilu3VbcuqO49ZjOrf8yhznsQeD6VU/0gNbcTcnwjTAXNzyB4RJhPm7X7veg2r";
  b += "xX3gweoFCKdHvVkxxq0QzuGcAJWnqsgtKQxa5B+nMtVgHZ+nqKBfwhN1+6i+rRDPYtDgJzudURL";
  b += "rc0wuWOyEZ4VYO/1/1a0v1agoIooDfgT61QDAWyKv5RID2X/By4srALEiM/PukEUTccAlyMaeQx";
  b += "9LBYjU5QPFTQa0NqGWOfoH0J2g8XyLBwBABJmmGLI8wN0SR2T1A8FrlC78uhcAgnCwKY/MlX2Cy";
  b += "MpqOjUPk7noJj9Vhx9ZCE0CKHfpb+b3uKQa+QliFBcl7cq4sIPisf7lUfUFdb2QnzV9B6if02sP";
  b += "+RImHoEYcF1kCDUwVDhha6hxxaVFR0WMq3ClO+Lf4c8RcTf3HxN0j8DRZ/BeKvVPyVib9Dxd9h4";
  b += "q9I/B0u/j4i/o4Qf8Xi7yjx99EAtC211PdaAdDt3fcSrX5yaRso/mNtqfsDuBokc/KROJJVMVVQ";
  b += "GzYuQ6ZLUOMr47SNQ8RUh83Q0okwiZKIkChWDolSmJeI6vn+RiaiVn9/Y0BErbyVj6o7efqsN0M";
  b += "oQwjp+RLHRXGfN3VIz4V4Ah2bZRg1ZQhEZSU0JxkKHatuSrkwiC803M2mfnA3iyTu5nq0P7k7j7";
  b += "+cB+b5zhAGLE3bcgxshP5yuN85brgDsnP0dc9ScBoVwV68XPkSyosu5blnU2h14vpAWG/05UsIE";
  b += "WJZdaw8326XvezkAqdKAyJ3dVzv5TssEs2OYFsnv9viTg7hnwLdoe4Uh7p2vRVB99dDABAyx83x";
  b += "ELbpegca+wO5o5ih+AcPkd08mX+5N4Qaez61FXdWgOHZbigzMr2tnnbHDbV12d6bKnbrNQyJxk3";
  b += "ditPhNjMCzFsQBuYNhGnI9dt9A/MOTVv+O+8PmDcPvq4phWyaaO0HIdMp8RoAHFEIfX1iZzEE3w";
  b += "gNResXpjLJS5sK6kRhaUmU6oLAz75At1ZlpDUKvJ6sZDxc96KEAuE6cE39+cFu6oawthvWuv8To";
  b += "OIAZhIaNNFIouBHbE0rHfTkQVmyQ0puSP0ai4t58w2b72/iHHiXynwQMil8k/tbCzJVJBCfRVQW";
  b += "EvdimUcaIF8PGwPL5+zUj7mT1yj7zlUR+85VJJXYRfadNwT2ndeZJ5g74UBdbSrjzh24MteEjTu";
  b += "fgzsvoLnkjqhx504z676U8Gh9uz91+ANW5zXWXIPGmqsxwBR6zBHoEEWhldGiq9HVFLGIOVq0Tf";
  b += "Giu63mtJGlWGMY/FXRc7GIf1ks4l8W02MtdVvky4qRnQ2IHWaQpA73Wpi1VmjW4h67ilXZLsfWU";
  b += "HPNN9xNlpzRaZuPJ8YlLJbweb/Ih1hXXKWgCQvzIlpu2SQRLbdtIkRLfM9dD/aoU1ePgwwTDbWn";
  b += "YYNKZ6hlYDA3QSv2dm00MIgVAW8SZ2ekJd4TPk3SYNQHzKNrDKdtuDst8mHEoxF0HrAJUzBvYpl";
  b += "taCzSGkVUhVuMzFVk6wpOhM0cPCvrPpvgUGrfiHky1hrdF3N2IQQqQ+BVVBGuiDEKq0fx2GSWYH";
  b += "TuQK+7hTCVuQzSDWn0kJ3MWat/KNbVpsD2FuoFxeLFjjoRvm9KuEw3sASkvoKdG5sxm4wwBePqo";
  b += "4jbIPxDGzHqlEZA7FcAJwrHBkoNCJYKpWNov0IYz5Lki5OdEkqjCOXZQeDLRxjwzjIoKBadp1NT";
  b += "N/AM6DJ1vBUZkE9QJ/574oNL/adgdhS2ph1BowzznCyJnjsBCkR84nS0HXWWisECEhOVq2CVmIa";
  b += "KTycIYtPfAKFy1pA7tulvJmEAvgMsg0V9jW5VCdlA0njnNA6ReGWsRs+QjasSb4u0DZZlCcuREM";
  b += "UEVKm+O5MaZ2DjbG6cvZfGGbJxRrRxqwfYuKeMD6N11w9wXKs+hGG9OTjWlTWzQ/Zqyu3b8BMEN";
  b += "T8aOEMbdgaPWIZtyznkkQcwi89bFCbueksGWRqVhWfg0TH0KO57WMMINo9dTmGOoQYrVIOM3iYa";
  b += "+Z1AoSrN8SwCOrWRrYXUUrfbRmG0NIouQDtp92I2oStmAwOdyLBDRIaFiPfDA3sVhGUkm2730oR";
  b += "OgyK1oKzr1mjsNm0vBbS3PedI84kCbOuJWQz1zIeXLbYtyDg2yNiCGaMkEpKN3BverYAExpIuJT";
  b += "4KOsf9egAlyXedEMiGBFn8Xl874L/P5nd9YDilGghtuxokTpvQQQEtIimUCRyLRDlMQdxz0eJ60";
  b += "T6STbtzEchUZJWg25bpHz0DD3qHkJRU6N96JNrrGQoDoWAgAOGqr0kAP2pg6rt5NEbiiHlPEbIF";
  b += "QwwJhDU8oFU2GcTuqgxytlHDayEvy8OL8IzB8AIl4V7lKB0R3w2ph5QyqI/2dVkHuX1fH2D7bgY";
  b += "UH4XjqokUugmay73KRnq1lAPpCMbSRPUaYZ5WE+Yp6CXFzzTAPB1hzSphEOM5IPw1WwEIFk0bzx";
  b += "c/YnotRrBpayHMkSrrXBj9KutzgVHHdqA/yEmIUFdvYYg3C9l5AFK3m1A23UiQDJh1clMa6Savk";
  b += "QHTUJrdyKhqKOJuZOg1lHs3Mj4bsn6NDOKGhFcjI73h+mgkvAbxinfFK3ABNbKBpb9zD2cZjUDR";
  b += "3m3mi8o9ULxUsF54FaBHGRPt9WekYxwqTLp3BnYFATCL6V+xE/kcJJRX7JSPIJ+7ZmfE8uDOncr";
  b += "SQbM8uDFKiD/BbjcGKlFGgISEAMh3PN9DzoEjYCI8Z7FQHR1xlNGkxl8xqj2YVT2pXHkKmOcU9b";
  b += "0eqU9z67GVW48N+0/kjJGQi9J4kn17/myzZw9aAABHT3cx0I7JvjyIDE2BdrQQyYT37g/SnICec";
  b += "mj/DrsGPYUWmOyWY6XuChmVMpXP/IGty1yQO4DGDKFAJ8gdYDfZBATL3AFzapbm5WCRlmvLvRvZ";
  b += "pthyr0jSEWG5VyXdV0wkKoxQ6V17K/3NQBCjx/hytWhfGiAk00NI1nhSIKCpGK2IitGKqBgtXcV";
  b += "oSRRJeZAqS7z/16iBNmqlhIpJKuNJXhMADzVVRQq3/c1xwjvcnCBnS6CsIGr2J8SRT8JBcSdwhA";
  b += "IHJwnamSS8z3w3GU+Ikags0Q4WN4SPOs/UoH8kXjIHOiDjDUFZrrhVQlPy7j8q694LFIq/7lZGp";
  b += "xQ7xS64vm9dj0KndLMaXmhwKKIKyaVdpBgXN6kuzNQ1+z6QIfzTPgfj/Y/xv2WbrsazFpVcZG/G";
  b += "gX7I/4vNq9DezJqBZCREtsXzxrOyowRDcso0DLtKGy44iBFY5VRZysZS93d+mhQmMbYvuymOxqX";
  b += "iNY0qtgbiIt0S3mFZSXejrWn0fCWLQZWdOGWv6cwOTTriUxzTsZgj+67Ii2Eeko9pcuQdSz87CE";
  b += "zaVMFBlAU/HqX4zg2mZ441nRqpuwiZ4n8vBxkedKshZHiXqCRAhgchLCHDJwGxCu4NJtT4FBkFA";
  b += "SuWIlD3wYT7Poih4ZXd0DQZtRyCfgCmu6CmAM9dUFP58dxX8HRjr8uQl/OekJfzHvZy7jXJCMl9";
  b += "xGEvKPaqVEB4uCs4DMKXZBC+PDfZ5XKPqbtcpm4KkR5AaCBPcO8fxWofJuiUIUHAYsY3i/oMW+Q";
  b += "zvOOP0mf44f59hmt4KvqvwHsceA+SR3sgaQF5FKY+NHOuPiO6mHJPSjtaRBcCvXVZGTucI7qYFN";
  b += "GFA6mkTbV3uemYtA8jKh2GFI2utUArFDCI2NvrzEjo66QuQy3gwBYUABM8frYgMEUS6XNyLnKJM";
  b += "i9Q5F6Szwn3d5aKfJYvbBvJTJNKZsph2zb8hmWmN2qnAQfIYCcn33OvjZVYaInkg6mB+zhY2zsg";
  b += "XkxCeCubo813P61C0UfLilHLW1bcKc1iEHnPX/m0ClbvAPLuRjkraTVcGzVg8gyo0KRzyqRzyoR";
  b += "zygyfUyaiB8M59ZeYdk6Zec4pk88pM3ROmWzq4FL0RpLdShX7uj6YiL2iNq54Trz2qDBzAPzEbc";
  b += "8F/MT650LMQQ/cKsiLeLHlObShfvI5tqEGq+fnchEvVgQttXVnATTqY+n2N27alJyB6rleowni2";
  b += "UiIVGsI7wiO2Pu/57DkgMhtyLoJs5AOhrAoERBE5v4LyX0NHwCfoqsH0CIwR6IWxTo+zAYlB9yg";
  b += "ZG6DkvvaoCQ36ApokM/MB8lppJuMxbju6Gxj+RvuZ3h3NDO1Ue3EBi7gzo/eNuDRv692QcqiKNU";
  b += "FbVHWX/Z08pOdge50VgfGyFoGGiQTUiBoFSnDPgXj9tkgRnIoKI5NMi6wlMYrBBp2oLSjYggDsU";
  b += "LOQu+ZbCbimwOawRAnxaTxsfqeMOtyJ8wP3s+EGfj49D51sMdnxcAm73sG9Y7d9+y9PXf23vF+Z";
  b += "u9V2oxBE0qxGf7JmIGxR2CswS4EoCLI8qPDX71a9NFYwzjBkBSqyN9tNKfh36ZGtCUJF0N4D5u4";
  b += "bxKltWH8VDhCwAKWCFMC7Pxq4MGmMCxYakQuHP5qcPe8nKWjJvcBWnub4JvA4O1RA2b6coiJ55M";
  b += "qWWzGU9JxtI2hKFaMDwwYomSM+/WI2R5o2R4E7YJ42kubE41PkGPyFBmYcgRK5j+R9beKQ5IEMH";
  b += "f8j9ji73fIN1U3+rMik8eKTB5LN/ojs7wrtfbg4U/0vPu6hZGPwSaZlXzu7+OYBG2/JWPF4H1A3";
  b += "3cfIjoFYSAQFAK09A5o6V2kCYLHHHBP5Zpg/ByOXmOlLsVY36hKZfQKqyMbIMoaJLpGuihO8nWT";
  b += "9UBkRFiD5vgUhALwuePTh6UT2XRSdGHM3eQEnJfCbfYSjaIOsBIkfTfi9l4WodWAVfEAQjoRYJH";
  b += "uj7mlItUMNHZBvF5/8y09TACu/b4Y3l85H1I7lv9YtmP3j7kdl4DLAVsk08Cgj3RgAyYRuSmcMg";
  b += "b1sVIYFCjGjtkJ/zygh46YAcveszv8b3Z1Oa01bC1sZtOWNP3CcD4mG+litFIvAQt7edgf8H1ZJ";
  b += "FEA74nUb/nsjeIDsTfqDozQKcASUuUOB/J0fx9DslfQ5U/FSyxiA44lpdfwYFBUXMY+9nR0DrCS";
  b += "VSTORM7bmj4M5OUc6KhT8WM28mMkl/GmDpGqM/deBOOB1TlKzhVS3LG3jaY0Myhe9vCQn41Smxk";
  b += "hgH1SKA7g/T8/qO+/Qjpbi+67v5OsDePk0HljkKRwvrMwzoz0+AwwQHxUeRBGIFliYSMnGk4ky/";
  b += "SnZ/Pl/qATslMXBAFPGIuH+BgDOJnHAcnNswPfj41sqpWH1QHHDuBZ2LcDA3FxOELp20Ex7kw+T";
  b += "jp112zU5enROw1fQQuCZgCxE3AbBXcNaX54vU2KJzjD0jG/04sNc7fGChQSSGGKN/YsRbCk046X";
  b += "a7733/IBvn85b5FwfBnHsq97EcXsLKAt0UB9i+IJDf/kLNmafTeh8YSQHeUJDTLz0dTbsG3AFIZ";
  b += "ARyi1NPjsMsWuwBGMjvXA9vZYSniY8Cgx3CPsYEwUY6KYEkWYKGI0Hky4lCjARAElkphIqkhJTT";
  b += "yPEQCjCY6ur0CQGi2mZRq24LjYqXVvLjFOcanzTfD0SkqL3UGoncYpBpHakqhuSSrbet3RNOKF+";
  b += "oVUsxm/EBYQhSy8BNogL+MXphPihrc8nfTENTTLhNSgC5elY5O8yzCgIvRg0ht0IUVHFLkYpKp7";
  b += "mTfYS8y5cxmoni+EjfDCZcuq7KTocukZGhhZk0Zym8JW/NwQpJHO4XCn7OIvhnSLtHayaUMqYLX";
  b += "plhD2ouW+llAi2qheliynv5NXDDDQoNIBL3/VvYheeeO9bCK5Bi7W3xvoDDeIa/ctJRbYfG/gHY";
  b += "0U/mNYQVRn+O0+nLTzAwuCKGLDs4Eo4r5npSgCRa5bng1EEdiI7c+qd0ZlEy/DrUHU9NdlNVrDu";
  b += "oKGRZkWUzItuUyKIBggxIrOpEDWj/eFSYEHgEm5OCAp0OYd1NvTh0hqfroMAeyGUaPoRE/SlOGQ";
  b += "M0xJxZTwLUbCt5i/fR0J32L+rnU9jNglPuOOH7Dw7SJug4rS7g8FgsB037MQVlFFzsLjdWjWXZ1";
  b += "Im36aDroSf/Mjop6baATx9soYPeaRppI21u2PkMjN4CplZCuMi/6BdEPvc7Ibup7XumHL89wNH0";
  b += "Qb9nRt5Db0dm0M2rDpoo0fXBvW3yrbsOFWrQ3d6z7ANmy5XbZBYvdgG9bc8QG2Ydczqg0Pam1Y/";
  b += "yduw3Lg2PWdFHcrsto1JAQ1RlCGgxDWyyMYgwniq4BllRGUQkETsy3KuspGT5YaNmiypXWVGVhX";
  b += "+UV09f9aktuSzhxdBjgH5bouyPCR7gsxNm4SlJ1SCdt68Ehx5bIUzc26V9hpk45KdHAx3atN1nW";
  b += "jMuXfpye6cg5/FceIAgp7FsMhuI+b1Ae0J7v3UAheIoptJooJgPUFh3U/TPmC7liZ2zHPKg9StV";
  b += "p7lHc3GsibpNQCl23SbWgUMOa6PWZIJZKjD0lmpVJEV4a4MGIma0J6WBOyVAe69GLuN4HzYwAu8";
  b += "rgWQ3AzSdDIS4FZwJgurigKeSngPhJ4Kfgc4Twe7CypZX0cndfYdM65O+P5T82uDQM5NVds2Nup";
  b += "yS9fP1hJAcjKgkAbwQnd9jcldLMMMIS9D1w4NgzK0k1CvO1JcpJvWRCEjG9AADIjCCVmi/fBy78";
  b += "GzIa//lEJw5s20DssyAC3wD1mNOclK5qzy47mbHeiOVtj0ZzN8VBOqi2Ygsr+uYjsn12yVy5Aw1";
  b += "1px1xaSaa4qG+txqsCjI4Npsf+67f3kDVzKVgzP2thLlgzWzJEkWelGpWpQR+YZANBE6P1iatzV";
  b += "1wCc0ZAxTxbDDVG/jTctxOAUOouj3vgWuS+lQADdJgzjaAaXgGArfCxq7on4SIz28Tx6F6b5IdE";
  b += "G4vowvFdukD8VVGPh+GSRT1ZABQVJB+EMKm01nZPSnWELHoN5RsEWxlKiUEz7f9UOkahToNcs2x";
  b += "2zSIPerTCJkC5X1MeFZTFwPuVTYljqU4bGCtzWS55bugAY8fbSQxpYVNE1dgEO4ku92DyDH1tcq";
  b += "RVwazh9ivzrSA/ha5Mlvs9q0SS6WJDaRYbCkUOc0h7L/hZgiiONWKMdJSxmD4rTyFaQ4p8UE9nN";
  b += "T+JUGyesM5EkqSIuSCeAK51kkN4hvioNn8pJgRRKTL8A8oSEcrIRewh/xcm7UL3mTCRY7htwUSO";
  b += "4YYFExk2Nn/LLjTLj9FEfsEiuCEHCZyWiAwRuRUHQ21JbNIOD48qlLNbHsEMoSE+Iy0jj2pRgHT";
  b += "3lxzHDkSPb98gNq7/tUpYG4/iiVb9yGbzDajwUnKFYwKNDUjZcGD5zo3ScICJNBRVMMQtLZaTZO";
  b += "wCqIqsMTxaNfUHYoXuFe/vg3pJQyRiiEOzwyYCVnTCdwHbHMmeRt9amkanrz5o5BgKdZMUTQ7+Q";
  b += "KhbJN2ZP7DPwbG/K5Z2QrJp0OWwzwZKo/ZFWI3bF3w94ueiqFp23FZT6t3wiHW7Yc/4/wwClaDU";
  b += "0KwKJwo3LPc+2OyvNgMZKh6DWOxq9OZ8MeFugzLknVYHG0Yf/pPsOGnrjpPQTuk3aYwnWhWmcQl";
  b += "Nawzp2ZkF9KrADXIh9Jsteq3EUV0WHl2CctL6y2XoJtlLNl4lw3Pl2PBk8FJNeR0RbgkcJQi0mA";
  b += "yRqizN4xaEWO6t5BMuhv5q6TzrkuspEZFhDKy5faixjbAam7XaeXTYrMEWNdCs+rtFGJwWYXAui";
  b += "qqmSezO8Mame50dgGGx0jmLkXevs0kbSwQ4HhKPJ+A7pBKW4CINDh1BC2iBMol0lEkk20EySgHa";
  b += "QqKiKmQLqawcCYzcJitHkWhUqgfd1LEuHL6CtmgTHXJF03sIgFyzMbPRDwi0ORiHAj7mIZthnZR";
  b += "oWcyOoqoAGWteH++wlopX/GYgr9jc3yv6+oztxoA/4+H3+xkx+IyNA3nFb/t7BZILBhn3Gcg3Vp";
  b += "IPFV6DShJ+SVnspC3J/U3RQKId4q7E0qKAwZZf2AqCcWJ8LIgsD1Q9TBHcCFTkBd4dpM2cg3smL";
  b += "CLPbvbve0CcxKthcTsUWsEhWC/3OotDAbt/sjn+QWHKX/MAxDbyr4KnAIM5izs1IDuh/YY5g+w4";
  b += "zCnYVOQGW+FfF/8twn+L8d/h+K/HmE6txAijXdpjiax/1NIsohqhQVMrID6Jk4delcyjUjfcf8X";
  b += "JZx9/i/n3WP4t5d8T+XezgRdsAWGAwJ3066kzDH8socykjUZxMSXb6ieXiIvPiIsecPoU1/d2yt";
  b += "xPZ1uz/i7Ovk5l39YJ+Z1ZMbN0UwqpCEbobx9DFJlSv6bE+XSCCRanWvk6i/P7lRBmIKIBsHlER";
  b += "pdR4zmLM/ImS4d0pgnpaB6RThh2AdwCgULTnSJxE+ZdK6MTg7kmGMmwCUZS2VIYBBONAopfa+YV";
  b += "SVmKzCvY7rku/2n8M1udxl6WUn2exu7z8eg5vCt0Dn9ZVzYgXBYCglpNJ5hDYRAAgBTsszA0zFh";
  b += "zKFvjAomKlgjAwYNe/zFS9QEigXT/gRmUicBnFCvr4h1v9bDFcSk5LZlkMWugYrFDWhofq8CTRm";
  b += "GQYJbNMHgSe8ou0JGqNChbsY94CuAN9hG1kwBx4V4ObHiXNZNMlImTEYt66009FDG3MOt3rxXXu";
  b += "25mIUu9ZlWHFQ5RcJbI8uDiE33YTPYWntnUKGi7bIkZxMGThAebIYvXrbgT95DeO3gPqevbNXlA";
  b += "vsV3SW7cU9x4UnHjpTSzDsqHbH0QP2TVQ/whmQHoiFREQZMiCnIRQTzF+1ANRXVC80IUuCkpcNT";
  b += "LwkBLpBVWXn+LrG5VxOukgigKo6w4lQzEIdbIOXkOxIGctqBb/63Z72kblt0HkPDJCLW6N/H8mo";
  b += "1SXdO9MVDXMOt6bngR9mnp/9JT0tr8NwOJDhasv4G+YHXvPsWdD14wN1doGwBckew2oPcQlMkpU";
  b += "MCBDFal9PAGIV4htCCP8Jcja45Hk4ObjeLg7igHQygARvfRQQHuekF36X/B4nmCAxCtnurlt+Sp";
  b += "nuvGt3D1q54dePXvo/XbXjio1S9/8aB2znao3s5f/Repet0FW4L+q9iGBJfICTA3WP14j8EZ/Ah";
  b += "IT4mJ/ZajnKfPyjk8T24Vt9rA2QFS8aUqYyhmdO2yW/2Cpf4uyBqCdQ8hq0/3z46cjGeFcBdNWk";
  b += "2KfkwLpr2gmak9A6k9gvKw3K4EriKFlSjOya/F+GRLfUFaX9HB6CF/CQDPKxhrU56LJXQGE4gIG";
  b += "fyhUgMyRWHxivMJdSgpqcSz1RbGy1901Mn7bOAamMay0uizeap9NH5w6t16AOrN1w2nHJzmbjtI";
  b += "3fDEAaj3rAgsCC8tQUpKuxBDrTYNfxgXpZtGgGFtaXbydP58YDbGkjY4g9lryZIOuhJTTcbwZK5";
  b += "grx6/X4gSj4r3EmsNpdNIz4v1dTHBFqQNGfbJ4AWIdl8y9I5muDLwqr++r1V/KRx9FOio5RQiTh";
  b += "LUsJGO0ihntOt55WeEjQNwlCbANWPuyg2sxZdYcploOCdB4V+ZxMhJ4uoKcfKyJTDhmZJUn33q4";
  b += "fh9U7RXBii66l4ZoIgzVsuMc4PoO/upFHbfdfIpe78YNljCw78mYoPNElI1LdiCEUPJCg4x6b+8";
  b += "UpwFx9NBs+7aHowkaqlp7gWczT4FnlEKd6jv/phcPF+OwIuBwgNiZH6WAwBvvyfA/WJsMQoCDEK";
  b += "QyQD/xZhk7o0oERSZBBpG3N6XALWO7PADgBuDAG4MBriRGnYGuDGUkp1CeHEwNZzEYSV76nPh45";
  b += "A8Jv+sQPySxGRQswb7+DNomMR6RjlpLlePZ9eZOo2M5C/y22/aROViBhg0Hs0KHfd5GyJ3O2jNH";
  b += "Qvw6igauL5Lleb3px8rl04yQNTYRnwVI2o8S96nwFeZkk4130etq+7ov9ZzQuoMBHb8scJVjMnA";
  b += "qtABs2R4jaTPxgmmLHolrR2IGZlEx1fWYMxiUVwyjfIfC52xcD1mwcHLtKVPUOcU1tSBk3ahkuO";
  b += "aWErbqb8UKPmZfgFvk8eYJzP8QVgPB1ZCWc/apwFrHPP8VdvBiPJpZdUg1joKFPaw5cLZUeNIpI";
  b += "wo/kkgMTJ05AKDVxpMmafQA0XuD0HoxLP6RU8FkTt6K9Tkg0S1lOOBpRwPLLGa7bxsC6F4sZOMN";
  b += "cmqQihCmxCmHZ6s7kqCuMJATV1dPTRqJkjqeFmcFhGuMOq3GOwfWAEgOcANwXHMscQVWRtQvLjl";
  b += "f57pZCtwc/oS4O2KTWf3liDQNxnsYj5tOnMg2Dcb8rq32LS650w0zgcq2QrTs++HeeuLZZulqym";
  b += "kfqbbanZ/ww5Hjoo4WgBrg8JVkyO2w/5q4l2rLCnTm5mvQmup+/A+1ddly/ryNnC70ew+tE8Vft";
  b += "OUFZ6Rr8LYUnfzPtX3ZVldsKnG6XAUc/yWt8VIl7u/AnIjTtssxV8AldQhgyEqrZhkcMd9B0wh4";
  b += "rCZ2JCNm+pn8EDnw5zUahyuk0QufIgTwmDnFOnV4+DWQ8QD+Z34xXykzI1wWIb/usHmyl+Fc3mo";
  b += "//o32fxa8H6rIGv5Ss7ohTvrVgb22OtXgpqdgkSw3cJpUc0dnllLCYcdZvJpskUOm5tvUvLpHMC";
  b += "vGaSZMwkzA0HySQfs995HHqUQVg2Uc+LBQDlHZy3HoLdIOZeadoC0fHtp1FVb9rVRuaOxVY7GS4";
  b += "/AHu6/9gh3/utw0f0op8SmhBmXQkaSRmPblr5GY1d4NL4UjMY50dHYlm80KN4Cr+cI9totNttS0";
  b += "IZ1OYcLYZOIoL4AuFwy+zNzTh6SlfMWJjZa6XmQrNID5kGsC9VAjaiJsIukMz5Tg5dgdbFd7L/9";
  b += "D0AbI+TcV94Q11f9U7m8cCHFfp2unzn81dIH0CRrxDSrrt3NFsW4ZUPHZAhpHBv5aVEbTUFWytp";
  b += "MNGIgByMdmzqEBAklIdAv4BQs9tCMNUJn2jgeUYkzHZvwpfJMELvU9GFpu5H2LKZF7Sxrju1ADo";
  b += "wTW/9QJ4ReDJJHRwp9/5IPutipCiS8M6ITDwfjf20MAOmDKOhxFgVVZ1lrP9qoABw9PO4qJhoj1";
  b += "Lw7Kx+FghIXf9ceBkXJdb7YvYd9OMTK6N2T63yRp1Zw1zpiah8V59b6Up5aT49oy5AbBTrpL6bU";
  b += "l4ExnOJJLdIL2IonDflpnJErySsgSR6o++9DftTGt5CyQpC/a3YylCqSLS/QYcySuzPycG9M0wa";
  b += "RFnSGjRDx/FcuY4ZNfPSqyxXDNiOiswtXt0269XF1juT/RGelUTvnv351Dxj7Ql3TImvXzUb4SM";
  b += "nfudKJSRD178bk9hCs1tMik1gZZkfqQS7Rzp3FtqHN4mmaoX8e/QFRDGmLjJ2k0T+bTDfKtQfA1";
  b += "6cH5zgKJZTQwm70rJmknxANetnMNXv2LOmlhYYXSd9ITd8fp2eQSj2fcO+ITzQ83I0k+ShtwGdy";
  b += "QCMS8JsqtDRagWg+yQ4Rk/CNQEZ+OkRMKZ3OTivHhmUr2bBY1KGaKYskpD6tUz3711VBVfvd6zP";
  b += "kGTWI0D8Mt4FPJLeAAWJxQ/df6XrAcG9IYlwW952E+ypDNoGkR+x6YD8xkC98dWDNmqzjTQYWI3";
  b += "U0BAgD+TzbEVmkLk9qzDvrzKblrBrR1pUxOswMVushC7My5tkhK/4X4zrBMc3IsQjDOEAGqNeG6";
  b += "/ZfUcuwsOWY/CyaTjRJ0bVeWcjSDkWOobgzbQLy5/X4URqd5efh59yZGlasVF+IXvUwxr3Z6n4j";
  b += "TocPMnGzmF/y2IUVAfqL6cqtIhdVZc8Y2AKaZLHykaWwLxtss9IqOgKXiXZoy61pukIiRQNUU9n";
  b += "k0Ppz70uUaMEryBoPiDup7hXTDljwtXEIHuE7fhGfJmSyG5wcCiI6zNPbqZN4RsqACw5B0UBU1K";
  b += "WoubBpIyghXRBi3KgoCVb43AshaxMzHta6w65/bT5mnDeA6eGzWWpYDHCiDiYbCqENFip2XwMwb";
  b += "IxGezWqluBcqckjQQNwMUNaEiaZnyK/hwL3TTsA6FascU14jcG3DKefYvqkIm214amEmx2e6pfF";
  b += "5SI7NU9bIBAtNsl1H0C7q0FSnifoylZm1wENgltyIOqYRB5t9nQtVLpcrAVoaN3IdCuCG5G9uL8";
  b += "FLLOO8RwUNB+AKmYiGyWNFUi2aDISrZ+kuYzgRn6SpfUyXhUZ6Pr3KZQ5NIOcFtkHC/RwVbDRkQ";
  b += "V3kgZsOJFRxR6BvZMClqikyRHXLptieZsTAtrjaME1gIX59yxcB4HznyPJkKkReiYHkm7PTyQk3";
  b += "Y4fkQ6foey+HUeS3yMx2omGdC+HcBdGEN0C/qE8GGiUqZ2SttoRZ6HVs9onGqfoD19BTCNphTDy";
  b += "k62I7Vnw8Kzww7NSJ0cp+ArYPP9uywg8FVlNn1uAUXTOQbxtptpPj7K2REBv+wuID/yn/4J0NGx";
  b += "B/i643vOXgJHt/Qu7eQfnSr/9+cpbsj83v7WX/jyJF75HDmqeczrS34KpIm8oSMTcm21iBAV1x/";
  b += "utZyLH9GmKS+huj+OJZhNklW+MtNd//RSyoHYxuU4mk5hcI5PiehVe4wGnAtbzaTBVsxpCRLE0T";
  b += "nkCWZZyfO10xdOEVo1FviAGaQTda5JGilaVjYtpfSwdhmgW6+ehHn39TIwKbkrZHu7rjhzy0qz7";
  b += "oi0tq39vKTHNiftBj36YDweGDBrJqiCEkVh4xJFooCqfhBfVYdYMdmCL/eMwYboPmx7dUNlIUfi";
  b += "RmfwMmtFbHgf1UbDlxQHMuLTdYfSdkzUSIgl8v5wvnRQ/TpPvKiEJkTrGVMAROiWXR4XZI/jG3t";
  b += "vEwrshJjHAdGqRN1E8QE7QtbAkBiPmGaM+mKwfSGJfu3c6IejZ6mBPusTK3dAwr0dGAOIAopCtP";
  b += "9jXZhbI5GlqYnaqKs/nuu84kjk3UD+TdffY7r8c3QOrOvSVnRjNnYPUPhnAZ6EASHy29omfyn2h";
  b += "6f7IITafqYLXkfqkaJnhzt2Hp80TzP15OvCFkE+frJ42jo2EQgZnSwyDjGbiYlaTp7uTdV9Degm";
  b += "fnwAm1GLPXnqKgQejQYVQ5Ne1rBXC0ExJW8PYNBDe2uFBUhAUgebaYrdnA8NWyqAHh8SMIYQ/D4";
  b += "5vKS9WmGKnEZNiC6c+BVAoyxBlRpA9wOwcbxsS+5a4MYSRMkl07lZgkGa0enAn4vRye9nIu5eNv";
  b += "HvZyLuXjbx72ci7Vxp598blvhmJNyLq/ImzF64Lu6uPR80BPHrCQI3VlQ06RDgj66KTNJ7Y0tyu";
  b += "LeV2bTHLaeVzu56QTyn9lj0AwjPvk/8ayJNV+Q6nAZxMfQ7OXe9/cN73o4Z7z/t/9Gfvv8H9Pyp";
  b += "OhAsVLQ67N6gHJENp6Awl8vGIxVSlgquKvXI/p9QJ+bgaDPjTv0C9zx7b8P57rP9HT9DQ5W3N6h";
  b += "pEJGvjrDj30Oo6h2iboHS2RqAncXTVC0mVnrIigXD2661jxBhD1p2eeeeF6ditQA8ifYk+maCiQ";
  b += "hBRQRiD3GG/XvVhPXuKIq0ICE0yCQYxCWL/2LSRj6Q1m8idFwn07ZvYWuvkqAUfB1rcuZGtrImH";
  b += "LKA4n8PJHqWIdp27BE1fGZrHJO01StRWd2ecZzGJGpJyCp+ELnskjSmx9MmBFDzxA+57cTS9z/3";
  b += "s9/nW6ohPr0U+vSaJZRGMpvf+Hrgq4CswiDlvQA+CKpIexCt+8KTIMl9/B/emp+A34VmRywpNuD";
  b += "L9tfeI4TnP0HaJHG2Iz0T6umc3sjQQrwQ1/yA9O156/G6VqPIsr1WyVfLIB6pOaiqTqdJ82hzy1";
  b += "v+VrWADLBWALDWW/JH8o1tZySz2LY5+0cH+tIJObmONspUqz8OCkL7oW30xHqUgNxkuA5elbX8Z";
  b += "vACxowlgWnzkVbCAMMrBsqmp8RTTDyBnJSigxjIVZf2wZzPLXyvRfo1AmT1aKezva5JjtKTtlNs";
  b += "v6hDHRSSuxJNLrwU8q7fdgDAseDo87BxlpCoMRcKItv+GojOZ7kNxksu5f48TyJ67xuKL71g4oH";
  b += "nEC3eAZU2cps9dW1g/F4gR+njqa6BFP4SeWvNozlNjcy3esRmfkPLjXmnKQ0M0lriK1x8TNR0Zs";
  b += "CpSXhI1Hdrn+vv4ik1gY08u7/7Wx3O+ogwmTgKZNZPxqGMzUKBOIl84lx1/UBD2r6/3bHw16OPN";
  b += "r+a8p7/hfE0O53flcN5ovb+HynLJBnFq2iTK5e1OMDuh8ScjkLDJ1Mwhuk0UdoA0lbJAtZX3PT9";
  b += "y9vKefX9ibJ4n0Lpnh/7Mmpjcvfssv30fyz+9j+X/p7/ykY3sKVNjPdfEJAHVZ/k/7mP5Z/KXHx";
  b += "dopP0eMji2UO7ct62y3O6lCNm9JoZvuM9G7wwzV202Oli46ActLWK8ALPE/Yy45G2hr0/YqX/Cj";
  b += "9QnlOdgCpEVPmiN3K9aeczy+x61v+qjdk//o/ZXvUn3hEZBqb3dp2PKkUUspTzqSe0A5R2ErelI";
  b += "zHsbxZfRl8FeH1hx+z4+sG5fH1i+aR8fWPWn3Ac+md9j+nJyHHay7tXKRLLfot8YeNH15oCLXqN";
  b += "qHY3ktr/RIJsrtMfAuL8w73LCW5UZykgLZdW0sPxXVrGDKm+YNOeAjU99khVFMwntQtCBa6Rs3V";
  b += "aVkzXSqAh5ZxF5Z8qYloLYukhNxFGBdiIIlev+yWRlMKx1+EZSRZRr4E3kej80bhuWZVp2ikIcd";
  b += "zCCbAl+uZnFDZyd6dOWP4J65xN+7z8lbJoGoU2qgdH5Dkua5zfmzpG9lL5tX0rnWxJwbLOFn4Eh";
  b += "x5SdQZG/+rmNZECIAEYkOSNIh77fkW+Oj2eUkSL/B2RwZIZqtOgEjcnYx8yplEmUijQDUUR8ISy";
  b += "S0lnKFyL1iQg9icM8XUp6tlhSTz8iX7k/JXILjo16GKoAGO9C0IHvY5Pd/5FgQcA2h30H2X7BRH";
  b += "bjoR6QY5IkA4NVHr+XSYysCkEVuc8ljJxvw8NjnSUhGb4omzx6nwjjkeEGEwQjWeC7D8TQqpDH8";
  b += "Hjsd//t9957LzGDQqKCqAeqcn8cT5NjT2HK7U6KtkrLYrGuPbPNt9p49mfTMh9ycBwCSEdzhpS6";
  b += "Uhxkg0yW7Y6sbKZSqZvu1yDm59eS7uFoHvBTSx6yn+yz5P3mgIv+zIoUHRkdV9E0bWjd55Sf54A";
  b += "+KSY+acAFB/7t0O2TlHJrklJrTVL0C17JcoYqZ6hyhipnDLy+Ut7+ADXS8h/g00Es9J6nczdAWN";
  b += "mflAbvXTvEkjjUf0X8uM+SRtUAqBKCwhfzBpcI02aChnjUSpssKrwSwdQlnYUYTX2WvdUaeNm1V";
  b += "K8xkLLfzq13ZFTsAB5iq+VeYcNewYfScQZFh5oxxIhCLJDdP/bccdEdiCM4wwL9rXJF2Vup36lS";
  b += "n1BTzpF+AeTAZ9RIj2TcRj8e8D2Eyk7Tk0BXxbYzA7Eh8ANwT8jxmUTpL1ulEqqCh/6WdKbzhLB";
  b += "zJoQEi5AkuK3IBK3ogOpTFqb+IPbDEkeb+5hDGx/5PaWOicjvTN9zkV51fyNtAGgns3lTJE1Ul4";
  b += "xnwRJgPM+PiS5SUUt0eR4TDsgi9s1q0VV/iOMuy9ravuv5YZ56+n7Xx3O+bdUvxSQ8HD/vhzL+Y";
  b += "erYPFXxPrlv79tLRUGhgU2Yj4cM1fDu2jgd9hYuDQNLH0d0i4XWfmw+BrHPkJxwH7PJpq+EFxkr";
  b += "GDwM0qkW2Fpbbti0HyFVJ5n6gDglRfjxavW4aGq061+It7LpX4qclV42zakR0vpTHpdk5wxhqsF";
  b += "OyaRjUtBRA+uSYwyKOu/4F7YqOlKdqTTlj5aE252TxNUdXwGLu0+njWFY10VmKh2dEe7VSPC4D6";
  b += "jZkFvkeiry4F6K/Aw1ae4vY30X+TPVcsteinyVivza7LvI1xORyVuSU6QaS9y2l0r4m99STTmGs";
  b += "aNiOb7IQbi4j7HAB/q3PY00XGMb2H8evRSgwD4uiSHdfcuQSM6kj0bOwboQIF3Bo8KadPLlaftS";
  b += "z/6KuOw8i0bIU+J4oJJG2p5n3bkMrYawiUn8nLATe6NnzlQz+xkndQCKPNt/kZ1Oqv/GHq2OF6y";
  b += "nEfBZEVANIeba+nvHn8Q7RkRW3Jo/EtzbH9WKQ8/05tRR8K54B2K0wWUThWaxpw8TvQ67CUES6d";
  b += "vAY4kaMFF3+v1WO0WnSV8DjMNbbAygUPKDLTRsIIUGDaTQRwdYUz9d+aIY0pLQcEyXzuzimPhjj";
  b += "Maj3wE7Tjo1Q9RKw9/9wEaDZpnfs5Eu3UvisGaReQg4D3LDYs6jJIcUgqkJHpDbjSb3q/EUtiN/";
  b += "iVgHFui7it5+qyjYW4EkMj39vKPb6q8KbubRklJxfxdLs9GtqQOC9vkKq8P9Or+BAy2lbS2AkiC";
  b += "+mrKyhtwCyaDAcZpVtum/CefmEWKMEHZkBcynw2HE0n1PMZxgcdis9YpW7BYsRswdifVcCwnHHc";
  b += "knPopyya4xx3YRJ8ZK8OP7wRs9BoMwDPMP94/wDAjNTQUehQI9eoEhfiEX+Kjq038klNuCVn8fH";
  b += "8KWSamPav4cJvAT+D3uGJQnpYaxgAPxGgAuPeAI93rvo0YgX1WCiqRbK6ih+23tndowS4fg/HcR";
  b += "421lX3fVs0cYET8XFAkUpIaHd2/UHiLkKNA9HyMl9gYgSreixFy863aWAHmpw5X5HgJ0g8Xd21b";
  b += "qI5xLNuKqv4fBsz+2edoFM1Td+0kf97ANMHgjrG1dkwTr+m1R+bBDHEHsHQr9C9o4cymAaR49ZR";
  b += "i/PYfuGk4ByfwVINkaGpZspY7EvioiKVXojnystxcmceSxjxiBG3c32h4brgk9HThC6SzREYbSs";
  b += "IbyXWwx8NMwVRpbU4dJcwneU2H4DiPp0K0Om1e6VzrQ/eRJIvble+KMB586jNc5Zo8ucTzBTtFA";
  b += "uRn8948J91Z0FOv7PcguqQbmyzs8ELVw2PLRgiPOX6PSygNxHeRFyhXiltchCTd4awiX3XBPwpa";
  b += "MQE015Zki71A5CgS786KVimb1xnOy3hWHHM+U396FwcbX3g226u4Qmf3G3eg4vxygZBLuUB4l9y";
  b += "10hRa8BmZI+FmAQJAl3lEliuQSxIK8q0QzCyCz0NACzn2M0prhYsqVlg69ELde8Fcq42WbMnDlS";
  b += "l+nvabciDcX0oiTdu986NIVWy/d+RWw8TUmbfznmy9t+eZPHvPBqr2/2kIHVe5tSVuK1h6fOiSc";
  b += "sSUhcgIrNTRO0x9K4kOFEdMyeqkmg3ZVp1piJfhGaih1KExa989O9K1/HWDDQqBu4kApgZ769TW";
  b += "/uLj7hV2X39BJXXXLNY//793r37l+EXQVlnjjn1es3bb+rc0/5RK3d1+08uardt/0sSp7AL2dty";
  b += "F6f4icw/L4ypAvldiFW8VuqLqMedHUEE7Z4u7UATTTDX/8SK5+uO+2+s5SlfJa/Rilgr4Pp4ZKc";
  b += "BLfc6+PackSSIbL0gryH5BYPKkCefvyZKFaJP6G+8RxNJlLy/QlpqqMbMtzU3hY4rRUVb3yO/Ho";
  b += "lKAqTHeHquqWD/NSpxku8fu5JOFPfSXyGjcczuYoyli3NcjgunqorgJKlaiKw6+BijEIQuQ14ZK";
  b += "D0ZUXJ0HKIN2YH5tC1++CtHaK/nWPxvodPdpoX7bkYFpknS22rRTteN9MHmWI1/oEad2K2Yg+1l";
  b += "rDI0gEvmw2CShVynT/m98rUkfZnSAQgheNZ9pG8NyQLDNUUrXxW2KOBvWIjKlYVHDvsii05RhQG";
  b += "B5jYFvce8VUd9+I5UncBokX89yhRv7ezvPMzWJSuH+K9Ve1THCHXW1SX5r+bjhlDoG9BZM990gy";
  b += "O89jYo69YYeuB1N178UK+RJEo3wpOmMadoa/6r4eAm/kZ8X1HbQQ/e33462fWfIh0z08tyq9VtM";
  b += "tlFMe10p98LpCmmODRZlvO1rHbXGCMp8I2rDN1Mp8x9YSv3H0Fwf5KxPULT22uPEP/RVruP/+/k";
  b += "cO5Knde8bSEi+YqUG8KGq07F/pZR7TG3ap/prb9WLf1Zv8N/2Zx/Vnduhz6O96w/6gP3MPTVVKf";
  b += "Ep/Xn/Nc/oj39YTN+pN+5H+mr/pDViv33lVv3OpntioV72GZgfsN53t8tIzW2mnoS0oaDu1w/0V";
  b += "TN1/xLC3RW7CCObA57W6ex0auJXrNgL1JdfB67cBVG14HF+OaW9p025cY3KjHP/8VnVpysuC0OV";
  b += "SuWh+R00CVmg5XRJ3gyed6d8HjKolUsF7LtM7pcsMPui/5KS23O12cP2OKb/+gYS8WmnLq40q7z";
  b += "IHrmBJXJKQV9001XHtCpoT3+X+Ie5+n3rE3w4c2b8sWUVw9SvV5VepF3wtjs+PNk6BoUpCVRfHa";
  b += "Dv01/xWVPSOhbmi6HD5zO2q8dck+OlZ8DRndqvX/EF90Z9MWcvpWlZQH75vw5PifX/nD+qx3d1x";
  b += "dfm9hLp8Qb3oYSuVoGlGCxdZwkFSVS7u4amDOSBSsqkDDXejjSfSCGt996Qa+uY7xZMJ4rX4t5H";
  b += "qTlLaP59+3XegXhBlm/l+DbcrQb8XJVJxkl5gUsx2/P27KbLFr4dJMev4N5k3PdpwUw7olPL9Yx";
  b += "v05wgeBP5Jynt+vn/gvX5Xl5MSH/qh/D91TdfFXYYJjegxUpd3WUuamtqWZGqb2jMNzR2ZtubaJ";
  b += "i/T1tbSNtHLQDpT7y1pbsvU1i2sndeU8epa6jNjz2rPtLWPrVvY1tA+dkxdbduClrFtmQUN7R1t";
  b += "F4xtb6sb29Bcnzl/TF1bbUemfUxDy+jK+WVV9eXl8+bVlo0vLS2bP1Y8X5+Zm21vaR5dNqZ0TFl";
  b += "pBT5XnxnT1l5uuMaXDcO4zgFZkWHI9NUi/XHxaxr0H/xa4k/0vZEUfw7/6fdjkXQ8kk5E0lCP+I";
  b += "oldR3e7IYFzZn6ybUdtd55DR0LvWov05RZJLqkXZRxTdcoibx7EDzbsGBuxwWLM/XisbntWAP8W";
  b += "9uxpC0zt31hbVsG/5mLHdTUUlfbNJd/Lli8ZF5TQ93cxswFUElz7aJMTkMay8dXUmOqtMZcJ9py";
  b += "nHj3PPFYm6iqSYzYuWdm2pc0dUycuKT5vLbaxSNGnuu1NHu1zd65NW1t53pLa5uWZAZrfZYSf/s";
  b += "/qgsz548uHVMxZhwWb2qYJ0ZT9I/lGmeL+h8Sf9BOPe1Dn4mydS2L5jU0w+sXi2+cW1fb0CG6r2";
  b += "MhVNAlyh8tykF/n5pTfmH93ExdfXvt2EUt9fg6Y70o/1Hx+11+n54+5YB8Z13bBYs7WkaLDhcrR";
  b += "nzx+DFl+OASkRybaRZLpKF5ATZmj3h3VryzS/wdIv72YXiMgsj4DNHm2tAB9NsGm/rtKO43PX2O";
  b += "lh4m/k6MpM/W0tB3IyPpk7X0KO5nmT5C/JVp6Qni7zDx95nj6t5+4Lf3vtb93SNuvfOtF+97j/+";
  b += "DtQe/+z8u9Q0LxKIZDfvJmKqx1D9isdUubhhb1zF3aW1bA2xh0DfLHddoFO9dJv6OPSBzYp5Yxo";
  b += "2j5y2ZPz/TRi2o0FaBE3ONc8V71oq/YhhDLe1p6R+Kv6JI+igt/Z3I85A+OpI+TkuPNmkPlelqk";
  b += "f6Ylh5vUn37//2ZpqaGxR0NdaPrlrQtzUAPjBszHh9dWNu+sBxz6XJ+Q6apfmzm/MW1zfVzF7Uv";
  b += "GHv+Ily5Ttw1LhFt+W/c8w2VXin+DsUN+gCcOwtry2l0KkPzA95/m3jfl8RrJvF8XfDioOylP1z";
  b += "wi7bXmk+c+MbMWzrPHPqZqxbGbrj96UuOPvL3u77oijJyjR7CbYTnar3JDe2Lm2ov8BoWLaZdur";
  b += "ajQazvtow4BsRWDgsdT1hxsIpuyNR1ZOqbLsBxl+fQ4TAmbUvaO+rGllZVVldXlVdWl46vH18/r";
  b += "7S2Yl5dbUXF+NrKyvFl9aUTqkqrSyvKMrUw09pqRUeILaalDr9O9AtvRKsSrjFD1Ll6EO0dH9H2";
  b += "kiP2cV8qjuxLR+51X2rM2ZdmJWlfOJ7nqkxP4D1epify3JbpE3gfEsfjRE8cXutFPpzvd4tfUys";
  b += "3m8fh1JYlTfXNn+jw6gT10pHx1EGslf0i0wDRsm2ZupalmTYxhPWq7LnyDJJluZA3X4yk9oBXGt";
  b += "Q/j2kOmZ4/0DrKgmcWch1nZEQHZrRi0yd7TZna+navo8UTdwRp1ibudXhESXiCkjDWDXKNcdr7W";
  b += "5hOaeNx83jcYI9pny076MxMnfhuuD+H78OZ0Ia59Jwc/+Ha3Jm5GGZ5dO54557R0pzhubMv0wzb";
  b += "W83v8XguyHlWcoC2gyXzOpoyo8vFCV4aolnuHewanxfvuN+i/joA50Nte6assg5Op/Lwy45NuTg";
  b += "PgXY5Bs4jLS3pI9muNeLeYJ5HcEantT3jGD7LYE1NbxadKKaRmAMe0KPbxHOwX8nnj+e1KtPH8p";
  b += "4r07N4Tztt+py50ybPnVHz+bnTxQ+s5c+dPnni7Gn+aLiePfuzZ809c+bcM846bS5Oaa+5pcOrz";
  b += "7Q1LM3wNGzENkwtIBpM1v85/jY9PUhLz+H21eA2ed7CBuQ8msW07xA7GlQNtc5va1nkCaLTkzTX";
  b += "RJgnq8W7yrS6zuDv0dP6u05mmkamp4q/T/T7brHm9DeLFxcPcY0xWj2TeUxkehLTcEFHiXUs9sg";
  b += "OrUrasUd5tfNa8G2LRZ2jtDo+xXU8+8tNI+c9u3r7itLu838f23PHk2NK/nm7d9MLFdMudz4aL9";
  b += "3xce1sgm8ZwXviyAjv9MkI71RaVj6uYnxlVfWE2nl19Zn5pWLulpaXjiutKB1fWlkKZ82EstKys";
  b += "rLysnFlFWXjyyrLqsqqyyaUl5aXlZeXjyuvKB9fXlleVV5dPmFc6biyceXjxo2rGDd+XOW4qnHV";
  b += "4yZUiKOqorxiXIU4wCoqK6oqqismjC8dXza+fPy48RXjx4+vHF81vnr8hMrSyrLK8spxlRWV4ys";
  b += "rK8URWCkOuqqyqvKqcVUVVeOrKquqqqqrJlSXVpdVl1ePq66oHl9dWV1VXV09YYJo4gTx+gmi6g";
  b += "nisQkiqz+eQfKAff23eyjN39Hir1BLj+V9SU8fpqU7xF+Flj5L/FVp6U4eTz09TEvP5zUu0wvE3";
  b += "5hI+hNaOsv78wdJS28r/GBp6VlumJbW056WlrS0nj5KS38n8rykpfX0cVpa0tIyLWlpmZa0dFOm";
  b += "eYFg0eGMnt/Uct6HSVrj5J57iIvz6r/E3zT4Kz919Myza86cPf0LNaMnz54zms8DuS+MOiBjuDd";
  b += "KW4zLoWFa2xgAve37lVuv+vLj95+wZtqPXtzxw5+/+174v4NJDzx8aJgeCO8nde1zaRDUflJxGK";
  b += "3HUl6/ivb05tc2AAkk9noxPxrmXxDdcYl3lns3nMnj9pOvqDiIfMWew8J8RQPTHaLv208rcvE73";
  b += "u/7YMbg6+Yv6pA9e24RvQ/W2pADUXfdwtq2sYsyHQtb6tvFC+4T9QOt8Fic6z8Aks66MrEOqlhE";
  b += "tLilobmD5sjww2lOZZnW0dNHa32J5PBEb5Qnx1RscqtEWTiHbhW/wIMtamhvByoENwDv3HM38f0";
  b += "/HE68kayL9yZjd+T5+iWLBa0GnA/XAPPvIy7SgLKO/e7rdvGKzNiGjkwbdsAIUT/QYo/EaF7K/2";
  b += "o7OjKLFnfAEqlvWNpQn/HmXeD9V6atpV2wD7VtXsuSDq9lvtdW27wg08+xHTrX9b3iXZY7Hez/z";
  b += "A9Y3njuESRvXMH0+wE4fIBQgo28ckw1nzn/tagWpvAO8S6QIz7I56ienqylH2C6SaYfZhpGTx95";
  b += "kPm5rxaH9+8Ti35QvK30zxeY97w69+1rf77EPW7eece3/+uC35xVdcvSuSuKB5997SOfnf33Z87";
  b += "ZfeTPd2/49JXHvVbyzPLLXnr80i8tP674vdZL+5tXOjMkPqpBLL7/yjBjO+dIF2m8D13b0k4LcY";
  b += "1oz1zRnndjJMOS6ZIknT0yXZQk+flX0v896pz0OeecM++c+ec0n9N2TsfEtnYUDgSaigOqBwF+8";
  b += "CgX+ZRzjqL9asFRtH8t5fRF4hfkOMv59+qjiF+6jp/LUaWElSqoOunvHfYwkjf1WzfU+G+zdyxu";
  b += "a1iUaRHj30aEI+0ctfPnC9KFzqHV4rtqUadFvI2eLtFkCXBU1orzp83zagXP2tLegNSH4Q13cd6";
  b += "Ui184M2fWi5m/ZNE8UVBs04KPaOhonyXuFWl1EQXBxxHQzOL+4cH9aZnzT5Vvq6vU+NPxuG7EJ4";
  b += "tfPb+K3nsa1seVzMZ3UNZB3oPbF9KRZuwW35FhPr0kkj5ESwPd+zEtXSP5Pk5PO2D798DPjtUfD";
  b += "euq+vuvP31Ofzz1umvKLqx9YccFkx698g9nf6V9Jz8OrEoX/Nra/vov3lvhv3fEnxPZd6Pr5r0B";
  b += "nO9va8/bWr7D9/qTsewvbbG/z/fX//09Xx2R436Qcy3pRfSiC5c0N3rtcEguElSmNy8jDs/m0UD";
  b += "1Gd0enZf73z6xKwWNKx9Tjk+JjCWKJl/n0d53EcsS9kqPauW7xR+cCbXt7SAmFNsi8XkTvUVitz";
  b += "vxU157pmn+GLHdjRh5kD6jtmlBS1tDx8JFwMYYLSWuUc88P8g8ZPq/pT64thmIE6CXYJf15pEst";
  b += "VZ0fF3tknbxiV5Duyeo7QViF+9YKBjL2jGyjivZrqKudnFtXUPHBUrSAXMqTTzD/vOYSzPiV/A7";
  b += "c6Fhc4FpmNucaRfcDw7UnDTZhJwgdYMD4R8OTKMUj/8X0YbToD9TB4gXjfBH044J80cTNFntRP5";
  b += "2Pe/Eg7+G1Tm35ZjwOaenD9HS8pyTaXnOyfSHcc51Hxvee8z9pNP2v+1AMIaoM1zImY4GXcKHbT";
  b += "/lOGr7am67TK/p58yW39ifDG2NN2zhlLF/efajs9Z+tr35s1+K3O6cjSw4jbM8O05iHYpMnxJJD";
  b += "z9IfHXi32F8NEJ618ddlNe/wjoCPQ1rxMeis0AAdP7JrJNxWA92QUOzuCk20ykgfqkh6V5Z6fnl";
  b += "lbSGZF+euo99dCD/W3VEr/Xg2WuMG6/9mlX9syb77Rsse+MD37PPGRm3zv7x36wdb15oXdfyMWP";
  b += "DNtd+95jXzU3X+ebh16fNu454x/jkpG675/6Z1tJrD7Fv/vh51j1DDz3g7duXfvmbea05fPAXrc";
  b += "POuc54csY2c/qe1ebEIUPsv14w2brXH24syxxvfeHnHxtwG/Vhm6yNV83Bnn8kExt7njjmxpXT3";
  b += "nzuSNdYBOcTn439fUN/e8KHNd/K1v+x5nrvmy91/val1qIrbvvU4S93X7N7RdNLv2/cdmvJ45eV";
  b += "/nr3/YN/0DmnZcTyoeaTF566O/p8a+emK354V+vhv4m/8Z07koemN0XKjzr7x59a9/vMU4sqOhI";
  b += "PDh5xRfS7H73k0LvdzY/uemDCQ19/+96udWtvePW8d/709BeOfvTmk3965uo7Dv6+M/Az7XPHh8";
  b += "+0bce72AagDc4SpUeUnj9y1/EkG/nz8STP7W/cp0XsLw6mLHzEKJLPXco6aZlezrJDKb/uqF2g7";
  b += "vWwfk6mb2B938GUIz42KmIXcoBpvhNHE833hURwnvctD5cStYkTyVbhv732liVtdZmJ3uyWRZkR";
  b += "I8U8GE0yq6dH05iDLY73FZpXJHc0DKj8Au+C0XUtLW1iQolOOXgjfegY6r/BFtGFs2tOLfP82We";
  b += "MKZNSUMNYNobkSXiPmrqgrXbxwoY6bvEYmttSLeoheeThOwJ7DCyKVQjupB04Mszx25tBv3aatk";
  b += "efDucqvmZWY117dege2o5AxTVc79lU2awZp84+pjrc8oqxJOPie+GWg30HCEO9RbVN81vaFmXqu";
  b += "Zji27zFtW21YlMXLwgKBaZcQf+sHkv9A58yK/IdMzIXnK5eoOoLsrA6UUh/7jNQl2zF9HpxgjXM";
  b += "bxBsn94eUi+FB+qTpSTvmz1rxvR+v1aw980t5zWPXdLcvmTx4pY2UGMFnz5z+uSJXkbUd4zeFu0";
  b += "D+P04eLP38s0zG+rPoje1oK2aXnZORD/5SumB108aZWH9JKThP5CYTq45U6zcjgzspfVl1Hf1sN";
  b += "o6GhZleGovKyOZc8viTFutJkdYWUb2W/PBGAk49/ktS5rFB94h8kF3SCMDb1iUaW+vXZAB9r1Bz";
  b += "FnQFHeIDUHpDkd5gt9fUtvkGZvEs7DX/k38wl42fexMNbbJcpJ5w0JHwjQjVYf1De3AD5+XqR8u";
  b += "ygzHMtLwkIuALSPwAeUk06W2kcFTbXNLcwNYAV5AKxVmQTu0G+gWUR7sHOeXk62imjswPYD+LKc";
  b += "+yzeVcAKBrb8ocyTuHXO8mVM8lHur3QDORW4T6F5AtCFFF6+XU//m7ceOlhavqaUZbG0KxpFef1";
  b += "bN6aqvKsZRX4khw3UiBk0sooYMzL9p40ge0papFS3x6lsy7R4JXrDlaLbZlmldgpINT426US+eG";
  b += "xt8K5x7nphimdXjqJ3aeciydsO4axztC4Hy3ws+RxSEDtoqyoD8R5sOxuvjaPzfEb9gE7ZAtM+t";
  b += "cHHN5OvrSKWlIIsfXkE+KB1tYrpCh+Pqr4X9uB60AFqPThS9QyOPq6F9FP+KflhUK6Ya9vNpoj4";
  b += "49y+oIB3LRRX03cGcCFqBWjWedHeIch+TtnuNDbBEUE40ivcA0GNJzcWXtb0B9N2TxVqcI5biFF";
  b += "xxU8Q/Z7R0TIF1Nl0tJNlvc8VU158HGSCtK7hD75T3wAZ4eks473Oo65Bri3QU9C9QOOGydXRuq";
  b += "7Uj9rg+97svR/a72ZmOmbwGZvJUh19aqLMyi/Ty8PwsNYcn4xQ+E+ftnNoFp4sR4zeJ1Bk45VjP";
  b += "ItJnqSknf2GOsX+UyXZs1D9YGuuBUdffD989h+cPqNF4mqhpcVbH/Gq9POiNzoaxp44zGiIyiJG";
  b += "TZs48rcY/Y/oZc2qm1pw5afocb/acM6efMXXmqXNq5PUZZ5122sxJn645dY43fXLNGXOmT5lec+";
  b += "aZNf5pNWecdXrNmf6cmslnzZlSTbqk2TWfOavmjFNrxO4iekD0ah3lzxL/dIC+lpJzMjBVzqfE2";
  b += "YJga1Gp6f54ujhrzqkw16ZmmsWSB+VwPSTPbmhvUNVMOn0WXfizZp02/VR/zvSZZ3hf/JIHcoPv";
  b += "VdFe+EPxC328vZLoO9D2icm9VHRdM+klM/Vbqmh9P1FF+9SpM0WHfG7O6Nmzak4Vn3uq90XD2FN";
  b += "Fe0e0vllnTj9b9AEUMYZXUz3RMmJEBXsx0TulmvbvKdW0j8j7QHMCPbooMqcXRdYI7KmTatszlR";
  b += "UBrbO8mtoF9wL9Y5jIU3uxOPDgVu3i9iVNtbBTiW7vgLsLcRa3a2cXkNBnTjm1qqKyGgqAqtprq";
  b += "p2XafJ4Z4VcPs60nMViH19Eenkx4A3N7fIm7XcjxGzCzWxkqE3iqdFBu+B8mAe7iqAhwsVa2jv6";
  b += "KKdt6eHmyoMdOiOdNoybJ7joI/nwBOp76k8xL7S+boU5IPtS0rU1Wr/NEd02Dbtssuqw0+BttNB";
  b += "mcSeI3xq9tZPkR4nvyHsj2CXmiA/AGmWG3r427Xzj+UAjEcmUs4C3oZpwktraHtlf2jV5eceB4d";
  b += "FhoY0Wu69gdyZIXUxbXTvxtW9PJDvHKrYNlukTOS3oloBG1u4vOmB2vPnaR9zs6hPI/mYd880z5";
  b += "2XFWAQMAPCPyROJfjnyRJpPr0wkehbsdyo4rz2y7/ptdTwGoh9EYk5Ly6SGBTBoZeXVk8EcoIZH";
  b += "nU6EGuA/abjEgVvT3LJkwULxWLs6C1o6PkBZCtEitW1EZgN9ppYeqCfBVu9TRJ+uPZFkLoXsT1A";
  b += "rrRoEvSPt7KaJsodp9+o/RfTMgZYbdHyK5AZvJXL1AH3KD/T1VFap1lMkmz6lrqmlHcxXxc2WRt";
  b += "EXgt5fIjjhpRlByYvtq3Y+7MvzMkj6tbUsXixm85y2BjJ0bRej1twIV7VSpSh1h587ySWb8f1Wz";
  b += "bXVnjdXHHuiN7pPIr3cD00al4s0e9qLxd8l+2lP230Q7WlPOTlsTzt48OyO2rrGiYPFf5dp33E5";
  b += "y8b25zu+ehC/I3lK33bB9acceL77/FMOsF2w+JSxi2HltDWjj4OofyaMR5z2Sj1doqXBhq4oki7";
  b += "5/7l7D/goijd++HbvUglVepGgSJOyvYQQKaGELkmogWN2d5bElDtyOQggEhBsoIiiWFABO8XexY";
  b += "6AioC9iyJ2f2LBSnufmd1LLiEhF8D//33f8BnuZm9ndnbmmef5Ps8880ytfgHUIaAg5Ceoxh+R8";
  b += "z1K8FyiQPSM9N/nPud9IvUt9zl7LIaCcuvsTAqiUur5C1MLuGEt10tSA5Sx11bEGbDafqFKVSXn";
  b += "m5k2s+p775lkxs+cfuKlhVWXCogYqczVqO2cmRF6wCHgBDiSczTZiO9YlJtv5IYwKECgE1C3SMf";
  b += "gR4BYaaAoChz2yAtz8NeHfPDDejqWkjrenNipIv4mkWs13K4rW+3u0KJ3uk0E0DY7DOA+BHoV6L";
  b += "rRtblGkx5EmR6LxpLuOb9fn4ISu2cRMcGSfZukIcBTSwOziN811EX3k9EOqVSjQe8sRlW5yEuGo";
  b += "gChq2FXFXZZM9BaEVEG4A1MjKmlpQyuwMOh1qJwcUkqVZJ79KYXiX+5czktFeT+P0McLH98iCOv";
  b += "EjIdn8fmmdX9yQkSTYPuKCqq5p7ukTIdO0n1+6rfk5fp2K4uymx2huJP1OHnSnmfg8euyHT8dT5";
  b += "3fRsj+f2Mw1sj+e9r/P4b46xLRPJ/Mo5Noervlwucz64Dnc8pzufAlc7nFa84nxf9TT8rlvYly7";
  b += "6evS1M+rn0gzX0E7/5JvlM9a9jybLvd3NGqORzw+r2xfA58Ou13Ab4vPbsbVvfh0+p2x+FKUM8F";
  b += "V+o814ZNMSz7sNlk6Q5Qzw7x84qfmnTEM+AVTMPTP5yyMAVj5d3erBV5viD+98/0H5U5nXvjYnf";
  b += "80tF5p8jv9zB9nk887HbPpo3pPyHzFVsj969lqcOlb3Ck4e25Axllx47MPujK4cubtG537fdXxz";
  b += "a5YNv/v2CPzT0hxXr9CkZPYd1fSjxioNX+4e1KYl7/PGnrh+29rVh53x1z85h3os//OHWvceGLR";
  b += "mzoxQNFod/lTpvzz8t8od3KJg05Kk2tw9/eH3rXu/sfnt4p5FrD12+JGHE3Xmv/NrTHDDi23bt1";
  b += "X+nl45A677YVv7HPSPm7Wz75/uPfDpi9MI9U7YfbJ51e96QX54sHJa1Xcz56e74i7Py1j32aPel";
  b += "D2eFdq5fx3/9ddbKtNcTL5nRYeQt1iWvNulw4cgXj3425220bCS38IaWw595ZmRGyWdFRY/9MnL";
  b += "3ay2vuPzLrqMGHWl30fftpo66f8D4/fz4a0edNebA1Axr26hJM2/7dczCf0YVP+UrWf9pv9GZv7";
  b += "984MD35uhWD/3eacaBm0Z3WBu8O9xpz+hVyL68oNQ75o9/LvjeO04bU/r3yq+2GSVjhh/Wmzx7d";
  b += "MOYdvN3vtXzuQ/G3HFT2rCyzY3HWncc2LRz+eCxA3Z89v4zfeeOTdFvWFHw7+ax9w757K/FHfeP";
  b += "XbX63fCGO1uPe/zprLOWjx49rnnLJj+9/+Dica1vbn7vrg5PjJt2/L29L2z4cdzNLyzb/+TQLuM";
  b += "X9ev+yXlrcsf7D/9y4cEjV43vcJtyfavPXxxvZPr+vqXVH+MX5MY9wUzrdWFx7ivNvyyfeeHOXt";
  b += "LEdmtWXzhffmnTvq2vXVj00uQ3GrX2TNjxa9/nr+kgTdAfeKa49JyCCTum9ExqWnjHhE4fPo2/3";
  b += "/DOhK5je7xw5/LE7C3otwdWPJCRnbJw0v/a9Allj8vb8t30v+/NNh/90Aj/+Vn22cEd05OeaZFz";
  b += "3mj98eX5w3P63nH5hgcGL8xZ+Mrq87ZkPZKTd+ifkraffpMTmv3UVWdf3zH3u2GPtv79kwtzN7S";
  b += "d+enBCZflvn52+Tubvn0294KzzrfeCP6a2+RDecCxXedNbDH20l0DBk6b+Eazt+/olrhq4rHV24";
  b += "dzI1+dOCDtqSlb1/470e561lN/rOcmVfyvTbfQ69akL7677WDTozdPWvHwy3/0zNg76eB0MfTYG";
  b += "N/kQtlzbRekT351sOdQwdOByc/2rND2v3Pn5F7Suu0f7/xwsjxoRHnzw02mvNSjz48/5A2Z8mvp";
  b += "33efJ5VP2bJyTtN+gx6YsqvdxoLnvts/5YJ1Lbf9tKHN1HE72/1x7/IxU4VO3D8j5i6ZeknXi9U";
  b += "OrZ6cenufaXHGxz9NXXJk8pCFiedMu7N/v9Vrr5o4bUVy/6eH9Fkxbc0327JHrn1p2oDUJ77L8/";
  b += "45bcx9X50jLT0/j8vafcM6AeVd/MmgZ0csuiFv2oQWP7Tf93revNCot4NveKZPGv95/Jhj0vTiA";
  b += "zeM+GLARdO3PTC9z2Z73fRw+8e1SRXvTm+B9scXr0uaseniMV0zfQNnvP/JzD65cWUzdrV4unxj";
  b += "/P0zFk36tnXuiH0zHrxxfF/56rP807YemLckOMJf+uP0tneuuMTf/dG0g1+3edT/qz+pcN9n3/r";
  b += "/9+QbQye912nmoQl3LJ9494SZD3e/vO/msZfD7OiRNumc52aya6YsnSP/NvOVI4Hz3n25Gzp0+I";
  b += "2+V4byUPnCC56Td65C7+et7D0kbTtKkR79652dh9Hlnr3zl07njfs9S2/++jFsvOv5+vjZ59xqL";
  b += "E096M/+Y69x93c/qPcJceaeDV8PnbAozXxp2YOF168MmsKsW4eVP3qXeWzg4MkTv/jIvCO/519y";
  b += "72bW9pd/LxuiZlrlj3ITWg6dZ038Yqs95cYHLSVF+eKv576yhqwc8mF4S1vcMpQz9p0Px+Kfdhx";
  b += "qtnT4pfi7f/hWuN1TGJVfMvX5zj/jAY1W/v3+O+fYKbsfeWLXFZPslYv9B45fdLX9z0PP/rzPeN";
  b += "nWbrvohzWH/7Qvy4z7euEzvWe9O/LcB685hGZd2emnqY/MvnHWj13v/fXsJrtmnTU3cdI7VzD5H";
  b += "6x+vXfij3J+47Sj6uu4MH9E5jHj9s7r86e+99zhZbPey3945Jb5s15KLnhw7ObNXzw1sGCq8cEH";
  b += "bb8tK/g17c3G+1I3FryfuS5/ec4XBSkTdw5+oKDlRSsL57/TbmnWRaH4KSNSv150UeJdah/p4KM";
  b += "XJV+9TGN+/O6i0b/cc9lL53Uu5Cb2OHTT3OzCZwsFflHuFYUb4xcd/fyi5wt7WYEZb7C/F8oDGi";
  b += "mXvNK9aEnKNa9Mf2x60Vs7tFueufa6ou3/bB/4vbSjSH3q72vPZY8WnRu6NW1iF6H4x3GDX9t0v";
  b += "138zVfXPds6Z21xcHd/+ZrH3ipOefmqlx/uEl+ysrSPePbG/iU3zzqyb8LI2SWLFh9e8+3au0v2";
  b += "oX8XdvF9UtJ74dafV+9vFpiztrBXWoehgdWXxj+eaMwPDGjRdfbQhQ8FdrUufvPGtQcCi/J2Vmx";
  b += "9pV1wj75wb2778cEhV6zN/DF1aTBn4yutuvV8Ovj9aunWQOhgsPlnnpfOu+/c2RNbDuL7XTd5du";
  b += "GUVUefeeKa2V99MP9zSXhl9qdXt2v98rG/Zmf/esetpcf6lL7755D1CS8YpVceWn3layVrSjfx/";
  b += "/64YOSbpY38F4euHsuG3pwzbS+3Xwktzin1PXdLUWhv2Y5znvhifcg3Yd6mrya/H7rsnkk3djzY";
  b += "qKzlzj8/mx0eVNZ2flnu7rfDZbff9NYPi4dvKjOPvyw8nPJlWfoLoUWfjWsVbvTg+H3v3jkyPKv";
  b += "4ukb4norwi4lzxx7b81j419db7j/q/SH8/rHRWy4ZnDpnRca6yWdn58zpN3bnz1/PunLOs2j+Rf";
  b += "teemFOq4UrNpz/0e9zpq7tt3zOnh5zg5ce7pPj9c/tJjy3tqVx/dyHLvnplZvTds7Nu/1baWDWs";
  b += "bn/vNysy87/CeVP/Z7TM+3+WeV3cxsfveL628pnzRgZlC9+u5z5M2/X4A4J85aIZYvO2p8+j193";
  b += "X7/RjUvnDdh5Xf87rr1n3pj5c5N3SJ/OC26+yj6yrvn8FZP6VPRPGjY/sEWbedXyBfNx0bkXK+r";
  b += "D8xcN793Bt+zr+TOm/NVl6DftF3yyJk3+cc/4BW8PuJL9xrtswbCrz790X+YzC0Zrhx9uVPjLAn";
  b += "/8/Nt3L+t68Z+Xtx02+N4pF/+bs6fwysRrL9Z6vbJ9U/K2i3ccCj01sfE/F//967X25vH9FvZf0";
  b += "/7FwuvMhckDujwUP/emhaNX9MzbuXr3wof+ulk/2tF7ydqw54r0A+ol3us9G0d9VnzJ/mkDR47b";
  b += "uOGSj0v3dvwq54NLrl3pO9ChV+NFz3y0pOTCtMGLel577utf75yzSCzbnN55weZF63b+uOz3XV8";
  b += "uqrnTNuz+GWUlYbs0fMJfVXSNhv/lef7f/3dVlN2O+HSvgHR1w+K5/GeQnayXEsTef7yzt369u9";
  b += "c+kt/OOLaPSH4P4/ihRvJvMM7etUj+Pcb1mXbz3djq5TNYx5eIqefvdLzcmP8P0ESkP+7xOvbp4";
  b += "w388zCs1xcXn5CY5F5IbpTSuEnTugvU9/v/5b9YbJgds8+8DXNEdnUbZrT97K7sM28/eyq7uv0s";
  b += "Ygyh/iqotBTNMwKBIkxCNM3sluOsA/bLidgCHF8KQjcDa/xGDSM0ag71zpqZl+Os40d+rzLbzPR";
  b += "cnOPaAdzfXGu656Ycx2+xY45jgwiXFJRFYkQ95F5zeJVzdVuO0z8leC5dKHPWQT2eD3Mce0OI+F";
  b += "uUmPiXHMe2UYyCHk+us6aJS8LFKbkR3wf6nNICVFLWNrd6ne5lT+9cx1+nLBwsqrrq8WTmOuuz7";
  b += "t7Qyh/ycp02hEXBc1MU/70Z0i2uD2P09bVuHJLba1y/w/X5X1+DNl7MPfO08W5uDZ+mGDY5Rbd1";
  b += "Q8NkCn0e+Yu0KVRmObIk0M8JCYOtfsRkNbeULH+E8guKHdvOTRMdnxHCpXvSsSwju5MqvaVO8M8";
  b += "xAyUlZO2UmsrtcKjGlRCJChEqi96PXYLL5gZKC6MvRRWhQZuw5UR2olexhSwLaiLrxKnwgEiO3I";
  b += "LmQOdFV2oRn4jSQCEuSQ0WBLHbfFREZOG8VFwOUjVU5Rc2l+4wp5FyaG2pVgHxwQqUzisIRecqv";
  b += "9CHUl9PUmGfQEnRvFTiThaaFyrDxcRAGYLbiMtTMbYKwsVRvxUFAsFUukjt1FZlW+yB+87qmxqa";
  b += "V1xEuCO5r2eoDBEfNfelqMNaPiqxiiqNuAUlwXBZlXdh9Ao68YSziOWXji1dpCoJVLYrBPwWRgU";
  b += "XEqIJl5BvdJM8eUZUa4lJFlVaPWkDqAcX5drY8ZBNNcKhebgcm+GyyiroNQv6hvSpWRoIhfpYeE";
  b += "4B3ExfjgboI9vRSWXFqGQevRyKNJ/UQH6Fp4TJEgw1x1e6jlWNG931XxoOlhGfyEqnqhPtuaQ+1";
  b += "wRejIth/AI0+B+1ZYZLSKgO4iU5nxSgSzs9AiH3G6H9yBx6dYrDU/dOcXhqhJqAUkvJsv6dUdjk";
  b += "rtrnHHwtCJAZljLV2Yf5A+uscbiRbILE+YUwapCN1AdPm+qseY6a6viBRMod9rqxc8oseDGy5E3";
  b += "XVyp98+ZMdXgp8W+5O2qt6x4Sp8Rdp46+fj+kjZA2Uf5C9zNGr0oic3YYqDW1OFyGy7dNbUZ92G";
  b += "u+H5BMv7koVNyvb99oH7d+hARC/WhRylx+gvKKu06eVGs9JWa/AAgVuFua5vhF7nXvj84T32NSN";
  b += "zCIMNBIxP2QsIdSMuNLQUo4La71CaW4qkmeG6c569Cr3PgxDpmkUjjh0BrQjutb54yVx7NzmuP/";
  b += "+Nk0Rz7VfAotDNUfgd9JTI8cF3+4/QsSocCeR1fFg6ikwEzNDwQKI1tH6ZVCSgn5hMq65jWjsYd";
  b += "qPqPyPnjOzDynby53+zWSn8U6MXAi+XzXX3xz1PhvcWVixJ/jgRr5B4k/KKSHSSwD99ojkB6FFE";
  b += "33j5E9ElVjH3H6q+kKN6SS0U9whEX0BZAVI0BW5FbJhbEOA4y6UnX/ICPypCEROTEIJENWCahT5";
  b += "Av8MCgiHdx6MkE4DKbCYTzIhkHONB5KZcIkIgkGE6oi5TIj/D4rVPW98gtxsCAigPj1jQMJMKyS";
  b += "bVZ9Gw1cPJswcffR5JcRlIO7bh1ZhIG734mjHvFcs8aFyyYRpj0VeHa2w7CHhYuK4IHZLp+uesK";
  b += "FhEMPdRk0uZwTCIwm7HmCy54HAyceWsmdyR3kSqbLm4cQ3oxDmZQ5h6DsGODGowkzdhs1zOXFg1";
  b += "xePBq6iTwiQLyDKtlvlTvS0IANzR9nj6EzaBxhtLnRLLaKe4fCJjwyZIfJKl4f6rhNFvpofBfnj";
  b += "mLkSFoDpghMbsdZNYoveTyKvxndV9MsKm5wMzed5eYbu3O6lUvvjdzvrVx/kybuvd3cPTrt3Di+";
  b += "Ke48Snbra+P+1sSts6U7Pzq415q5sYBbuc9o7d7XyK3/Q8BU30H6B1KjScDHIZ0PKQPSeEjTIRV";
  b += "CqoC0AtIaSJshvQRpL6TPIf0Kqc3kZp5xkPIhLYK0HNJqSLdDegDSq5A+h/QTpH8gNQZ51QoSBy";
  b += "kD0lhIFqR5kJZCugXSvZAemeJg+EhfNnVTCzcf6Y9m7jslu+8X+UyJGoNIXORIfye6ZRu5KdK/K";
  b += "e79iW6ZFPeZZ0XdG+nDOPd70+nQB5C6Q9IgDYc0EVI+pHmQlkG6BtLtkO6H9CikFyG9DukDSF9B";
  b += "OgQpfkYzT0tIvSApkAZByoI0AdJ0SPmQFkFaDmkNpPshPQzpBUhvQPoY0v8g+aCuv+EzDmixGaR";
  b += "WkB6PwuxPQHqSxHCP4t+16am1xQBINxyfsVTD4d2tWacfUKor86mIKEUAH+tzWPE8XcNH5cS2gK";
  b += "IC7dhsOPLKYD3V5HylPgN6XT+rYJ6fKqSO/HzXcM5wiMSDPVGtAfZUBFAyYwAJ6Vx5/2j3ftadT";
  b += "zuJbAcFNRUqGtjY66lYCpKqD894Xv6xkWe1DF3yUuC3y86l77H44OZl0wYV9/nZF2UX6nzRC9b/";
  b += "tJL/rbn340N0LbHtibajjBv6Jt28z3tUa9W034Gyc3/6Y887iZ/6tn380Jtb2y0S7/F26/z9WDY";
  b += "GG9TFfW+advk7z5fe8dGHl/dr1WL7+M8LgyUj9zT98Ib3SmY/0u0he/uWrkqrTlPfGZzeJOe4+W";
  b += "Iod1ebg//g33pszf1rx6cVn/6v5NDug5/6/8qOq72P7aIywcLUf4bwz3n9LJAEAepDo1nOnoaX3";
  b += "P6L5P9150gkT/Q3pdbxAPXPUS/JkIwZNNmfnTXcn5k1PCsnO6r8fHfenVje6gu4vayvmY/NQmz5";
  b += "Q2GjB1wqKAmHehJXnJCzaS5Sz7xY6wGtDuoJFlWvprKe8pPUQwqlZqRykXvnnuyZpKHk5qh3nVN";
  b += "PG6PrDrv3RvKzGceXqLIuyE+Kyl/qjkMkj5nq4zTKjYcayTdhqtffuEY+pUa+UY18spvfN7T9AO";
  b += "+e9t+8dHjXMUKzr2+/ZUebY8FNnx5+l+bHfbr1+SMPzz3+5+FPaT7l/cJBB1dNfL75kQM0n35k0";
  b += "bVbOu+9uveRn2j+0lty+R55F74z7Mghmn/8tXu2rNw8+zZ05AjNv7H853PnnrP2hwVHfHSvc3F2";
  b += "+cBVWbseuPFICs1P2v3E9Hkt0pc8fKQlzasTD49RVjd7+Y0jHWl+3E0jtMAPN177zZGuNL8jbcl";
  b += "5bywr+8BztDfNH1rzwpo391y2rsNRiea/3tyrzU3J0kH5aDrNX/OI3OvwLO2R8Uczab7/Bdvf3v";
  b += "fuzqWFR0fT/DNvvtO+e+Znry47mkPzN7523rO77yi8ft3RPJpferexsGvR5k+eOWrR/J8f+xtPt";
  b += "jfd+d7RIprv9usrn1//9/7fDx4to/mnKo5vvG/L448nH7uY5pePvLgozm9cft6xpTSfzb0kzTy+";
  b += "9bULjq2g+dxuz6xasWzsjVOPrab55y7pGew69599ZcfW0vzKp75+6o7n9t2z8thdNL96YdkVe/z";
  b += "3/33/sc00v+fW+1ZeH8x8etuxx2i+sFXTF/7+JfGqfce20vwTPI9zz3vozX+ObaP5zYsW7N2+/4";
  b += "KbWx7fRfPx/c/vta1Z3oG+x9+l+XeuCxXc3LXrxqzjn9J8k9c9l/72+OVHzeMHaP7H9s2vsxK/3";
  b += "nrJ8Z9oftcV4wNJu7auuPn4IZrvjdvtn9zmybcePX4kam/7wLW7j1cx5WZ3v/vdd8dT3Jyx+dUf";
  b += "y7d43RMaliat/rtcv2Dx2W5ki0dbJby2YPeaFzU6mzyeYN4PC3YLl6zMdj2E8iu+33SX9vZ7xW4";
  b += "k1qHn3NKmW/dxd1xBvcA9nu6Ht73LbzD/t4FGTQQ9d8vOFRr+/KHnqKTxeD7Bm9pfk7jj0g/pjh";
  b += "6P55ZOswf/02n6tt/cVabJ33a4p3fBmOsaMxbN/3B1sL31M/Nxd6aI5kfOPXjLzXcWbxjMlNH8s";
  b += "sKFjy0oT/otj7mY5ue2/Wze+gM5j81lHM/Wl1+9ddp1l0277DpmBc0PmH7jzlez5Z2bmdXO+65b";
  b += "82/eY71u2MGspfmv/Otufu6OYZ9/ydxF8+et0D+RXr717iOMs0U+746b7iy9ZfufrdnHaH7389/";
  b += "nZL/w6ZM8u5Xm9w8657c2vx+5YjS7jebvLs9759bdqbtsdhfN78vusuD3qa1vWsy+S/NpXOc1nz";
  b += "6+bv+t7Kc0f+OjX+Vlv/XRfU+wTgiA9Mx77/ro4lsP72V/csYy8657R4+e8+yP7CGab7924BMHr";
  b += "9m0PN57hOZ7L510T7ODnfemen10iaYnv+r7r+9qdmt/bwrN35aydv3hW5t9m+tt6fx+qL/xUWqP";
  b += "zUFvR5pftufe+TNGZVYs93al+T6fbfYOPNDlhbu9vWl+5fHMGf3WzrrmRa9E84OeWrH2tjbiux9";
  b += "702n+/g5fPXbdJ+1u/8ObSfMfzd33TMkLN/7Y1Dea8dSFZU6Qs7NKC0Jh54yAQicO/UIXM0XyhL";
  b += "82ryeeVeTexq7eH8kPZOrCSK6cOT8izNJTe/Cp6empCt8zqvyDruyJ5B+okd9SI7+5Rn5TjfzGG";
  b += "vn7K2NSxWxnPvFVuhB8AQKcGkl79GRcPYHMqu+8QEfd4XmXMZ6Bg5t6Km68yeP58o84z+u39I+0";
  b += "QWSd/o3kFbZ6HxbVyH/O1CO7o7oyUuYzpvp7f1oj/xXr4NlI/iDkR0bld7n5k9KUY/fvy/U9sWV";
  b += "BVFoWqsJg0qFiZ8/283XiEOjTadx0wCFGXncuj8Sqj5R5zi0TyW91833OH4vGFpTYXD0AsBiV07";
  b += "2WkfKLWAef9IxeECGxnEucNZGTrHH0JX3jDTj2ysHUNjomXDbUMUwS3E/5zrSq7z0Cjj018unYt";
  b += "Bwf2zQgmhei9JYXIzErIy7N1Ns7lEbNaPAGZIsxvJmz2cS5Ea4A3QUcm+XSgLMH7qUo/YzE1B0w";
  b += "oMsAUKcAhYaqempmEbbLUlNLC2bll810+y05NZVcTUtNdq6npXpeCTjrcO/AJ9Frfwg463bVC5I";
  b += "SblH4LVImJeh8dgw6ZSJlyU2R/hkRdPrypSh73SuQtrnxgVPJ34LU3vBfcu/khakLe/SAz+rvuB";
  b += "3S9FoHDYgVBu22oBtH19XNufL/v5xWAZivxnjvcPVMEiv5uxLnvSPrcdxp/kXq+zDOsbna5CjIs";
  b += "lKyvFr5rA5JTtzASL5lkoP9e/SsY2dSMS423WBxGaUOHW9x9b5IfpUbG456+KeGyoC1uORfzfef";
  b += "7uymlUZtrKoodebEdfB5TmUdZOnEqWFbqUOjkd+d8s5v9EkhMlPprINCNOM5APcS+8+/pe7arbN";
  b += "S5BR1nwucp3IPP517JL5zGQmaQq2D1W5tG3Js7X3gk5yvsLekuu98uMzuo6VGVqOjjfXEnu60NR";
  b += "hy9utfFXLetyqkg1ucLtBX1hFVEmRoyInvUN/eli9CzjrCYDf+c3S+R1RejnfwRCRv1shbbn5a3";
  b += "759p9N2uaNZ4C540v0LlXta+6cSAxBZGQ0RDJLaw3n5nqQjZhJfgtwyZ+1qZpmzp/WyMsfWd02Z";
  b += "szdhdZnTnwaeVVBClp/J8PcgX3qmzs3HznAQWxNU9mKZs+6+u8xZ23+7zKGPSB2kIdW4M21FVRt";
  b += "8YYc2IvfX2qfuerkUduaI190jcMK97i6WfsHItnE3blfYiaHQ3o1tHMlHzmvyxDOMl/GxcQkJbG";
  b += "JiEpsc14ht4mvGNGdbxJ3VvCXTim3DtmvcMa5TYmemK3ORr5B90Pswu5Xdw77FvpvyXtL77Afsx";
  b += "8wXcV+y3/q+Y39O/cX3N/uv9zCT0r1/xthxK2+//Y4Fy6+/ccMjz1z2cHxCkjIgY+Lve9/ytWyr";
  b += "qBMnLdr4wIPPyV+0uPzKa273NW7SvEVPXkobOixr5NhxFs574skOHRMSkxu1bKPoaffd/+FHSeq";
  b += "1q+5LSO6fYResvK55wP/CzwenGoeOHM/OueXWvv2698i9bd36O++6974tz2zdFt8opVWntAuGXn";
  b += "jPvbveXJfQrv0552Vc8O1PB4+/ut2Xeu553XqIWtqIkaPHZ+dOnDw1b8ZME9uFofKFi666a+ODD";
  b += "72494EHSwLPXz/jnAVxXl8fr+1l+vWtWNLJyzft6OuadHbc+XGZvia9KjbGd/V19fVIlBqNHbJY";
  b += "TWqdnNi2/1DdayYmca3jung7xDEDNd+ouH6+5ISkhIGp3X0pSYo3La59gi8lYXyWKjYWE/omJi/";
  b += "uNmHU+Ym9Wrfv1rFlm6Sx8IDMxu0SkuNHJHZPCjcanNErvn9ccvyF8UxcM29cxXLj7BGJyRX3zD";
  b += "hnaKPk+MZnpcUnK719bSqeTreyU0YkJQ8b2mFEYnbjrITkij+HJXfyDs9SvU0Sk+P1hOTFSruE/";
  b += "t6OE5mmQuNLb7XDjSq2XTXabLyUa9Z65cYlw9c/vURP6OXLi++WPCy5R9xZSx6ahkf59ITmAwlJ";
  b += "rPk7cen7vZI2fLtYbMp0im/iS1y84kpfYVxjb1JCs+tmDk8qS6/4MzmUGGw1bH7LlJYpk5LaVVy";
  b += "+eLh32eCmrZaO7xwfX/He+XEZXZhgH297H7t4YOfmaXHM4r29lnxT8VfP0b5kH3tp88zRAypeTo";
  b += "9nfLlxHSR2cZPePitlYnLFA1qnxr19SQlsk/iKWy790Nfc29g71+ePT/ExTVN8Grxcj8Rzxi7OS";
  b += "ekEbVESm8CtSQkVb5yXvDTew3jj4uLj2YT4xISk5skdG7VLad+4WZOUpr5m3hYtzkpqzbTxtWXa";
  b += "edsndGA6sp1bp3rP9/Zp1JfhvDwrMPey97MbfZsS/2UPxx1lj3mPJ20pn7f86g3cpMnLV1zb8bM";
  b += "mTUeNPnykb78L8qb79y+9+ppV193/8DPPvrr9tdc/P/D1cY+PErSa1n9A1sjpS6+BHx975tntr+";
  b += "/ec+BrTyW59yf0PsPCS1fdettru/c0bt4TLmVNmpY3w2/hq1fdD0VefW3fga9/adx8aJaFK5Y+s";
  b += "vX5F9774JdfL122/K57nn/h1R17Pv5kxE3Pvbl9956sseMmTZnhv/KalQ8/8eQLL23f8UHz1m2m";
  b += "5f3517HjFcWzP9/XpHNJoGMn/8JLHnhw0bNbW7c5u/Ow4WPHEfq/ZNHjr7773qe//PpHaWhlWfj";
  b += "Gbn373fvgky/s2PPBvlsGrrmJW9n57Xd3Hx87buq0hMSmzbr3+/lgSUAdcMHgodeuyp4V3vna3r";
  b += "c+/OjbY8c9qf5zluzzLclM7OCLb754c5OKTXGdkxZ38LZLZHz9fJIvwcskxCc0Tx7ftEVCboLX1";
  b += "zE5yZvoTfCyXq83xRfnbRTPNGkVNzahQ8KkBDa+Tcp43xBvH2BPzeObpqT5Op3nTy32XXRexc64";
  b += "JQ9528cvOeqdktA6qW0SIbiL4pPj28dPSTg/blhybx/Qhpdv1NvXPr6Rt2Iz/NSPH+OtuCsx3dv";
  b += "Um56gJZ4ft+R487aJ/Zr38XZp2qVpxQrfkjXtGrW6YnVcv7j+QGltkyqeP6cspeL99ilxFcfjKv";
  b += "al/HabV01anNey4qnEijfiktv29ybHa4nDElPiyxqd7Z3qm5JUcWnbjsmtk0b7Kq6K33RXShsfv";
  b += "963+ONuCSlxcRX3NFv8RwKT2isefr3aV/G8t4O3aeM6ebj76SfeK8DGuy5oRmXmeNePIZLPc9eW";
  b += "avogn1Cvs4WPCoSLFziyX3LXkvLCCyqvGe7ZcrXqcUbBLAchg061wImHs9n1XD1RpSoJOL4gtWi";
  b += "hNHI/aKFSLZqY442SkcrllM4bBqgjqySiLlXDra9Hxf+Ivv5GJEYPCepCv1BM5A8H/WUBuvTjxN";
  b += "GJLkOtQaCHX+pL9ayKm+mZftY6T4s2qZ1TUmd2Pth73fm9uNTegXu+6M3eN7PP2Ydn9vUcS1VuP";
  b += "z5TOcp8qTDJXdSujb9UNzVBer+263WuIxrx+9nrRw+U0PhfLlp/4bhAlwm3bV0/wbMHZeO31md7";
  b += "Pu6S4/niy9wH9qNJPx3oMmXvd+unpHp+nvILs2iqJ+hJ8PRhGIaFf8yIRlyrZgyGOcCyjO9c5uw";
  b += "O0xqlJSUxbX1MEojruPO96Ym92jKpKhTwJQKtJySznZg0UtyXCLcks+0ZltVBrvtYmFvM2ayXaU";
  b += "TycXAD05JtDVI/jTwL7k7wJrNnM/2hbAqU7AHVQ63eOJh1CWwjWitpEjyUJfmOrM5WPaUTM4LxM";
  b += "VA5k8hcyLAJKYkGwyY1SshiO1DPZrUJA0+Ma8R0TWJsHxMPjWLbsT5vM19j+BrPNGWg772d2LPh";
  b += "30CWSUhk2EZJDMx4Jsyew8zx+tgkJt77CXQCtDaB1MgmxiezDNeZ93GQj2N6JKWwqfCSjFdjaEO";
  b += "8aYkse5OXacwkkAd62e0DPcwrXTzeq5mZqZ74AtbjY5JT2fGsh+Aeph0bx6xh27dozHRLbNeor5";
  b += "djSJd1Z4ZAz7NsCrxXP0aEWlk2Dt67F5vI/Ey6jQHCb9aMqKPMfuaGOIBlbJyvh9fH3A31e9jx3";
  b += "mGNeN8CRmnaE94z2ctDnQnMAG/XOCYxg0lhpSQQeIzfS7oSOoW5jfEmtqI9yzCtmSYJ3rhXEsnL";
  b += "tCG9Gk8GigzCj9C2ePjswOYmkisXMbQ4g70wqHGeJIb9A8YEKIK5Fp7nY1KTe8TTkYpnvX2hwz0";
  b += "J0CHMhNbQFKhlfryX1Aq9OII8ivHA6EpxceQbE9/UA2zQw1zguxCue/qybTzQB764xEQ24Wzfaq";
  b += "9H9QmJTBOmdRzTFGptTmuMs5h1UGaAD3ogoTjBM7PiF4/nisXLKjw+4jfBHK2Ar68mehTiG+U3A";
  b += "MfPwiVpaX7/XPe733HO9c/CZWlp+ZIBwlNEModUAyEJMf3rLOfsRfeTGBH+UmxDYUO1DNDDLUtV";
  b += "DJ1XFXbQRSF/aF4oLW0Q8TtOS6PPIFXQx/kF1caihUzelCxOECSoAtmgumvYxlg1TVMQvMNrVOG";
  b += "oZJFanJwfS7pmG6Yg2brJWxJpiwC6u2iZHLZ1rGgy58sm4VMCRdjv8CRq5vETpyc35GZaWgmeG6";
  b += "mXbN5HhoVUBWuaaCANyaRSTtJFzjRk+BRkTjHjJtVbaYgGfXCrpRm/ImuCqtuYmCJ401ZIt5sKw";
  b += "qYuypzAIRnr8ePrrtiJqOTW6PxsazKvKCqyVd4wbZPUKHOabGimyemKLsmalsDXOZBl+SA0oIim";
  b += "iooGjxcEVYPmcIm9ycl/8Arwvwx1En2V+LzSTL7M2wbQiKYrJrZ020gaQSQX9GK4OC3NtT+S13e";
  b += "M2mlpzuox/EQ9B/yhfOI4FSI0pyIFGQqxpliqaYli8tAG1YTLkUmqMW3BsnRRR1iQkcEpjcYX0p";
  b += "ZWhViGSmiM5bQ0EmQ5LW0S/J/tXikOF0GbCmx6ICbxBoIaRck2DYO3FBgxJBs4Jc0qKqb+CmlR3";
  b += "zLdb+mDMqAa92I+MkUABbJtIhELIo8a56d3Kwa1tGqXDNQBD8msOlSqNH1CBomhSG858dcMcqky";
  b += "63f80eFJugiUY6uqKhpYszWtyX/2JI4zEa8Kkq5wPCfxWlOt7h6O6ldCWjonw/gqsmwLhqIozUY";
  b += "2ZGxKsRU2sZ+4mEBdigrTGgZF4i2Ns3Wj+aiTkwtdTjmB7vyBIHklQdYtQcW8wZk8TEijxSh6Sp";
  b += "qfTBZK8c65kGlp1Q8/r/zJHxW5N18RZcPmDSzokm6oKjqrrsqCsVQG01ZUOVETEVIkVW2pOq8JL";
  b += "wYVODYf6Oay0myMSk2AcC4Dy5cxB/xX5XkZBklQpFYZwRP6mh4N6H64/WpjvzNWCmcAIxU4W+J1";
  b += "TUBm66HpFqnd5TuUr40C1kEIyGmSXQxd6UauyXCz+YogqpA00+BhBkiozaQ6OiNyhG9a2ghrFJ6";
  b += "XSY+cLk0fkuFwnHAZ9lcdJAa32wi4L2+LHLAowZL1tlw0pbutLEaFLu8kD1A1UzU5WZFASGjIaj";
  b += "eu8OQ9QsP1p6WdEME/Qs6SxmHLFnhF1EVNs+X244N1krPz6XbybN5PeEsIutrlNja8LGE1qqHLJ";
  b += "gycbum6js0OVzLpVed9wYCTTTf+6PqHzg5TU+WgrNAY4k6Sk1+KMRmTkxcLYURQfxoNhTyo8gfo";
  b += "buhvZFmUjE3e0GxdsFXMcYrQsX/907yAHqpNuJFmWRKPEKeJOm8YVifDHdzIWfdpaemkL1Ldy87";
  b += "RqeTA77SJka9ABU573DLOwTEge8gRGoSbKBYnIU1VbI0XNF04m4+aGtRyG5GLoOL4abM0kNcaiB";
  b += "cbqNEAmdiZr0GNJ9KZxWOeV2QkGZxgqjKXqtXL/W0YAijJW6bEi8CSJQFwjSJ3GdEQDkXlmcueR";
  b += "EUBRGNjk7M4ldfRORNOmXJDQC+UsWjAVxBvyACUVEmx7HO1qNY5Cmda2uCCWaJQLnGOYAwG5gqE";
  b += "WQLvVjlgDIpm2TD3uo6uY0pHTtGthbO5RwaSdti2BdXYHAA2QTGM865jTnw5Ot9cgnGDhEeqDgS";
  b += "hltFQOSodQp/iRlkOlKaeWE+wNEDQKp1s4yu/00kA41ZEjfEGmdlYkjlojqkYoopVuduK/xvz0A";
  b += "oAIdKxEmVTkjiFExEnypLafWiDXi0yo0VsGLLEAZrhNYCHao/cmp1ZdTiN+92lqqoDqIHUAyR8a";
  b += "/poaGB5MalWsySOJ3hbFUBtEPSevaPkwbDIrhAirSyKcS1kYJFTRM0QOUvpJUbNWrqJgry4n36j";
  b += "sbQIkQgmj2xJ1RVLVERJ5M7n0+H+mqIHG+FZlYJH4izBMCWVMwlSx3bvoelROKfKVbwe+aWaOoh";
  b += "xC0AGVkUJKX0a+/2lFrAT7OysGFgPvgKeOKuEnJTtRJ8CrmAj0xR50HMExNsW6sdH10B2AZCeKg";
  b += "0B86KWIwK4QPGQFBXmCbZtZKnc6U04CXCbDizNNmWZAxY1uBqJ1k1GVBa7QE4BmKmC5iKINsBBT";
  b += "bjj5JPW6WA6VekdaWljwkXp9cmTjFOaxU4LdbJMC9IBI9OyJdDeBsemTbh8jucI1WkA/QFb2Jwq";
  b += "GRo2pcFRhEL9jt0Pf1nAD/UVgAzwkwBfgZJKdUSykGCbHCgiqoSQJstp9bJZx0xHIJxtCZJly4Y";
  b += "B7FZEguJqRGRWwK3OGdeVXQwX4e0dooHWwFyARlDpYWMLMAqHJEC4oGmrcp3z00+3/pYi2oNYVU";
  b += "3AbbKlQnnR1obVCSCj5UxaGnRGZWhrgiM0yRZtCckqBuRvCTCJC2ZRlW9YQTndZgJCl1RV4ugZN";
  b += "rlKeo43NXhvSTR0C7rPThsae+9HqZU20jhgTJyqyQISbbH/I0z6qbA9yuuG0gtjQrMmF1vpI+DO";
  b += "HKpAnUp9lVVlVF1346kD19Ggp0RZk0xONHXFSB8bK7IUXWRZAvAFByO40tB1ReFs6EoDODWSBwx";
  b += "wwDyJ956Wg2bVwwQtzJkKKDMSpyJQRKSMc6Nupjs7CZmJGm/xgiyLmNNtTb5gYLBevBjKL41StH";
  b += "VRtG0bQLWMQKQIeODAwgbWICAgNdAMRBVUDpuTBg2JTWmpJjmQySFdwbKpcSDYTH5wRu3zhb64P";
  b += "7Lt0fJTVyoojwEeIV4UBdWAhnDGkPS659uJpZFmg85mKCbMGlnUuczpTqBbvxPoNi0tHJHo/uKA";
  b += "VTn7a7uHnBOU7ncRvXM3kCWozQIP/EQEZGvyQzMKY5vVodkUQQNqtACOYA2IwQSuMOzMNo+zgNA";
  b += "sGD1D5yWgpuHZ0Z1nhAuKLCrpxiNrkIWCZLdp9aGkW9YyIoNDQQVwMkVRVUUDBiSCbm6OGBCMxW";
  b += "BRVhAsIhqAhgUFqbLAgfiVdMRnWfVKrtqYApV+WVRByohoStGkK5syBsms8EB2Ii+PtNKDZ/4pH";
  b += "ExMxeZkZMgYsCAaNahebcYCZhAAOEJPdKW2YSBNoE/BNJEhCeLoofVCoCDGhX7XS4aeIk6qQRxG";
  b += "qmTpSNUFU0JjRjQQ01aiYxFZhsTzgGRUkeNtcezAGEm6SlsFRKYgDMyLGEllPG7mKetXVEelji/";
  b += "+cIm7n4SOrg21I1lQLcWSVXP8BdGdFiLsIKL3UQFuEdL1k1ioUDVFwIJqShjmBlIUpNjyhYKrOe";
  b += "ej+cVEFDoadEQ9pg/lDLI4qasW8EIYLWWCQGOH+wMFFnk3k5rTyf9lpfP8JQ5YEAAg6Ipkgo4s6";
  b += "JwhZY8GpA23FwQIWrLIRzbd7j2abHomxsPIr9VnHtAPEb4q1gC3qqAscirHazmT02sSyxgUHES3";
  b += "YJ5ojKz8KYMYtcrLiEbuD2H6boatKwjgPWjDMGY2yj1jNQMtcJwM/2EkWMA2JkpuT2dHsDQFwnS";
  b += "gnflImb4EfBthW1ZUrKuGNSlYTWF0TpWE/q46MhJqqW0CBx3qzsQRO3vkZmqOjVwko6srtmrrMq";
  b += "dYvGTwyuTBNQeKuiMRdORE2fAX2ADMglQbINudyfhYoq5ZBsEapiFw/JRB9c9lqpu4IWKoTVeUs";
  b += "C6B0AJ1wsDC1MExVgGgJ1BC5yEAbVPUFN7mdVPXTFOdlnPK84+8LZl9ZEg0xRYEhTfgDZHA83l5";
  b += "J5BINp5dF4lU/hQhEew8J0ImADR0kSMgVbCJeXP6lUwtYqGWca9t0MnpavA6QFJDnUOUnEF36sv";
  b += "GJpEEhXxGhOzck5b8Lq3kIwkBZhIFAUuYFxV9Rr4rNQso0ECOpAwRe2iQEn96Vu9hGVWS07mN7u";
  b += "AMOTlURvBSlvuNPDdQRKedBoq7bOmWYGuKomkAvE8PS+PSKijtdDQ1rPIyrwsqBvVLB2kzc2qtA";
  b += "CJawTw5wCBqlbOgkG/JAg8z1NSwYhMLN9JABass6J4dDn1Wefo2jE7YIHYv0B+AxnWVKDS2YKuG";
  b += "6IpLRyOh7LuSjReUlNDpoQPsAI5KFG4VYcU0uVp092oWf0tSAKWAjMCA0ixTsGpHWCV4VgMQVuX";
  b += "d+cRQg3hZsURb4Qwd45HBhkjLalLNFkQFaE4wDcPSgDLsyado4QSAQc7JmecvJb6ahM4ESzMFJA";
  b += "OYB3GHrVlabTU7mrKr/7lgD3OWJYuqaBqarikGzj+js97iNR4JgDRg/JHB4YL0+tcCMWRgfCmfg";
  b += "8GXZJBXHAA9xF10RtvGC6pqAZEJimYiXtILs9NPNC1ll5WSUBGVVVf7kfxSyZ+d7jSwBuwDASoC";
  b += "+abwStEZbbKgQG+IhmQSdCOYdrHgDLPrhOWKMERxHiU7Yk/ApoJ1oA3RBqkncyVDqxBKtJ5Xj06";
  b += "rCSoQLOh3Ig86J88Hhtd4dLQjGCFdFMyHthObCiYkWhQIFIaDRFdXVeBWmkmkoAVwK5hWq8ZCdc";
  b += "xsdw3VnWD5wEcFTRQ4Q+EAICry7Ixgw7QxEP2AnU1NR6YCOLi0X01VKILHHJtRviiYAAc5xAkCs";
  b += "DPbDml12O1CZAe/6Z9fEPRToZEv64JmaRI2TEvFhi2VZaV3qx0ZngQVOl0v26DYQj0IZL4IYCvs";
  b += "tpqu2dAJY+ZTA1dxKf2Sr3O6pOigkJsiKC4SnlN+iuCqDjk7pE7JCqTJSZLMC1iQNc2W5rrLr5U";
  b += "hb+Dp1JXO7/jRVfJ9w+aQbOgySAlg6IZU3t9Zjp90Un3VHSUQUKKhWAhrGMSMzc0bFNPaLcipyu";
  b += "cjTcQGJlBU0xDS+Pk8gY7QxFI/ocmygpIQ7WGnu4NEz0Ugc2XeNCzL1jUk8gv6uuzMcQ2ivIN+B";
  b += "sN0/c0WeYUDSUq0BVsz0MUT0qM6x/2ABtkBoq/D9yz4Ws+stDVVtixe0QTDRrIsLVx8GqiqDihd";
  b += "C6qqBqyBxkzBkGTMmaKkauYlsYJi1whJl0SQAGyek1RFFDTNWGTVKp8jB/TEKMQd3RI4szNP8g0";
  b += "FwVQEDm1KMA6GVMEMj+paKiqjze9Vpi5qVw8rUpWBT+YVyZBULNiSxnHCYqZfzZqgIpr1QzmiJS";
  b += "EO+JYi2IIiwxy2lzA9DXq8EGFvzkF/lbQoaIJsCIYmWqBPwTy6lKkd0hD6jR3SVN4NGpuEVU3gR";
  b += "IVs4VKFpWe4flsxZVMVLAUwmS5Y0rKG9bMoVPazAGxMRSDybFHVZR1dxgxrSE1a1IARnwxVFFXE";
  b += "AxwxLmdGp9fi/0AF4RBytsrJpx2nGjynIKxzmCwH4yuYC2M0OJODtUnAT38JUS9LMBH2iCzv5/M";
  b += "mwB3gIzpAB7KAdSUzrF6sFC4hIfj8NLJfpcGJOGtIALYEXbRhTkpXMZfWxhRiUhCpbKJngaelDQ";
  b += "mUWPTcUHJ6bTYgE5MiDepwUvkLIBXyA1UneQNJQNqypCJVEZYzw+rlC9H+U84RM1TpxqZt2LIAC";
  b += "qoqycqKGDoG2DURMtU7xuQt2cISAnWMFwE/Xc0I6XRH1sms26LAi5qhgFIs6KCWaNcwfN1Ohu7/";
  b += "Om/ImiGJCKYBLxvaSqaBouFaZnJ6ZNWHtMyPggVE5qFgkHTJELg0ycmkOysqkZtzg+RAZUIZ9Av";
  b += "1LhUM0wC1UCFuCLK9irmxlrXHaC20dr+BuvRUAg7GFRbXsfRYY4HS5cmBwmJSCdmjaoqGySNVBu";
  b += "XjOqY+NIYxjzQVy7Ih2pyO+OuZ/0xxl2GCI9XSRI7XAMiYq/+7EbmBGRzroniVGcm0OB2mhMwJI";
  b += "uB6Qb+R0euG0VmOYCHhFQmnEYB7GYAWRFWTeV411jBZ6UFc7C+1TXIeaIPUAstGmmELgmWJmoVl";
  b += "+6aTtSOHBAmuQvOyroiaaGIOtGtb4oybmZHptc6TWDCgpIKqqIuCYshk7MRbzmRlt57JytYyUq1";
  b += "sp0bPgoi2iWVVNASYHli7jRlVL9srBeYLqMIfLiEGS+DFs4pdezgIKyzC+FiGKCpIs25nLoyyEE";
  b += "QLUarHRqYImd3wptGCmdpxHdMBwjxo0KppaIoJyO8OZlD9aoaz3g3o0VnvlzkTwKvOcUiUFSDod";
  b += "Uy/6u7ToYBNoAhos1aYLl/IooxBDcKEJ8uA/Ncz0sl1MkcfM3lQhzjb0FVVx5bAb2B611gRMOCN";
  b += "I1wtn6A0WQVNQAMixQp/JzMiVo5IvhMbSyRrY8KsNJvXRBtArnYXg8+8qzEZDkvEAlYkW1VFxFn";
  b += "K3f/Rc0Cq6zwQElkbM5DO3cNw6d1yTipEbVCUdMsyBIt4ESrcvUyGo1q6Kkc17TIbHpURvTJEwB";
  b += "EALYDDwO94ReeRfB8TsyLO8aANExXeUBRLNs37mRiWM6PM4ragKlixecAxugA0sZG5hnEqqF1QR";
  b += "tsfBpM6IufyuuuTYwtCZePhm+OtUw+odvRrh5QqWySLCqeIvG4KooAsVdrEDChsyBtpoADoOkgA";
  b += "VeMAUKHNzEoXEjT0jWqqhqf8SirMTk5FCkgCBEIRb2EG1MoGaM7vyFbH+OkvF+h0VUCrkxTC4DA";
  b += "I7QeYhtgPVFEG/iyZsqiDQq1KDzL965XIuITw19l0RYfsoRAAtplYBTDzENOnZmlKy5SnEvHLmQ";
  b += "hEsC3x8D/Ay4cbOhlsUDlERTEE0RAtjTMfYc6n9qMoI0sIl0UgqYFFS+SRYfAI9E5DerRemIVs4";
  b += "kQFjMRUyWYm67GITK/NzFgQ8kfl8jGHeGTrokL9HST0+JmUnE/AqJ7UD6ca05FFUyZrfrpJVoFN";
  b += "+UlmRHo+Lq+EN0S2jcDlMaEcSZBlbGs6R2zFov0UM702WzGxM9RrLXaVfWhJlceiICIDY0MlKoM";
  b += "lYeFpALY1h5RGeYhoGzQacalrJxqP5hUFUJSTjmtQGhwoH4Nzg0TkEr9+I1BOOKluENs0SFyiHm";
  b += "LlGSYYGaA5ZI1gIjZdBBt9NRTEpuNPTkAz6K2hMmKQzobLdPMrXBxLr6Xn9M6qtL04cDtfBG1LR";
  b += "5JMjl5AhsQ/+3/gkZjDoOaLCkwReFG8lcmoddlqcMGsXPolyg/BoE4SILRB4bNNXrZVGJPnmIEx";
  b += "WrUq9VbA5zxIfZMsu0swWZ8HCNHgvRzO5hSV+I9aMOk1zGNJk15gYt6d4rgyk0A9xLEXaMzmJdl";
  b += "8kRmc7jCdBmB9A+uiKWiCoVoSQiJ+iRmVHuUhUfP49Po8hUHjBeXFsjEngc5rvMwUnXFljjhquA";
  b += "odb2NiqNSxjg0AYuYrzPxTdxiaQLdWpZ9U0mVEdmARUkDkXWWMZF4ybUXbVhsGqWPhgiyE8QB0A";
  b += "X2AgFSwzFn2q0xa/RKfbD8opKZtXbU4zeDhwaBzm9vhzQv/T7056Pe6qmGgPQWYqI12MMYp+yq4";
  b += "bm/honAINIhS9yAO6vCtcxonKCIge0kxrZ3MsDqteycVGbrKawIvGCCWdZ6XrNeYYXXAzAnIKij";
  b += "nFcdWHghR6xe8e2TCCgKRPaaoAl4hq26vM9IJHK/3IOrKSpbH/HOpkzcoKbyoyboh8gZoDKr1Rq";
  b += "XhyI04Tf1+C0C/mOVuPtVFC0SSBjBAl0Al2lVfARBeBkh1lQMy4jSM3ozB+GArkruXyPW5BJAFq";
  b += "p+OMc9Juizau+t7qoI4kVNVXrEAS4uStSc2nc0QgNsgS5AQz/GCwO+NHfUTaQMaHCcJSDQ13XiL";
  b += "MLxgYUGDGB7WJFkAKQCCW1dBnLzNqLV6lLuQNlxma37oAerca5mGRWKqabKMRPEdyior1Wu3DZW";
  b += "xH+pb5TE11eBMUzYlEyNOfZcZdzqTiNKNpSCyU03Dtq7ZwnuxDYjIaZosmMSVQwZhwL3PjEuPMi";
  b += "O4r1UjIsbJNUNN4YA3cJIGkBHG6QMmoyYpTUBzq+YLISg/Kg6UlpFzCah/hq6LkqbZoq0qiq5+2";
  b += "NAKVAHLxK8DCaDiWZr2UUMrMLDKC4pliYgHCWMYHze4AtsAFcLSgdYMVbHMTxpagSUQUyUwd8sk";
  b += "oyp82tAKbES4DSBtMk8NQ/2swRXYkgWg0tKANgjy/7yhFUiColIObsgaQsjYVx9LESwkYRUbwPk";
  b += "BFen4C2Zw7W7jztYOej6Zo3TyfqcmuuYCfNYSBEmzZaQh80tmeOyW0Gp0rEmWrYiYJ/uOMbb5/c";
  b += "yMGNfcaze9VLe8UDOGouokSATQiMAZ4lfMqAY6AIO8jrQiHzQzGXG8LXO6BlxFORDb/NckgquJP";
  b += "zMAQEmQvmaGpAcLzVDDbMacqCuKKSEdVEx4G+6b/8hQpVoCh1RNNrBkWQD8vmU2MHV539exyBlB";
  b += "l0McH65BlpXe7aTYJxYLSFTYfIeBAbDTNZgB0E5V/a42aw4ditHUhSbH0bQr19kEQVBlQ9Z1ixN";
  b += "4YGDfN3TqmQA2ZE0QOVOUBawoPzS0AkGQQTmXSTwFXTYF/CMz9qQVkJPlKKK0An73u5/4OjpaLc";
  b += "Vzsko8vohHBi/o5k+MWlMbJsf7ucowwU4RYwdWZUUFslJ4k4QSlf93uk2BSWIi3cS8Cd2saPzPT";
  b += "FZDBHl1gwTHw4vJBhJ5WbY5/iAzMJbGkU0vfneh0NQ4zTJEW9SJBEbol4ZXoSkm0kDOqCTIiaJo";
  b += "vzJDTsY4nTAWDucUqzinCXq8pvEcoBtBkW35N2biKVtE3MUtZ9LKmBMNHpHgMaR643dGpGNPo9k";
  b += "4mjM5ZgzUTfq/6TjOa8jQbVskBitR5SzjELORSY/WtkFvwEVQgz8y0WtnJHT61laOOLNjethTTc";
  b += "7s91OUNbEAlACHAKKqdq9CmTnkm/uOwEV5DnEmwpIscpzxR70wH/O2yNsw+DZIekv9k8mvlceYx";
  b += "OkkejGHXhhXasXElorpOokkI2TymqHIIohY4S+mosZe7pPueK2aAGbA3S5CsGAMsjBiwqFe06Aq";
  b += "SrzEcaZOIvT8zSg1RcN4YmspHevaWmjn0lVbybCwhYAdarIl8P8wQ2JdWo1yr0e8KomiiDgJ2bK";
  b += "C8b+xzxChaoaopkA4EfwzecnmtcPM0GhrSezIApCtYOmWquuyImjakRj8KBxLFDl3MXrJWAGQZ6";
  b += "gyIjEMLCQcZU7m4xaiga0UUbUVE4CNishipHmMWezOq5PFoKCTIMpF211gG+/staE3F0BLa9knQ";
  b += "oig+s4c6mCGZEkwFUnWJVDErOPM7BO2pEbMF4TOChzidCwZ4yMXGgq3JBVwCjBKCySQZVSw//0z";
  b += "bVtRLAPbBidiBShvMTujLr+sGH2yqH8CCVNGi+RrJieIiCws8xaHbWkJq5xUejhnPlMHS0XhMSj";
  b += "SWAAuqyiXsvknNQGdhtsQmbpIhdaZMlAcLy397x4l6ZqOZcvmbc7EtqgtY3vW9NB11jZID/CWJU";
  b += "kG4gH5WpItX8bGzBOi9A0V2IGiCYoGjEVAtn45O+OUFfkS8kxCOdShnxxfQWYaaH8WMnVRJBPFw";
  b += "lewD/xXcpA0/AzIQg10OBP4GhY4DmENXcmm1QF/LdfWhv2RiZevk5UdXTRlZJjYFPWr2NwYta4T";
  b += "IyyMxbOcjR9ktDVQsSxVtkTVwJomLWdjdtGpcmpVeAODSm+JxN2MQ8IKdmRNSi4qIOFTRsP/NUR";
  b += "ALvEkGoHLq2zvmqZInC3KssRhbKlXs92rrYTBu5hllGULlkaszCB6LF1WJfmaWCc5jIOtA33aPL";
  b += "GZyfJK9uTrmBbSJQCBAARJgDLOvpYd1cCtbP7IoXnk6SDcDF2DGc+DNq8Zq9j6VlFlS4EhJ7Yoj";
  b += "AzlunruR4plCrYoqAJSYHjF69nY1ngdxVcwJckCDqjrxPBlqatZqfa1CrLiAAjJdFyjAcGASsfJ";
  b += "OsYwbpx6Q2zFZCwAk5UFE3Eyr3LajeyCWOYw3RabHdMUpvJ2ApCq5RBZtBhCCrZ1jkS+EBTR0IU";
  b += "1LIrdpzxGUQcA2DZNMnkxsCpVv4n977bg2Yah8bpCToBHBtZvZv/z1UfTMmTECQoCtC4pqnwLm3";
  b += "XS9YioTqPXiMAC/ZZiYZDWlqWbOiLL/YIg3sqOaEj8mWijj6jyMLNk0B41iZMUbS2bFouThOtdJ";
  b += "NigFSgS4jRDsDntNnZkva7YowNzKRejpFgQ5dct60DZIrIxkBiZ9rezWfVWFmGJTmVVrt3ERRxU";
  b += "UVnWbEmWkHJHDHVVb5gWHcpCUUjwNqB9Q7Pxuhhesnq7ol7S5sgmZ8mUTMEULY5fz45rKBXUiAG";
  b += "gk8NSbN4wRHhZ25Y2sH2rNhEUO3FgXPcCSsT5FmcJGLi0JUqmBrzoTjYvpqW/WGcx8H5L0S1ORr";
  b += "Zhyvxd7JT06juZqm1kciNQuLOtHnqTDdkyNAyNVjlJFpS72c2nHYgmevPs6cWhoRZHu6CoqNIpx";
  b += "9JMkJu2yVmqbSqafA90dfDMdbUmciYPsB3mCznVh7v3zI6kjG0sIR1pimXbqqjcx+aePjAlvaIY";
  b += "uoJ0TGSubQr4fvbUQ/EBNHMcqInXKchyCRRCxIOysJEdGIMzQzWlWjE4XcCcbJLTigxV3MQOOjH";
  b += "yTT1mbNPSFEUHUIYFgPQy2sxeEGs0AMvdx88Jkq7Kgk20K8vmtrBDYvL6WbDALAqEQIIvXEiX2A";
  b += "VTIEFiVUz2skoPsP1PpjC5omouCBAaKMNQdc0SkWzYEsBV7kFWP3lp+CVSFli3RewDoq2aIqCch";
  b += "06j7MPs0tp2qdQ0fNdlX+rWsLBnVbYmUTURxroGbAwo30CPnIasNkBvJ4vOiKwmqoLyKLuw1v5w";
  b += "Hl3NTlftZaaFRaF/6uisMYOzp8e0ouC+CxbIghaxhBrYUjjjsf/DzxcAjZs2JjvJEYJp9ThbVJ/";
  b += "zH9XA6DFJJAwPfKRHXaeHWhF1BT7SwyHCuDIyKm/PJ17IOkh+DsumJZnmE6xwoo05Yt6LuNqpUA";
  b += "AUBlOyNRJdxnqSjdmVyjGiAHYBhc7UNcyTI9XEp9jY/M9FHcCAgDhLIlHHxafZoelRNrKYOZelY";
  b += "MM2yQ4OHt5A1p9hzTPqKugEtEeibgsCcYa1iVOt+SyrntR/pYysx7hr0dCzJo9EeEtb18ytRCuM";
  b += "xbvVgal+MwAMgkQlpVKVBAwGldCyAfIIvKA8dxqzU0WCJYmqLgkKRwxgzxOxUa9LSPVQZ4iIeRv";
  b += "zwGttpOEX2P4n1a3pj/Aq/gIazkBUBUmSiAKKLUPUXmxQaZlEwhAUgWwsBx1feqlBpU0EEhMT7w";
  b += "JQgyzNeJkdc0rmzIiDE3QivARUZlsSMmT5FXZAvXFBzOJg5V5cG9smaOOiYNscx5nKtga9DUwAj";
  b += "QRDNUyFbHXXXj3Nt+EFWVU54NmciHgZW9sbOK6cDihA5cnQIs3awXYvKAsgmFU0jlBVrJN8Xkey";
  b += "ppuaJhicIajKTnbQSRbNaJwParX0B2x/hOuppsXZBiInK/IGQug19immbiRYN5PvFls40VPo1zr";
  b += "C8DhnJeiqQLfhSAgJ+utseq22izGEZVYt50c2rikqlm1AOPAfT4yxb/x3VgPdItt+sCYKEmi+SN";
  b += "3F9q20Mpc5h+um52REztclnErgRMswDFCGdM5Axpv1FSAbSmwVk+gBqqEjYTebGSN8nJsPLQ8FE";
  b += "Z1IlqlhTRB1XeB0XtOlPWysy0PuSSRmoIg6UYIKYMmKJiqKbeswC/bW2bnzC6D9UwuC6YN6Dz6h";
  b += "c0+8LQsokN5aOd1skZMMnjMIS7cQx7/F5pzi9HV2o7k8RdVsgxwgoOgk4ImB3j4z1crAGXTiuwv";
  b += "MSlKx8Q7bgW4jmEOtvKKETFMBUaxjYOoc9y5bmF6PwDuNJQtFRAAykWFpiMQXQe+x+knlMmh54V";
  b += "mo1A0QiwzBVjld5GyYQML7DSirGapNIlghTiLucvIHpyGHNQEkBxaxZMCriIb2ITvxdA4W8IcA8";
  b += "1BfDZ3TREkSkS3oiFNl/SN2ZMMiUUTboxVJU2wOMJCCQGyb9sdsot9Po1yKn7CD6l0CrQZqyDS1";
  b += "NM00CQQ0iVep/Sk7LObNKNWdSGRgTSqIK13RNMuSPwPNNQYXrGp1YFPVDXLUgCQLumWizxsk7jR";
  b += "sCSDGFIEnG5ixsI+N3lA0qHRW2N10So4DmsOTNpskcDbwOYRA7HHKF7UaL+qwKM8qDZC4QcPJR2";
  b += "TjWUa1/WwAyIHr8JJi8iLosOjLBjdof4NLfNXgEgcaXOLrBpf4hnWDPgeJDY2eMUUUgSIQFXVO1";
  b += "wzqrixj6D1TkRA2kY2+PUP1fHeG6vme9denSFYX7SDUHI45lPIyut86o5K1EXEtazwRnLwgqSav";
  b += "4x9OsaWcocoAYXmLN1QDoPmPbANDPfx0OvYG3gZ9mxdIXAodS9b/2MknM2nSmeSPBCagEyrTzUT";
  b += "2LFeurCKBk0CMgrbBSRYI1Z/ZKTGurNY/X5FJTiUwJIw5DoHoPMjG7NavAtwROAskn4kFXRZ+Yd";
  b += "1t7Mg55ywa7lqgogG/JsyPfqFwdlpO/1T/9IyoX/ORqvAq4jAmG2qBr/7KijU7vcoSHzlILZ/ER";
  b += "xZNC0sgyURN5X5jS+tzyYqS+fBiJWU50J1DZ8fkmlXmp1tNZSxoAM5AdvJEhsq/s+kxhEIpIEFN";
  b += "qQ1CkJAmcRjZMujnonyInZF+QlzdIWSRPQxzZpILnetC6NHLhpHDX0BcSqIpg+IvwRChP9gBJ3f";
  b += "cqrnAwWFDJxvvNdVGnGn8yY6pXE9wgrISNALf6EpBKdWw6OJBafqk6FC6BNTSnfgKbwKd8Zptgc";
  b += "Ktc3+xfR3aKAVsQwbfQeNuMDK6S4wjOE4XDUMTAUT+DSCYvgHhJS6NRTsak12cgVJyPhyd6A1xf";
  b += "DAkG0SwpsiaRLQG6x/iHlCH7SvLKs84eZQarIMoRqpAtrgjCf/LToxt9aFWkoyiOJ0TMBZMSeBF";
  b += "1dIl4fD/CTIn25plyRBFQIoItJoj/50qoigaOdrINDTgArxgHIWOKzwTHSdIigA9pqigqZKI0sf";
  b += "+u3cAaClhEyiJcEdF5o6zy047tm5OoL7IujCOJ8TVNQwEQlXhBB1wuIUqvP+Zfk4iytoGlkwBaY";
  b += "JlocXe/6x7kQh6JchXQeIMidOsJd5pMWl4sa28SdgWDBtUM83keVviLvX+Z6695GRPQu+mbcgIV";
  b += "Iil3h7RCqAT0LGI+H/mK6agASNBGoLGgYxb5g2eMUs+tT6daM3ndMDwvKUiQQVIZdmXef9zPw2F";
  b += "BxTG8bpAzgtTBO3y//6RqonJYpsO+BNksclf8d8/UiNBfzQMUNowFN7irvzvH2kTRCUY9LxXWTb";
  b += "1q7xTHG2Xhg/JCYCmO4QcVdWgme8Gu7ZM3jIMFWQDb5BVkOXe2rf2Ozv6C8rmFhAF34l87Jx/wG";
  b += "vIMnXdliQkW7Kwwjv5lO0P5DzeKKMBoDIOc7JBYBBSVP1q74j02mwsNWYNUTeAS8D/GZFMvq0CJ";
  b += "sCaAXhK5lVeu8bLRZWwwyXu5udhJZWbIEiwSBq5XSHx7Tl9pVeujnYm0E9owVB65mqQRLAjDA4r";
  b += "gIEt27ANSYNxu9ZbVAV6XCtY7aDHsRU0EPiooHKJNvFmV2QMWtgqb4OMwCoxfNkaR08L1BTzOm/";
  b += "ZaUW3rSHphtQh2zRL4oH/A7a1ZEU29Ou9MS37yYi3SSQVsoRl8ba+2ntGAaVzKhvlxyS4saUoko";
  b += "Awp5C9WDd4T/e8uiJy5DGwLFm0yCkX5GwpVeZu9M6tQ9RimIhkuhK1KfI1Path8j1Ee8Hpc2xiR";
  b += "SeuDYrEy9g213iFujWzyIFxNgYZIoKSiARZBbF6k7f4jIOQ6EYiHtA70AXoDeSISPVmb0OMaWQz";
  b += "FsfZooiRjEzTuMU7u47WDsclQCVmdn4YqDSr94RTbzEAAE40FNki4XBt3bjVOyY9p27+70CCCOM";
  b += "n/C+jOliQQI2XdOA5lmoqlqSv9QrVAlQ7qGVaznS69zFcUkiNdpbIyWQhi5NFXUHKbd6R9fr517";
  b += "1HhoT10E1QOzWdl237dm9WQyKTVD8IUZJtkQSst0RVki18h5c7cY2OBmeHeYoD5IBzlbNUXsAGO";
  b += "fvQUHW0zjuoWge4EMc5YxXYQ2mZs5pHrAlU96QHH8jYNGUZMInKW5q43qucEDrbWdE3iHYe8kfi";
  b += "uwOV67atcJYhc2Sj0QbvBXU/nNj1T3i0RM6iFHVQH+AVTMW+0zug7hqc0pTXRsob5OQ7WwZS4k0";
  b += "VKdxd3rF1j38gOM8fvbxC2lFcECpGZWZ+pEKYSBS0yJbCkaN47vZeVptCcxIHn7rchGLSiqI9Wk";
  b += "hQAgwwmBzbjnjrHu+Q+o6fdINBhMLAnlyHNVUkp70Q1C0LHFaEe72Tq8ECeGbAhU5Z8DWLOknGB";
  b += "hNUSdEJIhJBC1Jlg7vPO/00mb4Tp9Tv7r3CWBexDuhRJOqljO734pgMC1HNNoj/fXZ+6aAQ8XeJ";
  b += "IH/nKDpEr9HNBKYh2QjgoiDrqoY2ei9lGvogdyPHIMtyH9Wtvgoih6lVNgMZimlLukLUSlWWtE2";
  b += "n3ozssNGQZpDw2VW9YcCUBIQEgtfUDE7d7MUxWSUa2usivCOoBLapk62ourTFW2uo6Ab2emFDe9";
  b += "3UNGwjLMuqirCFrAdOvRlRvV7Y0F63ec0SJcHSTdPWkGw+6L0gxpPRIqGWFNCvORNjwP8c2YTzk";
  b += "Dd2h0jMcVBQNYD0BMHE5sNepfblWWfDjhNhlAIQckCwanCapemKgbRHYi6oKzrHqdi0TYWcCvao";
  b += "19lmH7EnOxZyP826wa7dbfZk/zoJtmQLyASQrD7mbU435DuOZ+GSuSAlHveembWfJ7zSSbSYSnc";
  b += "KQBPESoM4ntc12ZCf9OamxxRji9CRbRMJAjoE/cEZl1IcLKVTETgs5pEuc4QFqk95S87ESWXILD";
  b += "vhoDInIq5q2EjjTdCcRUFSDP5pr1V3P9bvbF+TFMIatbrkY6AZUcAWp1gCKCbGM976zyWkqIcsp";
  b += "RHoUxKmSidZiDFNRKhXt1XOfNbb4sRz4bfWBtxB6pOl+8o4ubKo6SqAaUHReVBkxee80omFrHAQ";
  b += "6iQCKlIM5qoh/j/NfVd4ZMd1psbogN31rj5r3/ZhVw/rWckiqcpBgoYcjiSKEpM5tNaWloYqDuD";
  b += "BABACyVl5P1M5S1TOWVTOOeecc8455xz3nLrdjW6gw+0GxvaDRMwMbt1761ad8/+nzvkPrBWOp1";
  b += "VO5DfNqRq9AhFxea8BtKGCv7FC6TfP3WK8RmB/YnvIDgghMHNjOQdu+BbYO5PSHEut3lLKjDgpH";
  b += "YHvCx/YvXXOjtoOuF6vWewmgZW+A8kEhbLpljqvw9vwrpOL2HByjcoeBb+Avxoh9Nvnzh+2NHDd";
  b += "lkBNJx+hi/TL3y1lJTMAXWANADk00++Ym7axelVeGT0zwRvMZMwyEfnOuYfNgO8OuCmcyDIQwM+";
  b += "ocKNj5u8ahvtLZ84e7neo1qYoAZIKMEnTd8/VzZIlPEYaqAewwbRi6j21rzTJpOQpcgS40pL31r";
  b += "6SEs0MdY57RhXP/H21r5QUfBnmt0kWjYnq/XPnYkkhRiniCYwR9EB2py6hRIKvWjuZ+OKp7cLkw";
  b += "ZpHaSkwKgkcIXxgrtsMbvP0aih9NTs3LwZuswqnBe1d5krkDO4J9ugH58LCCAlN/MqLwWGQqcIB";
  b += "A0WOYwkfBYzPsHl0NgwcmvvQ3PWHpqoi7r19R/hs4fBoU7BwbNjSPYb/OdIvsXy8Gx4vEpYVGcF";
  b += "2rSlp68H3AjKMH567y0wSlt3fuHDzdssnlo4UDd8l+KnkSFtYyy5T6owUOX5kbmuW476L0uZmzQ";
  b += "O/cgRvweNblYD5EimYZx+FNzt5sG/mgkb5iHImR4Bsf2zueP0zstEJ4Sqb6JMDFwB2wLCPz73q0";
  b += "LTDTrV8dlmz2ReTt5pr8LWANIFtOPOJuT0C9zv+G+xv+Xl4bluKFGxSBNzqospWfxLobSdBbgOA";
  b += "DbzcaURt1U8XxjFvjuBk4CmBl1AvmMuEOVRh/NTcnRaGNuWd5SRBRmo1vL8MicBE+E/P/cPMGkb";
  b += "FMfR5akds4uCoRUqKshA/Mze2oVg5nxOEGTBDhiVjAf76z865hcFATHm1YyWENlBFWf+dFQb5VZ";
  b += "BEG0aFcJ+bW5oxs6p7CoTj9/KrBjSYhU2WKaAHQGpg431+7tY16dSA2jk2ywwYY41SYIbnF+Zu0";
  b += "ztZrCa7l1093swDtQTnBaAaj+aF+uKM4xBDEnFKC00KTv3S3D4lxsAlAnIOwMQIWN/Evzx3zuBz";
  b += "VUH+nSQV43JgNkgtZfJZq6/UY0iU05goIF1CGDeBf3XsZdVNS/qzB3QPSCdkJo1nX5u7vIoWj4A";
  b += "A3YVyeQL3u/q/4ZeO+uUyD/jnReeXS1U7MbAAiWUxgPVUX58TE7B3pYNNwQECwYbVpKki5htn7t";
  b += "Q/YhxWZU4tcGsA69+cm6JY3uioYbEqqRwTPLtvzV04ylWtrq1W2i2XrK3eCX6onFt/pQ3xDvCai";
  b += "YxxAH7p23O3qk/UCuyDfS7AjGpMPvbuO0CM+3gV+vDN7qaf5hgP1TAQUFJpKAlafXeaCSIphYSt";
  b += "tKMEh2/19+YOrnJcGG9iFgCro9PG++/P3WhxcSOudAIZONsp/mCqz5ksoY5gVAiYeSA/nPurPZ2";
  b += "IfzR3WZ2skL7cjcvcxhZ8tJI1VFKGijw3wN1EsT5G+h+fudWdYE1g60guBQf6b38yN6YL60XLm1";
  b += "tV96jlKt8aeC/zSgFIdClw8dO52RP4B0w9mCYnUc43IzPi5mdz/zTzwL1Ge13FcLcOfPKa5VOu4";
  b += "6EFuELKGNGRJNio8udzd1z4p83FojN4FA9m0bnN4mKZkDEKpUhCthXcL+b4aIIP9GfLlb4MPKNd";
  b += "AzxpPA+O/fLM5U5RIYFF5JBt0Mk6/qtZYgFaiWB5gP9hbb/Qv67nTTgAAqOdRtlZAIv0N3N80I/";
  b += "cfvOO1UGu21zsIpIlIsA9MuOAYxPtlfvt3H0PjXA/BSptdsnJBB+Fb9bxUIWuDEVCPbxbPJchFt";
  b += "h3wBCt9jTT382tn5ED277WBcKh9poF/EMBcwT7+zN/SxcQc/MggrCGMvKHOTPySG9zfQWcgtvqU";
  b += "H0huScJz3Mkc0HFP3YXxphLS26yU3BlUjaj3Ef+09zJenXN8JGm74LiVHCRooZqsjY7++e5mw4/";
  b += "bS3tdjiJScOeDl5zbq9tkL3Osesbc9XtVQJWArYZoiYcINrdG1cMBC6KDdgsudYea53BItVRnNA";
  b += "5CxvBbnMYOyZ2j0bdWPSM5WZgwuDrY8sPYHjeuHs27jqFFNRs99QyK2k5wWYdSjp9r8ad9i9Fsn";
  b += "h1cnhwwSPVRpkIuEBksF33bpw7WfdjAP4DgjKKA36Rmici830aB54s1Z/UIwnXgGaCkFhjGPx9G";
  b += "26CQsLO0w8e3xceWyVm4ubrz7zM2NtUYeY9ihza+8E9pup1ObzeYqDIQgVqwN8oRwDMAoK/f2NU";
  b += "t5ewsraKNOdY+e+06UMdH4yiAUYDPmU+gOm0D2iMVUkYVEdY6D95H2dFbIZ3gkVKqNGC+fzAxk2";
  b += "HaJrChygl64JIlwy2oM8kmwc1HjDNyfKu2u0hsW/gV1Wo5nj5GUM1uxrO9eU1UDCyNDBsu0aN5O";
  b += "nBjesOrc9QRL5eq4a8nnpICElwY4vAUVAiPqTxmGlOgQcf7CDK1nceLUtM06I6R4/BnPTQRq3kP";
  b += "wLLz5IoSoMIzcJ19S6TEm6WOJArrjEV4WGNO/S1Pev2l7rCnaiqaCY4DRWIQKLmGLgi2BYPb5w1";
  b += "POy/XhJKjGKJZJ+Dx/R6LR7R+Mdh1qR/SezJ/L54ewv3bVVvdWXX0nTwgQHOyFnWVCRwKy48slE";
  b += "vSzVEoX0ksNMENsKSj2pcNaUu9YwOKSoig3TYw4kAhw6Pbpye/rBqxnsDPwOerLxUgDUZN49pUL";
  b += "Te45PhTAwCs8k4KfJvj22cV8984jNsl7Mwn2MMlHgbgZNylR/X+Ju9kc+Oy1wiymqSgR9bwZKj4";
  b += "vHjfjl6AQYzeqbBhQounjDul3PQWMtPsDUknn08sXFeRwsez4xQBn4RFvLJSgv+IvipKCxgwVtf";
  b += "eQU1wG+BqvKkczJPatyur2SukL3jpze30qnSs7n3D0erJM3iUjp/tUQMzTraCLxJehHikxsjJID";
  b += "XXaxktzdQIaAKJKxvpLxcfAYDDJe5DhHcLVXiKY079I2Swf9sDWtqX23qsqUAYva+NaPwesJQTb";
  b += "kSzsmndkcbkiwwUdZ+iRNBpTJAjKVzsNWe1ri4Sww7/7lgZc27lZ3lN2q6Op2uEwNHw5QX2gJni";
  b += "k8HGDzzeJ3ATZG5AoKcMHiEFN6TZzRmzrI33MLyMiaArVPgw5/ZOHuEcez0X/AOJshSPIL38L/r";
  b += "R8KY/VGxbijBYL9zDiZPJi6tfdaZvZ1BVdCYLYvg6axTzx6BZzaqgwRpjfBaa4qhyecc8Fp57pl";
  b += "ZK8874Md8/gGP94Iz89ovbNx8dAwKY65LGuP7HgUROUeVnhdN2gmE2SR99IFJ5qN5MTz4zIdnO+";
  b += "dmBhsTMao9tc6xnF5ywPP70jMzvy9r8GGjdv7YkZBbkhiV9tiEGnYZvN3La0IfJ00k3HqO/YnhN";
  b += "V4x091e2TgyGk1fvYwcFLAoJmZmV2kCBEz0STRbbKFn3Ktmuu2rZ7rqNTNd9dqG2H0WF9y6C8tb";
  b += "p/vLtIzEFtqO5wTLjET7usbZI3LtOyUBWYOxZzTkABTZ5Nc3/mWhak+9Q4+Pl9bUd3QbSI8LmNj";
  b += "DoOEflxHsXbq9tb69hb9XRGRXq0DBVZ1/XaweZVDjM2LTe1jHHJOCtTRvaNBx0dayagRNimYgeQ";
  b += "AMsN/WG//Nn/pN3afum2e3CWah73ATvqTOLHiVJcnO2TfXuAY4gVbUwPawRpFo3lLjGqUsDYkzI";
  b += "gnmeou31rhGGy6c4sHrwAG8src16mZQcYa92zwXGcB8MuLtjbC35dlg+dvGeAGGjQH5hc7Jl7XU";
  b += "oSSmC4HB872jkUfAhY10Fa6Zq6YNr3Qj0pEBR81BUS2dZuydjdtOIDiD/KaXci2dNywCxnfw6Wi";
  b += "m7wJzP0UV0J42CRFIq0LaIqTARtfvbugah6XlRAwrVyxwTOmEUs69p3HWcHTf+XUXRJTJAhgPBv";
  b += "zVextXLkzs7jyFuLCQRmhg7Zlk4MtWv69BFg5fMZb3ea5QWEXyBFeEpN7fuGSK8Mmw5CZNaeYET";
  b += "D8hgAbJBxrDqhBqhWLHi1foCG4NPhoAkOBC/GDjSTOX+9QuSZigDjxQnyBt8Iw5NEmog+Y+1Lhk";
  b += "yrxXsAZrp9Y21peWcXEsEa6sh08sMW9fc/HhxqkDfeHdL5BgCVlpDPcak73FRxrHF07WTY4f3S0";
  b += "56ZCFcgCCMLXAfbRx1sAJeGlLUo7Otk1BjJi5rDGXPgFmUh9rdDS3u5o6F5X/jo++qxAVam0C9K";
  b += "TCu49P3hbCOmIYIVmxIDlxn5h8icbTPemV1Cp7buInG0cmC8lhAlgvcAE0GrshKu98Ilp9qnFev";
  b += "QF28uq5pERjWrpyGZyn+XTDTk717tw+SMDmtCQIKUqj+cy4IEug2oEhd+DTgmYqf7YxdUtBl2F7";
  b += "sAT+l8gcOfvc9EMA3cQemMlwAFqZ6M9PP0QGqsws4xQWo/aWfmGGISKjJESvvKeRZPHFxj5zuzQ";
  b += "N3gkHb+UjgQn60n4HNEC3XGQhCEkEd+rL+x3QZ0ALKieVPHAaEb/SYCOy4vpTyaTxACuFdFIaQt";
  b += "1XG2e+O5qmKMpESQZsmIAjfq1xrONWu/3lKgnGy3buN9hJroKX0WIsXjAKqFQl8vX9zp/MzhjFm";
  b += "KDgHxxx36h5NGAc4QA2AteEWhG+2ZihkWfG3iIS9VKYs+Jb+30VwGHYrjATWAw5yPTtxj+PjKvt";
  b += "KRXvKuthnXhHdO/wFWcNSV+tqlvL6crAhUsyoIQtV8BVEtVWf6dRK0WrY7KDLCklsDuck1p/d5q";
  b += "LjeWAs4SQQWM6C/veNBeDU/GBBKeEZXgK+P2pHtsKeGWOHeWyj07+YJqLvUQ+Qq2ihMPW5T9s3G";
  b += "xoC6yKHLDsIqw05oK1Gh71R2N/GzVxnASODHjMAKD+8djfBgruSWLB5BQTTfEn4387gbPIAjwTj";
  b += "c5r/dODPmLSKFkP0xJ0SIlH/7M6No27hFrK4Aw5wbLYn5/pp/pF479XCrAlURDnHPOktYFNkEPO";
  b += "2f+y8eADK4uaSc/LJCc8h2WjADo6ZX6FmS+7Ad6ptLnpTqTFSiwE306IbLBSJWZtf90wY4QYSpZ";
  b += "XTxYSLKkyHMhU0jER/5vGObs3wK5ty5k0gD2AgSnHRfjt5AssxdPl7DSASC5+N/ECYKUplsZbSl";
  b += "IWf9+wk9Ike70ejXOMazDzRAmWZfrDpJupJLSDlRFYxjIf9scGH9dicqXcbolxZznLDLgfbEEV/";
  b += "9T455EnQB2j7ddKp6jz165ZiKdXO2u5n5verPqrU27jZBVzWI27/+r0aqjKSA3x1gdVhO0lz39u";
  b += "bC9Mneo8bNmWvXVhOdKvGmFhJOYqTJk9VUScWPBAI3wmYKkyZdc2T525+xaU7LIxJAQ0ijTkuzd";
  b += "JlQVftnBRtDrS036oMiQ59dSjjqQGH01svEfzlmNTUAZjZ9pQsNgZ1p8Cl2btPZvnjL16yWEjhO";
  b += "wEFQK5B7tX8/ya5RZ90qwkxgTw2QH4jbgX7928YGIDtLL4i83b7ut+xrAvm5OCZ66ttO4+Tb0rs";
  b += "NMNNN2pfJvlzW4PU2ENwwK0kIjDDsz3bf7V4uLVnSTOxeqE9n5NPUz4tJTGoMlDgZXtzVKoS2MS";
  b += "nhoAFoYZku7fvKTOYeGAkN2FA9lSCbAbDBkBcFClyAOaf1+/0HwvZ794e+VIByAugaURXHHs3Qm";
  b += "vrvID9zf00RirQAAyG1yLKsI+tcHwnB+0v6GPb/sjnUbES157kzJQJ5mz44Y+uHn/QwsHpG+Cf7";
  b += "hg223E2rJpwjEKmAhbvVjq1UP2+7m1EzmBKcfO00C7yEObfzftgBUq2IUG4PGSkNEi6E0y+eua1";
  b += "x7a5zoaJjQy5PojvfXGbanXA+oC6JlL+7DmldM+wtikPxK9JSqDd8Zu8oY8vLm6cKI6qF7saJ91";
  b += "zq1Lwj3M4yWVhPTg72ymu26DZU07p9ydv0AagRp8qx3RsaUQpArATX0ySjvKHtG8omY4eex7BC4";
  b += "5BWwiUGMpJfXI5sLEYv8+YCMMrCElhCdCKqfdo5o33wujsDoQWNnmYtG4wxo9xQDfAKxP3D+6ea";
  b += "eF3YD6Yrd+NGDD2IXLd9Po3j91S4GKNtriZqpqz4GlGq05z4kLSsxjDnJwYTJKHUWlLGAznx57k";
  b += "INnpQDjSKDtBGA04Y870MGNgf0ok+FUgwm2j28e7oPniz0LtsQzwHQFZga2TCTMP6GZDjYlt2Mh";
  b += "AGkACQf8LQQPNtgnNnfxBWMDzy4YIF+WA6x90u5f8CEAdwuaC5UUEeLJzX8cLyUyTQ+xI0V5OFE";
  b += "TFBIE5SWlT2nKYW75eDpRIY2ltZWq6WBWMWotCzTgzD21SXeHLqp7LvaCFkteEQ9UNAKk8JJx+r";
  b += "TmGU5MfHqzBmuMLJkQOJ4ZeSsVe8aZfqpnNtWYk1+M52wtFSYGO8UCeY9BOZVCJtejg5mlqL487";
  b += "+UpbsMqGZvJW2JM+Gs9y6cBzEiOpUacC234s5pnDZOB7ZV3epMlE5YIrTEH5dn/Dnzic5rnrdeD";
  b += "0YBg1wrWQgUjsK3ZY5sDY+Nzm+fXHKL0l1lfQRdgAU0FcJ0U+4bD4zyvefdDNV/m4CaDRO6oF8R";
  b += "hSEJ6+vzmxetTlHDj8ljcXi1KhVXaDPdGcik9sRKwT3pB81Y1x6tQbAJjFoMwwiudvc8v/HewQF";
  b += "60z2cAlD7FM1TzwAxQBSYysxxlNOWLZ7CfL2mSwQybdE1YQqe12DXbS1kK2I2MKM08uET50ma9V";
  b += "pcZEA+PBD4UMcK6lzVvWV8PEjsDWphg1GZW8Hrh5U0+1AwfRjvcLRZZsuiILAvWaIAfhL2ieemY";
  b += "mtgrqsQM8NFx7VSFCS5ZO7aWNvAJNqvzBooClCliOooC08te2bxRHw3dSGWSXjXDxL+6ef4E7po";
  b += "3Ulq8GqZ4cb1LY7NBE8qttQnbFsfXNC/ZTcyXdyvE78kc7u9ObqgRWRLKbAKgnMJrm/tqlta1+E";
  b += "ZG6jlQwixIJIS97mCG9RoskEdtSBYdoPzXN283ItsibHbvUyTV4FWv6espWhJXtY5A3S0saBmUf";
  b += "sPsQwWdpHSWYx0hkEP/xuGm4Iy6WOEcp7BnMNaSRTZvqu2vNu8KxLqcrEWsbcFkHq2JivrNtf1V";
  b += "X+SIRWYkCzkSw2MO6i3NW6/PoPYBW5c7oikqAnmr5FuBMo5ThhgZnlg4PO6yI73ohUiRupyICNw";
  b += "C4HZva9qFbc5q9fiQIhoXOaY/o26kenuzri6W6KC7nAWn0hIakqUxsHfMtK37CgI4rIOYNLAk4Y";
  b += "M27J1ATqaq5ev+8t8VGdieHuzu8KRjxBjgxYF7hyjnXT1vsisVbscOKiedBmTnHLhwx8m7J19iG";
  b += "LAy+H0rNVeSqfdMvoTG5ID9x6hQN0jz906+RHOJ/ZQsS5I5Z8z7/pXm7P3NMFVXhHQN6hlU7uk2";
  b += "+DOGGvqS86oTmOxyDLAMPE0akxk+UOPLwARzZ7LzSijqwwf37Ty9CFRR+GKUwQfn+UPN/7VTwVb";
  b += "FO1bcZqEI1Jb0KuUMmnf54eZtF+589Mo9lLlIZhTC3NPNWCiCFgnMWMkFDjbHTLwBQsZZEB+Z/N";
  b += "6W4qGtBGxDMsk6f7Q5ra4d0cKpnLFogqOH/tj0I4CV40nqEJjSSfiPTz0CFv8kyQX10hir3CemH";
  b += "oETGqM0EXXssZjjk9OPoKlymkpvlIwy+E9NP4JNOqNuAMt4BJ8/PfUIlsH+UsZh13JOgvrM1CME";
  b += "sOYCVhEqfWui+WcnLyEus45eJx4Ch20dPtfUo9UOUPl9swA7vNI4C3MtlYZPByD787MufO6SBAR";
  b += "HifDJqqC/0LxgR0un/1jvDjARY/PemAcTEBm1YD0BqPIvTkSqBZ6WLJIdpArwHV7NZHgxQBT+S8";
  b += "1LF8bkpdSI6csYImVBAYZWClDgl/c9olLaUwLWIjhqknNf2feImmqHKeUACaSPzn513yNaYogLL";
  b += "kvvrE+Ef23fI3pBGRUymqytzTp9fd8jBo2RL1Zl3ahAv7HvERN2VJQKQK3j2OTnm81/3H/noP7m";
  b += "F5zwYGiinGkPhiZ9a/8fimauGZaTSGAmUX27+X9Hy/YVvz2tdt/iYvevF7Hh0GBEBdXGObbMypl";
  b += "w8p3m/5twc4w2Htz9fcCGjy6BA1fKx/RdsGLebSaqsH55ioR3E5WITiQAiCoJ6b9X23qzjvWW0j";
  b += "MsSJRWswQO6ftNseDX1lYmiaoA8BPCEvC/4EZD+gGsuAOSioDJKkrbGdtQAsRHIQDJfgj2GadIi";
  b += "d4UbdabI6YFwATNKCdZGRZ/1LxN3ZEGJQw9khZwGw6bu2X64+bhAeWr7qJYct44b0mmxMUE6Oon";
  b += "tT8K7YavtTNBenh1p6jV8qcHeWTDaCYCM4ZkcBp84M/2e9jLWQ6CRw8LOXjv0s/3OyDAWhKjzlL";
  b += "hQQHTv2jebTY62y1kqEFqd9L+qbcUyBDROnkhk/vlvm0dAWvPFKpowlah3v1q3yPmHBRTsWQURy";
  b += "7jr5vnT8pf2iPPtWSVgDfEI3rJeEzyN83/1Cf599vmecNgzBUbKXWgzErKW6fWNlEzcbkUOGmUR";
  b += "onZcHDB2F37d81j0wa+8euHrKIGForKuMKr3zeP1FViKEwLXIuQGvaPAm4RgnV/aK4OMe79wYER";
  b += "Yq3dtAscvMQMSpJp97Rp52wTJRmp8SliTyYfzR+bdjgCLheVRLJe4NYHg0lDVorMFDP6T1Nci8n";
  b += "xATeewRJX5f/cnIcPeGJxbe3Uta1zh309/GSbS8t5q6REb2HEtLvpDI8a1rvMwiRuA79769IJML";
  b += "YAhB0Uu7iWqxhsqH5lyRhqgmNSqKyADad7tG7X8bIhYbXG+Wtgc68GzzrZ9nIGSxTAtQDDJSIL9";
  b += "2yx4Vl+/QKUlHgaOVUSvD3nxNyrdWSh76rJd6UEME+S+GUpNuq6d2v0Lhuqx3ek1AMXYhBVBAgV";
  b += "mb1P6y4TrOOgJs/e9ENYgPD7/bpExqIOuLDgLKVI5L4tOqSofGvj8k4XrlLNG72x2LjFMO8F0fd";
  b += "r3XzY53YrYBQXt0uqr8JAMmE2COYIT/dvXTp9UXhMfWXmGgi8AALos7dAHdMDWnK4ElQRvKsCwh";
  b += "j9APbnJCFJK4Qt1DywdUmPunWUWTsq6wPiqDtbeKDtdXk1HRihwWZFkqLyQa3/AhsJe7N0Tiwe3";
  b += "Kp9ntnNfbRC4qYUBrhIzJQ/5MCn66GtM27XrAH/myOKEkqmr2v900HdcO/NuOQKJUWoh4/rLHlY";
  b += "6392Q8kedtjJjnoYL/qriWgHTI8F/vADn9ZHtG7Yd2SFFu2RB36PR7XIKPOM3VfL0YDF9eODALL";
  b += "NHHWPbt2633od3TixjStuc1JJbI5Oe0PwNM4AxX7MeMvZgbqOp+xIsigCJKV7bGt0CszQvIqb3P";
  b += "Sskd2KjpQzAOD8nASCrVdjUI9r/f2EG+w6xxwOakpuNSd4KADYyAsPS/fxrVuPTt/pmpm9DZUiG";
  b += "EamYdqygQlg8Qmtq4dJAS32TM3Qeqyy2CdKCO0q2eKSCmJZYB4srrRPbN3tzNwZT6X33j16V1Kn";
  b += "JXz6xOKTWn87jeDeUIlmA/6J2uyANsEKpOrJrf1GyklOUQpGBeo4GeKfAk95cp9PGSkKEPvAtYq";
  b += "AW/hTW7cd4nwHXfVwwpmJlUEKxy0PKvGntSbWzgakGt5iBUg0LsuntzplDwXJdLpQll5inWaPEi";
  b += "ANEQ7sg3EOHOEzulM6tYRVZxUsWRlZxD4mklgU6npm6y87PrBMwvWt/9r/x46oy7Na5y70DvyW1";
  b += "uAxhzXUu2QNM0NX18qbCmtIcpxrkcCv8Gfve4Tn7HuE57aO1tZ666ZO5JAdd4kEH7wyjD6vRRf6";
  b += "vrFbPQ02ehUXxdbpdUDZlf6NF4oy5zQxSbnw/H0/+Qv2PcILW2cP+HQgpB06tpFyURjmShmBsE8";
  b += "nFfOL9n3HF9fYDsaDB+KJEKGBzIWXtNiQS3Ztu+wYyrNHYI0AuLh/aevwoNPuJugALxFgkTxQ1e";
  b += "gIFS9rHZvUzWPIMybCBVEAnpkRDFDey1sLk0vNXa/BADytVRpPjmABaWVe0RLjIjxd2M49BVqjt";
  b += "YCbM0H4K1tTKPL7TAyTVGFnipyteVXrFmOVWAYyjICiGmYNVw77civ66jrfJIDhZwzzUKhGbP2a";
  b += "yd9eBcAexKUUKAXfy19b5z5gr1HsTWFPTDyTfF1LLhyGl94VGLtN0QhOsU+MIQiVKNM0Um8JfX2";
  b += "NXcydc8bBrseWXFmlN9S4xngF9AxVB7GbiMhvrHFNiEabaDWxYOuNSG+qNREwC0FlMEsJwE+gb2";
  b += "7dpt7a3j2Owebh3Fo8ZFVJv6WVD1pYvIrzgiUEZ0Npohm7QvG3tsSYsEPonpdhNI3Ak6FVYsLat";
  b += "7VuMe6yleQ2dg7bSJTMkyS8DRR1C97e4mMu7l7FcwTL4VBhVqoo/DtqfEOPS8RyyjNhxir2zlqG";
  b += "TBpcYVlQF403+l0tM7akce3qtNGpnrOEEE5h+8gM00nNu8dfuo3pGJ1LsRt7IDwSuDsHzPue1oW";
  b += "1Vs4wQ4NNgIHLWZhb60LI7z3Asd7XmlhDSGDiQoZpABdiLHHvn3wJDdwLAbhbWUFIsB84wCf+YO";
  b += "voHsGqvk9RbaO1UuRbRepLhaih2EEIuJsTmaoP9SISHV754ZaZBMt7+b8ETLbWgSlqYyLxI3Uur";
  b += "fK8eELhd5TeDsrBuv9oa6UWG5hRuBeL7R2XHFwb6sC4j7XuWj9JeMZ7YkojVdz6pAF8y/Dx1p0n";
  b += "Vz8Nr8m8EOVri8ZYL6sdQEZMWEYYfDQs5k+0zMmany1bgjE97gIFciDUJ+tc2knPo95zHqTH2nn";
  b += "wOJ+Cz3byzH225GGxlkRTESlsvE/vm98lRgBnROsRJUVDP9NyCx5Vixf9ds446Pn4p/PLHxbKz5";
  b += "jWdRYma9StT4MdkQz4HkySVcnEz7b+pX6bhnptiocIBvQ3LZbYOdt6ojARKjD6udblMzdt6K24C";
  b += "L6fEWGx62gmSn6+dfspZbeWi9LAVimpM9iomqaAGiecii+07jDlYJ06wyKahF8zgw3Shkinkvpi";
  b += "6wxXNrqYmEb9DpOoldJ+6UzfEOhNAGiRM9ACQAryy2f6htFSrQ24GQKGxhvxldb/2WWcVpZP+YH";
  b += "Wo0P//SL4/ypHFxZSr/R/KSgF68hn6TnLJtCvHqhxzDB2yjYZrbjRyX2tNblCtG9xAoshsJ6UMJ";
  b += "EmGczXW+MaaJb7XrNYJYJXdwc0BwY/eSako+IbrSEFpnDNzn4F3qVgMli2YHYEi99ssZFXYFVq1";
  b += "UA4kwi8HzCg9BE+07daf7s3U22gV8RAdGrhzudf2alyO3plN1QlIkNCTSLQKwWk7NsHiFa+c4Bj";
  b += "fbd1yzrstEOJpUjOwTb1SAmAXn2vdUGR2hhC4CYgaGKDMAF7KVHmmTLfb/3Hgp0KB/nBqNi72yz";
  b += "B9xL81bCsogiCaOOl/2FLjiEIp05hWnPx9lFwabXSxAGCVvlHrcumP0OtfugeohIJKw6mU6qABT";
  b += "Hqx8O5Sq9YdKtK1TNE5xypEJ4FychPpvoQ3GbGgBnDBsHCEf3Tlu0L8OTt1VDF4m+7emkxUoAfV";
  b += "hbXyo9LIaG2MAAXCbubOvez1gy5+f2SGNrGiId9zDHNpXY/b108w4BmZ7zgAY5ZqxTQOJinX7T0";
  b += "aHWa46nTw6/YG2xAzwFJMxF5DPKX08ReNFybIswK6rZGw38107z01Sxoxn2MQNKNZ/Clw69b/6P";
  b += "v2AqFLMEIb27hyVkxT2njN63zJiWJ9HeyK4fXJDDMDYb9FJzU6rf7H+J3rQtHDjE2TwfHAkaUaD";
  b += "AqaEHB0Py+NUPaCxhNp7RiXEZOksl/mByTwvpalDEl2aUkhP7j/qfhT6271B6iRgD/SFV3ilkkz";
  b += "itjMFHtz/t/ymvb+x7i7vsf4h7t28/gkjrGTOgQgUUx5cGzUMLv2b7+0MK/zlHe4uI0Tct0ACOX";
  b += "kktBK8Kovlf7uWfqQYed/E33sFwRkfEwI+lsPWX33v9Xvk/7aKX8MCrLFhAFmsnj26dKyh5mvjh";
  b += "w0ZlSTQR4XPD6951hjAz405hs0CvwTNP92v9t4KSrOnfrBDjv337IoaEAuIPch0Lszr8VyF8wLS";
  b += "7dmi2+Fn1VtdilBksKWy96p7wgQfPoHtC+aooD2hp13Lt6ke2UcCvhPXwwmC+iuMsPbB+f8caXp";
  b += "BPlQKMsJEelcap0IpCGxAe162baxLVtX6m7OkLBLwOVgMcShD+4fWR9PI2uGiHktFg9g3BZ0QSY";
  b += "OkeTOGEPaR+tO0CvHJQpRYGLxIAttrPPD4WFUg1SLYndAYP+VypZ+t2Fsbv/XJ2FgkGFmBarZ+s";
  b += "VFQuVQlDe+ugMTea6f3dL92HtW9aIaHVnGJWELGAwHxzsYkUeXudq+MCdDBxA0NHB/qYC4Btjj4";
  b += "Btc3L2bXOy9rZR2DveMZoylVIa/ch2RxxucNqHKcPd+Ypb3viSK3dOxhi2NeLaMxZ1IuZR7YnAx";
  b += "cgsOA/YOksyw+yj23c5IMn0nqqCI/BNYHRLFPVJs8e0zzs55Qa20gLVECEYLQ2L8rGTXyxwsEJJ";
  b += "aW+k4MKFx7X53kv2NDpwWGoH7oZIGjk38vHthx46OdMm3R3Zm3mXeqo5qlJIix0/iHpCjXcnChi";
  b += "ht4I7ZrKyT2zriWGTqsrVluNYQWAnpKxTfFK7xnGUU1nDDGfYcgwWU3py+6I9opFTlKxQ5ZyE5z";
  b += "dYTGZ1fsrkF6ZBOGW9C0rSTCR7ap3HJiZrD/vdAJFlABOe1iZDgzV9ASWJPUokYETJsRo/Pn3yo";
  b += "yl4suBhT0qegsvuGXUezepkiSXBJQxQSP3MyfchOnDvLZAemcCip+vr3Ad8awaX5lWQEi7Vz6qx";
  b += "tsBMRB0UkyFox9mza3wdQNYBFpSOzrJE/XMmX8JgsSsFTtepqElOz61hySIhklAlCJLokJ9XZwL";
  b += "ATgLJY4DsMJFRh+fX+jokWCc0IyI6AkbpBTXeh8IsZ0O9joTDH15Y5z4CUKfyXFhnDQtCvGjyfT";
  b += "B6oC0gZmYtKoG9ePIlWNoVMfRIMVTs80tqTUHyWDqReADcYKN96TDrehGeO/dbV2VzJvAmkfIMe";
  b += "D69rMbacYFbT4jBEmju08vrGINc4lI2elzZ+hW1FgIsZws7O2ONbXDmlbVmQRKeKFdaArjUMr1q";
  b += "8sNlICGKA52JEX7k5NV17pNgbVviUC2Ru+DUa2r5MiOYjIIYRFKaUPna9i12+Z+AyUZrJch8bOt";
  b += "Y56cqJwswNwHrAHPJmVWOvq7exa5IzjPAuLDMJZAvB4+cXt++16HRV49ugzz5jpVbHUw32yl74C";
  b += "TGIGGjUg5oSIo3tP96V0FelWISFZh15ggwl0CZJ29szxA1ogCjOQeDYAgz4CTe1P6bwZKPraWNt";
  b += "au7wT6U89HC52C95869uX3ryZ1M3EYpCj+92O1VvCQdZYQQqhnYCZbMW9pT6NwT7zAILawOOYGZ";
  b += "eWv77xb6aH2nTqJ6wWmYP2yFkCKKP1CgXIG+rf2gQ0MGnhihqGK8AyGInpTRNM/jJRWWZBfADwn";
  b += "g8W+vYa7BhQAYz0YayY0g72hPEx0XWDIMiCJmC77FyHdOdbXmVjGPnTR8JEqpd7XZuCOC6jicZY";
  b += "p4FyiyJwAT2bvb45KkenlONGgLbCtlAc7TG/6eth17dgBoCDP/NlaL0i5JFgCpt0kLcNTvnXAtb";
  b += "LvFvOJObBYN7+R8xO4GYCi80u9r72pL2FH76ouv4DZNjiiO7Rq1DOCz39++1eSrNrZ613MDcAeQ";
  b += "FXg5B7MVPwBmtJMCOM7IM21hc1kjpHHJxQ/WWD5gpU2mAHa01syzD02+JBmhrQAbL71wxNoP17g";
  b += "kUUKpBXMTOXU+faTdOpVOhfXTH61+OLX+sfLDZtr6OHiZKyalOsKKT9lb8LWZJWbsJ+pchC0vAK";
  b += "SYbDQ2M5OfrHORUQb8SmAySWw/nj9V5yIKv++1w7pN41PIn65zEUDUyNBvRvDP1tvP1LkoM569l";
  b += "9oCjFKZ0s+2/zrnDsnrV1RPOmkppMJqs8CY+1x7YXLaFG6hqwrXElZgn0ybJVXwCd3nxwSV9khi";
  b += "dh6BapOYdYnhVgxZfKF955nyoYYLcUXvwW8mErJNLvj0xfal9UfvTdmRvhANShBKlTD3JII9ll+";
  b += "adcReaMC5DG8fAPgD+9FCfHnWEXt1ed5YCe7Qi8SUSVZ9pX0+auqltY2itTQk36fUIA4yRSoEw7";
  b += "QF7PoN+Mt+tX1hp8d6Of0/hV4e+OrJrQ0XSmy9xJMxp3pzaQ1sVt+/wQMZDthCSycFTFv82oj1y";
  b += "FKCL+adtiSBJwhfb9++VgRr6CxEirZWBs6VMFyKb7Qvqz0YuunUHXEL2yKtl2pBapQDJ8Wx7Fc5";
  b += "8s328RkjbP3xYZcys7D8A5eRWW++1V6un6V1YmMNS1fL9+089zEMWFS/tuerOoHdLFkGyOSyD/n";
  b += "b09xrREZY9VvHegKIqMlwTZE1Swrsj3WMmiRo+k77lYfq32wXnL5i43RB1KPDQLsDVsOeuEzNkf";
  b += "5wVwkelTY3G5XeaGnrqLBdAGdA4oUi5Lvt5x0aH1IczQCmazBZYGOtKdrhCJ4DOjSA/QGSC6Dm3";
  b += "2vfafoAaGcZXYD/GTBOUgnplUrSYhue+P32lTMP3p182E/dF1piRheMHURKHMb/QftDh0bvqGmm";
  b += "eVewuszsuDy1bXPWflZQ73MY4OGYjkcBEIFDkz9s1+1vQlBj0yWgctQYMF0/ah+ZnCvWn7xFhCc";
  b += "R/BKsAmxbRn/cPrfOAH3mQRENzsMHxzWQIO1/0j5a9xF62WACVRZsACtOGImZ/7T96jP4SWcQkR";
  b += "2SstpVGaAxS8VISiQqnd3P2mZSut3pTqJfENRQic1bXRIwxM/bNx9RetsTNdeOC+IBdzGdomK/a";
  b += "B+r0/Z0dwyYBIZnYMRZ2EtO/rJ9bp0wRzm8Wtn0pQ6G5SCJC4FH45n8Vfsmu2IM3Qda0gxLNqLm";
  b += "sMyydf7X7cntS/PyNYvra5vLVT7Vkg42ecNgnRETuNG/gRW2q+imKrcJa9t9SHFxc2Xt6sV1Vx5";
  b += "DYhTJMMVQWA1o42/3A00IkCodJHdOaC/T74aTwC7vXNneXFzLebNEXawz4E+jZ1iPJZT8fXtchc";
  b += "4p5Kw7FyvOkksRjXYORKY/jCW88D2BCBXlU2+8dF4QGrhi7o9tNeay8pmrC30GikVVxval2ED9T";
  b += "+0DSCz6c5uMSJurUuYK501G8hiCQ0UNEq+d1yMuuRiFoUqiXacvnk7EeQkfiHEbvbz7/O3q5ejd";
  b += "7W5XlWT+czaXlk9VTbOAY4BVooJErzhl95g/gJe/50EMcq95ORhkg9WKgv9VCABLoYsBWUIl4JQ";
  b += "kCQYjgSLde5aboxhbRr6aQ4wqqvvMX7EwUkalRzIH/hH/BY3+iVUUwK1igcbggXe0gqE6kqb3nf";
  b += "/PlcpSp5DnfvNqgs4SSniVwJu3QKujjBEriNP9J164XhrWLykA0FxaCxsDaKTSD5g/MlCSV5mU5";
  b += "dW81pFpu7D82GlRWMwAo7AVgQa7mIi0D5w/t84ARf2iMmwmOCzoMCR4C5STPmj+aJ0Rgltd3F69";
  b += "ermEnWFjW5MdTYKDD07hwfNx2g4CPR96dPPylBfuvM3ZLW9sSg8Zt9kpeAaembH5cCIZbH50D5l";
  b += "/+qHZmuQNvefCsWHAqf8NKobS+4sj/SkFvad0gWXwkCZLYqwS7qHzt91DQAClwp9OJnBSl5Wf75";
  b += "BOFy4Lo/QwpgfyB8BKWKoUMExx3fw/DICa0RBk92nqkb5M2w74ziyiOS0Nd8GpPWz+74cWH1S/P";
  b += "rk6oVIJ4wy9C9ZtCuVRnQYb+jx8/nDlKTfWsKAI3tGvFaILy8VQD0xfgoGIWTxi/kYdl1eEZauU";
  b += "8EfOL4zzE1h5sY5CZ0tlly8ZDwwIDCbLsBbBPT1q3oxzbenUjmMjMiuHkUCuwC4w8uh5PWETdxP";
  b += "BMTkqW4qBd05oIo+Zv13fQxdEcvz05lY6VbS1e//QL0mzkapWE6hqRwhYJCFEcNo+dv6iaYcqQl";
  b += "/rbqPTURRrBKUrZ+BcPG7+glmGK+FGkizYcpqdzkzwx88fn3YkNBkbCZP5e88ngxMsGKG1jYrm/";
  b += "IT5y6cdtSvlU+GtEuN2QN8BpUQKpAKo8BOnn8N1bADblf42iWtrsXaCc2PFk+avOzRatmb605Y9";
  b += "df5Hdh++wN92Dli6CZpeo0aP5sEymrVUT55fHP9IYSdhrG9orLBdXNtAJ17c584xDhBcjvqe2Pe";
  b += "EOsP9U+bJyDscLpZlSRsVjMsaIIJkmvinTn/J0+ZvNUFsaEcfrjxllFJb5Hwozu7I03vub9g8oF";
  b += "HcLSZEZATiY6MEK+QcM8+Yv8OYJ1jdXFvpyr10quvX1tAEwP+X70JtspZmWwpzhXjm/D0OdK2UW";
  b += "Rt7MHekZIokE6j2DMwIB9R0/RlfHc+av2TCdytlFJ3J78TELlzd6n2G7HVOTEhAzVwaT5+9z4Xw";
  b += "nHk6+volV316cH6JZ5stLMOo83Mnr1ealIvgMWkGOigpeR5Y+hp6qsN0QoEGBQdeA1YLpZLE549";
  b += "54sO5VJeAj3OcEmBELCsC9vwF85eNvmZ0yptZrNr4lUnQGkujMoo9c2vJC8c9RnUwvJQkOFgTg8";
  b += "oZaHzUL+pSo2HXVEiOkivLZ9YyA4d28O7Zq6RfPJ9GXzljwW0RMSMmG4rzBFAkZ/OSqe1CsooFa";
  b += "bM0BrO6wkvHjHC4hD92jwDsGrOeqU7AXpM2L5thBINC+oqAqTeR+ZdPPQInnlvA9ZGDn/BKvqLG";
  b += "EhdBeMY9dck6wEOvHLPGhuq/DfTFKGsMC29zDMajTnN2+VXj1hhQs4pv8qSVEgmVlqWQr55nI6+";
  b += "pVnNJXkNrBGQRPlzK1r2mxo0MlzRpbqIhKTASXjv7lsbmj8wUXQilwA69bsxsd7aSBbiHrXIcsn";
  b += "wgo6+f0u4ZhcqBPFAVEkvMv2Fau6mAl2tNQo7wH8XfOH/B6BnDTIqRHB3MIbVS42GQkda4N80+j";
  b += "7D+BJGYFxEB20Tz5vnl8Q81KCY6kGxztFI4GFrpUj6ARk2WIEz0Lmkb3jJ/85H3uslNi21hyuYo";
  b += "8CBVClgwb62zMrXwxCUAo5lhky3ytim/k6PYTUYlwPLBAl56+/zaGMs/VOEhrK0vY6D7WPnvMFH";
  b += "90se6OzE+Es9QAMhxbFVE3jHlE5PociSUM5nApzN+g19fe+21N/gPwAKxyntj8y/mV9zqiW0A2o";
  b += "calwPpu8Ffdghiimf703NNJILhr+k5mp9Dzl5dPrG0tXL6xjchWhmjYdXemBHGzybmbKpv2rrar";
  b += "cCvt8g51J5D/hLjUmd34lLwd+wcI27wArz5DYFWot5/TiW8vfkXN7shrB6MuJ19oqiGbt5sHoPf";
  b += "Z6drtv4/pNVxPg==";
  var input = pako2.inflate(base64ToUint8Array3(b));
  return init2(input);
}

// packages/sev-snp-utils-sdk/src/index.ts
init_shim();

// packages/sev-snp-utils-sdk/src/lib/sev-snp-utils-sdk.ts
init_shim();
var pako3 = __toESM(require_pako());
var base64codes3 = [
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  62,
  255,
  255,
  255,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  255,
  255,
  255,
  0,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  255,
  255,
  255,
  255,
  255,
  255,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
function getBase64Code3(charCode) {
  if (charCode >= base64codes3.length) {
    throw new Error("Unable to parse base64 string.");
  }
  const code = base64codes3[charCode];
  if (code === 255) {
    throw new Error("Unable to parse base64 string.");
  }
  return code;
}
function base64ToUint8Array4(str) {
  if (str.length % 4 !== 0) {
    throw new Error("Unable to parse base64 string.");
  }
  const index = str.indexOf("=");
  if (index !== -1 && index < str.length - 2) {
    throw new Error("Unable to parse base64 string.");
  }
  let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n2 = str.length, result = new Uint8Array(3 * (n2 / 4)), buffer;
  for (let i2 = 0, j = 0; i2 < n2; i2 += 4, j += 3) {
    buffer = getBase64Code3(str.charCodeAt(i2)) << 18 | getBase64Code3(str.charCodeAt(i2 + 1)) << 12 | getBase64Code3(str.charCodeAt(i2 + 2)) << 6 | getBase64Code3(str.charCodeAt(i2 + 3));
    result[j] = buffer >> 16;
    result[j + 1] = buffer >> 8 & 255;
    result[j + 2] = buffer & 255;
  }
  return result.subarray(0, result.length - missingOctets);
}
var wasm3;
var heap3 = new Array(128).fill(void 0);
heap3.push(void 0, null, true, false);
function getObject3(idx) {
  return heap3[idx];
}
var heap_next3 = heap3.length;
function dropObject3(idx) {
  if (idx < 132)
    return;
  heap3[idx] = heap_next3;
  heap_next3 = idx;
}
function takeObject3(idx) {
  const ret = getObject3(idx);
  dropObject3(idx);
  return ret;
}
var cachedTextDecoder3 = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder3.decode();
}
var cachedUint8Memory03 = null;
function getUint8Memory03() {
  if (cachedUint8Memory03 === null || cachedUint8Memory03.byteLength === 0) {
    cachedUint8Memory03 = new Uint8Array(wasm3.memory.buffer);
  }
  return cachedUint8Memory03;
}
function getStringFromWasm03(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder3.decode(getUint8Memory03().subarray(ptr, ptr + len));
}
function addHeapObject3(obj) {
  if (heap_next3 === heap3.length)
    heap3.push(heap3.length + 1);
  const idx = heap_next3;
  heap_next3 = heap3[idx];
  heap3[idx] = obj;
  return idx;
}
var WASM_VECTOR_LEN3 = 0;
var cachedTextEncoder3 = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: () => {
    throw Error("TextEncoder not available");
  }
};
var encodeString3 = typeof cachedTextEncoder3.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder3.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder3.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm03(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder3.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory03().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN3 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory03();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory03().subarray(ptr + offset, ptr + len);
    const ret = encodeString3(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN3 = offset;
  return ptr;
}
function isLikeNone3(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory03 = null;
function getInt32Memory03() {
  if (cachedInt32Memory03 === null || cachedInt32Memory03.byteLength === 0) {
    cachedInt32Memory03 = new Int32Array(wasm3.memory.buffer);
  }
  return cachedInt32Memory03;
}
function debugString2(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString2(val[0]);
    }
    for (let i2 = 1; i2 < length; i2++) {
      debug += ", " + debugString2(val[i2]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a2 = state.a;
    state.a = 0;
    try {
      return f(a2, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm3.__wbindgen_export_2.get(state.dtor)(a2, state.b);
      } else {
        state.a = a2;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_28(arg0, arg1, arg2) {
  wasm3.wasm_bindgen__convert__closures__invoke1_mut__hd38b50d590c09891(
    arg0,
    arg1,
    addHeapObject3(arg2)
  );
}
function get_vcek_url(attestation_report) {
  try {
    const retptr = wasm3.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm03(
      attestation_report,
      wasm3.__wbindgen_malloc,
      wasm3.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN3;
    wasm3.get_vcek_url(retptr, ptr0, len0);
    var r0 = getInt32Memory03()[retptr / 4 + 0];
    var r1 = getInt32Memory03()[retptr / 4 + 1];
    var r22 = getInt32Memory03()[retptr / 4 + 2];
    if (r22) {
      throw takeObject3(r1);
    }
    return takeObject3(r0);
  } finally {
    wasm3.__wbindgen_add_to_stack_pointer(16);
  }
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory03().set(arg, ptr / 1);
  WASM_VECTOR_LEN3 = arg.length;
  return ptr;
}
function verify_attestation_report_and_check_challenge(attestation_report, data, signatures, challenge, veck_certificate) {
  const ptr0 = passStringToWasm03(
    attestation_report,
    wasm3.__wbindgen_malloc,
    wasm3.__wbindgen_realloc
  );
  const len0 = WASM_VECTOR_LEN3;
  const ptr1 = passStringToWasm03(
    challenge,
    wasm3.__wbindgen_malloc,
    wasm3.__wbindgen_realloc
  );
  const len1 = WASM_VECTOR_LEN3;
  const ptr2 = passArray8ToWasm0(veck_certificate, wasm3.__wbindgen_malloc);
  const len2 = WASM_VECTOR_LEN3;
  const ret = wasm3.verify_attestation_report_and_check_challenge(
    ptr0,
    len0,
    addHeapObject3(data),
    addHeapObject3(signatures),
    ptr1,
    len1,
    ptr2,
    len2
  );
  return takeObject3(ret);
}
function handleError2(f, args) {
  try {
    return f.apply(this, args);
  } catch (e2) {
    wasm3.__wbindgen_exn_store(addHeapObject3(e2));
  }
}
function __wbg_adapter_65(arg0, arg1, arg2, arg3) {
  wasm3.wasm_bindgen__convert__closures__invoke2_mut__h7ab7860d8788d47a(
    arg0,
    arg1,
    addHeapObject3(arg2),
    addHeapObject3(arg3)
  );
}
async function __wbg_load2(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e2
          );
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports2() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject3(arg0);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm03(arg0, arg1);
    return addHeapObject3(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject3(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone3(ret) ? 0 : passStringToWasm03(ret, wasm3.__wbindgen_malloc, wasm3.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN3;
    getInt32Memory03()[arg0 / 4 + 1] = len1;
    getInt32Memory03()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_as_number = function(arg0) {
    const ret = +getObject3(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject3(arg0);
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_queueMicrotask_2be8b97a81fe4d00 = function(arg0) {
    const ret = getObject3(arg0).queueMicrotask;
    return addHeapObject3(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject3(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject3(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_queueMicrotask_e5949c35d772a669 = function(arg0) {
    queueMicrotask(getObject3(arg0));
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm03(arg0, arg1));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject3(ret);
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_set_8761474ad72b9bf1 = function(arg0, arg1, arg2) {
    getObject3(arg0)[takeObject3(arg1)] = takeObject3(arg2);
  };
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject3(arg1).stack;
    const ptr1 = passStringToWasm03(
      ret,
      wasm3.__wbindgen_malloc,
      wasm3.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN3;
    getInt32Memory03()[arg0 / 4 + 1] = len1;
    getInt32Memory03()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm03(arg0, arg1));
    } finally {
      wasm3.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_get_4a9aa5157afeb382 = function(arg0, arg1) {
    const ret = getObject3(arg0)[arg1 >>> 0];
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_length_cace2e0b3ddc0502 = function(arg0) {
    const ret = getObject3(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_new_08236689f0afb357 = function() {
    const ret = new Array();
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_newnoargs_ccdcae30fd002262 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm03(arg0, arg1));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_call_669127b9d730c650 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject3(arg0).call(getObject3(arg1));
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_c728d68b8b34487e = function() {
    const ret = new Object();
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_self_3fad056edded10bd = function() {
    return handleError2(function() {
      const ret = self.self;
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_a4f46c98a61d4089 = function() {
    return handleError2(function() {
      const ret = window.window;
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_17eff828815f7d84 = function() {
    return handleError2(function() {
      const ret = globalThis.globalThis;
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_46f939f6541643c5 = function() {
    return handleError2(function() {
      const ret = global.global;
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject3(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_set_0ac78a2bc07da03c = function(arg0, arg1, arg2) {
    getObject3(arg0)[arg1 >>> 0] = takeObject3(arg2);
  };
  imports.wbg.__wbg_from_ba72c50feaf1d8c0 = function(arg0) {
    const ret = Array.from(getObject3(arg0));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_call_53fc3abd42e24ec8 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject3(arg0).call(getObject3(arg1), getObject3(arg2));
      return addHeapObject3(ret);
    }, arguments);
  };
  imports.wbg.__wbg_entries_6d727b73ee02b7ce = function(arg0) {
    const ret = Object.entries(getObject3(arg0));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_new_feb65b865d980ae2 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a2 = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_65(a2, state0.b, arg02, arg12);
        } finally {
          state0.a = a2;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject3(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_resolve_a3252b2860f0a09e = function(arg0) {
    const ret = Promise.resolve(getObject3(arg0));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbg_then_89e1c559530b85cf = function(arg0, arg1) {
    const ret = getObject3(arg0).then(getObject3(arg1));
    return addHeapObject3(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString2(getObject3(arg1));
    const ptr1 = passStringToWasm03(
      ret,
      wasm3.__wbindgen_malloc,
      wasm3.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN3;
    getInt32Memory03()[arg0 / 4 + 1] = len1;
    getInt32Memory03()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm03(arg0, arg1));
  };
  imports.wbg.__wbindgen_closure_wrapper126 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 31, __wbg_adapter_28);
    return addHeapObject3(ret);
  };
  return imports;
}
function __wbg_init_memory2(imports, maybe_memory) {
}
function __wbg_finalize_init2(instance, module2) {
  wasm3 = instance.exports;
  __wbg_init2.__wbindgen_wasm_module = module2;
  cachedInt32Memory03 = null;
  cachedUint8Memory03 = null;
  return wasm3;
}
async function __wbg_init2(input) {
  if (wasm3 !== void 0)
    return wasm3;
  const imports = __wbg_get_imports2();
  __wbg_init_memory2(imports);
  const { instance, module: module2 } = await __wbg_load2(await input, imports);
  return __wbg_finalize_init2(instance, module2);
}
async function initWasmSevSnpUtilsSdk() {
  var b = "";
  b += "eNrsvQmcXNdZJ1p3qa2rqrt6XyXdut0ttfbeF0mWulpqrdZmybtjWUvLdsu2LFl2Eii3lDiLAkl";
  b += "wEjM4JAMGHGx4yeBfXmDEkPdw8hzwb14AwYSH+U3ew8MEEJCZn98jwzO84LzznfOd/VR1yzZMfh";
  b += "NFcd86p27de873/b/vbN+SOP7Yw14ikfD+1ovu8y9eTMAf7+J9wUX4DH9JwSMfPfgQXqTVyYvsm";
  b += "iBVqYtYoN+RCvYlfcQC3JPgt5Cq9EV+N//EXrVAn1+5z6vA2xb4Y+H3wQK9KXdR/o82ZGGB/Cij";
  b += "VJH3Vlg7KtjGBVZcwOKTrAgX/2q2P3jvifu7jh1774kHHzl1/9wjx86emJ87eeHYqfNnHz12fu5";
  b += "0IoQbWpUbHrtw/sFH7j/2yNx7E16V7+6fu5BIwHctynfHHzv2yOMPn5g7n2iCr7rtd5586Owjc/";
  b += "SlSbijH+64/9i5x+cen9v/4MnzZy8cf+zMseETc5MnpiaOTw6dnhs9NTjI7m1TnvbgY8dOP/7Iy";
  b += "QsPnn2EfdmkfHnyBO1arTfMjU2NTp0cGTs1MTF8fHx8ipFA7crc+fNnz7spwLpIv2s2SXviwfsf";
  b += "fOTCsdPnzz587PHx0USLuOH+Y4/NXTg2OTE+NDoxevzUxPCJqROnhxK+cgN54rHjJ04dnxifm5w";
  b += "cOXF88vjY6UQGbujBJ1w4fvLMsfGxyeGJKUKa0bHRoZOnxxkf8BbW7tOTY0Pj4xPHT08MnTh5+i";
  b += "Tegq8hrDs2enzq+PGxoTFyy9yJkclh1stl7IaH5h65/8IDx04ePzk3PDd4YuTUqZODY4PDjKBKW";
  b += "wcnh0fGxyenTg8eP31iZGyCtTUSNzxy9vj5+x87dvLkqZPH50YGTxNWDg+P47u62W0njz/00DHC";
  b += "gaHhiRNTpyZGBk+Ojw2yO5Q3nZwYnjw1Pnli8sTI6OjkxBx7Uzen60Onj42cPn5qcGx87tSpuVN";
  b += "DgydOsTuwQ+8l3DlLaDt6enT85NTk8fGhU6ODk1PsnhJS5aGzJ44/dPQBAq2hibnTpyeHJyeHxk";
  b += "5PnJoc1Z7F7js2On56amTq9DhhwfjoyMkxdk+7jtHHHzk1d/rBR+ZOaaQDHAwePzkxeXz4xMnBi";
  b += "VPHB0dOMhxghyh6ThyfGD45Nnh67vjpoVOTJ1EIVKqNjZw+OULwMjo8Nzw6d3IyEcAdyxEHjxA5";
  b += "nXvs2DhB2sSJiZG5ucHhExMn5ywmEv6Pj52YHB87NTU5eHwOuYNPOT/32NmHnpg7dnxkeGz4xPD";
  b += "k+CDh9eDUnNaYCw+Q3k5OzQ2dHBubGhsZPDE5dvI0e4xKj1NzJx6/H9UHw2NR+fbCA+fPvpdVL1";
  b += "Nl+aGzjz1+fu7Ye88ff/TRufNDw+Okl78bfiP0E76fyCYSfjKb9X2v1Sf/S6XSiZTv+X7ge14iS";
  b += "EBdve+l/URI6jy/IUgk8n4in4DfwlCg/K/BL5KqnJ9qJCOE1+bDY8j/yDfkWQEr+Lwq4ac9P50m";
  b += "hdBPke8SPnkv+T/9XyqXZZ9C0p528qIkeXTe98hLU7RJyRT8z0uxC2kpvDL00p7n19GnJELyinS";
  b += "iAxoRer7e0FQywR7jp8mrE9mQ1gI9EskENIi1kBDGY18lOqE56XQqnSZP9ZMhuZf8sBCSfkJfSa";
  b += "vCMBkm2N3knaQxdaEXJAK/AAXybPIkP5f0oK0Fch9pbJ0HP/cS9CXkhV4yRa7kIVAMPWhWOplI1";
  b += "Idd6VzP8kSdBzwgtySTQZgkDU2SCqBrSB4FDyKtJQ9LBJQK5EMiCc8P4dHQTC/woYnJpAet8L1k";
  b += "6Mn/wdvp1WNX9j94ILmTVgdeEATkUclECI8g/2VIt0I/THuPev8n+ZcMCBdSWTIyly9dejmRS38";
  b += "2KKQennv47Pn3+4mOR4+ff4zIwIULc0QBw5hD5OLRs+cvJP6Dnwdl+sTJuTPHHj//UOJbfucTc+";
  b += "cfPP1+181PBeurfnns+COnjp18YI5o95MPENkmCngucdVvVCThYVJ99mTi04E61J2fY7XPB83q2";
  b += "PU++sxhL7HtvWTSc4zXHzt59hHShAvHuFg9duzYg488cfbM3NCxhx8n1Q+cGpk8MTZ4amxq8OTg";
  b += "1OTUUOKPgxXq+H7q1LELZ3EYevQsGenIUP9LYYNyy+nzc3OJ7wXaUPo+mDWcPT+X+IlwqQ0axgZ";
  b += "NHD8xQbTOqcmJyclToxPHE38aZL9KWFn2cj0vh8+Fl8Nr4V/Sf//GP/gVf9u18He83/F+l/x7Pn";
  b += "wm/Iz378n3fxt8MPgLcv1J/78EvxIkystzv+39cfBbwV+FLwSXvGvhl4LXg5eC/9f/TPDV4BfJf";
  b += "X8eXAtfDdnvr5Hy97xPBn/vfdL/ePAP3v/hfYF887HwU+Fr4U+GbwSvhX8dvhD+cvjz5L5fIf+9";
  b += "6l8LXyTX2Q96r4UfCp8K4Yb/KfwSqfrV8IvhvyXX3yD//Rvy33/xP0de9GwAr/g18t9ngy+Tv18";
  b += "Mf538/Ur4TfL3q+S/fxf+V+9y+J/JY3+NNOYDwa8G/3cw8mfhb4f/S/i/kfdeC2//X8NfCn4z/D";
  b += "r5+F/9zwZfI9efJc/8Rvh35O8r4f9D/n6H/Pd/BX8a/EHwe8HvB1fJf79PPn/J/8Pgfw8+Fv5J8";
  b += "P8Fn/Lg/X9A/j7t/WzwdVJ7Ofyf/T8JPhJ8wPs98sQvkCd8K/hU+HT4yfCnwo8Gnw6/EXzZ+ydy";
  b += "/yfCvwj+JLgcXA1/n9z3c+FfB9eC7wefCf8++FX/I95XArjjWnjXD/w/DP9D+AXvTa/ub/+x/Rv";
  b += "hT53zPwmz395EefBM/CmvLxF9yov8MT8RB5EHl5aFOJz5xpXffqV+YeYH5H8NT8X1M3/3R8/8ZX";
  b += "4hbsWaKMQPlZnoMvw6jJdF5IdJ+X10uRI387ui+pm/+fJLf1W/EKdm3mJ3tNI7GvkdcZr/lDYjj";
  b += "MOFuEF82Wo0KMMblOW/alUbFEbLFuIm/lUDfVODvJMUSYP+8fe//g3ykhxvUIrWN9KbU/xm0rVM";
  b += "3Apd4y2NkvS+ZnpfUXQwTctp0eKC+CbDu97G35Sl92bFvXVa1zNxciFuF182G13v4F3P8181q11";
  b += "PQtf7+Vft9E3t8k5oeoZ3vZM3qI3W680iFPry5669TNoyyG/L0dsonQjZJIXycTNQKOZVlIZRsS";
  b += "aFCI9aF+LlvNREf6JzqhIVaLlJlOtouWARrhJ1cCJ388bm6b15cW+vRuR8nFqI+8SXjQaR2ziRV";
  b += "8g+KUROAZF7+Fd99E19eu87OJFX8gZ103q9WYQXSGTR7k43L/7sP377FxqAZVgzSG/LWbwoxo3A";
  b += "i0FeFdfgRSx50bwQr+Kl5QovloufNBm8KGi8ILgj7JzkpX76CIa+foN9kmm9tNwruDAgvmnj7Fz";
  b += "NybKC3rtC3LtGY2cxTi/EkfiywWBnO2fnWqkTFHamgZ1D/KuIvinStAdpELLzLt6g1bRebxbhOr";
  b += "JTtHuli+v1Mx/43Cd+Kw/g+IHKdZudLXEDsNNgu8lOymTJ8zBqVKRxFf3Jcic7V0kcIsCGeU23g";
  b += "sPu6lwnwFnHS5P0J5T3AgqLcZ3IEgHOel7qoY/QJaoSDdByjyivoeUBCwwAOQTOCGfAWnrvWnHv";
  b += "qAaclji7EI+JL5sM4PRz4GyQikoBThaAM86/GqNvGtNVWjsHzhRv0Ait15tF8IXAEe2+y4WvevY";
  b += "BYIgt3IQIY9BZqUCnI64H6GzWIWZCZ9CEDnn43bryWK4piwoDlFTdGQ5mAaZh+rPuxaDTqKBtHf";
  b += "3JZE3oEOlCkArErVaka3V1hBGQbuGl9U6E9RgIG9AQRjSECtIh+ghdT3BQSiiO0vKQBTyQEARpn";
  b += "jN7A713g7j3Jg2kHXHTQrxVfJkzQNrJQbqN/yqngrQJQDrNv9pK37RV3slEFkG6XRs9jWYRLCNI";
  b += "d/DbplxY3kSxG99FFB4DpwbLnjgHsJziVZsVWG4yYLlZwpJQa5aX7qY/iQ1YLjdhiaLC0RzvRFW";
  b += "4KDAbLCwvCkwUAQPPq53AXCeBSURgPy9tWQIwiZ5AERB4HnHoCQd+m0G1aCKwGH6HNPwSXaeKwD";
  b += "h9hK7xOOQl0G+i5XEL1hWijFAEejmUttF7t4l7d2ki0BNnFuLd4suiIQKDXAT28F8VVRHIgAjs5";
  b += "V/tpm/aLe+ErnRyETjAG0SZZTSLSAqKwD5+23aXpADso7wO/CguAvC38yomO5voD6cEYTZrgkCA";
  b += "n1NU+KwC/NlqwN9J5SO+m2jAKlDfKaFOOHBQnyhMahMDB9RRrLgwxIdQRkywUxGQEpGKVMW9XwH";
  b += "7/upgR7E6rMvIomBvtOSjNtiJZkOxEjKyw6HZHDLRDMpQEysmE+urysS4MUsAsRJTiGn6CF1Hcz";
  b += "GSwrOLlqctUQG1iWLVx+G5h967R9x7iyZWUdyxEB9RFq26WMVcrI7yXxVUseoAsbqVf3WEvumIv";
  b += "BO6MsjF6h7eIMpzo1lE+lCs3sNvO+CSPpdY9cUFEKsDvIrJ45QhVptMsSoqksiGoFltyOFiNavO";
  b += "h6NeVZh2msJERPU2XjpIn7nKKUxC4g5RaYsnicK3xGfYFB/C1UP68LJfG04c4oOiygUsvjc6rAj";
  b += "Q4eoCRH50uy5ziwoQiqohd4sKUKMlc+trChDRwCiqQu72OTRwxZqNg6ju04evrfrwZMnZtD5Xyo";
  b += "CoionUXvoIfSzhoikF8hZa3muJH2hxFNUVHPJH6b1Hxb3HNFHti9sW4juUrQ9dVJdzUb2P/6pOF";
  b += "dU2ENVT/Ks76JvukHeyYQVFdU5bcxvNIhKNonqc33aPS6JdojoQ14Go3sOrDixNVAuWdG82RJWJ";
  b += "7nZTVGeriyoR/9O8dJtTVA/qogriGfXVFFBV/A/RZ65zCqiQ4nupBMf7yVjGBLOWSBKk3MtLty9";
  b += "NJFH8uSTH96MsLyqU9vzSLZQjUihR/Ed1WV5EKBujJkuOx2sKJRkpUPyFLL/HMVKYYyiR3WYYXL";
  b += "Rhdrc+jFqyu1efJ7ZGHcok8lb6CH3M4+IuhfwYLd9qiTSMLij+D3Axuo/ee5+490FN/Afi9oX4h";
  b += "PiyxxD/bi7+83InRRH/dhD/M/yrE/RNJ/Q9l+Vc/B/hDXqA1uvNIloCxV+0e86lJSzxbwEFsC7O";
  b += "g3r5gao3FhX/OktjmOK/XRf/2cXFX1Upp98l8bdViin+h3TxB5GPVtQUelWl3LsUob+f6ob4XoK";
  b += "QxcW83hrlTTEfMcUcVcoWqVJGFUEfrSboDSDoG3TdsKigo0ox9MOigt5o6YbpmoJORjRUKUI/HH";
  b += "eMaOZYHzWDPjiuTweO6MO9pQ9u1efIrVGbMoE+RR+hj81chUjF8SAtn7LUBOxroEo5y0Vznt47L";
  b += "+59VFMp6+Co7yHxZb+hUgLO7C5e83AUcKaUaVvL4nmchFY9agte/xavR2Vj1WMXrHpUb7Q+Pkf/";
  b += "nqd/H6N/L9C/j9O/T4BcPRx1gSB0VeKgEj8MNeT6Xry+D6/vx+uPwbWrEuVhehKIaRGUumhDusS";
  b += "qxlFXdNTlHHX1jroGR12jo67ZUdcC81Grjij6FlrXwuseolShlfEy+pfV0J/GP07/VujfJ+nfBf";
  b += "r3Iv17yaOXD3iUUmy3NWrXiERKJfpFSRLJris66nKOunpHXYOjrtFR1+yoa4U6duQrDq/P0CIbB";
  b += "VvxhJSNiPCXfsseE3+Qdf8pdvkQu3yYXT6i0aRNowkpbaRfbJQ0seuKjrqco67eUdfgqGt01DVD";
  b += "XTMeWWtzlzvwiB7+tuE8hake+EsfE3+UdfUyu3yMXX5C63iH1nFSmqBfTMiO23VFR13OUVfvqGt";
  b += "w1DVCXSOe32s6fC9aGcDfDlTO8Jd+yx4T/yTr1sfZ5RNK7zJRXuldBqYiM/SLGVlXcNQVHXU5R1";
  b += "29o64B7B7YAaw27k3j2Tj8zeCABn/pt+wx8SdZF35KY1CTxiBSupl+cbNkkF1XdNTlHHX1UFePB";
  b += "hU/UM4ycHSvx0Njtgpg4z38pY+Jn1bamdVInQVS30m/uFPWFRx1RUddDuxC2OmltmBaj4fq7JCV";
  b += "zXTgL/2WPgYbk9Yak4bGnKRfnJR1BUcdaUyaPUCfCEZo+sCO3tgEDv7eJl+Z0l6ZcrwyBa9MoQm";
  b += "GNnddhzYr7BiDzTnFg5Pag5PwYGbBktQn1WwCnMTdXvHzUPv5Pcr8O5Q33YWLALalvVLZ2GbfB5";
  b += "bZEM7ZA/Gkipi2w9FTdHdFuVf8PG/M6NWfh9a+h/xd0pjWK79DYvD5fR1eaSMmK8ovQ7sRgf3K4";
  b += "SrPT8qdO+uBBfuBKWPNYD0QgcCXEAW81uGVNn9/RXlO0m5+LYoVjDVJtQakJNCtN0X2m4r2m9LG";
  b += "UqbKm1CwYE0T9TApgmsBr3V4pR2/t6I8NWV3PGl3vBYzisYKqnYLhejfaTfhdrsJ6+0m5OwmZI0";
  b += "VWZWXq7otYrs9cZE0GLdrCjjdrcNrHq+9eIWORcWK0oCsnMhL06Ef8POxd0ziscXpaWpyMmZYLb";
  b += "nZbsm43ZINdkuabErXG+vR2pRWxreok6+X+LPiHK50twnFTwZR6G1coMuSXBV+dKr8KFSUZtbb/";
  b += "MjKBbNFmLxNmDqbMLlacrp1qSwypwE/5dlN/KSDeTN2G/fZbZy225ixmddgLPGrNbihCgsHHSwc";
  b += "5EveDBpPalsLe5T52L8cgxtsBqdtBqdsBidtBjvouXsJPG+ozvlPODj/cc9u/E860DBht/643fq";
  b += "9dus7bDQ0Gtswdlcal4CJ2IGJuAomYr4NYtQ/oGyRZpRZYMcPGWIabcSkbAIvDURHaoKocWlQ+g";
  b += "kHlD7mgNJlB5Q+6tn92mj36w67X7fa/Wqz4dVsbNGpnWy+TpAtd4BseRWQLa8CsuV8r43X497ZI";
  b += "8o2vgk+nBMgBNuWDsG2/x4QlBOH5iWhMmMvO05VQWXz9WPzIw5sftiBzQ85sPmUA5sf9Owel+we";
  b += "n7F7fMLGa7uN11ZjCzlU9r/eHmq7HajtroLa7iqo7a6C2m6+Q2zUn6XF+RpoZrtZHNN1Gqbba2G";
  b += "67t3FdPuSMN1mc7hgc1jCvGiz0wHzRy2Yt74zsH/AAfZLDrBftOmwYNPhSZsOFZsOP27ToUtUtc";
  b += "rdbQv8y0RVi+6QIHiJpFH3xK+XTE1253/M7vz77c6/z+78e+3OP2x3/gm784/bnb8gqh6z6XFen";
  b += "BPY+qFsnPLRk+NKdE7Q7J1QS4KK2cXPJCS2sub0XZKv0dwQkQRKmoJg81/0kp0ePQlq66MVdsT0";
  b += "JOgEUqBa5klQJaRAVdGToFFIgeqrJ0GxkAJVak+CfvkoIvVJUDOyUKcW2tVCXi30qwXQPkQUvKe";
  b += "eJLVx8EL54mOxF3W+cC4KovqnXjg/7q8D57wgyj71QuRF/S+cI1UDrKqBVuVpVR+rStOqdloVsa";
  b += "pGWlVHq3pYVYpWtdGqDlbVTKsKtKqFVSVpVQetKrKqVlpVpFV5VhXSqgytyrCqZbQqR6tCVtVCq";
  b += "5poVSICf8PiZ+Gr8uB8XyL33x7zfxkcEskX9EzSn/nAtz/znQQ4IXLLoZlfeOsv/9RfMDcT/Zl/";
  b += "/I2v/VMg69/i9T/9h5/9muv+n/n0rz9XcNR/4ze/+Meho/7fPf0P/ynneP7v/tHrf9HguP8vnvr";
  b += "7f3DVf/bVv3nT9d7nf+N3/lpp5/d5/a985urveWDyD0JzLx4Aw9+H6V86o4vpSBg/uuiBKPPFjL";
  b += "wBPxG/6JU/8aW//Wzw0JekC6Wg84vel2Lx7kBz8OQtTfI2BpqbpOLkmOZUCnW3H+nVxLw7+Xvyi";
  b += "krWz5+zvIHt1lDMeoVtauZtMpysAt3ZsYk3jG3T1eneiIJHRd3NM2X0U/fQAo0mh0WkQIG/SHe+";
  b += "lL6uzMkz4BSQXq5JgwJ1nAIt1kY223tHCrRyChierkncOkMKCP/TguKd1255Ior2N+F+pkEoBHm";
  b += "Tbj+fMvyKcjgrE7oZ6dut+6IaXppRveE33IjjhklDYCDSu4e3twXHdH7vMoXeeUJcpLeYvRG26v";
  b += "TOcXp3Wfvw1LWW07uP05u6VEnnvBQiC+ndzxvWg+fxavMIW5DePboXrsUWnDe36YbVad1pRegkw";
  b += "6O2aMxVOjQ2EbYgNzt0t7+84TfQbLlzq2whSETurtCdrE1/3kbd5ztahrMIk2MAH+SucJ/tQpsF";
  b += "fm+kcLdIWIncXaU4lOvczXPulqyjB+rTy7m7jnNXNwlDvZHj3D2ie3jqzSMgQO6K9ve7QCB85/r";
  b += "legBuK5jcxZFIiDDz0TV9cosmd01QdCgOUB0Gd7slMhFyhldmu+EjZ4EAsSTsvFYsCQStGgiIlJ";
  b += "lY6sPtdVXWOHYkYiLdcUoxkctzLMWceiU08TAdj5lHaJpjaWNVJ3zhULza6YSf5lga5FjaiEYVh";
  b += "vJDLAmnzxiNV9TmEcghlkT7j7ggJxzeuHlZfBRBZ6EJ5zsG6Jpw8VwVTQjCUR2EHQaauk00IcSX";
  b += "634yPYuhCbG7XrcrcKNpg5Q7xO4a1RLVlDsH6BC7K3XsLgY6w/U/ZWF3ndO41DTiHNANRRVHeOH";
  b += "P3Kj5nUs7VGljSR1FMxy741V9mps5doecPs0Zjt0Jjl3dUNP0a97GG9bo8AIjEEfsTuruzwbEj1";
  b += "JIx0eIXrDRirP2EX0t3+ZEa79EK4JcmCSPLg2tKETclDWeQpgvileUjuW8o+sVvMpT3g0mXlE6h";
  b += "MHzmqXhFaXDgHltvBJNgtKxUvfwNsZWG9YoHbEuHasMPzwT1uvMARSlY50ezUDXjaYVND8lHrQQ";
  b += "DwMXSkcDJ/qQ4XQ9rUhHD1lSoHSUq3qSNnHp2Oz0JM1y6Zjh0sEsUsv6bLiZS8ce3jBm02WYYAu";
  b += "H6u2aF6wpRHSPvlGTCVzhbtO9NEyZ6DdlwhSlo0uRiSkqOvFRonarSIGMqcClbkoPJrLeiD6xQZ";
  b += "MKvv0vpw7xDmY/hHKwqbocoNTNcgKuWZocoNQZ4rOoHKDUGeKzoqYcEB2IUhfrgTKMWYg930Spm";
  b += "9QHk42GV4EpLoP6VCPDpW5QnrG6zO9NX+5ptJA0JQnmCSh1LZzohkOG9JKhLqZ1XOr2KctmXeqK";
  b += "XOp2WnYYdGeeS93NXOr2oe2juJtNYFDqbtWWhEbziHCi1O3XnGRN4eRSt8fab7pNl9ZFpc4trIt";
  b += "IHUha1KDKmuFzFXBpHtU9ys1IL7pPR7SDCl+8gYwulvO5JV0ozZt0B/RFpQulmXtuxLMolovKF0";
  b += "rzGn1t5ZavlVK+UJojXSwXlS+UZkMs19WUL+kqPqn7JJr+uxtNMURp3q4PfuP64GaJ4YQ++cpya";
  b += "Z6Q9jPMU0IdhWyXl71oJWxKKMybUJpF4APdW6oifYSoF2qOS/PBqm7jIlzcIafbeI5L831cmg1n";
  b += "qwJuXaA0H9d9wg1nriYuzaL9t7qEfo8tzbirfKtuq9uGlrlVpRmVwAldCVy3NI+Y0mxqidGlSDO";
  b += "IfNSiel61ajJNZBi1hPD23bQUGZ6lpmvxJqINFpda1BI79CmsKbUrTalFLbFGaolIkduoutyili";
  b += "jpq2a33MaWh/qALu6Lyi1qCUPcB2vKLRljUEts1yNeGPNTc22V5Vpivz5Yl/XB2BLvGX0SWse1x";
  b += "Iw0kYTH6KMm1wpSF9yOxvmm5CvxG+/kRNedGSvxSUVLDMR5riXuEje0GVqiwLXE3dZZOHUe5Vri";
  b += "FNcSNCKWeCBuWtRbu9vMHcDwtSxyLSHaf9ylTBxaAk+jjuvOM7fpjr22lkDlcpvmc/suaAm39ll";
  b += "ES4xaWmJKD6yR5NpnSgsRsJiWAM0QtdbUDab22bEU3cDmC/Ea2A6IFtMGpvYpKdqgZITIW2c5x8";
  b += "dS+wwo+mCguj5A7SMi/E0uTR+g9jHUyKL6ALWPoUYmauoDMiai9tlf23G6bKoN1D4H9MnFPn3yY";
  b += "KmNm/XJeI5rH+EmRI3PjFGeaxupY04aDvAnlbBFqH1EaAoaAkxoDvD5FPHNeFW7oW98znI4Vo1P";
  b += "V8St8VYQcx6+BFq6RYq/CLdl1KM64fXiaBi1kVWPHbDqUQfSeuqfyrxTmW8q80xVfTSjrdHpSux";
  b += "XaCcicj2N1yfxuoDXi7jzi332oc/3w1SZqbNdchhGTcXCXfXKetQ0vF4EhkNNYd2Pkm7Vo3xa9S";
  b += "hH1vMR8db9iE2rHsGWxy11zZn6LjxeZAMHc5xmsQFN59Zavp7MmrwS+QJKhLAIGPpVtEtOXREwV";
  b += "j0ChteLo1gETAH5pQVVuFsxamOf59B1XTqg+tH9FBD3I+M/6uGHy/zDx/gH6rhZkUEkKSgegN0Q";
  b += "BorDUoIRFGvR6UbUIyh4vQgMjKCw7kdQWPUICqseQWE9H0Fh3Y+gyOHZnDbbOag4+t2MuodFRKj";
  b += "i9Wk4UB62uF4vA5Ix7yszPK9Vj1zn1nTaSe8hxaCyDacrLAgMZesDlK0PIO+e5kz8FP/waf7hMx";
  b += "6ul1S2Pghby4yt90j9jmxlAduGZT2ylde/xeuRrdb9yFarHtlq1SNbrecjW+vw4FwbrGaEKyJ3b";
  b += "z2AITfg7zOMUz/NLv+KXX6GkuQei29Fzjfmv3iPnBUi34oqBfkUcqdiXrpTuoj60YOUMw8i+e/B";
  b += "67OcH5/lH37Ww20plTHzcCLGGHNGDvPIGOpzFN0k65ExvF4EEEfGWPcjY6x6ZIxVj4zhTlZaTMM";
  b += "JxXJvAkOssBAd8PdzjOSfZ5d/Tft8xqJ8E6d8k0oKPo3ZrLgHb2a0nae03Y8UnMfrGbz+HCftz3";
  b += "uqSzuSthnO0xlpH5LzNSTtboz5I+qRtLz+LV6PpLXuR9Ja9Uhaw655tTIrzOASk80QWRAR+Psco";
  b += "90v0E49ZNFuUpshUuo0U+o0IxEm8foQXn+RU+eXPBEokjwnzYkSy0kzEoU6xkS3yHokCq8XJlNI";
  b += "FOt+JIrh+rhDWcenlXAKOzAcCvx9njY2xl5Hs6RnYsnOejGA11m8foF3z6ePX0NWF9ixNXK9gR1";
  b += "j3lnvkfXYMV4vYv5jxwxv1juUVUoK1yoyNgI8hG1yVKJG+i/CdWOj4tzN3Fl/mbFiE1liYWM3yU";
  b += "UXNvYFds8LnvwGm8udh7Vwu52K1W0n7vaQ129iDWqNWsW6rFWJ88G2fTZACBfWjg1yUem2rzyhL";
  b += "C0DXGCS525g72kRq8oW6d4fHSVLX2G/qbll36YsgNlXR3ANfqv0pMN1dIc4cYXVcAP+0rJy73a5";
  b += "fzc4XWWNkArLbbvpwFg8hy7/dYcPqTyj3Wb+znzrlG103Wk/MGmsttUHGs7km+wHdtkPbDVW59Y";
  b += "DzXa+x7Y9v8N+0wr7TSljQW+/yZCzX/bsV62xX+XwJG80NgSqvMqMCvK8w8nmFrsNO+w2lOw2pI";
  b += "2T7mptMLSjbzfhCw46zNptGLDbEBsbFf71tOQXHNR4ztGU3XZTBu2myD1U33YHHLv+1v2So3W/6";
  b += "GjdQ3brJu3WNdutM7ddltA6c5j/1w7nrs872v05R7tvstu93W73hN3urLHv8zba/fOOdv+co90O";
  b += "b7N5u9n77WZvtpvdZOw7LbnZZgyAn/Fs36d/5ejQTzs69IyDEcN2jw7YPZqxe1RnbIm97R79rKN";
  b += "Hn3X06FlHj+6xO/Sg3aE77Q7ttDsk7bf3vZ0OmQu5RWIAZBwe42mHx3jK4TEu+rrW7utBu68323";
  b += "3NGRuR77Cvn3H09dOOvn7K0denHX19wO7qYburh2q5KtfbI859b7+r5iaL4uta5/B1zTp8XTMOX";
  b += "9e0w8Uw5XAxTNpxRwK52WdR4S6b4Xljp/ldocJPOKjwMQcVLjuo8FEHFe63ifARBxF22USYE1V3";
  b += "21Plgg2FJ94pEcwt18cV633LGVEQ5zGbNudt0pyzKfOoTZmzNmEesQnzsI0OGU7zXi1VmiTPu0m";
  b += "YizZhFmzCPGkT5rRNmK02YSo2YRyus9I59f32kud9NmJ8GRnWdGimvRM+q++ERhh4ETY0ZhLSt7";
  b += "PdFFlJuDrLazRjeY2mLB9RKwCZ0yO0qHqE1qseoQXVI7RR9QhtUB06W9RCa1Vf0a1q4V61cEzzC";
  b += "PXRI/TYC+dg7wc9QhPkczt1qbwXHUKhJk9rtqI/KNTkFEfPiNbU0ZpW9AaFGuZY2oLOoFCToTUN";
  b += "6AsKNcyttBFdQaEmpfiL5mkNcxetR0dQqAkUb9GQ1oSqG2juP9/nnxVpKM/3JaLzWhLKvEy4yE+";
  b += "X2RlJvJGlm+yFuHRpLeeeYsxYEC50UVdFP5LG9JKNC0oewX66fRP1Ks6QBQSvEAfw2SvAS+t1h6";
  b += "Bx3WbOyN8jU/hx2wCeI5NtmsWDUpDjhihZ0e0IMCFkWrXnb2Mp63oVF7xxw12L5mQch8Y26xaSr";
  b += "brReh3fEuiRwSAbF2QM5hAXDUwTSvWk5SZkWzZbFGIaE5FYeKbAy+Kt8FL8pjXKVDTrSZ6dsW9B";
  b += "MT1N0ciAUd+CdCI1D8BpPMYW3UWhW/OOQrcBmiKxH0hjeCLqnofRxqiL7bpJ4+xKvKNaqo3GaFz";
  b += "JT3UT7kjp2SQMsjVUWMxthXKhZtoi3UzkeXxKmtiJ4MyEpDtlBOC4Laqv6DlMMUNil5pVdBeNeA";
  b += "wgWu3OFUpkCAi+W08UppMdD2qWsd1GwoNxhUMtDg81BBTNa0gDS7boboe6m2FUhwcRO3DzuCrx+";
  b += "xcUyzU84tBzJGXxAInvXvA9VWlrqkZKNxkjmChNd6RflOEiLK1YdklPZmQWjI7xdjkox91RtqIH";
  b += "I8eshEnVT3UVS+zaq9iumYY5hahL8bBa7fIkXSn8dCF6Tx8wK6WlxDK5yw7FtvLYK9LkRQmC3oH";
  b += "xUvsVF9KcwvmcLhM0LSGNqlvUcWJxfiOhOjK+xWD8Si3P5QoZ9UFm8ZGMP6BbLDWgceJaDQ+c42";
  b += "LrUeH9WtujUPEcjCWzteQR0tJolfQsQRTALCjeIWd+cU/UVNGtmjDtX510f2Mb7IQwvYrjlhmun";
  b += "yY2GJa7hbYJF/oQUPHvJloDULBL99UwYMOMK3fyw2vAIEfBct3kqg9QUNKdoQ1IMQPPVgTobl1P";
  b += "rcWAs2lFKXW48qJu4VjqiesBS7tN5xstHSEALLpJhdFK3Tedpgwo6q5NsxrS+Fb8CgmjQYIRBNe";
  b += "Bain0FMTEFjCkVZ9il6ekIp3U0rIpfs1T5mFELE5BYR8/npU7+fGyqLmiO5xhNr0GeQ6FR68NgK";
  b += "xtmpGw4ndTB8ia1hNgOkyR2W581ANQHLeyKBpQZOeb2/mxM+CaI2tYy6lKYNovs7QyUUOY7tKtp";
  b += "dsQ9Mt1m/0RRFbfgonZCd0PcR3icyvBLCr2dbogpKOMcpC62gXPiMMzIvMb1Ud4t6J6dpvwXGv4";
  b += "6HfIGNuNimtDUYZYVqItrNAVI+Ay2qIaWJrIdGFv0oKYOqxJlznpRbDH9vgxM5nuMzeEuRwyo4P";
  b += "4gFzuxu1RS0W32sckddkFxSh5P8u826tkLrxZt1smo6HiBo0mskZeGZk0LFoG8B5XDkSnXfBmCT";
  b += "52RE0crdsEWqdV82GAfr+SiHKVC/rMrrIbBWlYV/5lRGuXounHhNpWc84g5ncSPpluKlMYwL5PE";
  b += "ZzlyrH8ctvpJZpQJGEU0V6/YEpATrerH+Fo7yNTz7ziW7jakSCNxW+uhfZGSGoxqouSmbN4pe5f";
  b += "t2JRtLuQ7cLzXgu2aqwXmZlNWr3L1E6HtWyCijPcLeYpCZdTZhQT75JmMfHqaGVFy4nJc781SVN";
  b += "yFq8+agIJuEM7XVe8Vmiw/Hv0ZIS6lLCgqLS1UTsZMkACNmu5HE2RYcZts2R8RQk4KCTgiG4dXw";
  b += "cScKvuuG+IE0uQ1oPCOa0PUkdRApLKiLRHkaNpfarZHW0nfDItw/ehBHQpwqjK25Au2dTaJKVIE";
  b += "JPRepAgYzgyEq6WhVhpEjSFEtSqSOA6R+ZilECaH68bJGidLlq7dReAJUhQm2JmPuqUoGhpEjT6";
  b += "DuTGJS2H7TyIIulSRaS3Azs7/ukuzWBMpoqVTiO3yzTYKFUw/4t3y1h68Zqos6LZmvOUas0LMrF";
  b += "SDEcjUTNI1XG5TaznXqKpMk7oRkK65GFuajpGrQYxHFeM8O9xiSHL834gauFSdYeQqnt0e8QGkK";
  b += "o79aSlhoiyHGHLUOCP6IPpe1Cq6pSR81aXbN6CsrkDfESNgAWHcYjLWAPstO5SckhOB3OKxB5Fq";
  b += "epSIjM43W/3aVK5RxfWVpDKvfrs0pDKGbdUllEq2yypNqRyCtOn0LR1PZYMj+iTQy6VI4ZUTkmp";
  b += "7JZhB1Dki0ZW8UWl0sglrEjgviWNTYvJ3V2WeFVETjuwMOefHrCzj8nEg4Zbh7Ry5Z4dXEUzm/3";
  b += "4JnlSEq+NVlX0fIOYqSy/IN1BRPIzrquVALQd0QCXozk03YIcCNGcEKo5kQEL0hBp6cEewetZvD";
  b += "6K13NGfoTAPKUSZ1PiREqcQ4nTJ2GmIg7qog7SgjwoHOHNwA4mT+pODAXIXXlKz2ukaybMaEXnB";
  b += "WvIdAK0zu26GZ+hpubZfDJayam1UhDouLQiYIl5+hWdt9+lwlh483ZUiPfoE5j7Ues0KLOVO126";
  b += "6zTqrllIWLFZ37a5G8fyOmWOctCluu6S0/oWRWvdi1pLTXd+xJVhWiYM1LTWLah1uhStd9SltQ4";
  b += "LW0ZNa92KM/U+RevtdWmtQ26ttQ+1Vrel9QytxbTeRlRpI9IVDj3+lFxhPfKIBbXipOFBu0R9NH";
  b += "ydOxqLzSauX5fdc72zifsM97H7pNqOBiq4+wtOqDCNLkjLA5aQSQuLdZ/w1InWkjkHiN6ALr/Ht";
  b += "JchRHeTqSyKXqcQvbt0AWnSBvzbXXLMgL0aN3eP69sAfMDPWtrAEOB7UIAPVOJenGm169Cnecn2";
  b += "6zMf5/JgGerKZeaKoF5ZEWyuviKwRHcfim6rJfqG6M64RbeMotelDL9HXKI7pYnulD5Ud4PoTuq";
  b += "ib4jumFt0+UK6Rzmu3OsS3RFhcx4N4oK8UQZ8QWHcaGSaklGRVjh2HeVe41JltNbejiqZMvjDEc";
  b += "eMv3GJc3+ZznwCZ1vjyjlCQZkkFXTo3UQmlig9RSE9q3TINoP03KJvht+tb5IcRkeCTsVZsFPHY";
  b += "whT/kO6XN6m5ermgc+iXeCuvFIP3XQUpSerBA263SWCR8SmJuRAa9eRXh81KAPX/ur7WZb07UXp";
  b += "a7VSVxvSt8ctfTMofW1KLIHNivRt1tHPpW9MR38XDFyjukQa0jciBimQvpQ+yPWA9PXpEmlI3zo";
  b += "pfVtRWKiA4Sn9RumOg5ulwnhbCfMopWlrTbkq1dzXd8maa+zbZsdWUsbDPQ6pk8vfcZSXfiWKY4";
  b += "cS7LFDB8ta3DdepY9d+xDizQum8Bi7iXtQUHYTScQ9mDU6OzMgJ4bsHNbdy6dlpr1GRUS24TSzX";
  b += "tnsWamIyEpdQVsiMomL41ZFQR9URGRKh5glIsMoIuqKcK9LRNZpImLsiiYB4sY0bLO+dGYnDmMo";
  b += "IsZxQRcMEF262AzZ8y88wN2JibmoFGCAVAvoyuZ9bYjLUD/LHbCXYB9a4iCinizZEJ9RIvTyT30";
  b += "y12So22sYm1uYBRCW2mkcGtbqRM8Amov67vuAvjPIgLiGpVKSQN6MurbJPGdHe/VOPYKOBeQxBL";
  b += "K64bdNOa5ZqXPXAvIIArlN2USfVObuo/oupgXkEgK5WzmFHXYBeYXc8m9RghEvRyD3LMRJHdwbd";
  b += "F27U5wDRNs5EKkHXJcMBa4BsctxnpS7bnBur6mTXZp4gwO6w5rVF+b4zegGKh2axRMSkW7xpBW8";
  b += "DSFempU5i1PNbnDjbR1O8lsV7es8s4/deIsQb20KXsdceFvhxtt2xFu3El6EYXBUP+3eqeEtkKa";
  b += "oDG89CyLMP2KQ4W2rHumMHnTu4MBYziKqi6hwiJocWpHWwktLTeRIvOyw44orCq72aN6F42u9Yu";
  b += "+XUcy6Qp03HBsZnQ7NwNu1+vhc1BVa5MYGxvcG3hZrniQu07CxTPfAzQJvd+jYMiaoOzVs7NRZ1";
  b += "gC8bdDxskJbdyA36c7YLIbrpMBgCRbULArI20BJd8A/1V03v7c6tMKsEvqFf+pFPrYuSBPNehcf";
  b += "24Wpo8bHWeRjm4KDtYqOmNWJw/m4XZeRJuDDVl1HdOrL7I1SxhqVbZoW5GPPgrQc3KHEKWrRT8K";
  b += "Am2QVjwQfpHYdgkGcG3VL4ENDTY7UlrZGpHmbkrSg1UXzHW6a70Sad1s8m9XNVxlItyPNBw37M6";
  b += "BZk86Hdt1QQw5UZO2GhGphUX7fGc2yDuq1KOESGX26FRvUNhd9Wtz0SSF9eiz6GjGpsxIFu3n/c";
  b += "iIF0zvoX6syhWN9UfHZ7epLq+zLTbwtNB1U23W0RZhjo4dF6GZWxniAzFQ+k7DzeEu/gYKVdqrX";
  b += "dKsWZtzChlmkGhaemsJjglv1J8HEn6WY0vNEMR+Dt1ihoarzQLaqJ0GTWuhWC81qoceZaKqHJpo";
  b += "K0a3gPPnMnAia0a3gvMgp1Y1uBVBTUMz4I1rTqDga9NCaXlqTRbcCqOlSXA9aaE2/4mhQpDV9ih";
  b += "NBntaMK+mrMrRmQsk4FdKaLbQmKbJLnYfkUudZbql/f593dgGcDxTPgkapFaRnQT01xWeeBTHYW";
  b += "2U0U3IlHmu9SCfCPQt6Dc+CpgUlX00fM9WIlXVNvWYHjp4F1MirTp9pjOmeBb3a2xQ11md5FsDv";
  b += "4yHpNRS3cc+CPsOzILOgrNvoLCADjW3W5pOmZ8EYNLZFeuRIzwLRg3wF29sgzdiaFoRZLc6zs4Z";
  b += "ngWFIZ/pSjJv+QdKyuhdPEnulZwFaVrcbngW9C4pSTtMYJHAE11PFnJvQo17Z+2pWPAuaNfcL2l";
  b += "qwrKYeBn1Aom5dkdfpI/ag9DAYF3uY25Wsghr5mqIxZSq3xaFi7eRUW+xUSO26xaq6sBZJp1TPg";
  b += "lnFs6A9qqvoyaCkZ4G6hUA9C2LFrtgIKEygoPod9DgSbeFc+QB6FmSg8z36Ot+wGGfz4CFp179M";
  b += "0PSAZTfcEieBP1v0EcvIzZNHvm43fIsaMBSSYEyfsv7boTBmh8GY/Y6RdI3lT6DsdaeNjcp+M3x";
  b += "JLEJtwxvjGenhGHdHuYq+akfPglDuRKNnQQjMGtC23hTLZ2qq0anb3hpRU/vF/hNYkvUCs9K6Fa";
  b += "DB3QJu4gvL312CWav1WTI1YCzqUGnWTwTW4AHPMgEZ1d5fuh1kgeUGFiyWD0KSAzM0/nZ9wzMJm";
  b += "szYdTVdVPbrgV4V3m9Z4s7yWm0pqCxcbc+CZs2eYrtiT9HD7b9Nz4K85VmQBxRsrOZZEIIWHHat";
  b += "JFfq2xnLhWfBmGJs3emCzVq0J6yzPQs69XU09f0q6XuABqS4Z8EuZXGU1jdAqNHSLh1fBX01vAW";
  b += "xNATW/cv0XZz90uugDaBkxFZt0T2MxjF4UaGKUSpZ0zUpziv9Cor6q1j2qThZ69jtGq+5PTvxdj";
  b += "wLWqr6rCzjttqmZ0Gd5VlQB8jaWs2zIK9t/G9c3LMgBGQZngUGFNmu6QzRu4isjbZnwQRuuyueh";
  b += "rjrYsAUd2u1rbnl+n6Z7ptVUvDZqc8RWmHjetzMqbhOHhKWdEW7WndyWCt2kMAOY7XT4UD1Zdmv";
  b += "qMRIy2tRC5l012mtLjv9TmSuWKJXS23PAtfp127rHMzyLNhreRbs52jNoWdBTpqF7Xd7FuTUrCQ";
  b += "3s7zhsXLWakZMp3YMh/RdBeMkdq/mWZAHtG7QjwOcR6/bpV31VoHWbbrrSKi5ZK5yQb+M5gobXZ";
  b += "4F04jWLkXTTyiYNzwL2sEWK4UD0IQujdQBY8q1bW3E16fTgnFFEkYR7W3KkXBJcW/YpcvWahPt6";
  b += "6TDQTugvaRr9EjX2ktAe6viXrNWQftaw72mNtonl3iau9dx/HXEYSVx1LJ9qu5ZwK0IuICiDfRO";
  b += "xQZ6edRf0S0O0LOg2fIsaAYJqOpZkIvqFaOkg468AqpnQQeIzJhiunPIJTK3om9Ni+1ZcEi3pMh";
  b += "rJnROz4LDaDKwVTFT2KCbWVDPgq26bK3UrYnSKEczcNBoeBbsRQnoUoRRlbeNumRPoFHDsGmS1L";
  b += "tgSpVx7D4txEqToEmUoFbLzn+XflCoS9CIJUHgcNCoOByUHM4CS5GgdkUKI8XJLaoqQWsdI8JS5";
  b += "cYlLbcu0SrQtnA2nceE4aD0LBD+Oi3or9Ni+euYngUtlmdBC0hVVc8CeopY27PgXmETES0HMRxT";
  b += "Auzf6RLDu9GzYL/tWXCnboxYB1J1V03PgvdongWH9MH0HhxX8srIebSWZ8H2ClmaGJ4Ft0prRWO";
  b += "A3aYfJx6W08G0IrFHpKHfEV20jRQOe4WoalK5B2dovYpUTyhSOaGLryWV0yiV7Yqj7KRynGqk6R";
  b += "oxpZINPY3M4aBRmYGtU6RynSmVk4ZUTkmpVB0OSsrYWF0qSzXlrtbYtJjc3e2wy527Th8Dy7Ngv";
  b += "rpnAfWE3q94Qq+p5lnQoHoWnKnuWVCUngWnpGdBITolhOqU9CwoRMXr9ywovGPPAuEkUAQXWFA4";
  b += "se5ZUNAdBuqjFtl7t2fBvPQsWA2HTmOLeRY8iPEC+jm1+m3PAuYwkAOtc6JWhiJ0HuhAhXinPoE";
  b += "5jVqnTpmt3OXSXXOou3Y4PAvuxbE8v5hnwd1yWt+jaC1uY92mqL5D4hRc0Vr3CFWmaS3Fs+CQrs";
  b += "kMrXWrW2sdxZl6r6X1jNALh91aay9qrW5F6027tNYet9ZiimUQtdek5XAwKB0OmpTz2PJ16iPXf";
  b += "sfkO5hDLFWX3Xm9swnmWXCvw7OgqHkWUJPeet2KpODyLLgXnXpaQPQKmjijrA7oEHU69RjeB83a";
  b += "gO/0LGDAXo47U8f1uFR8wM9Z2sAQ4DtRgA9U4hhnWh069LMgvzfX9Cy41W3vdlTaGRyt6Vlw2C2";
  b += "6e1F0bc8CQ3T3uEW3jKKnehYcconutFt0p3CJoS6kj7hEd9ItunzbSD2u3K2I7jp9ZkFFd6iiTA";
  b += "XQDmDQYdejWswtbZ96sZ2f6Rp7O6pkHnT4DhxRkpkvbe5/h2Ep3QDSc6duTVLUrSUY9PYvwbOgB";
  b += "aTnFv0wY0AfX2/V/HLu1vdouA9ts7JpeJfLs6AJZXAn6ThuSizXkZIFEezXBdkQwUPCXCmKFek7";
  b += "KM2e9Tga7v0sS/r2SMuqPTXn/Lvd0jeN0qdOlzcr0rdZRz+XvsnFPQsM6RvRpC9lTrdV98spRfr";
  b += "W6iNcJ1quRNJ2NqNIz5AiQxmHndSQI5ZY5xIlrLZnwYRjFNzq8DFw7a3uVbY+pRk3kxfV4+JOxb";
  b += "rokA6WNW6T170I8RbLs6CgC8pu6TxTb9omlhHizYrzzIDiWTCgb6vSo6cmRUS24jSzTdns6VdEp";
  b += "F/nuyUiE9J5ZuLtexbkAeLGKrO6Z0FPxdyOCTWD7mmXZ0EkJl8gIsaxVyMMUIZnwUbdwLdTehbM";
  b += "Yuw8ZtLaK+2pVKArm/e1IT7rALvrEGvjEgcRl2eBy40mYxiAJqMGxai9T9nDKOs2N2ui/eTXODS";
  b += "s0YmeBTQb1rgGmrfJDbd6BcibpRXpKt3FZUAfGTa5gTyJQG5VBoytjnMZ5K4F5BEEcrviWTDh8i";
  b += "zY6AbyWmmxuLamZ4GiHXuUCI2dCORGxQyqpHgWdOrmtvTIYIYDcYXpWaAC0eVZkL5ucM5ctybe4";
  b += "IDusOHOko0aFKvIpOJJktSJSK2GMwreNuI0o005pym6lggb3HhbJ63PCzVPi0puvEWIt3bLM8HA";
  b += "2wo33makJ8qMy7NgQOe35VlwE+KtEUwaNAyu14Kq4rDbg54og3KkDi3PgrRuLOXES09N5Mw6bM6";
  b += "XXfdo3iW9fNp0Q92kjo2Sho2szpsW4K2BF2PffoUbG52IjXbFqqegYKOgW1RxbCzTDd1zmtfIKg";
  b += "Uby3XecmzM6iyr0+wdZxRdOKRbdwfoNdIjwrpG0vZX521gBdKtCPgsnd83ObTCDkf811i6HbbqV";
  b += "twGHzuEqaPGxx3Ix3YFB2sUPu7QicP5OKPLCLWSv0nnreEBOihlrEnZj+lBPjYqMXu3K561PfpJ";
  b += "2KzmWTAkPTwChRv5JfChriZHaktbE9K8XYYyRsNyg+bb3TSfRZp3WzzboUehHhIZKIHmQzopGmF";
  b += "C2qzzoUO36FD8L3ai4SfTUrl3SLOcg3oSxfXSo6tbd2wx6NPjpk8K+9di0bdNp09OomAX7x8dtZ";
  b += "vfYf9alSkc64uKz25XX1plX/bzttAY6e3X0Zas4b2SdDMra7kmKJ4FSct9ICM3HIwcSCJvl/Qs6";
  b += "LOcDsYsFwPTsyCkPgXUPwCM/0wvAfQsqKvqWZBTC+1V/Qe6qyY5aHB6FjRQz4KkSFjAfQRaRMKC";
  b += "ABMNdIuEBUFUr3gfRLSmida0i4QFQRTTmpxIWGB6FiSEH0GdSFjA/RHaRMKCIBqjNXmRsID7GmR";
  b += "FwgLuWRBiwoIrd3n3gi8BdSLwIx9E5J/wbElLULAs8pkjQJ/iadCDltdJO0VBfbSmoo+8dOqM23";
  b += "Nxe9QX0Sf9k7m2idrZmzJxu5xnxnVcQLboqQxusuapUY9ondaBfqVxSdIYfTukjqXxoKIQF0gb+";
  b += "pSXr1Nsm6MCa14+Lsj1e7yex9oWi9d6Hq1dDGPrcOMrY8QjGtaNlNbqVjrycEEYKW7RHCJGFIeI";
  b += "TLSlonssrIdlDOkXzILilSz6PV8XxSllT4X1PEt63g7LwX+qYq/PbCyYgXyTtHCMm6OVFfPoe1m";
  b += "0hm86TotNRzHVQPII5ZuKsjzjYFXaJCsWedZoDhuOcTjiyzjOCQzRu1IJ0ZuNbqroS75mzEcLS9";
  b += "94GzOHF84EgRILhpC0XeryOKRrgXjU2m1PCWcJMjaRRWMRk1Nq5F0jydsSr5EuHXEx2maRtx4X8";
  b += "B2aiQ8f1KblgfBoNbqKBXI/ERrkVIfglMy4ZdJcDs32oINrmbzlISiNtoY189v1ivltXTRc0R0g";
  b += "iixVNSVfnCJKY42c4MfL1ahd1F6nSzrK0Dwk6QomUWnUnVbyVNaZC0OcIzwswJqMg95gHRskR4i";
  b += "Ev8XdEt4yOxfwvQzO08BwBGFc7YCYi4KrOc5T6RAaLQMb7W0GS6d1lqbBVMZkqXGwmcQZeptubI";
  b += "28bFMmV/Z0tZY7ueGhokR6Kopwh5q5wgbFXKEhWlvRl3M5ljiJ85eGxBHeTqvUyFDtwPpBYclAV";
  b += "wVxp3m6imeOVHbrMLSpAF5Ml85xlwUKtihdyVORw8bkW0b8Dx58B9dpBkSW46FVqBjNh/r8uisa";
  b += "wFmXnFDXS3nviesVs4x8lOLOZy3qLhwcUleFRWe0isOi04DFcgmLfkhBYZjgGxNh1Tm1yzGJdYW";
  b += "nkPb2A9rejuIB1G2mveLoZYmqQWkK0UhF6yq621yeuccyA5WARTDmS5h4UjkJIEjpkZmF4tV0uz";
  b += "futU5QuqXZeQMgZY1cXhB9O4hpjAx4sf2i9USBWt4dU/q+AbVVHSZqiSKQqxYDeDFuqZUU10jD5";
  b += "rBIdCLCLTLcjqMRMjaiW1ZGzrzZ0cNgxTTIZ3t1AcNbBMlYBN5Cy2loUbT1RpMVK2GLEb6qA+PH";
  b += "mkBzgSpWNrdtUA3WjLy42lpVW16Dm0wHaY72BTrAQP6mouR+W0UbxaJQcbcm4EsC+PieRbxZdZG";
  b += "qh2GIr/LjCbqaBKfVsr4vv0m6racAfD3KHGITdauIxy3Ebsdk52vtHE57dc+0JkDzahl/FrAed1";
  b += "tonsRdqwFl19wIurIWF7+Nmscwbr9kyayPPL2k54BahRYAm6xYm/LghYBaAp1JwXg0YUG2VYVsH";
  b += "/j1Csi2VoVsXA2yQ9HmtwHZLgOyteHZ7dj0mXQ4M03VPP2ZkGjVZ1O7zZR/XJegcfw2xTi+OWqs";
  b += "GOEKQOAkjKkbIj/mjneqHiFJgLEwwN9FN43AE1P3CMRzzjxGEC6AEb2Qr910Ywp8bQ3sszOaUTJ";
  b += "UIYwnBIz362dLNNqFcIQ5gNM1Sy424aYKk4+9uifrlNhoJEPBGpCLKaGNDXEYR3Egi6Z1uG9bp4";
  b += "vKatgsHNPlZEju1KxVJKQbZ4S7LSkYlEH9VClYhY6Duywp6FWlYADyhggp6LWkIK4iBeLIYwY27";
  b += "5YoBYNVpWCpOF/twPmMYzt0r+Mgf6eS2M1KGme4iUtzj1bLjRh6E0/DSkk4TqEbsQxDwM5UuWRk";
  b += "QTK4wUp8SLHBYabQ3HQnPkqPvuM9ln3KQRnKoxlTWB2Ui0SwMohvtsTpAOYma+OSccA2ddsl47n";
  b += "tkoEQqI9s3hK1nbj4mBDx+xXdshvN1tdII8l4J5U8MqS5zcsbog3gSrxdF7FZNI6dUsxFVhinZk";
  b += "CIdcokaRPatW+23ENWy4CCqjyN82B6ljxNuuWJyeXN0VEuT0O6aPrMUrpOmfb5UbAEeTL8ZvZEh";
  b += "xaVp8FF5en6ZWdzTSna45Cimx2O24ccJqO3acOvMke73dzM5fK3QPN3xlsqMj1mG5k06ZFEfGnA";
  b += "xkeJhZgn5I3TBMOI+lsxaTEVxVuFCNDq+E4qpmAR4oOpKin4YMbKru/B6714PYZXn53FyvS/x6S";
  b += "ltLAMNTLPR3eZWeajW+UKPGBzqoB5mYhgJd2KY9sdOEdql5bc8Z3UyCc+XGF2Q9Le7nYRbwS8yz";
  b += "KgL4Qiu52axcVHLCVzGzMiI5MzpFyjINZtuvUa9e7nHI7vouopPmgpoEO45DigGPgd0P1u60Ffi";
  b += "KQ/h6g+Au8hQ/PcjJpnlBAfbc9SulYC9UMmyD0wxu8WQ/JGl6/ZdnQL2a5rowmQPEPdzMqIu6q6";
  b += "2YxGxHdZ6mbGrW6YfjoY3W6pm9VudcP005HoTisI8CQO38swODbuQa3STfa7o8NcjQSGGmkx1Ui";
  b += "noUaWO5br8RKnqe+O4pm4ThVkxf3ZpSS9zVdw55y62SvHokRJ9OFAx5TBQX1U7MVgNTRPVK+cvd";
  b += "6hyZxh6zctHepzQnxu1rFK4wDzXsS3UDmFFYghj3vw9LpRMXttNI0H18ig1fEeKp4g2YYgTqAgb";
  b += "q3EfejqXtQhXg9yoyw096NvkCGHm6URnK+I4AwKkNOVbJNb6Bjw98B5pHPizIVuXAf+LdERS+i6";
  b += "3UI3yMNdcKFr1SfHXOgiM3vhYS50aX0bhFrN9KO9RR4TXuIIv8yQsn7HrnbeEeiu07FP2lUz7Ob";
  b += "1rxNX11wnztRYMcJpCVvFKDkeyFqsHaepB3VvdIazLVFo721P6BCikT1kUAKxq3ZIHyRm0DUip8";
  b += "S6zunAyoAI8N4QDu5Er25DmKZQmLZVwCNePxZYLYP6NsqNPpCweMqSJZmWKOpTxGhIWIDEQ0Sa6";
  b += "sHtmI9ChhB1u4VoENeEQ5YErdIkaJUO1ymwAjQkqCSyroMElXQU7wSRG9AmjLjjzCXICEnTC6vO";
  b += "Vt0IsUU6SIygzQAzbtjDxaJfGgYoFmD9DiPW9BJFpfaWca9DLAYc+3wuURmvKSprUQQU36x4Oz0";
  b += "xhj2MXXqM0ylciYSKmXyoAy2rbadNiTXSAX1BNY7Yn4Z48jndXmkIoa9u9A1RgYCNvn26c4LMGx";
  b += "61V4ywdSzfz5iMiAWiETdaqB9wo34QN+cmFcPNQX2jwcJ5jAY0AueN+hb1KsS5sT89Hk1ZOG+Re";
  b += "nydGqKK2X+DuWOXvvMaSHu9lTwafCda0qqwHVkCbFfWBHBtvd5aU8O79gQ3OkDdrRjdMoiuUU4x";
  b += "1jDbiEkeEtbQP22wDG3CjY82nc80lm4oT8dW44bvhBb0C00qOzC2bIeurmhMQBF+a6PYbduk+y/";
  b += "0usEZC4UUxwSjSZiAcXW6Q988Lrmh2YonbBt5gPVWXQ1auFyOW2wD1rlKp1R2Dcr5eoDgX8NxGe";
  b += "hndDRM7nq0GWXbmpPvBGbrHYDLXffkYoUDji4b3DUycnksLXToAcRGS9RL0qKsSUFTJNNW8FfEJ";
  b += "Qo5OCMa12dxXW40KXHJVoiYpBRj8Soe/Klb56GFpk48M+1VDsaMoczCD1MiJTgFbdWVSE7Dj68z";
  b += "PYTwW436CnW9sM6INnA40DnkRhccGhyG00sFxoaaOqnRAZvQAZsemY6qXsbGifG025CmFjfrQ2R";
  b += "bVlEkLRQQccSnHyWdohbrG8UOYNxI9EkGBjuuBLr1kSBwM54bo7bwxXBa9wrgXN+gs2p5FHFDyP";
  b += "W6Lwrd+hnlWeMoBrp4qGaFlQIVb4edow771WJNdvZJL/+kPPSnAXvrrZP/RjfDAhlgTZwHNApZL";
  b += "ekyU9QYVjRtY3PK1m1K97vhLBrV6Up3YtO648WI9PjaykVkPTM3pnzQ6K5QvP66ae8SoK1ayF9M";
  b += "rJiRp2Fw/h0n+fKvQ3c54tTdqsONngdsIAoxC1ucHMoGMtdLZBYU/I3gAmYDD5s3orvrjVIDM47";
  b += "ClTR1BKdTvWIe5qJTcokUW2nEZ6d+6cLubQM9i40z3IjMYPFWpMlKvd0b0Lo8rXvNLJPsnuaMHk";
  b += "F7N7VTySV0KuPoXpM4Z4tJL6AfdYIho674qCvZzj36wPWjyVetprgaUC8dDeqEQtFjsvu65bRvW";
  b += "k7bdtIFM+aztJPukcaAwu9JmIYKBythpq9bTmcUy2nNPnpL1Zjsy9RCv1oYUQsr1cJ6tbBBLYxq";
  b += "ltM+Wk6PvnAu8hXLaR+tojcIy2kfraLXC8tpH2OyrxSW037UTmtGhOW0j1bR/cJy2o96aM0yYTn";
  b += "tR2u0mOxQs47WbBGW0360VovJDjXDhuW0H92kRGlP5D6zyy9eDBd6E+XXs2fiVB/cEYJ9+J4401";
  b += "1Kk89+RD40QBX8t6+7lPWn/WlaznTHjeXSwXDar/kvaix/wCd3lROlTJQqJ8b9l/D6GlxfyszHf";
  b += "pQm/xqjbDl4JG4te/Nk6VmIGvd1xy3l4MJ8XCwS7VN+MTsf+eXB4h+HXTC2niE/Azvmwp7uUj08";
  b += "KDtfao5SA/6L2VKevJZ8+mI2DuB6NRuTyXw53BeH3XHdbCEBlS9lS7mA9SQse+fIVyU/qiPvI5P";
  b += "x5ijsni9nzqwOEodmw+nIL2Xyfi7yyUfajnJYHoBbSHu8MxDcnr6klGQvLQU5+ljxxkIilyM/HJ";
  b += "iPmssd8+ShEwH5STmCclGWO6CcEeWomX4qkk/ksd/Kjvuj5GNy3B8klwCYnorywOlUmTSDsGNTY";
  b += "hLiBs2TGU/jvoJXk+BF8q8eiGuRllGyiJTM1aJkOI2E9FVC5rtLISMkvCbPCTmTuKVA0KWRkHwJ";
  b += "v1kiCUmHQqDj64n5qEioFdcL0r1Gq4rzcV5UXaVVCjmL9NNuSc6HGDkfYOTcQS65ceguJWdIyPl";
  b += "oDbxSZAJq3UQ0iJdE4hGcQ48CDYYhoV4SjuOAeoGAYUioFywOw8CCYRppmMzRx4o3Igyf9eYjSb";
  b += "mnSUkS7bLnJNolT1LteficHvef8xj5Koxu71Ng+KIHudb2E3Zno4Iqp601MdlA/hWowNdXQWX+X";
  b += "SJs/p+FsFeBlKqAv0orFAl/mVYo5GWUv6KQ99tI3teQvF/xGH1f8hQCv+4RkrYStEfZfYWgJlHr";
  b += "yb/WGoJejyQNa5FUE3RB0Vx3KeCCXh/ldEEPNFqSL+E3S6Ql6VAABL3sE6SqBL1EKxSCvglYVgn";
  b += "KgP2GQtBnfEbQp31G0O/Cd+G4f80re6U6JGpAiPqsXwOZeSruDTBEVSVlDkmZrUFKvwo6G4CWPk";
  b += "NnLmrQ0BkwdOoUbVgqRX1E58uEdjmVmFdohULMl2iFQswc/fSiL4n5TSTmq0jM5+FK6p/zFXReh";
  b += "cJr/jwMGeRxwKbEfHESlE0A1CRv8qD2OZ/VvhqQrpDr9JniGDA5JIQl12vefHEMSLk+MRmTZ+8s";
  b += "JHBGQWpe9+I60vt6P/ASRHDJaOeX6giV4AJFwFBdjtELXjngD8bpcnJPeJHUFecpY/KMZMVcRK+";
  b += "veXGS33HFY7d8xWMj0hWPELUIqq98hTSPvKJ4ksAnzRrzome176pPXme0L83al+btS/P2hfCK55";
  b += "TXX8LXV9jbL8Hb4cOrfhzwe1702T3P+yU6NL8IEGFNfCOEkSksnhQApvwoT1KwhpTUWCC4SAO5w";
  b += "2KZEp1wSLmNsEDc9ya/T/b7jbTV7xcz19FvypdradLvcD/t06tp1qdX0qzjr6ax489lSMfxpksZ";
  b += "dtP306zjlzKi4y8moeM+dBweXE4eZJrr1XTxSI49R9RdypA62Zc3A6svL4XXy8M3AtmXqwFr5jc";
  b += "D1perAfblxVD25XLIbvpQyPpyORR9eT2pMzFgkqJwh0iVyh2w/KJ8pGwgzwvV6QjM3PhbibLi86";
  b += "wkU0Y5SoYkVU7lq0SXhWTqFVwoJYmOSkdtUZpogrhzxvtI3FGJ20E7tEcdR78Udc5su1wpke+Jn";
  b += "BOiJInWipNE4URthwqJclhK+hfx5T68HEbaNGtA3stxbXa+FGJrCFlli3xQYzu50ov94id80iHt";
  b += "bhyUCHNIC0BBt0HTwigc8BNkGQFLHIZwKgLwlKTU2BlgWkDRkqSKCokJS6BkcSslMdFFWJtkCss";
  b += "gONzJCZ4h97xzgs8kSm3/IxD9cppBlsqGRnSypCQYP0np+5JDwWz9IVYwz6auU8Fgn5P4W6qi4q";
  b += "C4h45hmZKPSAIuchpBw7NReiYoLiB4M2Tawb+9mgLYEhqSNmTJDICjM8tUhvZs+VR4nk+epz7pM";
  b += "qW3/pwMfQ4Z4shTsmRphrxZn3gtSzkRIlsYYRahLGAGJlJvptn1uYwiNwzvbCpFKCQlJwrI/DaT";
  b += "z+XEBgIDQoZyPeH5SFNGC9Gb79Cab2fnBxKJ8QRIFQHuGXgUnb0k/jQ7nvhPmXw9wcxswSOPh2t";
  b += "dTlGu6tO4OqX0L06AUzxwHX6WJUs+74m4aU8hIARuIp2IA7peRsRlo6YzsAKHS+s8bGbUF/+txw";
  b += "dafEMQNdDVTPlaer6UXRpKi1ErWbi0FNewZ4FQZtjNTDhfTZfqiOYISwL1hEswpYhzswyRrwDf6";
  b += "ojowg4OqJ6ATt6VeXsiIkvvSLk/GWVgLk4UlQcLcjbhJGokB5kG9xRgU6mJLtkKUHEGdqhBAC6K";
  b += "n9cloxDmTr/ukRsaywvnYn9PgdSxnpFWBooQlXi3ySsTdDo8T37ln4HdJ3hCVsEd/5XSSJgrA9C";
  b += "41o/qixeX8CbY2iKcJLP7JiDuvzglE5AlsSrVClGz2ueLOjDkfQx/CQoT0pviZqots1zFsAEg9h";
  b += "CACYAS7TG/L4Fixe+gijeNIpigwleX8KjKzWfgQkCJwwFpW4K1LcMqXiHtSuRI19MWO9jtabUra";
  b += "aUraVTGSYcyTnJlTD+8pmjsK3jTVzIMIFeoxua89CgvOQrI8EC6Q3jpS96kIzLPB16mgZcwqkVJ";
  b += "g5dE68P9ooMl0qsE8DJNiSN4yTDmMZFktwEHiaAUn8wTkhHNUH7pqa8lil/w6VfZ8suiRJbz5au";
  b += "8VH7+0tcS5d7yJaj4WEC+biK8eRpKvwQ3+6T0nCghSgjlEg7KJTjlEki5tINyaU65dHFNjt0nBO";
  b += "ZKpur4xsbBPYUMHwcBHZzLtkJLK4PD4pMkn6KPTEn2ESaQC7yazZMIPjNnCLeBWbBTDSXYnUjPE";
  b += "hE7XwBHozSsZOMOkDb6qf1owaezJfLrNFzSMKG6C9fH1YcBBt6geFgMA4H7B3y8gD0bPoTwr8hw";
  b += "lDlDf0wHMH/cf4NQbCac8K9lqgyT8Lhrmfni3WLiFAjZJMo/y9hHB4HXMjgIXMlQKqAcAKdpZwn";
  b += "c6xDuhNOEeEQV8fkn0DMKNLiDtCj3pyO6q5AGuMPTJNxpA3nzONlmLpH/RRP+c9BCQPG4//mstb";
  b += "cCdP18lvXuTTk0srkrwXEdm7vW0bkrwTKdu1I0pxHNJSQQAew3qKZ+WkHTGwjs72YYmt6geiO9q";
  b += "0BXuVkYdRl4kNXkOXxEfYMT8w1GTFybkacLYjYgcb67BGICnJX704Q5bmLWuaaO2DSOSA9mNDkm";
  b += "OiB1uJlEb6ezvhDBk2Q/12aVRBDoLJA+UoFTEpaKbE77bFKS8E1cnH4PleebIZXa9YnnkpT07r0";
  b += "yfWpnbIr/iC+K+GaMuijia1CqSFAWYBUf4jRPTMGvpOMsTsERGOLrfJhTDtzYdF2dL5PGpeVo+T";
  b += "Rq44/jNP7pRafqQZWpepZO1Yk2zMKcOkmvYW5JjF5Ko3x+1gjan1wO0gkeAUTAtD+HB9PmdG96l";
  b += "kzHmPZPCu0fSu0fsEEDBwGH9geSSmV+uYoyx2Eg5f6lHDcui3EjS3+QvKH6b6j+d0v1B1z15+ka";
  b += "Jl3+4gfIbPAF0DR6qRZGOcrFElfZzxQ/e4PuB7BpUKhsQMIej4/lgNYQFUbu9MV+AixtSCtfD+V";
  b += "c8GUcVb4aMm6+DLN+uYBBsRG7QlThRIVy6kJxnD9u8Qnsr3vuCax4xcuOV6Tf3VfAvNB8xcveQ+";
  b += "/qO94I7Xdk3pVuANMAZR7jEUEZEcJGwDmceJfCcoJg2ysFREgImPcQ2YJTyIZSHR2hS50wZPcmy";
  b += "sUzcb4vIYamzkNUk2fhuVl4WIadqJVgLQkCl4/qqPREncXLsFHYFmVIuUL0eJ5elREfD1LJLR23";
  b += "fakCY3+mTHViHVzq6NktPf2iUwC2QoeXnSllQE3OEgEiX9FDLnxuBoaFDD0DK8FX7bd9KW47NEu";
  b += "HCDjH7UvARiOuy178IK7LylfIp3J/+XWo+CMQuAQ8IEGP5+gKBWck3nwpSRcqcYijzutZ8swGkF";
  b += "ev/MYHcS3357v8zgXvIrCQTB7i7vI3rvz2KwsPfYmbaCnuQqnIn/nA5z7xW/mFOIkWXdxPeebP/";
  b += "uO3f6HBUf/lz117OSnr3+L1//j7X/9G6Kj/my+/9Ff1jvq/+6Nn/pK/N05j/B4WQ4UFnWBeU8yG";
  b += "GULEcCePmJq/MzPmAl7r8dqg+jo3Kr7ODZYdWkGafxpRcURsJhGUTUTJk3E/heFj95cEdSpoCcc";
  b += "MSFlQyKX1Dk0TmaEd6wUEmox8xWwW2Fi/INz0tfzwxUqtHr69jiUtAjW+Kz1TUtmHEn8Bmpqa+L";
  b += "PqEX+83sSfVY/4s+oRf8zVqwld65jJMbMUZx4m8Ledxh2HOHw+xkDyMSSfX6GBNeDaqUDPATwwm";
  b += "DUYJINxRDIDZ9FkmiSXYF9FmkzWKVGlDJZWRBSQSAYWbTHZLGPlSBhLjgdm4NsKi0kjYPnugT1z";
  b += "A+w3wP6jAvb8DbDfAPuPCtiLN8B+A+w/KmBvuQH2G2D/UQF7xw2w3wD7jwrYe26A/QbYf1TAHt0";
  b += "A+w2w/6iAve8G2G+A/UcF7AM3wH4D7D8qYF93A+w3wP7DDfZ3BxIziX8Z+GKoHcp6TFLK8PEksJ";
  b += "MUKIieBFCQAkXak4ANUqBw5OlHKWaNjKOtdppTV/7SDrXQqRa6nIF3umjgnQYr8E6nEniHhdnpU";
  b += "ALv5JUEpSzwTk5JNcoC79QpCUpZ4J2skgyVBd7JKKlPWeCdNK1pUgLvJGlNoATeSdGaohJ4p1FL";
  b += "Wfr0mHcXpixdxwZ1Oo2lCze6VUE35+h2ND2AoUeO9JCdJjlNcdVHQ3ulqa2JVBFgs6cnzeGhoJi";
  b += "5TpzlcfKkFspU9CSoMgWOr6WYqmP5dwMl9lheC/SmpKBKEmVgpE8TkWx7+VNpCrw80S1pAtO3eB";
  b += "agt8xgkUa2NzPBRVFP09qEKs1UPHEq6q1osRtlUEIeZm6BKr64GGWJSGGD6kWDZBhOzCnVpacSx";
  b += "Ha2VWlnkucAr9JUDDDYXSUDmMwLk4k6K0ZiCxFgvkvaiZGOdBDaqpHY6mUP0pU4MHMhYnazBr0D";
  b += "oj91RK8jUXoEUZYpqXNrdS7FAygud/fPyNWBiXnbxdMbZY6TrooWLFXGZOS0g9ifpPctpPdZIgi";
  b += "MBLLzzYhi2W8jjamRVjuJOTCXaRnYq3RYxHDLR712Nsa4WoIVgxgZHkOxz00PM16sHqUYIsdyWY";
  b += "u6K1r6BxnwjtMa0gATajVRMkGmOItQq2oTakASqq4SI7Wq02mZTqcUhnKNtQCdixGoSOQaqRsL6";
  b += "opQ2jTLQnXi+ZXa9DMzZvTr8fUjkTa5M2qtaBEkZT5fmZ4PgnnHzTZ1Vy1GXSPnQA8LsGgRdn1V";
  b += "wubJ3ATjaC6VrhmMg8yi3Ma1CSpCKncQVYjcWCe4sUGR3VrE7q3UpjcL5iiDONIwwYLOFRFVMO7";
  b += "iaQ/XWjGsOe8hAytNkP3PwI31NblRYqkSF2PEiGQEmXAjN6rzYbXOB5+lT8WsvOsMBmyowoAWop";
  b += "mRe0OCe8OKLqnFnM5Kbf4YyZeNRAMQ21cEgm+vaCGeZThPmSNwjOU75tybXIx7U4twb9O7xb0Rn";
  b += "Xsxixt6HYzrgPHYzIm8oSbfejEo/7CWrmcxhjWRkQW5PSy4Pa7otlrM7KrU5ieGah7UIvDK8MLR";
  b += "mMxvjbkdx6xcIDLvvcitVS/ze0/I3FoN0YSS7AMetoXG6oWQ6T6m3/EhIi67bsPrNF7LeJ3BDLo";
  b += "5mv6azC9a1XxULEK7zEuVQ13GEsixJ+zA6yxed+J1F15ZkhqIa9kNzydI589vx2/axfMLYs0NCY";
  b += "jY7/fidR9eb8brfrwewEC9zYQ/MD+S+ffa8Js28fxmTMPB1/fw+4N4PYTXw3i9Ba9HMJllE5F28";
  b += "vxOhjiMpt6EcZrZrcN4HcfrUbzeileW8auF/OuFRw2JPQf4shevQ3i9Ha93aJsL4NbH/q1DqQ9w";
  b += "fcCEhydZY9nVIAlRhv7jMpnBdQlTrPD3bhYuH4KFCElPKQv2EkYnT9JUAqA3knJpTzNRiAS7Wcw";
  b += "mkZYbFzwxbSg3COQ6PdQVlPOeOnsvJGnordDcgnDsBIS6bqvxE6nlkjX2Y1KGLlQfmHI9NlW9SS";
  b += "NLe8Ld9h5NbLe1aLc1Y+hh+00Z1/syS2j66ut54F0yDaeZnE/p0zq7Tx12nwJjmAje7Z4F+rhzX";
  b += "c/37Y7eYXf0drujQ3ZHRXIS2aIWY7Cr3Ta/VguvjxT9b/d1t4kW+2Y2RoVGR20ajds0GrZp1GnT";
  b += "qMkY05fcaLZxKXcX3yHJ1ryztx+RifV41S02LQ/btDxk0/KgTcs2m5ZdNi2bldXG2+gNjhT2xu0";
  b += "7JO3Gd6MxB0TfsjJTpkXzm22a77Npvtem+R6b5u02zQs2zbt54o+31T82dMvd83ed9qPvXttExm";
  b += "jZyl02U3baTJm1mbLDZsp2mymNNlNyNlNaFW6MvdPushmXfcLz7nNm87vdVJGvUDa6bLNs2mbZN";
  b += "ptlW22W3WSzbIvNsgmbZfUKrxqU+QBZLlXeae9xOt3CzqdazHnIPx8f+YFQL00CQY+f9JOiZjUV";
  b += "RJf6TUEtdKuFXNWzqnq10GCcYiknUgGeSLW9cI6sPFrEiVQQdSjpGQZoTZHW1IsTqQBPpFrFiVS";
  b += "A5085cSIV4PlTtziRCvC0qaCcSAW0pkucSAXaGVWe1qSUE7IMrUkqp1YhrQlpTS+eSH16td/JUk";
  b += "FcCs/EAaSCGPAHYgicA677F6n7fsjCtpFvwmSUhABvHtyUZTdFWfa1J7/GEALwg7IHATjIpwzET";
  b += "QkgDMqzZAEHYVCeDljcvqt4fROuV4N5QuoAIhIX7ybXNz0IeeCpYVDg60s+uPwHEJu1lIqCAf+S";
  b += "X0rTMChJKD3nxxDGLxRhUNKs/vseC95H43H7dsC3FASLp8G36b1hBPdHIUTu8HnKAhq5gzYQm+f";
  b += "JYF/j/jWfde51v0rnoP51HzrniZA63g9LtxLlQeyVCBhIe8pKwMEQ4gMGOf8iYTsN1+KxsAlZCB";
  b += "RBIJAp0UuYo6GXQnZPSDrjl1lEFwAFFMmtuVKGY4yGe0vtoeHeUvtpsKPgArkNYzNgwJ8cDd/GA";
  b += "v6kaMCfJIZ76yHrdxoXIl52lAZ8ITemeMCfnmjZHTT0AmnOPkAjNCVYKhp9A40y3G+SxY9hbEsh";
  b += "29LINgglmbLZlp+lIW6WxLY0+VFeZVumKhqvBjrfsiz8BzAnSflRylLu5CjMoHt4fc6XQgZJYzD";
  b += "kEwWCr4DgqgBBJlf+zae+nlifSHSVCUGLbwWxN1sAGfUgKn0w8wEWDOgZ2KchVW+DsF7xCCPuDV";
  b += "H/7yXqaZTUECU1SXO4BJCtxiPPUd77/rjnhbhY3Eu+fDUBsWjIZyL65P2Pxij/AaRlgUeAAiBfH";
  b += "GJ9uTkXe1SDKE8rLYNvpmOfRaYhn3toB0TxZsgGg9yALp2BWLs5iLUbQGj0SLLIRHkRvvSLl3x4";
  b += "TBH+tBSvAK9e8iB5TlD+uD+/2qdJEAJIBRC3kuszSt3LpK6NXD/vzw/4CQr2KFjtf8ifCF70kIW";
  b += "NjHmEpbnZAoRQmz4DgacoM6hqeNNjnX/eL7Vj6gcanaaJ3PtdgoUCYMODMMGMOQQu9QiXZoRLB7";
  b += "k+GzD4XPMh6A0jcCe5fov8lEwIy9E8RVkHfUBXMM344bOhGshIpC0X5ebL/hmCmBzErKFRbYH2F";
  b += "HTd5L6QtrSHQGE/gRZ57GrS0QnS7wZI8NACeSJogVC2VRQIQtoEeRqJWNDAt+P+q3BtH/e/B9fU";
  b += "uP8GXNPj/jchmGqKqOxwX5zspmh51WPZLpLd8xhJFojWPcsBEcIlorFbcfAgQNjPfxqnaEh2CMe";
  b += "XpMQFhcYlMiXggSonWlZcYHIqwmZ3shc8qoDwEKu6GbDIFAJE4yY1l4M4JYj6HZ+J8jU/GUGQ6e";
  b += "LznpToK0EsUfxMwB74bAChwRAaKuojVtXDggvm9hRYVDx4a+5MTEfKkI2UIQ3MxMa6VNREex4nz";
  b += "7DwhfN0BISQZrNEZZyHVExRio6Ty6MkXFYcxQGxJIKkhizI3vJoBR01LW1PVE8awixp2v5V0PZE";
  b += "Kb5STdsTGpRfkdpeENsnup6JToo0s9nWfmkaSU3RfqD7fFv3+VEHBD9XdV896r6EovsSOQi5W6L";
  b += "Me85TWFJhHLnEFCaQHGIg5oAiICCEqKl5MnKHyHXJqms+qyTc93MYVRPiXrN3TCuvEMjlb0jKN5";
  b += "CHZ9jXV9SHP4tAIYARD3+SPQTohcpk2k2untpjRVahFzStq8pQ0QLhxbgabCWFIi+0kUKHVIYFW";
  b += "s104ccDot8oqbhMMN34HZ8h+3WfiwUsFtKsr8UjMPAEkJOGAoZOTDhQmJSKUhJiNLKZj4ivPuC/";
  b += "Jkl3xYeQZky0lQmMmO9QORapIXw2fsFDxUSEgQWI8dXLPOQyKZe/qZTC8re10nd5iYrLH4QQwRk";
  b += "EqinKEWnKh7nyqx/5WqK8tvzFyzySGFZ8XlTwX5JlWXQmTpBVWaKcn5+hqjcBgkeWcuVn/vxrlO";
  b += "yJ8h94dCFZvkZrYAGZIFyhS8Dy9+GhPwdxpPmYSYfJWrMRdQbrmI1kr3MGm13aJItxSU5HiuXUE";
  b += "yWKpGk2gEYwJFJMo9bnCwdS2RHXl32IkUpXr5A+ruBhgDq67Bzwd5CXZ9n0n8xyDxLJy8ISgC1S";
  b += "DxbonIJG0vPK3/sJQrI/pMKbYS2g6sI5a07SWbMvBhkYGRBREPGZfHUQdFWOEvc7dB7ZB5hj4gR";
  b += "CU/4u/UlRVnyPVihiRdTqt0C91jO1Cmmsvg/XJP3Jt+Fjftx/Da5Z1LjuGT7MKV4jTwdCdEPbcZ";
  b += "DMaO1XpOnNgEUbBsEiwgmsLpa3nZtlVXREo+sMOh9J6gMb07wAfY+PUT0z254qLZ8hk7yZRNTzJ";
  b += "JR6aCTBEFq3LPLpiBQtv/whUC4rop6PkOmgEjpPQlhMVH+YIGwswuhk959jw2OR3jVfZ++a31bv";
  b += "IpA42PvZc548Jw+qNqFoaLa6kEo3xdRyI1XJZG5VpsEjYWZFdD6M6UQkICbjjHc4nK6xfK0miNB";
  b += "eXyxfGZB/dFZrBGnXv+JPait+xmA+GqJc+/Rp2kLQY82Tgyj8zCM9Ki7Q5B3w+zhBU3PCcsGPe0";
  b += "hX2Tg1OR/1gGAnoBmDgKlLIY2EWSY15Y/DSPU8GTh/p8/PXvQWWBjRjAwjKpJS/DcPoJQo/94Pf";
  b += "vxgARIx5ObJG993rpQsf+WjX09A+EyISF1ORGQaHPgX4QPhIFFkXeUV5OMPfvADyCwAGzgpiNr5";
  b += "xP1x4swTZe8cDK4XzpS3zufidNm/UH72Q19PgBqOvVmayZYGAiUX8sNEuRNC+T5xhvxdsbP7AuT";
  b += "18+nGaEhaAksQGqWdtIB8Dg6SzzAfTMUBUYmJUkBKCTIXIOxqoS9IQY4GurJe9kQ5PDdPxgP63l";
  b += "3d8EU3eSVBA6hQDyYRXq78EnbULxcpAchL4bqHqPVy8ESceCImyv1cSNtUvvgY7RzsX5BpbKL84";
  b += "odJv2KYRLz0YewheVgmDnYBFGF8AdP8gMwg+KsIYxci773nxkWg0wD8GOBx5A9uLnuQiCRBN32h";
  b += "BqZyyfIV1tD9hYByj1KScykxWyAdf0AnNaMgZR3QjJO1GCeAiEgv+Ezw2FFK4/KPFPJxgk4Byi2";
  b += "EJuTvfExfEnaz59LUuAmqa6CvXpRg2+Ye6yYFL1nIht00RSPsUXqEVC2gWhJ074A+BbLcJugbPP";
  b += "5cGmuZLVPTsOanjekRnYIeJXbRrCjFckuUhr0Hf2f3fMRmb7OFJAUCFgsBpQ4nEaE6PIwSHm5LC";
  b += "OrAoAHuJ3ugTQE9IvAg12mi5NFpqz9dJoULMYhBeOY8vODCuQfeLQTAjixyPQkLboYEaBYyn8IB";
  b += "npPgCIgDukB/3zn28pJXfpl9QSZ0FwWek5CWkyD4QhycA6jQV5OpDpxWRB7fZIZI4B7MizJsepS";
  b += "H3rMLtJlDlL4B9hpYI2hz8jQfShrmyT6gCnagKAiKjAcdOYodJvUFUFYt8xFd6+LXbM5ZLoIO8g";
  b += "UdIPI8JJbD3kP4eWiK7H0KtGZKdj8huu8Z3U/R7qdk95NRinY/QWFKu59C4ILSgH4jmj3oLEWzT";
  b += "/OfEE5zNvmGcBK2vsxpwqgTUNbSvYAAZs3kN+eZ3vMJlNIAG/IEAqXsOZDcwJBcnhoH0msDGhGq";
  b += "hChMB5KlaTcZkxKU6LNUgVMyl2hrs5A/Yk+cAAgHkA4sShPVB8j2QNhZ4q6E1CdxYn8EqE+eOXj";
  b += "uh1YX+NetCwK2akBd4FXXBb6a+kFSxdtHU+V8lROJZc75NUhoeOlS5RwMF09MwwiWKYcwHCQAQ+";
  b += "RC+gvfk+5c3Bn73QAZqCWdvRBBkfyAsJOPg0G+LgcV+VKq/CpAJ0N1B/1MXkuIDaD6JrT9m3ycg";
  b += "lVp5O+BZ0Gby6/wL8gTnyUSUUrQlQBjEwVPnJ7fWaA4ylAIwOD7Ld4xaFzk7Yc9QVpJRTRXfg3e";
  b += "+YMV8PrnP8xl//MfRnTTF9E7y18hn6gkQuGrUHgJCy+p37wChStYuKLe9k0ovIyFl9XbvgWFV7H";
  b += "wqnrbt6FwFQtX1du+A4XXsPCaett3ofA6Fl5Xb/seFK5h4Zp62xvqN9+HwhtYeFMtfOgjX2c1UL";
  b += "ikFj4OBaiBwmW18AwULmPhabXweSg8jYVn1cLzUHgWC8+phS9C4TksvKgWvgKFF7HwVSi8hIWX1";
  b += "G9egcIVLFxRb/smFF7Gwsvqbd+CwqtYeFW97dtQuIqFq+pt34HCa1h4Tb3tu1B4HQuvq7d9DwrX";
  b += "sHBNve37UHgDC2+ot30I8PsmFt5Ub/s4fHPpo8gs9bZnoHAZv7ms3vZ5KDyNhafV256HwrNYeFa";
  b += "97YtQeA4Lz6m3vULFrNwAc80YFvaxT9mm/uCrdCApD5B5AAjzGbLaYdoABgQcG2G5Xx4gn8pXaW";
  b += "MvXfJwXCZrnj0wru+HJWUCtDgZrUC9k8sTUQoOnqmwSzUAL4k8qlVgMjRfClGZgI4B1U0VCmhcV";
  b += "CMe0SI59uw0e3Yan00GRK6H6CjCNBEoUKaOIF2nv6+AQ3CJrsscNAl1MmQNMoQKGbIOMtBMQtEZ";
  b += "mCeQhyVwJCLT+rAMWpk2cTUZNOsITYrz5edYcYI+uW7Czyyi9uB+2FGZp20p98xTtZsop9kKLYR";
  b += "JQnpPge167iSLK5rLKCwvnGOTHPIfaRX2IMRxiqyt2GQoUfwkzRKYUGZ5yuSGcJF8BZObhJzckG";
  b += "aYc7sEn9sljLkdjFawqmCdidh8hnCdDVeUCRSWYlYWykqWHIgs9Er0JII1iSAqCvhEbGeB7lyFd";
  b += "OXEUi6R2Qcw1iv+GOwmwhEmgCyGu2DaAl8zysDMxBMTYjjuYmtOulCNkkCXFKyGqtIlac95LbqE";
  b += "bGaQYYTH+QpcQqBLMsdgl6CLAy6wYpylE3WfIcyTbeXzQzbry+TErDTh0xQfhJrlhv2kUVBfTvD";
  b += "JYplxPtIWfx5b/or5JZ1VUh3xMjZsnooHTVGtrBJ89ixsC5+8M0aTeSCw1+gLCpwnlBD0nM96gE";
  b += "P0yUzsPLPPTu0ToCwnrKcl8REJ/ggxdZbUuFLtXtZBT51ZB7CFEMgpWpTcX/DfOev8d7ysqbKoS";
  b += "YhFDVCWKhS6IcagHQC06aFoVWgH7xjaS1jPcPKSeSlN2RIFuT/t9DsWtl6MkgP+utI46LF1pQko";
  b += "DZQmoTRQmoJSX2kTlPpKm6EUlbZAKSrdBKWe0lYo9ZS2QamjNA2ljlIZSi2lGSi1lLZDqVjaAaV";
  b += "iaRZK+dJOKOVLu6CUKe2GUqa0B0r/P3tvA2THcZ2HTvf83jv3Zxa72F38EJg7XJILEiCWIoiFAJ";
  b += "DELIkFQIIiJDEKE9P1VBWlzFzw5RE0SuVXxQgrCaYhF/0M23w2Y9M2YssGEwsJnbBSjE3bUEI7T";
  b += "EwniE1LqPcoG7aYCl6Z5bBipUw7tPjOd05PT9+7dxcgLMU/kSDuzO3p/5/T55w+5+ugdx/T1N79";
  b += "+IX7dHBbXO8wxs0T5XnQ2yRKt81yCJGzmNLryVlEwQJO73o2Y+jN8Hj3bmB7ht6N+DXRu4kPRXq";
  b += "zIhdtkXOTm1l86N0ihylb8SvvbcOvmd6t+DXT245fs705Pkfp3YZfW3sfwK+tvdtpzrwJrd6sni";
  b += "seKPkEwCt2lFhoxYfKzZ88VtxBZPYYYs8VD+Z38EU8x54o7pBN4hLS5h8AqsftFHpEQt/g0DmE3";
  b += "kahH5ZQ1h7mtyJ0O4Ua/eHrHLoVodso9KMSeoFDb0boLRT6kIS+xqGzCN1CoX9DQl/l0BsRehOF";
  b += "fkxCX+HQGYTeQKF/U0L3HaXAAoHXU+DDErgXMXME9ijwb1m9pp9vQuBmCvzbQgBor4S56A4K+ba";
  b += "degdfzaQR8qFjT/DVgHMU9LehnClPfOe5BfVkEZ3N0XucBHwPkYJj5/LN+JyLCW8VY9OxJ849mW";
  b += "PNfBvJ1/1iE/FN554s4rOUbvPxfBNxNLQmHqWqvUVN643IIaccKPnfOnYOBspsEny22ITEgSRGu";
  b += "96mxNePSFxI4ocHErslI/HXKPENIxLPSOK/uWrJMOS5aUTiGyXxx1Yt+V1KvGVE4llJ/DdWLXmJ";
  b += "yPUtIxLfLIkfWrXkk5R424jEWyXxR1ct+RQl3j4i8a2S+COrlvw0Jb5tROI5SfzhVUs+TYlvH5H";
  b += "4A5L4yEDizUMlP0uJ8RFWxXcc4xzO5g9Sbn3J5IFjT/Rx7SWuCPyuY26xz0BBiNw22zBaHjuRaJ";
  b += "6WAJVxnH7vwu8P0m8q+JO0MLAi+MNufNhDH3L+cPO5PJcPe/HhTvrQ4w+3nKMVwB/uwoe76UPBH";
  b += "7aeywv5sA8fSvpwPX/Ydo6mPX9YwId76MMMf7j1XD4jH+7Fh/304Qb+sP0czXX+sIgPB+jDjfxh";
  b += "7lx+o3w4iA+H6MNN/OG2czTB+cN9+HA/fZjlDx84l8/KhxAfDtOHLfzh9nM0q9XxYse5CscpcnG";
  b += "cYhfHKXFxnBoujlPTxXEasI1vrWhPv7KhfOb+GDtLJInm1ifPLXiMO2BM6DHy2WePFMEGsZvPzu";
  b += "Y35/gBk/nu2fwW/gFr+c7ZfCv/gKF8+2y+jX/ARr51Nr+Vf8C6IT2bb+cfsIxvns3n+AeM4htn8";
  b += "9v4B1iH5Gz+Af4BQSI+m9/OP8A70ATfwT94T1B9qu/hc9Jr+f3npMfyQ+ekt/ID56Sn8v3npJfy";
  b += "e85JD+XlOemd/O5z0jP5neekV/I99DKGlw+eEyitfP4cj9KpIoKPcOR46UWOV07kOLFGDopa5MC";
  b += "nYaxp9HkUXQeqSEbZ9dmNZBa4Tj6RzBLXuziSWeRiqEUyyxwHWtcx9/1C34lniaErO4WubAJdyU";
  b += "zYLgnbjLCuCdstYTnCOiZsr4T1ENY2YXdJWIGwlgnbJ2HXIyw1YQsSNoOwpgm7V8JuQFjDhC1K2";
  b += "I0IS0zYQQm7iWmhCbsPYRWxDGmh4lBiyzE+Fj2E2LMU+8/VYYw2wKtp2PfmGw4bpy1ZWeOSlXGX";
  b += "rEy4ZGWtS1YmXbJy9bhvK/jsbHR/XDfgjBOdLXxxx7nu7DEsHHbHYS6OtpPIOOBsFPcWCj3PoV3";
  b += "HwQahL3Nox3GpQehLHNp2nGgQ+iKHthyoOYS+wKGpAzeH0C9waNOBnEPo8xzacByBEPp5Dk0c6D";
  b += "mEnuHQ2HHtEWaS5ljlx/OcSv9s2hFt7hDRZqeINvMi2uwS0eaDItrsFtFmj4g2e0W0uVNEm7tEt";
  b += "LlbRJt9ItqUItosiGhzj4g294pos19Em0URbQ6IaHNQRJtDItrcNyDa3P9XU7Q57Io2O1zRZkcl";
  b += "2uz4X1m0Ofz+RZvD3xJtviXa/JUUbXZ8A0SbOwzzU4k284bxWSbafNBwP8tEmz2GBVom2txp+KB";
  b += "los3dhhlaJtqUhiNaJtrcY9iiZaLNfsMbLRNtDhgGqRZtfJJ0hEEqXGHmfivMfIDIgggwIgbNGh";
  b += "HnSSPHmL0/cR1+G+6X5oo+vtckx7iiS7ay6NJ1RZeOK7q0XdGl5YouqSu6NF3RpeGKLokrulhpJ";
  b += "RFp5QNWdIEIaNSnlehyv8gV35PfV8kwBysZZrGSYe6tZJiFSobZV8kwd1UyzN5KhtldyTC7Khlm";
  b += "p8gwEF3WvH9xJXJFlAHZ5OvDAASRI5QsZ1ajGr35GyaM3DFCGJkfIYx8cIQwsmeEMHLnCGHk7hH";
  b += "CSDlCGLlnhDCyf4QwcmCEMHLor5kwYlamoACwFDIKdvrrfy7Y6W+JH9cmfnzlx5S+80QHJrqXDG";
  b += "yAX16GHXCus59Qgwa7o/+xS5BfKHHbYN8L9nxwHSvf8sXv8jLO9a8H00ZcNyAKOHb2G+ISp7d5C";
  b += "bGUYmG9j52ptnmNHoy4cRoVsx2ABnurskdyvV3ty+NtHiybnugpzS4je4tI6qGyHwvaCoaWQRnD";
  b += "E+LfeP1ym7GIjmBRnn1yt4cDTLVH4QA8MnaZKvvFoHxPHYN7iXkNTKl+9lNaCqHGMhgC1x21VKg";
  b += "l6kIJVcuHkRul6CXU1n39oklNbZYt5PD3qZ5N2CyY/mpu0Vmxb2H21Nlemu/jbertnzzvfZbfLn";
  b += "zmvPcRipTAX/54ufR1GjwgH54t3/v0k8eeyL6PDwuRc6+FEaReVTM4sZwFs7/vbPZzShuIh9B0S";
  b += "5n1izY9dlTjo3K1RW+d9xNO1utIjeMZmFO0+myFXkxkxyifGNU2+cR5zBXHsHI8qZbKnlNuPMms";
  b += "OwNvUqpkJL/DGba73qMSO4diNvUu9QNs5Ub5TcCHsZ83srcUy6rFBLpcyUeIsvTGh6DZr7oR4Co";
  b += "ZbvOy3V5qopZpP/uq70TxJXkDzYgQOd3t0fDDs8BrhbD6U9kv+5gK5s1P4Z+T9QBl0BKHnnJWXC";
  b += "HyffO0l0f5hBjycdG9BlwkEG+sX2438RpchsRTqcjiiJf0uR3l1ireTpsfGrDvKIzm867T8528S";
  b += "4VkSz7ywWuP6A/K69bldfII5XXYeoFicT6oXyePt6sME76DRRCXa/o0abEOOlglcTleLRJJizJi";
  b += "aXsHbY/rtnek7VUZMZcxONe2eVthbwmHh7Yz2/xk3p+lmTB3FDOBzdpnacZlnwnY3wJKBPj9xtm";
  b += "PsPFyyJaw1Blr0aYW4AT6HCu7yH3Q4pED8iN9R6fN9aWxXH5M30NM421V57Ty2GRkGqjKHBZBI9";
  b += "bENCVmX/Nd/XJGEnMvmGgtNGYavdAyvaCgQMBid1c4xkjlCTo8RVcnXCF581CVROYeljLihhKjW";
  b += "Y8ntZ7j8TE/qtyUMUlQm2Y9JomMSWLMFJoyJppJ5R61C2+gpDzku5mSMXFNB+ijWZFU+6MdrTx2";
  b += "2ddiZKSpFkxSkeMuppvVJ2oc0b/d1Cqsl0AMEtx4dYSKIqemwBb70Oot+si8Bty7OMMhDa8262A";
  b += "HIydKdtGrA2YQcMkJ2IqAy3WA7bGBNoA6v80DJXuXFtLhl3/oo3OgYdqu3vJ7c2bLagrdSmY87v";
  b += "JeOEQkhazHzqBfkT6qij5esFvhRtkbL1gqvlHIMQIiCmDq4/Psy14GYY8oIykuYqVRVLsaRnlE5";
  b += "c/7oBcRTYPsixq90OFMyh3odtC3C+iEgc2cFvBGu4eiwykgZ7eAGTY56WS/oiVSS4gpRyISlP0L";
  b += "5YQHvHHwynbXVI7+kGyzP/Wd+Jw257Ytsp2eYhQCZ4KZvcjk1oHneiROxoGQaax4KqEnG16vw2Z";
  b += "1lGZrtXYDuF3CGYIXidnxQ7ZbyXtdtqXjZhpiHORdMY1rydKe1QGDo6D72dEtACEC8ag8rTimUJ";
  b += "Rp2vVGtT5bXiu0rGuicbuzeafYDrihCL52qhot1pBWE405KC0FVQZStJRymXoaFTGLUVO7/YznG";
  b += "VsiZl/yB3IK4bTJZYfS57x/BlIz3tzQXl23NzT5zuqJ/YIRlVHHKLHfwcVIdfOlTqgR/GPpi22+";
  b += "W4hUgYc9tJZW3Ggu3u5d4dDeFQ7tXaFd9WbvCof2rlCmQFVIXO2ziV1QzTzB+qFITekMZt8Su8C";
  b += "YCAv9hfI7+zMNcyUmtw5J8S0nDDV1+ba8bkUUoi7bDHXJhZpsoLQbYPkUy+8W/W7V1KXlUBcObg";
  b += "nnCLLSAFlpDZCVM+poEcxg4Vz2HGbQrHLq8EerzHjeB1CFFvU0DLboxzBcnLxiCi390/LbEqWA+";
  b += "cPIqaHQH5mEUU3/QlQ0WlZRIXeNfumVN2VfYm9N1DrCUvueoKZMj9ZsbANgKRT0GAXNPshBc/3s";
  b += "l5imzCHaAVmrOxCN9m8+xEhNxgFwoMFZcp6picyf8OHnFXiHR/ezBZ3a7v29PR5mM6SGbd5RzDh";
  b += "V/qrHbpfl51R/i+fNc9i+owUKO6kqUAUUTH/e5f1IOkPBLV1+3zPvz9Gvt/hXr6QSaDsLTW663E";
  b += "yVwWrgH1PUg/LW7ef3yBtN+lLedCW7gMrQuD1KwttTAXvFUw9RD2ihbbTnGeKm86YxCzSLmxLu6";
  b += "IGcMJ3dW60ULStF18wSFVDHo5YMR0wNI0Typ6xbnUdm3XIXRvW65SZE9brVdt1Gsm65lKhet7YQ";
  b += "WbfR8nXbAY2C3WDFpUrf8NaXGFIzsFp5JZj9P4CGGmOBRXFK8ZyBdfZJeQWeypK8YnN5V3ylsA+";
  b += "8Q5Ohhx8JU/IecTHoa7xehxIeY8d5rKRNsnLWUcnrsJK68tvKwkH2H3UtCQemCyAGQ+LFwokquk";
  b += "+pG5K6TanbaLiswzYsn020NpA8iN/eNcxHBJRiV7/YjCX2SxUzURRXZCca+ebtNJSbaSiN6C38x";
  b += "XezCSgEmmLzqJRe3gDlj2j3MZS/gWpsNtFIFjKUv5EXZnCF8lOuaELvHknQrse2QQuBE0ScoG24";
  b += "XTsXuth0mIZ3hYZ3uS+pbsIdYn10uSOFIRLndZ6dJJsR55r12pSGeVU7R7uYww3M3m7exqTuCh8";
  b += "BYawqhWo4RTFS1mLwBF1nK7UpX2cqtUmib0Kl1tWVoow28dyop+q6oanKRHsWRPu06rsk+5Sa93";
  b += "O8PM7XGpyl+UiJTirMYsbD4WPcJzF9Z/V3Yepibl6HFM8omvX3nO1NCH+PD9CNg1lClpjORSRro";
  b += "yfeyu+pY+U0c249zTw/pDgtO8nQPpLDS64vC8WMPjPF2sSLKZ6fo1Nok97t7aAAY8oNwWC39wlK";
  b += "+l88HjtR2vDZa1DzFwHI2WHIDjv1QWH07gUgz04GWkp26r30IKF6Fz2uw0En80RzXEEUfES4wkf";
  b += "Ynj355B7v79LEDWp2k+N5IKyAQ+D9b463LcbUvIy9gMRX5vt1uaty5A9FlFW0pYgoK06dRBxZlI";
  b += "XIGbAyA6Js1XRNYihW1tQiq8G2ogr7xS9yVtjASr7l3n1azesZGbBTCmcW1VheceCPy+x4HNSKp";
  b += "wGGcNp2a6Fsw3NsVRlVcNYYmsdYeXk9WNR1W+nRxDFJjDGYpkcHRyMxxoCSYgxI8MYYJPS4DptP";
  b += "zO4CKNXuFSStm70ixjpr1XtFjHXYqtfh4ESBGkC2DJ5XrXrLcOsYmOjQGZiFuWGbt5dmMY1czsx";
  b += "XPXjyu+Lu8pzzSSlQmLzyjC9ewk8HgxBywbwPlJBZ/WwgCHjPBAI9czqgnia58jMB4N22eZ8Oeh";
  b += "vwXIIhBVAj/F6O73/qw6Jim/cnPmwptnnv+L0COb/tEw0UznGLMJlwsN3mPRcUt5bT7PJSfomhd";
  b += "34yqHpNwHiCuoLbvR8P9qjXNVeWKjrvX9RG4+tnL2nDvLJIFua+FCeIG8K/MpF6yySpdi/iC1dm";
  b += "WYMrsayBywnK/jTAsmJnerTKJpJNpCYxvL88BvWlJMMOlP03pT/FyRhBawsWQklfsE2n2JQb+Pg";
  b += "0VgV9fBKKvS3+472FwSw4Ay7yGdn0oSQUgtsj2RO8Al7b9CocH5exVPEKUcUgNPNUWIYIRBTAiN";
  b += "ykx1j/96xCCKZ+yQS7mZdnKWpqcua1G+D5JMpELUtpULE/X1jQH24raA25NTv1J+h1P6hYBGeLh";
  b += "6H+36kfwknETqJwEXGL/kGoPEEcI6xW8OkdEEdWZO4Q/eMcPRbm/VmpL/e409dQ3j1KgbMip8yx";
  b += "lIGMLBVEnzPlg8tZRfkCVIXojVC+REQOh/glC5p4BKw7Ig/leU8UFIHQOj+V3gTTvMDdFL7PUXn";
  b += "H6680Bgvo9GogUpoECTohMTWiqu7oU3fAbRp6THZ6SqBmiuWNSGJb3nKw45xio3Ebg7iIbsbbRB";
  b += "89LfITOlvYXGgew5HzeVpSR86WyZmEJh7nE7H6kX6wc42pMrK1BJWjCU1Fms4ATU0gTDg0tWqyd";
  b += "dVpVWrGiQGaatswXLAlqwlwcfRHmAlLzHAKi5T0ZfQruto1SSvheYtP9OcgZnbkENlnBons04bI";
  b += "blffG/Q+ACL4uaB3O56ngt4O5H0y6N1hiO1OQ2znDbHdhUKIqB5CvK/5vQ/iScR1tyHae/B8Luj";
  b += "tZTigoHcnY3wGvbvgK+UPUFOhoO+sREHjmoKe8gco6NO+oaDXG748o7ZntCAqln6Mfo/VlHTMoa";
  b += "QcPDZESceWUdKUckhrSvpjtfCfOvQ0xVikzvxL89SI/py4d7PUZy3lthbKCXOi1Znx5EQgzR6nL";
  b += "DtO/Ti4M1S/zrL6ifIU9UtRv3+o3LMgW78Y9YtZObHGMouxqSEnrzahau+plLP2zC3O/o/qzC2o";
  b += "lDtNq5xoDiknmssqKloURzkhKpXmgHKCefOoUqg0AC0Fpqpoi3IiMMqJAMqJqJI2dxlSFUBNwYj";
  b += "cyBgQqu3sD5TkOV5F5p2JPvw8fTDKCWLqjHKCNWKBUU4ErJwA/1orJwIoJ9oiyxrlBMoXMdYqJw";
  b += "Lh3vG7hHIiqJQTC1TCDOiN5BZCOdE2yonQKidC0JNyvtLILchbpZyohIFHaVMQ5QSznW056Asc5";
  b += "UQIkhrIwY9wuqKcEF1hrZywarxKAgtEOWHi1coJG3F8mOEM86arVGwOKRWbrlIxGDx8CYcOX2wh";
  b += "gXP4YrggI5Bix2vVAmzXKie69mBJJD4hpHYlYAbEtXIirpQTU/R6strw4or3IOa74j1m6BVcz0b";
  b += "8uCHHEurdRGFGOTGLEh6j3VRW0npZOZNU8mR1pmzVfFiH2X+AciKyygnWJESinIicBYbw3hpJPU";
  b += "6px/nIjtfhOJQTJtp4Pj6gnKiWbK9LKXb1i1tQxxslG1mFVNyNvOjYcLm40Sw4NmrOfl5LjJhJt";
  b += "IjPsoxszC6miDesEqgFPTPZMmIazBc7vF2a2UiX38hyUfZlPnxka+q7ZV8L6oPcbn73Ths55dXH";
  b += "c2GACrGSpVmrSoQsQcmyJr8FSpZbHCVLs1ayNKFk6Y5K6eVrwB83ayXLGvd0YY0oFKlia+wktUo";
  b += "WDAU1mxOM13N0jTS7SjAuE7M+eWqJfgdnoOYcttLZ1UqWlnPqhB42KkDwXVCyYPIPKgJbvBaxCl";
  b += "t5F4uzZRefLcUqWawWcNJWan0+aSq1XqKvR6UmB5Qs63mO10tucmjJ8eYzi82nVrLw1iNKlhhKF";
  b += "uHZb0AiEjGm8CR+vY3nk1iGkLVnZI3NIgUL5sTg3wR6GPMHKFliUbLErpJlo/hcWyVL2GOSiSoV";
  b += "oeyIQ/thznpPWfCWY2w5HCPFEyVLIjJxIp2KXPMASpaYlSyBUbLErGSJayVLDMzvw/RoQ8kS59O";
  b += "QI+J8BnJEnN8AOSLOb4KSJc5noWRhVcAcV1CULLEoWWKsOKNkiWslC8djJUtiOIMY2+afKtEMxJ";
  b += "WygztOlB1Vn15xAI7LKD0O6sfDkfJ5UNW8IrQVyLH1ZcLZCxePFZDXncbKjgR9sZEebSg7EvTFB";
  b += "D1moOxI0BctetzEvDH6IjCdjVJr3jzvmL2HbQM6LmMe43fNmA8MGJTZzvl/x2XM6zrWRXaqBbLW";
  b += "KjtuZmauVnbIb3CGzJTfbJQda2VNUPCzqpfg+YwSefa0gpSKxdBjhpJ6v4sn9X6E55M0CPT5OFG";
  b += "UFN2+Bo/HeuPMfPZaebrNe04Vk9BbAJJ7DSD60/InVdUDxIZu935c7VGZ4UOHj9yF74wdemqO3B";
  b += "fskTuLiqW2R+6Be+Ru9xM+Tv9/dMXFtYops6mAsk9JnDT7h1o+TsthdQA7jWnzMZ/KfkkNpmXSH";
  b += "tQEmnkfJu1hPs3bQfbTSpSmRMunR0U1R6VBTcuZ4Zi2R6WBPSqdqnYuVHm64qcmanZqemcdD5sW";
  b += "aj9F8ULEs1YmFAHCOUfnTeuajl4D9+h1YcTR64LLJcV2hsnZHvXt4GwLzGyLr2m2NfcTXZ9axP0";
  b += "yneyj6PAUJ+LhSJEnkyOK1CGgDZeANiieHJA3sD4OAunOENCUKedaZ/JSdxF9o20FhDWF+vPj9G";
  b += "juJPKXQhPwMMQe0MQUZgaH6RGBqqYgKPfSg2jOXnqsATlNwbfuoEcL5NRUl6hPKs1g9v0uIoz4T";
  b += "YzfHdpbyJ9ioebkPG0vKetx0prQIgchtA0jIqY0y7Kf02yCxGj7cd7CcaltaIKSub1b6RFj12qg";
  b += "/jk9uqCEfAozTY82KGED9W/RYw1IYAP1x0GNGEmlNQls5GNmYjUwscbqidXAxBqrJ9Zgl9P8GhM";
  b += "SyCM0Vs8vG2+fnA3JNBurSGC2zTssJPB6lrfL16xuQgKsYuJ6ziilwAtiKVReCEguH63xfTUwyo";
  b += "Ou0fg2jMY3NEqIwCghYqOEaBuNb9NofDtG45sajW9iNL77jMY3MhrfFr6/EBRrQDkBY/wGYzl/o";
  b += "a5S+TqHfD6oYci/yiH/otYKI/Pngnn9mi864Z8P9ni/x3jke9Q/xzPe7f08nu3d3gt40rz9AuOW";
  b += "71H/BM90t/eP8Ux2e8/jSZ19xpfLQJ4zIObQz5QvU8ljrr7kVSr1RcRYs9u7hCdNnlcN3Pkrvlw";
  b += "vch4p1W4PnSp6FYaeeTXoZx901SuN0uO7VT7NDROWzS//1O9vV+yiWP6JWHPx9QPyGlsdjO3ZFi";
  b += "tm3jX2yq8E0gv/Gs9wt/fFQHrjfCCtfAnw8mjeiyhA7/Z+t64k1EC/O1zJ5jehkhdNJb9kKvnbp";
  b += "pKvm0q+VlWy6kGW5JZUJWFljs01LA6NzXXT3O1DQWM04Zrlb1qj6ya7KkYk5pG4fKS2ug5Epjls";
  b += "VR/W6rol4vNveQM8fWCsrluoPtj6yuo6MKbWpQ9c//rXgaAqnI2vuSwjEDcr23FUuIEKi1xq7K8";
  b += "5VW9s0ALZqNO6DtvQrQ2wp1Y0wB7Lp1YxwGbb5klj1i6asQED7A5fxFdpx7J+cRM9dtC+XxmzgZ";
  b += "9jE2wk7KVS5zUznkhjHfAIER/tr3Eqzt/WDOnZ1gwwOpesno0oLrNQlzyjsJdzlaDgo5CkaGd/i";
  b += "PoWySFmX7aK8U3BFjhfIVYy+wozQFuLxDBAs3oO54dVTEQi2k+52JgNRzifE0CoRJDcfOYc8qBK";
  b += "CUNeUQfNyVVvmCg7avYlEvalUdmhmYDaSk0wzDhhUvE4V8gsMTzOJdcCEswg3yTj6h6/MCj+fV4";
  b += "Jg+nhvCUGDj0JNJXtMrw5IOrBJ4OVL79Nzxv8fWYEAlclQnOmbeaMGMRnVrtqrTTi7Mf0gKFnAn";
  b += "VLlj0iJyWDxpyyxVVAsoAOM6syhN4/LCct05aH29XEHtUaKLQx48luKoXKhZCOxUljq5cVWel9i";
  b += "IY/K5dOcHVKIj8J7JjNOs7K7z7xIH9oD39YOvGdRSSos5Ec6dAK763FT18unzRlS6nrMdGoRtRc";
  b += "aJ+I2EQkj9CEXssEJuUvfK9giGswHFvpSGyl1xvejONlI+JlEq9SMmbZ7wScnxapLxKAOKlXlNG";
  b += "+6PRG+WliPetOyoq11L5jRGMX2175GcV1XdJHQTEOUchnTchSQEFL7wKXsTxZhS0RZcbj1IlDwK";
  b += "SMqK+oZwBjOdSNfJ5jare2qh14/kzOVBo1z0+tE6lTbGMawmbbSdFWAg7QgMfCNC3qNuSwsPxDD";
  b += "xNlgztRvHV71GMU+Ap/2mj4LHaKMNPoXrxVs2sxb4PyQylsCH8bhJ+KWUSObaS5F7S/LR3vp1KT";
  b += "iG8mwtfWHo7H67QtzW2XzT7PYqmXGKNKXTsDk7pFdcWEKqNekkphj+3xiDDBxp2TmNhtsS1/xaq";
  b += "I2+BlSJwXD4y26bdQzMRFb2ldMMZZRzZEeZ0IVAMc45xW1cpmRQq2gx9WfNvNp2SBPlwvUPYDed";
  b += "PrF4mV78It+hERA5E8zP6NtmnEEeb/o+hrb/dwwhmWf0A/1t/miar+P5MQQK/76fX3KPx6REIpX";
  b += "6UfNyPSIv34ikQ6QK9yBgCsByNPANGu0v0fzhMkeQBj+EjvFqlPL3NNQhMhZZmc37MpzInSC41/";
  b += "C4j8f9CsJ8aZt+zSaW8jOnu3p+ixEUMSMdqfWVOJ1TGzjiMRHXNiFiDaT0HZ/jbWrcyRTLwTeI1";
  b += "UNlyJ2HBlmJFJLUtk1oYrExuuzJ4gJI6bkiWIYfa/V7SwbWhh3sDw3yt2bRTlXp4IHiaCE8+a51";
  b += "V0whMwUpl92Y9o2Oq1io3cIljuUZuKjRRhI1GARUaZ96wvErcyYo8RIZ8mQJlmt/Gpi8cer41Vt";
  b += "9trcee7/6eyKH4G9WKLRoAHCLWxDkgb2QGprKxqUKPejeLQ1HYdmm4Uh6aNjukdq3bzhhHoIu7k";
  b += "WqCLMAiNehDYKoHLQFf27pUNr+E6V90rzlVtl4TVpp4ZTwFUI7PnKBkPYLUlJpXUN7DWMIvXDs5";
  b += "iMaCsDSorQ2cz8omzCyZsGC4jn9Qj72PknXjD5pYhPtJYWkvL9dVJSWINLYv1MqDQHa2vbSelLP";
  b += "QGm1+KtaW21pbXvw9ry+tHWFuuH7C2ZJk8cWXyZEgmd9ZRo142MoSNykjeWmje61po2vFoO4PYN";
  b += "pp6u4zZyNO1s8/Meqk09W27mT1sNzOhnrOet9ObYtrpfbvoccPbFTRi6/tEwxayp07m4R360YXp";
  b += "p06CIOK4cAGP46CVMAVaxIN25gOYJ1O4r5imC5xEwju8v5uDwC7MPZWD6i7kT53kTO7wvj2/2Xy";
  b += "4vvog++OBfBGh+zio2HeXt42qcjvOm+dO7WXt2W1y+HynbGBuG8pb+lW9JeoWcT28XXkmNtrILh";
  b += "1hft+8PkyP++c1NuPD0B2F+S27va30IKbp2G7vIXqDyRBVp+TqLCRP5Q+chNUPe0yO7/Zm5O0R2";
  b += "qjAb0G/HqK7Ju7ybqCiL3nijeVsUFAiPUyBuaycOZ7wfIvBRWxlYhKJeWQVzbheAMY5JFGIYRAv";
  b += "b3CybBgEsgEDbmMVxN5aO/JG9mUmeGwMxC5+05S76a7B7dL414TQarkONonVroaVg43kHdRsCEa";
  b += "YN1IzmLzDDo80b6I2wu/VEVJsw9XcsVPJTCyeZtu8T5gJlfZwSQbNhzY9yru8sK7NAZwuBPmiWH";
  b += "Xuh5ovgMoUjnEJKHogvqRSb0o3Xk8n6HLtdArA8pT2S6PPFmZ3eszVnFbWhnTcLHb20BuvFzs76";
  b += "Y3Xi93WsPIEGBcFXCAHhnbN23jGyyp0zw1j2FmRzDnjnvrMsEHCaSXSF06jt3mvgzmWQ6BZM468";
  b += "1GEm+zsKLsw3lNrahuY3bPe8PeoNzuITNDXo8XER4QDdlGSXNX8BU0hPYiTKXY/BsiiUORFvoeK";
  b += "ty2GjmitynObMJIgWaFq8ncra491BUeb72CNNNVAGwyZ9QkRCvu0kZoIeO5OV5UiarPv4YItP/c";
  b += "LRguajeSqVILnSVCJ1VdJQs/uPouZpfZiH8opA+to9WqMmsiS6cbBV3EdFlP2UT1LOl/2cfWegw";
  b += "Dfnf68O1NsninOEQgFFMOLs7ozKzRkX/aUtJft+3qlwAFBE1nSqyiirmrdxoHWR27pMWld5GV+q";
  b += "Zm6arzEzN8XMXVPP3BQzd009c1OrM14jU5YLWVNP2VTmamqUxWtkrg5qbTATh/U1H6fwuX5+kxP";
  b += "Mvs35pGiAOqCZ6AF4Xoup33AW0/kkeqBTexhPuuM7iSzZw3iyPvuTnDq1u/I1ZoasxAt2QB8Gjq";
  b += "RrOBI2d+waHRnYCjY+49Ax6bQxMIXc7WMoe0reKn9mZEZ17dYcimQmWWUoyA79mFvXMYomHMqYb";
  b += "XhXRo/jdevRqypi2iTO7mwvUcB7z7gLs6kXd1yz8g/mIHie0+NtJ2gOU7WJU6AqCOYVR+b9XfL2";
  b += "ceppI6awPjKpPaWtdQJ1ioakCk0orC52DVtIyOmdMY9IxJvcxsPbNGi+G5V+wLDU/pjpy5rjH1v";
  b += "7hqXjbm9JNZGB9aZuDXlTc25Nx1eac7Q9UeVq+4FruMwKw7QT6tYlVTtUt4Qt81kPOurAJP9Gno";
  b += "vIOUt97iLnMHxg8Jbf4isvz5hrIUfgkjzr8yW7on83c5Ex9SvvFI8Vx2zrKRcCMJiTGCyPIXNgh";
  b += "LGlvT2DOcshX9K1Hf4ptsx/e+C+ef+intdPKz6DUa/rPd7PKAm/THnjcvvqcCCQE4EidM8EcEzw";
  b += "PJfzrF+dYyGIC3rFORA6wyEvB9V09ssX5R5l54joZQ656KSaxSpgi1cb9AxHOj3YhS/CFlf8CTR";
  b += "Od75gfAve0TzKeD1FHfe05jvsaW+ObH7/kfPb7B5L+ewjzYdS1+3xfgN57cJ5HoXv9g4BVHqPug";
  b += "9g7Lu9I/S4fbf3YeA17lEfASobDlL9/BC2OT//IAxS/Hw3TlD9/CDsGX1hB9whoO3lIdymWfr5X";
  b += "L4dhxokUySfFO0kzeINRWTe/cUNu73XtByxvMJ3j7IlC8XZqc8j/Lad+l2M4Fa5ojPftlN/Dc9b";
  b += "d3ufx/O6ncTf4KoRQO/Qc2KnfhbPdXvU9+JJ+X8Oz027vVN45juJnaTn5j3qM3j2dnufxrPY7S3";
  b += "hec+8/1302LJTH5fL8x4HNPZO/Rhg5ACt6Od7wYv4+R4cP4cMzuM2nqbDZRwszYlq2ro08aFRoY";
  b += "V/ByN0RlcMPGN8hgwPVPk0hY5PkyeOpgGvHubhZaHkQfbflXVeytLVSQOWuOjWcPJ1rS4ztauMu";
  b += "N7UrjjsmrPvbK/b6qRXQaSuqeyv+XLLNRGr7pXq0mqbaiyzLc+FfP2FkdFWw6WeA2b4qA9TFD7p";
  b += "/d7Anmh+LrDHmKfklapTngyMN4xffkbiduyxaM/cIIvXRAix+GhY93mQomcD41rjl8/JawN1k9e";
  b += "u6euW9JZe3pHxX2xHRqb44eNwqlnwF1sz/RdaPAp/kXfqVLay7Cf57RRToEuaCM2XOeCyHghQ+/";
  b += "NbYdqDc7cJOEa2aV02aU1GtM729e7Ju7TGAR4WwsGR1nBM67dDazWldZrQGm3hguZ7DJG5h4hBv";
  b += "hWn4Nv4XmthCGZrJlg2J9G3eGCMAmENZownDAPsXidhO4ybJF/1PCFvRR9kHm+9Pgg93vI+SD3e";
  b += "iBXLJd76Psg93tb1QfA9YU4KeQPHfC5vnYPGQe5fJtZki4F2q9kSNOASLmRO/9PLSt8j+G5vJ0e";
  b += "NYvOdUJy33MNglX2FthB7+qtmscVpe5irnWNf7UZBOhsrWn7kq50jXziEcSr3wFfJOatzRstOmv";
  b += "DVrE7mqgBhOmN74MsJtXvgu0pmetSBr5w1zOp3wgq4gm1ok/Jk1C/mrOFsskW/G+J8XvpuOzxDN";
  b += "B/1i75404zx48ZRSHFb1qdcNzloGPxtE4SoxfrAaNMADMYg+t5t+eLZ7Me/qfB7grnBJhS/LqYg";
  b += "qobfA5YFLXWFI5tx+gX4vYgtQYANkY9nj+QK8HtRZQiiBaBjb3VEpgfh99Qw/J628Hta4PdCc06";
  b += "sa/g9XcPvKYHfO6OlEIPXoLjuqKVCLQfg95CisqRw4Pe+ozLC1w783iJbf3TzxRWsP1iONdYfi6";
  b += "Ph9xpmOQmQA1t/0Aj+qEElnMUl5ILakMHcU9eyOyPjsO0Hkg26XDBaAU2otdmj1bFBPACvsmjhV";
  b += "RZreCkn3tDpxoAN7QD8Hht7ZAK/x7aza2UhZdmbxnh2rRCA2JjMwhvcwu/VETRUOwZ+T6Ia+L06";
  b += "ii/JM4Ecig38Xmjh90ILvxda+D22JV0cYUu6KLakaytCIUf9bNgau4atmRi2rq1sU+XQPBQDD8d";
  b += "QNttp83NggdpOz7f4SMzA77UFrq01dDrWEri2FvuIuqdjLQuF0hqCQlnmAcFpLRTKYu1WYdrekr";
  b += "ZXZUQW/KKea4C/C2kGzdWaK8w2B34vFjgplvVgDNQSY6Ao+0OfDarpN72K5z4jF8TC5TfoJYBRh";
  b += "CDwNYQwN7jZKVvtG+gXQQBsoH90jcDXEBONhm0jQKVIzhqxLKblIEvXKq2GqyFsoD3TcsYUG8Ao";
  b += "B4FPOwh8WvSEXdEQokLyxgh86SACXywxHAS+VEADU7vdNGVY0iEnsFSGJTXbjUHgU0wtgcCnhJg";
  b += "aBD4Qsx6Qh9IBEmkWpV4VgU+NQOBTLgKfNoBiLgKfchH41BACn7IIfLGLwBcPIfCpYQQ+NYzApw";
  b += "YQ+PRoBD41gMAXDyHw3WEQ+HYOIvCJU2vLYmTVsHhM2UcgUK1MIq8Sga9lAsSSgxH42GztF5QcL";
  b += "LcqE45XPTmgc0+k2OS/xUCeBoGvJQZr5oQ6XAmBLxxG4AstAl/LIvA1HAQ+okIWga/xPhH4Gg4C";
  b += "X3S1CHwtIPCFIxH4FgWBrzUCga8lYACL9dmQReBrj0DgawsCX+OqEfgaLgJf+30g8LVHIPBJsS2";
  b += "+rf4aEPgWlyPwLa6KwBdbBD6H1XUR+OIhBL74WhD44iEEPrcQqYLnQqU4CHyx3b7ioe0rHtq+4k";
  b += "Ekr0UpxNm+YpkC8TCSV+og8KUjEPjSIQS+dACBL3UR+OIhBL75GoHvA0Yovd1Ql81CTdbPwFMws";
  b += "YySNQAS6tJwqAsHN4Y4+saqCHyGH1wdga+9AgJfa5CTrehfRQ/zgFnE1Kkhu4kY+pfW9I+d3NOr";
  b += "ReBLlyPwaQeBLxIEPj0CgU87CHyRReDTNQIfbfdgLjnProvAhw8OAl9sEfji5Qh8ejkCX7QKAt/";
  b += "iEALfoQEEvgNUAgBlTW4xnNwj4+Qew8l9Ud66/fzQfDXpD8jbcgS+2EXgEz/HAQS+WCwcRTC1CH";
  b += "yLFer23mUrRbsIfDZe7eRuI3aHEfhi8Ueq1m06tG7TUes2ddZtuuK6TV3H5groJ+izj0HFqFrjr";
  b += "JYsYQtr1nRgzeIhBL7FGoEvqhH4dI3Al9YIfF0Xga/FlJx984yT+9pBBL4NQwh8bVcoYgS+fw9h";
  b += "NrYGiCLHiAEiizHNyjy8ZQ3IrJO7rEN2cm+u7uQO0ws4uedYYr+oKrm0uKJzeJbncA7PV3EOz0c";
  b += "7h2dDzuFsa5WbaJl1Ds8MAt+wc/ghSeA4h2e0EDhBc8DIw86FNktu864hr5Hgaufwtih0rHO4cS";
  b += "4k8Qw+hyTXt4dcDNmeOBNj4nGxJG5W1opVKdY5PF6OwLfBIvBtkOgbliPwbVgFgS++SgS+Q0a1K";
  b += "EBskQFi0wLElgoQW1fm5lqD2raYHzrbmx5G4FusEfiasjYYgS92EfjiKyLwhcMIfKGLwBdaBL5Q";
  b += "fIhDB4EvrhH44pUR+CJB4NOCwJcKAl9XEPhagsA3LQh8a1dA4FsUBL7YOIc3RyPwhWZHDWrn8NW";
  b += "Q8BavPADHZZQeB9Xg4VgFCe8QG9xZJLwQKyCvO20R5lvsZLIRaMZwiQzRFxP06MI5PBQWmJ1sE1";
  b += "E1QOMQLwcmabgut40hl1vHkHZwwCp7WqMtcexp3TrW2MeNaoGst87hm5kJqm325Ld1jNxsnMPXu";
  b += "0h46gpIeGuN2n/cHANMDx2trTfHChvMscJmc6yQr4CEd8hwcDcYv8jYIOHtWB0JT10lEt6/rHCc";
  b += "mleJhNe2/NkyJLzvWBG8eXE18GaRNwdYR4iblmkMxc7xa4MmkIyEJ8mg3cr+CEh4oUHCs+aJvF0";
  b += "yUm2Gj09jVVibRf9xXAHpZsEZcJEGc02JCaHAr4UV5lqDXg3mGspYqvbssNqoI0HHNW4VOOHjmy";
  b += "cfY1VcjYR3gAlnlB/AlShdkzOvXa7Jk71AanlAGlTcnx80SHihtAZn3mwM+4hM84fF3fwh8SE7A";
  b += "sNcIOHx+rxXVus+WaZ7ZXnsEFXgHD0Owp6L68s97hq/MhIeSMHg4Tl3XaEZhJdPwQst+jTFrK3o";
  b += "05Qc15hT82Z9ao4j86YFwwMJrMDwlAXDqxw2ioPcU/p9Dsw7FXDx8mE4eJZ95iowvINUgQz1lBp";
  b += "RPXf0qUe0WEkJBWzawzAYU7HMzJZW6GOPuY3ciG+As5O3iT7DRAsftGj2XJgRF3rklJ6W1KGzez";
  b += "VdCx3OJzRgeE0x0Gmak7CwpqlNFwyvOQSG1xwCw6uazLlZMLxFKdgBw7NtGC7YguE1LRgecSoOG";
  b += "B47PDVd0to2SZsuGN6HXDA8dQUwvF0GDO+DBgxvtwHD22Po7V5Db+809PYuA4b3oDFZuNsco+8z";
  b += "dLs0YHgLBgzvHgOGd68Bw1OrgOENEtGrAMO7ybDIAkAVWGi3Cfo9URPTCYeYcvDEEDGdWEZMRZI";
  b += "fJYc3HJLaECe6ev6xm89j4k4B2WGb1Od6yu166AmiofOlBnP/A5e/sH54qH7NVfQEDdTv2SvqCd";
  b += "asoCdoD4Hh6WV6gqP/k/QELlJ/KHqCbBWkfqMgyERj4CD1EyXO/rPRE4y5egJ8+HMg9WfvQ09wY";
  b += "EBPcHAEUn/mIvUvWqT+Axap/+BVIfVno5D6sxFI/YsjkPoXRyD1L45C6jcRx5Yj9acuUn86hNSf";
  b += "jkLqN3oCPaQnsIUM6QlqMLz2EBhe2+oJ2sbsdQgMr1oJK+kJNtZ6gqzWE1xX6wlmjZ5gC37cImB";
  b += "4W2s9wY3C/Busxd6MrJwpKnnKAcMTtoz1BK9BTxBaPYFcNyZ6gtBZYKEDhiewnkG1DsfAJJhoY0";
  b += "A0cfQE9qijTSl29YtbUUeDximrkIq7WcDwFIq72Sw4/GIwPCVaBpBo/EnMMrIx25gi3rB0rgbA8";
  b += "BSG90D1Zbr2lj3A6fKbWbVuwPBQcG+/7GuqPlZt5/t32sgprz6r67VUiPUdtXbXkCUBw7sV+o5b";
  b += "HX1HWus7AGtTtEelNGB46RAYXtuC4aUWDK+apFbfgaGgZq8RcBkHDO+Am2DMOqJZMLxwBBheOAS";
  b += "GFw7oO0Kj70jhrAxv1Zb4Tw+C4aWCmtEW1Ay1IhievTJuylZqJp8ylZqR6DOo1NSAvmOG53i95K";
  b += "aGltzV6DuEbb/FiNsbjbidibh9nYjbs7LGbrSyOfH4W1fRd4SyxrewFF7rO3RPXVHfEQ3rOyJX3";
  b += "xFZfUckYnHk6DtUre9QK+s7Noq+IxN9x3Wi75gVfcctou/YKvqOG0XfoVfQdyij7whH6zuia9N3";
  b += "rDIAx2WUHgf14+EY0ndoR99xAPqOiE0qpd8OQN9hO431HewGvBHABdB3ROiLCXrMQt8RoS/g5re";
  b += "V3fzQF4Hp7AF9R2SBWKMhINZoCIh1cMDqo/ho6CjerWNdpIVlvd7qO7YxM1frO+Q3OENmyrcZfc";
  b += "f1siYaDE/WwvMZaJUaDE/GWpdT6P0G934bT753oYHez/D5OFGUhsCTNdDtY8x89ppAqHhOFVMCh";
  b += "gdNT3E9PWowPGJDKzA84UP1ECaq8J2BQ08FRa44KJwhRTlYg+EFy06/7X4SOGB4yrim86YCyr5R";
  b += "4jSyH9Dy8TpzbgyTievMx3xj9otqMC2TdlUTaOZ9mLTr/DreDgwYHt81et2oqB6fl/K5tVnNzHB";
  b += "cZw83q8NqzR7pvHOhytdV/NREzU5dt7OOp1Kp/UaKx7dEWoMPDVCCQKJ79uhXuKTA5ZKCIS4pGM";
  b += "UlMabsQal04HJJB10uKbAzTI7Z2mpotikz24Jrmm3RfqLrAoaXChgetIOFHinyZHyPDX2qCWjXJ";
  b += "aBdiueby3UYca1rCWiDKef1zuQVMLwGvMM+QY8WvBHYKfwRINBBQdPAKj0i8HGHBSkOIG4ZqGoD";
  b += "NGevgMntAmQcyGkDSv+5qroMQNeo2PVFgOHhdw2Gt1iB4TVYldOoCS1yEELbNSJiowbDi6jLU+r";
  b += "uZo+d2UxDGYaP27sViMLYtbqof447gUAJu3IHShf1n6DHAYDhdQUMr4v6AxpYG/2rJYHdfMJMLL";
  b += "5kaKKeWHwJ0YR7CZHb5TS/JoQE8ghNOJjFVbxFgS6WaTZhAXMtGN5NLG87YHgSYBUTNxkwvMkBM";
  b += "LyJK4DhtY3SNzNKX22UEMooIQKjhGgYpW9klL6pUfp2jdK3ZZS+i0bpGxqlb/ObC4anDBheYMDw";
  b += "GgYMLzJgeKkBw+saMLyWAcNbNGB4oQHDazpgeBOrguG1DRheZsDw9KpgeLtd9QrA8Jor4cyp2pV";
  b += "M1zhzQY0zV/VsczkYnjJgeNqA4QUGDG+xAsNrrgqGN1DJ5jehkhdNJb9kKvnbppKvm0q+VlVyGR";
  b += "iebJ+ZYwEd1GB4jH4KYRBgeODMftOaQAeMRxeSmBcADC9yryAP4BAaDl9B3pKNYQgMT1kwPCVsf";
  b += "Th0BbmA4akBMLzAgOGd0VKWFYiNJTcq3ECFB8DwONUw2olRp7UdtqFdm0Nfv6I5dAb+aEVzaLY0";
  b += "njJG5qIZGzCHbsJE1WrHsn5xC6uVGaLeHlezQTQSLlMB8vm2Yn5nwjHxXFkPqF0wPDHzg3e6GtK";
  b += "zaUZ+GzTpEod8x6ZLsN+0YL9pwX6Dop/GiDX8mvHfttIT+G9gPoD/Nsu31gP/bRjZT7MWYI0zAD";
  b += "Wo3+IQqJ+qoKVCAy0lTBvEEo22/N81tJRy4G6MESCgpRouU/WIaL2QXGX/Wts0zNAxtNSNtzM6l";
  b += "GJoqRlAQB2kHwZa6n56BbTUTbczmpRiaKltiHSYfhhoqQesRq13xCrTeh+uNWkfyRtI8lEwYY/0";
  b += "bpX6MJKitb5KBMPRQEsp7mxsStTfJwQ9h80BXzP4UmGFLxWWXtrbko/BJlnRY8syiKmG1dyIMZd";
  b += "obhoOxFSjgpiaFMF50kJMmePYnpzSEm81OXQoO8mgZyhzMh/D6p60WDkNB2LKGpWq7O8Zc1IoOc";
  b += "U2HrqE4j6BAKMo99UQU048q1eqUP8MxNSY5PqDWq6G2VJBTI0BYmoLRdhyDRBTYwIxNSYQU2MCM";
  b += "RWZsoaQpio/H2hTwGLfLCBSYy6I1M0CIrXF0aaILBi6smA4JAuGLojUmOlVdFbvPgO25IJI3SfS";
  b += "35jBc6s4bKMcmeRBRjUmrf5xkoeoMtG1B+QDqwrz9cbB+Vpd2VOBSI0a22jVsfXt2I4GkVKCpfa";
  b += "vLIjUzAgQqZkaRGrGAZG6T0Ck7hsNInXT+wCRumkEiNTMchCp0AWRCodApMJRIFJmCBtDQ9iQIW";
  b += "xYSD4zHmPOII4ZDZddqAYUujYVnbSzVDRcRnenHBApJXTSADCBSnrfLvoPBRAp5YBIqQpEalHU7";
  b += "AfxOA6qiFP0w3iQWPYA5skUsbfKgEgpQAzNGPSgGy200CI+fHu+zXy4yQWRUvkD+WGELgqI1CJA";
  b += "pBRApBYNto8CiNSiQf0ZagNApFQNIqUAIqVqECnTRrZKVvkRgEip/MMAkVL5RyBzKfiub6XHjQZ";
  b += "ESuU4bafqHLAgUh9lEClWAzCIFL89QltSBSKl0F0MIsWeAq4RuRLB3X+YrbgHQaR4cRUhVORjDP";
  b += "5VhET19/ORlYMoFYHGm1P1SHzRDZhUKmBSIY7U09FIUkrQ4JUDzlPtjgabRjlIOUPQO5WhuMk7t";
  b += "UhSPMzKQZJSA0hSZriVgySlBpGkDtQTyM4nM7t4rgFJSmZVSltQmi8CSSrNDwBJytbmAajmUoCB";
  b += "ARn+fgGMPwgHjxSiTAugOqabuD1AkqrmVAokqWpOpXBPOWC/NPpsocFIUqpGknofeDxVDZULy7O";
  b += "4HJanimdcapSLzqMNktR19WTS+XUVkpQ2SFKakaRgxA7BfqsdR0aS0owktSafrZGkdD5bIUlpIE";
  b += "mxAcfHhSV8gxGwL2v+guu6NJCkIkaSUoIkpWA9L0hSykWSUmJyX88kBYU+Fo2ukKQUkKTW2GroG";
  b += "kmKGUwtPA8DSmkm7tqZs8ycVoBSWq6RsfzrAPf6qKh1tAMo1XUdqnBnsgBK1focLo+aqB1AKW1a";
  b += "yqztxsHG6RUApbQwqw6gFOfCgFKaoUy0O5i6ApTqGpadPRGyp7U4ODCglBrKKKuat3Hl1onSygB";
  b += "K6RpQ6n2oX6wt9kp6l0rhoh2Fy5Dkgwk5LPN8XOxqbnGCBVBqSqSoJgNKPS33NIi5zHAW0/mUWP";
  b += "lah7kpV203ZaCFAnqz+nPJqVl7311jZqnAB0G8dGVKwRidrmWptpEzxSa5ZQyJMum0zAJKsbny9";
  b += "fJWGckjM6prDRBpMrPmze0h82ZtzZvb1rzZgpvK6FnISWvVvFjHs3CTfIOekoMge4NeLudPl52g";
  b += "Wbl6720naA57TOAASrF2ngGl+M0BlGKZPr0SoFQwAlBKuYBSqQBK2Xh4qwGllAsopV1AqcgFlAp";
  b += "dQKnAAkppF1BKDwFKBcOAUsEwoFQwACilVgSUCgYApZpXCyj1DdEtiq6y1l2KLvN9AEp1hgGlOq";
  b += "65WmcAUKojZmOd/5mAUsoASmlXrxb8lQSUCt83oNRdAih1pwBK7RVAqd0CKPVBAZTaJYBSewRQ6";
  b += "kEBlLpbAKX2CaDUh2pAqXAFQKmd+R1XByi1aAGlwDjUgFLzBlDqAwZQ6nYDKLXDAEqtNYBS4wZQ";
  b += "anoIUGq9AZTaYAClNhtAqXwFQKlDAih1gwBKxQIoda8ASt0jgFILAihV4ghHv19AKfDycW0TC16";
  b += "+M4AupeDnNNJEtjNoItu5VlSpRXPN9jWbn9dm52LGXpu1s5n74tle+/2hSr2vsr/G6m820WxfqS";
  b += "4WVUpdI6rUN42W1qhS8VWhSqkaVSqoUaUaNapUVKNKpTWqVLdGlWrVqFKLtUtoWKNK6RpVKqtRp";
  b += "dqmr5vSW/E1okp98zqyQpWauEZUqW9ezfRfaPGroUrFAJGKHVQpJ2B8f76jQpWahs93g9ZlRGsy";
  b += "pHW22DuUt2mNwytN03pTtIaxflNaq11apy1ao80ezYhDhsgcImKQfwDHSbcvQ5VSDqoUK2A6DJ0";
  b += "g/MGMMSkHlCujkTDcK19fLJiz0/JWoUp1gCq1Hnse0GEFX6oDfmyzxFvfB83HW4Uq1bGoUh1mm8";
  b += "/lTYsqxfzJDYIsG9e8iUWVEjxbQBoZW/oObOk31QJTB7avm2qByVDrjrWl3yScN3NFm2rOu2Nt6";
  b += "QeYIopfKf061pZ+O8WuN47t2B54j7jNHFlvN0kRC3xkQhxEWByCMb3Ok/ISu0km5dNRv1hj+Jik";
  b += "vEyhuEPgmaiaskn5Eg6c6Hkm6vMGZwChTkbz/sWE3/1n6f2FBEBSz0dAF5vVX4hoLtDzhYjmDT2";
  b += "Xop6PfAFuXr4Y9cs3FVW9N0a/3vJpcAzfnYAy5Zkteykw3DqXStviJV+uFz2Nu12KnfppPHs79S";
  b += "k8afu+6EuNLibz+k3z/gKJkO/4Brtqs3shVmIdye197oxgtYkRrDqOEFdf6r44dKn7CnbsmwYRr";
  b += "FayY2+s7u9ujWD1EN5HcLV4H+FyvI9V7Nijq7Jjb17Zjr05wo69mX3V2LG3B+3Ym38eO/bmN9SO";
  b += "vfmNsWNvjrJjb36T7Njby+3YI9dCKxqy0IpGWWhFjh17tKId+wicCvZ3T0f7u6cDRrWpY1SrV7Z";
  b += "jD2s79mZtxz5d27GvNXbsU/gxzkpGbESVHfv6kf7uFgTMnEHLSTjbscP4AZpScxrKXaDlNFQ7h1";
  b += "basYKXs9mgWocNdnZzrsZx7NjrJQutfb+YsOA5vConqyMs6DRHHELBqHoC9t8Tjv13VNt/8/HVx";
  b += "Ojjq9bQ8RVrLCpOqWWPr1r55MDxlbjQwv67JS609diK/Xdr8FYtbedCCuVIdSYgSnXWkbj23yl3";
  b += "ZG3/rc1Rcgu64KzXEHW5dtXlNIdbcq9sg/Xr9sTMlmLtv/XyK1Y22CtWXH/39pC/e3tgqraHpur";
  b += "V23+PG/Pj0JgfN8X8eFrMjw0Ww3rX/nvdKvbfkayNKbZKdv3d9RXtv+Nh++/YVQfG1v47FjPh2L";
  b += "H/1rX9t17Z/jsU+++m2H9Pi/33WrH/Hhf773Vi/71+dX93bS9DH2n/HV+b/fcqA3BcRulxUA0ej";
  b += "lX83fn8M7b+7rHYf9tOY/tvvud9Iz2asHqM5TL0GH1BSdEXwI9bx/hx6AsXjdPBKOm4GCWdIYwS";
  b += "5zL0wQGrLkM3UCXOZehuHWvEEnsZetfxd+8O+bvzHQibhvzdzcUCeT5n9tosX2MZtQu4erJ8Nqr";
  b += "2YYsZalhEfZpYxFcrFpFvg/p8RGILPc/AyJQxSEkMSrZ5X4iKLgwawbH9BN8OnpT/LKqvhgc/ul";
  b += "Y42IozLM8nLtf4vOFiLyQOx7rdOxftUc8llj9kjhXvr9L7mQrbtDHkQBgNORAyf9hm/jB1YBFX8";
  b += "CLU1oswdi0a6lvcHXtzxlbpGGwVGG+PS5x29kPafmQMSpiTrBP8leYQ+zouDlHMmY4b1hW/2CGK";
  b += "Y7Txk2/3SLLfVwMxm5hK3jDkVGfAIapTeQEPTramzLKmEdGMQxQK7q0XH99ObYPelFUgkaspOdh";
  b += "+c2fM9MCNMLwdRvk6RjUxNvPArCEecERUMXdyL1cRDwm7TcZm/4twH7ksQtS3KfYkDi5mJKybia";
  b += "cMzmZTDHpi16CnKQY9HYOfac1BIutZGA15FkZDnoWRBYVMHbeO1LXoMf4c8UqehQ121ZZ72gWYU";
  b += "ly2c2vyzX7gAxtgQ/b69pDPoUADx3L4wOKhiIwWFjrhgRpY+bxTMIKwDYHVQ2ChhEEK9tUU4ogQ";
  b += "ASEJlkDo/URwjCJCZR9Nexrgxj0Gf6QM+fSBCxkGKb5orrNIylPRytdZgASMuM4iROav+sP1v+D";
  b += "X7R4o7Lwv7S1wb+qb0K2Y86Cq2UWHN2JLmnCSjDLeobhYFpY+MeQk+kJEEHQQjCjzMZGU19PP57";
  b += "gW55M6t2coZK0VnZ/3jR8uF/4r9GvaEs1dUDV2bMI5VCxyxHkIyXBE5/czIIj8vp0I5h7vl0z4E";
  b += "RzFJoJVmrqJ9+GolOXzx0UMfxQdqGqFYQLenZUX86b7/Nl5fZzCiZ8arMj0vH+K5hqsyl9GubS1";
  b += "voQnzeQX8aThegHPgP3oWRlwRokyAFcQQhnwLObqEt/dl7lDhrPkd0LMY29IP8+0f6R+HqzP21e";
  b += "hn/cG9fP21ofTvtXPy8ytlpCVT6tlJToXYT5kl4sHtS68sBbrFSUxeTtGTrLT8kpEAt7dFnlKlc";
  b += "9HBh0jKb8QGXVvUr4QGXlL9DOBWczx0LQQq4pqWbu7LiqRuVN7eM+VffZIvc3u44z8fvYq3zU61";
  b += "5d8KUXVF7v6kjEjPEnGeV9yR6xDNucjYM1mzfyDo9e04MjHssYnjCKNV/sBecshvjNq/Cwg7HyD";
  b += "Wh9a1HptUesFvx6TrMaUT8q3E2DKn+oqfaLGTb0akPIhyHKPobqPdqaU9oMwipNGM221O91sbM3";
  b += "U+MTaSRZkdvUXeLXokhlnXb555oseXG50+SK/sf1MubWf/bHf81tTI9O8u2qayZFpnvlHq6VZC/";
  b += "2CRxMd7L/meb+T+HDOR0s+tFe9J2YppZYsL9gs8SGDvQqNC7LWrIQBw4y317y+WVq2vAkpT9Wlq";
  b += "IHavmWzXlKjsx7Mb3xkm0//1GptXnOFOrxgU/+RdzV1GFspP9Ndl95nftnINi399Gpt6l6hTZ+3";
  b += "qf/rVdWhM7IOr65ah/bINJdXTdMa3dbPr5YmHZnm+VXTNOt5PrJ/XrapP31V864xsg4XV61DMnq";
  b += "u/sxqaeLRbV01TTQyzSurpgnr+XNYMHnFTwSr37wp6DP4AVyP8z+LTFr1Oke3+rBF0GUC7YFeyG";
  b += "Fzq9nZJodRLS+IrZxiax8idk0tFHe3VCV4XyTJN7149ppJkn+FqfGiJbqfuaqpoa+wFF89+/7Ig";
  b += "Rroj2pgS9XznUW28uC2PWxQqpw6wOr4VejUuz/zPiomJpDLGnf6Z1fLY3nvW0Tm3E9fTHV2Iv6U";
  b += "8WdjTSv28L3i7b6LHj70UWwWfe8wyDguCggfDE6wU02Y07oJD7TNFQKNXgLUfnzV/DUxX318bdH";
  b += "Xlnz1B76CsSia9NVDtK5EwUBIEMXspnzHiseyG5wf1PHsV0X+DwP2wkpELd0og/uLdENvDfugFu";
  b += "NsalLAgI3C2xsoQ5jyi3tTjLDOhl5XbGUbOaXjk+CgWAvQjA29tngOkQiwodfhBdKLS6/XgDwNd";
  b += "ocvL8gbJJuUF75+3sue13A+frBNYaV/vDcm2uodhcLBZN45tKEAc7zg9aZYBy1Xz4zla9jAYBLh";
  b += "ebenOfdcTOwWvHwyO4U7S6bA7+fFNB/sPVmse7JYD1ZsKl//sXOMtEDB+XS+7mPnnnyyN8Ut7Cn";
  b += "uFDZSoIEWM+CYfjYFGCPEcZSHm9k093OPWfXGA+0IMD9SKVaRc0PTcuk9bqO0aiO1ivonb9etmj";
  b += "StmsYpQj75qd40AvPENCmxTZqWJk2iSUmxzjRp/ZPFBjRpMt/ATcq4SevQQGrS5J+jSekD7RgwR";
  b += "TQofcp+Kt/4ZDFNfSgdOP0xClv3sScKda63kUaODcQxMSkpVp/JOniAZ2XSD03OXE6Kixjy8BD3";
  b += "WYgCegktrLy6JSMsfHw/yrfsBPADRR/0cDaUWI4/EP9Abhc0ZXybWd08mgxyvgDliuw2MehAix4";
  b += "vfjfoAK7YeOPkF5kSQJYuX8B0/Aliv1t1A+q+iZ2+4arH1Lnom5ibUCT9o6X/SRpgrANeOnoDt8";
  b += "M/tIHaPZ4Tjd/Q0zy6Yc/H/T4Ako/pH8sxxRT1KNpZBP/gyWJSBjXIpxZOfHcxdfKzeP3syYW7v";
  b += "4cHVR019y9RtZaPbV13QxKahiTA8+d+1r6F5hiGDT+7eCOpufw1UVfxyd/vmfe3nPfXvT48MfEa";
  b += "gOBH5dt/dt6DVj7iOJ/AiRBEKkA/4vUVvH4Xv+47CpEdb3v7sG/D264+bNv4QKo8XfU+yEF5Cb8";
  b += "+zyc/ONq0v9gP4j3zq3z53fNeeX15Bp8/59cB56uApYZOTuhPGRdZXy4U2ObhDFkZ57I5OWqeLb";
  b += "TMVsWzFTSsx66aNFthE+XtZNs6j03z5MJbxXsFTYHsSZbdcVEA/DzmaP6wg+igJIayigZkMZ0oe";
  b += "FfR8DMqET1TfaLaJ4IHjCspTejYQD0lQoODtAj1Cdk2IonIg9/MI3tfZJMJc1oEh3CHWM7zNwBh";
  b += "ZejLo/QdsxWSOH4lNA3D/Xmw/4k2js1lIuLQo8lvrYfauBmeIgLikh7wgGk9bFZYcD/fiJH0+XQ";
  b += "alQo5HpfJHRik3HZbZalNLoCdD7bZ94KNVIKcfgqZSnkuj+hujcNm090+vJm16XNcRgHf7XmBth";
  b += "wexfDKoxi62SonW9y9OZ8yKUf07O8QL1rShoWeiKQkzSWhST3BIL2WBqD6Lyo+oJIAhomm4tiyT";
  b += "INs+Vh5gWSZyWNXVWGfFnn2bVIObB1MpmXwBBvxvQp/ehhgeaAXtFkflO1YbLoeLRRfjBMeKhKo";
  b += "oRoSfG9Pp1gtMKnCLM/DPs0A3os+QkHYPzi6sQi7lykjX43B9Ek0y2ldw31Hq6aV1OXUNDFgwDW";
  b += "HVxyfePT4YHS415TttQb3miwGXCk+PESBGaKRhWkuLBgsrB4RKaXwaAKER2mZ5+DRvH07vdtEpe";
  b += "PjWiF2B2T7LXbPSD/d0M0TAVMgVV07p7lEjOfHpfzTpjov4XlawfjEZ/8TjOl5hftFwmpOYlCx1";
  b += "b2q+myWeVmZQX1V9Zq+Hb7LqoCeLcKwphinpoS/onhV0pJn5IUR4xrkHF/iRsSJwF95P1OTaGBg";
  b += "q4pSBasBEQhcM6y+3IzCUEOpOVJQpiEwL4T+bAfAPsCd+1CPBRyLTVqiT/YSvpjp7gfYbdxcuQc";
  b += "9YJz9c3bL4Qw+IRl8XKY3lylF8d7P9tGcekOhZEa41El6/bzp/ctswc/9TYuPiCFxNdkSz27mxo";
  b += "PsJd80Oy6UHRGVJ9mJPNbMoe8oAinTh6USG5gzYRRqzdZYTbE7F7LHcVVVP0usikGqxK2W4lLpl";
  b += "GNFc7/ICKdUNc25B3iQP9FjXJhH4bJIDRGqm4hXxymeLzzyCfgWBeJOhRGJKGmlH6W8zxHj3jzX";
  b += "6/IRWJt15kWWd8ViMWI01jzLO6fkHiFapGD72kfaxO/1AumHU0q4P+rqivSgwdwUzOBYqknC00B";
  b += "VIzvKhcq+D5TEjYt4sPMKhYzmbb5jhzX/LDgyv5cAgYPYuuynNS9DDKcyBZsBQ6YNs4Ris4SaZg";
  b += "kpanS8fAkxqVNXt4Sa0G+7S6ix2hJyFxCP7XnvkIzsHM7C+O1hqoK87YJxa4umlMxjPtT9KDaol";
  b += "uTG+cj5OkgQuLv0bKIbQoJygeflldDsxWZb7vl8eVMvtczKp5hhaTprJUaDI1dMxYHoA+xeN7zh";
  b += "Ng1B91fZInGq2Ly/naBbIgD9iBSAPYkdQFrs4vBk0WbbjCeLDhsZ5W0Sctp5h4QbNjOnmcj8SZ/";
  b += "5DiC5Yya2jlCWTYwLcj3KvLaP26xIlGYBgrIVXxriaPxKeODMi9YRGtQUWqprb1d8iPl6ah7NTU";
  b += "wD2b/Az63Quq7buu6qrSNJkNrHYNjUwNhtYLB6AztSAvJu8URNKTP2YaP8+Hyb2nXxvxPn/DN8F";
  b += "1cKrDMIspqKuYzw/6RhfrYR9/tBwvCd+QEsMgixkQAZYGe+yBBqGf5MEOWsOFyHP8TucagtKCNM";
  b += "HUg6MSwlFgf1GV+sxcIVm3X6JGIdz74c8J1GiZhsFSDPRrtCbBBPTNqg+3L6jJMyqv47dfVbBTH";
  b += "cPkMOFuL5WlC/mB6jt4dp8LijYCYmYwBCzEywz4teuSNo+tkMFWgp8qhy4MmkUkMXU7Gtqjl8mj";
  b += "xygxrJaIbRp6BeYJh9ynIRzTKU0ImjzBIU4rPAWDkp5y+EMLXsCpAkcpbxytN/RMLRpvLpr1XS0";
  b += "qv/jaWld//YBPz7hHiVUdJS45svLQ1ISSlLSQGkpIaRkvD8ay9lpJWUQax3JT6OEAxbjmDYMnMl";
  b += "qNofOoJhkodWMEyMYBhhJ6GeeIBNQUkUjEQUbFZiYqsSDIP9RJ0BYRgYwbANos1vnYfa6CaKGFX";
  b += "TnsiyIxhqEQx921UOrQyvLCaFVy0mNb4xYlJixKTAiEmRiEkxumGZmNTky9KuSkyC4RlHT/5SiU";
  b += "npN05M8sxgAOhirpZ73m3q8IT6lAEDE2cFEOPsNyz+W2Lx355X6PEKTq38J+DLaprAOHAwUDE4c";
  b += "M+zXZoAwYXi7/B5VSQG70eQ4BJaToIE93OqsnfyBB5HkOBIwIaNlJcnGAI+/XpPHStoxRgMOKj4";
  b += "6l9ilotKqOyntCnSOCIE3CpUXwkanLkbO2Y0OEnz990k6LzfoeBgi35eFQ0D90E9CEO+ImJMDPz";
  b += "aReG/y6936YtK8mJMsvoaVQY5vciGwpVxn3ZsBXFNJasIGRvph7V8TKQSGqZliflIUtXLSj5bZD";
  b += "bBvpgeQLZgw7gQRjK1YRxfgRmPiurJ3TkOSERobrU2l45UV2CaK5V0KlVWAvyu3QujVX19E89c1";
  b += "F7JBdTavYBayQXUiXul5tCAQe3JC+QFVUMHkGDEpOalQbPr5xU8daPsu4NS0x9xqvkKCRNKjJXh";
  b += "lewb4yc2XS58a/8VsHRnVNYBJFzfgSXwv2ven8XhZgA9KRXxy75YUQPJIwCtCNG7HmrxkgIigAd";
  b += "7e+4vT5wnLCKAJ4gA51UdwIgArzoBjAhwoQ6wd8JyK0kiYiBG6RUjrtPUm9cH5Uph4IJUvWPslo";
  b += "FSYnuxaEgr3+Q8XlH1PcVvcchrTsjXOOT1uqe55IZ8vFgZHHH/v6zEdFuGQh9MuSOXwUPMyeBdc";
  b += "IKmMRSDiBH5MsQI5MsXD1XwEJmckDEuhPYU6Iix1VlncCF4TEJjtcPWZYG8ZQD+4ZGpkB7YOEjZ";
  b += "HzN98dyuhiOqYR+crKryJvrcVJugJYbpJs2ImqFrGGNlZer763/lqe+ZEdT3169Afb/jLwP1Pb0";
  b += "69f2Fb1Hfb1Hfb1Hfvw7U96mEqK+Vo8MZkQxACQBrbIhqTFIB2+vjMJcvLT5Kq5hvgzvS5rNZWh";
  b += "G00O9v8/hz+sDAIiNt6fX08vT+YHoaFJLF7GkkDtDvb3vy8iBTGRYAWVHUYH0w5IxK1xGLAAgaG";
  b += "7PY1yQBsCFnhDgZNAIgiqZkzTwVATAUkSEUkSGs5ZPEiAzmflQRRsJZvaswMiOgKEVmZFkuFFku";
  b += "FFkuFFkuFOEmFFkuHCHL4Q4+keVCucIBZRxkzW4AbQ7fLMv1rhS7IZY7dNE+qzmxLUI0pt50ZTk";
  b += "NUdlGj/MGkOliyHLIq5bl2D47HJDkzMQd2TOMPr5az0A2Q8/wlYsTVDA9pqGuw8nDP5BsFCcdVH";
  b += "D/ZesFEGk+8B5sBbX+r1IrtLn8h8Xcbsp78dL3fdFoTUEFT1e/vtxSrRMGQloL0OY27znN687bo";
  b += "/ayDuA53adpLUB7lPedKRujwTLipJINtOfzuYA4KhfhNi80+NTZ7zCch9AhHxbkAeXjXFgCZNgA";
  b += "BQUGOGkXzg+FsGXP+MK9BeZsTVxST2rRxCJehcsrl2WkI6zLaas9UviW23kIuh3eTBS2oOx/aBu";
  b += "DWR7EiGwM4mDedSNoiRDbCLRbZu+4MXyJkZh+CaSpcqjKPNb3wdnZt+5JfLSUmTYFHKlqk28dik";
  b += "3egeTdsKW/MVx6KDGaK5XOzMNvXXsNIjEWvKwYmwCTYb9Mi0/rPepeniyXod3dl0pFZKbArqaaK";
  b += "TJLsn/mO7nGkuu7da4PSK6foVwPc67vIteDJlexmn3V66+ebSLZntY2288pydffo06Jeuu05kxM";
  b += "xm3O+CTKerqa2YpnttydWgSDMxsHAVqgPn13ZnOHQxLhmc3T1ij5cIsGZvb/68sYBNU1bX49s0U";
  b += "LODgGqbSr4rzZKPgMcTtzgg76kBgGt9nEGDeSzMAuDm7ADLQAU+EGvHE1uF5Y8sZiXBqJCTJwcm";
  b += "mz9u19crJywLWHxIaw9wmW52wRHGDAaqr2cZLIfHnH6T9KZpRTX2AzvqLlzh1fbv9JZPUAgheCX";
  b += "B4f4H24YlCq7qschyxXL1+MFFbdFsfW6BgvX+IzlOhwAhYXGiaiGhVRSUS/ku+uKmJ8tRGjq40Y";
  b += "Xm3E4Goj+lcbUV9tRHWVEbG4GAOYNha99oT/KSOLCkIEG7w3FpQ4Y2Y4LPJhQlH/K1XRoe1Qn2D";
  b += "nLZIyvOz1gFabIpKbgOFbILb+Ns97Kl93klEuFPZd7IZFTBOq1L1OeaIXlidwokWJYOWNk0dYS/";
  b += "SLFnhSyuAo7Y0nvpOWKVHUgN4ol7x5tIjaUBb4eQJvVJIMIvMWHWJgDwVpoXmUTYUD2YEiXg2oh";
  b += "I9ArmbYa6JwT9YFOKd4sYg28C5I+/wGmDGwp64CDK7UUtIij6iubXtZbSNb2+ho0WKyWdc2yVv8";
  b += "1rqfUVa57Gigtq2RtY2W17ZV1ba1vLY5GOwobx7acLTXNJUOVxkba/NZKhxLp1jIuwS+eQ6HSaA";
  b += "bKQgQYKk1KFaKeQJ06g4oVgr6NSGBGf1ah7tAUvGpSIETo2QNlYr+nX+L2JqfFaMKVV7Cr8+LEa";
  b += "kq37a/Br+1Br6lleNbyUfDeZEe7U3iTqjpYh0T3aWl8+95n+2tx9fDBV+1NVtMHaU9ad3Ce/S/7";
  b += "//4Z3vAzyCJZ5yCAILRRaSDvQk87pVbufb1+NB5R6+Dx1Zc4QWOs8nH0b1pX1iXaWxc68ENKpap";
  b += "moGISGHefIDJcPOAnDw286y/1fPKXzlxH0SxDJ9opN/4NWrWn/G11zRxiTdPAxzWIXaRbMWsKb0";
  b += "PsTXLe+oYG6bA0eHuY4zDt/lYEZXR8Sfo9X97oO2tx0dY9QCR4fgTBU7iW/z18UP4GpVrjpdLS2";
  b += "97xxDRtxGfwKh3UUAbh2lLS694i23Mva4+wXcXLSmk5xuCljJ+pd2PYwaHNlDT+ryeUsmD79/ol";
  b += "uo7qVObhU+Tl/EvxjF1wweJae6eW3hPfRZ3fG3AJOwUCR+QrcM1SoBXP3UWOkX2qQdGwInFwt8A";
  b += "2kK/fLgRBHkbJ/qS4SHu3QFuEua9sIdOD22Q5GOwoG4f4gtU/aNwUMgn+GyOlrDQHlSMLyLxuBL";
  b += "0lJ1QicUjlmO+BqtkDbbEEuZCY/B0SE3yNQ+IkwRCOzmukacq+rSom6lZXXkbR8gokT5SaT5XAg";
  b += "VGUuAipO0gn8KCbFFxY+2QzyPzSQrBxp+P7W/7EtQuv/Brdt3QJHrZ/oKVwWv1LxxIAt6u7i3s6";
  b += "IwDpPK1bGDRz74uDkjsZF95nANPh020G6J760qqIqnSRZwuKd/41S96/Ac//d7alpd66Y/GuiGa";
  b += "i/PKWABUnD7O5WlqEZlzT+ojOamHpgaWEYwvQ61NK8O2OWOJdIm5SDFyYgOxh3HqCCnj/g21FZv";
  b += "8fpBXzWlWX9gcGAFV7MLmcyW2ZKeVa6DJtvbQRHGMlO39rJVAIlZSNCfktJjhu0RlwNEOiWyRyG";
  b += "V91Zkm23oGxtZTz3q3WVtPDQRvNvVsWbOEFW0C4isdsyailIf5izdktC1m2pXRtqhaaqNtHypZM";
  b += "dWuT+kfkkuqHKNtNmvxUmN/VwTOwAz2YSAH7Dx4lRqCRucl4wgBxEdlexIgOXw+XeWqB3KtBy+Q";
  b += "A+gr50q9HR2tMtbmTH+XnOnPyRm0sZg9pWypHP3bTKGRLSAypoPQkvLx/ktiMMu3PMJQNpFD/pd";
  b += "UZVBiDWU5/JllVn7RgAah4RjKPoOjhxhWfqFY+YUDR/tVPU9bQ1nsgEH2d+zk88zkk6kkIdWsZf";
  b += "tAnOls0BNixnepcbSSI1b2+j4VYGn6Ta3YGsgDinW5pCsbUorxruIYIaOfwxW918GH8h2+DZW/J";
  b += "SpAamIFYNkbsBM73iAbXPAMcJoH1zlx7/cE2J54Tw+OWg0aRBYsZvsI8NgNJfsBFltmaTBYJ0vv";
  b += "W4vUEC/wKJ7YONGjBZs7uHV5MCTzYEgmiXOuwVZOPCPwIJ6wO4pdr2aJuaE/G030afGf2Egjy80";
  b += "T0HtuAjggT5pQeeczPJq8vlK/7jvKYhJ3hiCMsEe/bz366ybMmd5MGSOwGJc87aUnyIsV4HPZ96";
  b += "IZr9P06MJZLHuYZbC8CzuuMw0zU+QeF8yd88AJzz2+3ywDd4l9AkJAZA6k0Bi4Yb6j+8XaBU88p";
  b += "N7W/er1sn3F45KoD3pjcAPXYFzz3hrMeAanY26C2QMEfLLMifKXn67Cys/wG/ZQnAI6U48kBjDJ";
  b += "8GoqWsw9l1/0jjKgWCSU/fcGf84dLdr8u3nIbJPll72jFaztPN7YlDsoT326cgOKwacH2JghOgy";
  b += "VAlrulHKIzZ6plFZVCgs1/R7jCVMQNSisSm0xNg/nXj5ri+NqtFLD3+dMUMvg+BOCmaVhRVwzGf";
  b += "kYFAABPTC1KjXZPqoh+kzO9v6MD6rWWjjIdwz9/CPNgJM8WL/pMTbg72tBU/wqDm0sZCTbulfJA";
  b += "Wd3Se9RR/jkz/uqnvc+Kq9/QK/fBptizPny04rxN+XWEr98/gfPezKnEEbk0ZkbL6DPXvghihBl";
  b += "P6tYQ02LpczxgzUbAFMv/yUiBBxWvsbw+NmmIsjGWA34UsAnQHC04ws6jVEWar/Ep4bng4EDy5e";
  b += "Cef+dgHWf6JGgn30/78m79otmcC+fSWjk+IZmXdIbxAP9Pv18CcXNIdVLIaTafxsUfqal34lp4R";
  b += "4Hoh5+7wBJEEM54ubLN9GCW8rTz1A//KYWTdDWnsHEvKCluIvm+TrafFLxtM1YHM+rQpUpFOnzI";
  b += "uAqM84bAmZMmdMwPeUoG20RoSnCPF8Ph4t4uzrTvMApL2rp7guaDyp55RZcygVmKi6GREU4/iWO";
  b += "f5njBxL3QiiJaNcLi8FyZqlTh4Lk7LgeiAnhVzLYtLIfOf24d6d+E70DvFyqK2bUjFSqfP4H6Mc";
  b += "Z6t/sKfjqnaEuLreVF9yeXhquhbhh86C+wQOIMca0Git8sbADyukvYNCaPC+x6hL6Aj7br/Rqko";
  b += "yypDEJZUySgvdxLQPSMgPiFXw+UPFimNeXzFhfNk+0Dv0GmYy68WGpwkB//6xiRGtpttzCI20KM";
  b += "xGIMYCJSJNp+e5pnnGv/5AxupVkpmUXVbUaqdd/ODDdzy/PC6T6FE43z/gkN+vyBV+oxguBkEAo";
  b += "FJeU3Go0ubDzVDG9sOupfDqfWmg+Vaw7ST+Xvu5/dmH2qZM5vS69G392Yfopfl16p/vZheSpkyc";
  b += "prn7KBNB755TEQ/imU5yc5O5dp06ePDnvY9nl/rliamHPU1QelYGi/KdOUogtaKouaGqgoEmnoE";
  b += "mnoElb0HRV0Hksive87ywio2OBrgekDJ13xufLYtnw8Bj9x0gCAJUvM7M2s/LS91Nn/1szQtjOs";
  b += "l8PRFmN1eObEDPQJLNRLxpKeT5y83nb5FOlQA7ESryApK+E/YXzUGEYzAEibC+HPKMpbREKlZIB";
  b += "3anPh3LRppzSsKI4kNqAXIbZq74Y1vazP/HluCNklRM0Ob6ocGDkycdl9koOPqmyNgk+LvkzbwF";
  b += "gYvVEzmo3/HdoA6NYmjs6MY/fDoWKvEVL8gFZExdDXlo4toAQkRiyEhbRY30hBW+GYqbPwrTm0/";
  b += "ViEnNusp4Ak/UEmByaAMmpegJMOxNg1kyAyWoCXGDfIOmGMimf/UEZBgoTLZix0jcuEmm1+dDmJ";
  b += "h1eYqP7v6o5wIMMtrra+ngSlLwXfonFl/Pg+CnNKz8kaTIn9ghCOUu74bKgw8PU9EIEU5gMGb0e";
  b += "tCG6v6kqrhGGA+Ac8XpZsdHCnJgdfK3mVt+mD+My2qncc8bpaNtZBHc7Ie4BwLX1s981jCXQEXV";
  b += "aXvgcW/q/8n3W9P9pCvgDL8ONbV3QLEbY/jIRq14jlRPrd1Teyf6dZj6bShU/+FmR02bqkFxCKA";
  b += "HJEz6fVcLfDk5huZf9F1DxBjtPMWjSnHnuYz54Scs5oJT+Np9qeG2Rnge7TwkHNRgyxyHM32Uih";
  b += "6M7nSKwJLzy5IhSEiml9T5K8SSEmrw0ONqMdkLBJ3URmphM+SnBbhLDcBVjg62gunYgXrQDYQJe";
  b += "+lwVsLREAWuzfxcMvv/yTyo9KeLfGf8oMKYHD2K3eWd02WBUkfIf0e77r85Qhs9h0zOnBIG56RG";
  b += "sJnvcQ8abEoOqqd3eYXu+phhFem+/aG5XrbxZdvrW3A/IAkHRKJnMCS77JjHqKzxBTp+iDuc3GP";
  b += "ht5Ie3lsKj3d4EPXBIUf7xD3/RK1M+0CqfxvvJH/miMAly81eMtMCxbQiObQMmZTHuPajMB2O5A";
  b += "ljwgmO4+XxyjxfC58reAijneoHYxkU48zI2VeJn+qq9GIstj/bN6zljriNw9bjldZuX8XEb/iTZ";
  b += "SwwonwhCM0DUC4knR4nlH56jhqyh2fbuF+hl6Z9WLWoz9n4IaPUWigvlpsuNFdkOqzM5Ux1lrnU";
  b += "LKaiALcIuU22xpGuDlWco1vO6Ane9pOxhtFQeF+PC4EfuS3/u8nmAwAn0N1GTH7/MMwPcb9hrsX";
  b += "YQAl1k3lNOYC+EbRkZRo57WzT4kWD0t4D4EZHgy+ciQPA5wffU6tnqBEqQtBtiKzdXI4KO4fcdf";
  b += "dz+yN/H8XveoJSWUVhqJopKANEjuSZ7EyN3R/R2nbmRRonBI3ee3CWDbsU3X+jguNSyVQaYTq0F";
  b += "c5Uapp9cgNYxpNWHLnP6QFvb5eSXE0c7vqc0rjDdz/e6oiu9A4vAqaHf60TVHLIF1mCEoI6wKBr";
  b += "RoQi+m4O4d0xAaz2Oe/BmNXv0ZNlvsctiUFY3nbLhhqoB0gNMqV3AhA545xBlPYXl2OkDWCRC72";
  b += "KN/mZYHVv/hvIE9m1m2gEBdp1kMD3P7Mg6dFdgAdADQH7YU+IKRvgS/HwjwdGdZrssohA7+VJOj";
  b += "21O8pCW0QYGy4XYo/CYBtutBk4vN4pp7ZK1ViZxjgY7+0UtRipz7oUWBW6yogU4bi0Ls34xJoac";
  b += "ReKaj+6ozBMrcOUKbJlY+ScMkm2VMwcDzrZYV9+70Rq4zuKSvc4Cl7dRF53NzikX6Ol5VVnDmMv";
  b += "gX6T9OXWvu/2CkrsjnmfD5F/QdSq5pgIewcsSnFIjU/BNytAGFakUNZzuWXzfgXq8ZO8gxSQYKI";
  b += "FiwRLWgIeulNWsQBy7OUUVrLRgHCtjQRnZc3LZbHxplaXMAGutihC9H7dBOKGqPP1kVRvfGPCyK";
  b += "s3nvb2C/eTan+LKQUtYZE5kNj9N3YizfPUya04yG+2S168TyTXDfEPyC2rk5cnPK3MReSqQrr7Z";
  b += "VGlsiiz7TABGJ4P6Egc6WfYjAbukoWnQQK8VyGY2VEEsc2d7dfc7YJgFJRrGp7hpwCxOg8tcsfZ";
  b += "yuCJoz9y11PDRU2bU0Gduk7jzUhm8fbCfZfWpEjtXwXpi/asSS1iBz4qElghMqtSPickFGyD9DW";
  b += "SqTBqz3jZjHb/lG+qZgkbYm2GjvOWiV7eG0KtbLnq1vdBSaFdUQU1b9Op1Uoig0bfsPQsOLYEoX";
  b += "1ORdwAr65om7wC8MHgS3IBuTKV3GXBhv744YM65Scfi/LJRNHgIzIko+1GeG7iHAy6bFPCGQfZt";
  b += "Oci+ocD6tjAxtDGDhZ1+y0yMUNC17cQIpcmJg66tSuXkhPIoM4sLjEzRsMMYa75mAu2VgYZ9Nne";
  b += "GjHIoJuyve3VhbML+xiDntAOjPC01W2frxOMdyiiHdqBCMffW09UNF68I+G4kPZv3mazbCoUScs";
  b += "GpAae66ATwidKlwTspdqABpkrRzqpKUjnUrKpSffEp81CF0ifYv70wdmPMwzRkz5QaNeS0lXdV6";
  b += "SW+giUXDDZl+0DZPlDcB2Ui0kmDd+z8qnLmQ5OGOSrgPBnJpGZcB4uetkVnbtE49sV+XAbpzvpQ";
  b += "2OzcVC/Zubdi544hYJq8Y5COGEclNdI9ift890UMOAATc0bu/gDaWvYSmPQlBqsBuD3+TGQPMUo";
  b += "Z7Vv89QU+bIyBJggIfv4K7jVc8HrrDP8tl9g4ZtCREd2ADJNap+gIxtEGzYXeJwoFdglAei1zFp";
  b += "0Dbg5IfCkzi9FxxmvLG+YU7/88e7Rcyh9okyjSM9fbADHd50SXZWK2eg1BX9wnWGYCbxOxBXKaN";
  b += "3iO+Md7GaRmQO+I+UPZ7rFjjmIovid760phVxmJL4OdfsZaCkb3S7PnfCELnHFCbGzE7afwMmED";
  b += "ySxvWDkkyP6HkttN2Y1bTpQjNg6PREMbsVk1BD9xhaKeKBtUsEGR5Mr7tjlEW1IGkrGR83UL+iF";
  b += "qRKvH1i9ieLP5Y6ZZWtBXiAu95JlrdVLrHWTIFZq1rroUIXuNtj/6g+a+Xc89EaOaMv5VXsQqNx";
  b += "c+AysgkFe5coHGvpqYslKq+xrecVxhYnZyiSHp2wn8NQ552gl5l0Oesdf4xuzrYjK1KOd8p8Nlh";
  b += "cJ2yY93iR35BK5VmfePlAHf9hSYmzPeVIzDB+0NX8FgMHqA8cPXTghk5iV77tu0t2ubT28OfTIp";
  b += "GYGw7gq5A0PJPRkkcnrm0ofz2twAfl7xnkaj194CzJl1JChO4Oah1yj/10Vz1S7n4HXQBp1oAYY";
  b += "SG0+7fEH3e12XOWZoxJZAp7aqiz/AmIcslr7mLZM2c53tNfJhZfWsXKtn5Vg9W/HBgceDoHC42p";
  b += "R5+lDAkex72Go9wQfwxi38ahXj2W/6nGgczHmAPxTlKM4csZ2OZ/9V///kvQuYXFd1JnpeVXXq1";
  b += "X261ZJaahmfOuMM8mBLLVtWy7Js6bQfshB+AM5AgBAmEOJUO+CWhcJDj7YtQIAhSmISJXFABAUL";
  b += "sIMgChHEuWlzHUaZeGY0c5ngG3xvlLnOxCEQlC+G6GaUaNb/r73Po6palomTL19G/tx19vu11tp";
  b += "rr732WoxTpF5EsxEtnhMhNl5ECR8zQtTKJxmwC8wnGTdgq5WifKPBQjDwqkPGQ4SNgsBmLiKK8p";
  b += "BQK+jb53MRFLx51dI6wlE0T3YvUM3dmnrmy5Rxa6pbWzMOrwLrbCPC3JgdKRLOFc7MN6sj9YiUM";
  b += "fo/PGRqmUyZ976BigGeeYBQ1QcIkKnqAwTVHg7M8FSpHcMLtb4aqbJw4M3LHfhSlJ9KsBd6ZKnQ";
  b += "jei9wUQFgWZnVAXb9BIDTyQ8ew8Z/jS0noNCPD+gO0yOseiPJYxH45E03LE9XbydG4mZNjpMGaE";
  b += "xm6LDlDAewbSFmSMUM20+pq1mnzb4ZtqoqO9n0+YXHmv6prdwTa29fYUOZcS4VZbZSGoy7Bs5x5";
  b += "gl9dSDWRrSWQovcbTMqKSM8qEluddh6bY0PJoOd6P/DwppZtwh2h+1bh/pmsgOF5+dMfWzGebDH";
  b += "YrHMNyheJTDDQtO8l5hH+HSnwuH29SDgx1u0yiLa6asd3CtxWFIrs+T8QwyR3tWgSfMPcXcTv1T";
  b += "VvyUk0sjjLggNK5iyFihxEhxGgJZ2mFtR1I4DVl7frE9+87UL7TnD2pPXdP4hpHDDgk8gD6tQnS";
  b += "tJFV40sm88mXvNjw8VUnC6G/Nq4EMEqGQ6+cr4isA4hwG+ZBdkaYCYNMAoG9XJNArAEMPA7Migb";
  b += "4jtCsSqAjaZArJJYFjA73C05zoY54qJPDRTjY/tUxxPND5qZmnyNn81HR+auaEFfTPD6eHCiDSl";
  b += "f/HLSR5NukkJQ7/bzHNv+BZzd/iZCCX1vvmc2jAfA7pfIb/sPns7Y9keLq3R2b9ccCVxGJS6nXC";
  b += "bOZzyFSDwqUoqKaEegHH5xP/OMsV2DV5un9NKromTbMmKhQu0O4CpFPPJH+jlNHcAStjSK2/IKn";
  b += "NVqZWWBkyTFwZjrGWrUytd2UyP2IBX+kKCFpnYmHuB5dDKG9Io1pcqLIQEAryvgEZ4QhKjmlJoa";
  b += "gI2+Hgs7NYYkP4OMqGMwqveYH8jHE4I6WdY+RCdo4Ru2NBbfK3PPVdU6ZknLMiJQt7KVmoS68Zc";
  b += "0o21A+LTdQ9VILFnqimQRvj5ywrVMs71MxgsaYdauo65R1qaoeaBhZrfbBIW3fPuuQi8DRN2Qg+";
  b += "TVM2gpwCjOIUoVQfAZ3VYvdlxc4+T7F6U++nDyjX4ttyB/7BXEv9++FavvHPn2t5AcyKQiP25+j";
  b += "jruVHRiz61fv4kdEB/Mio8iMj/0B+hEIDYdKjc+6LzYEUqm6++NyGa7gNdYCHdwN1heXQ1l/Pns";
  b += "v1pwTmfdwCKbUFU6oLplQWTAkWTPEXTPEWTHEXSrG+m7OyUT7XedlI57quB5l8rus617aqyMy1P";
  b += "SKCBamo6ssTmR2JCnRdNuLxkh7W1IBJAkFTBz4qBRNafAhqrqZcvXVwNzihQVJZ3K0DcrRNDvsS";
  b += "lWc2lZ6rFZWgWehZIGfSCiSmFEyAx2rIgfMLdJSDE23HSASYJ3NQGaiDStesKkfAYlpzoKISlnc";
  b += "HlVdJQwYVpqGKYehtNRQP+Jpa76smpbNDnK/zPkaDuxjQNCoyZPIOmwQLB7qqlFdUCqva0FVtZI";
  b += "ZmbEdiXpE04J0Hr2TdNMKzJNWFaRgxbUVhoOe+bjgTiw9bMbjxHaon/qgTqHfZVk6uhnUorejr0";
  b += "tdhlaiYi4H2Su+o8b/cNkaDKRxRwQXu8T3jT6YN6PiWJ79PfQLeD57F51XrvIf8uC1fB33ZmU57";
  b += "KmE5iDc/+3yt7Vmvm3jRPbJ7vVRW5kOSdKn/rNdZholrp8cpqoLoZqV3zEt4/UthzRH8ymZ8GL9";
  b += "e+pTXjU772knkhbO9NjQYW8bUQEOnivK1VupE8/T0EViHHxVcOkCYCvBs4f1fA4/yIp3uVup2PG";
  b += "P+dxJz5+JiX3520mlHq0vfE3iBgpt2itLNBY3gjuqA0DkFVaWhlwvbB3gh1YCQ1oOAUb5aeC8nZ";
  b += "4R9FNI0IHyJ4waeeYyrIOwyDV2iaZP681r2KQEWXIInHw2+rMjfmTTScaMUS8P3DWPwvkGb11W0";
  b += "eyfltMb3yX68/HD15Ueklu8Z/5YOLJLCSqOjImOvx6SjGzM7s1Zi+gThuw+39O6D89fI7U43iRX";
  b += "GXe3/PkOe1G9AGsbEB8wFkSXf9lFoOeUd8Aej2ZkczdYNQLN2egDf50U1ddN+wE90iAg86MMLpz";
  b += "MSqAKwUQQOl8fmhRORUztymHq9IH0qXgU5eMwz8tVkqSEubdy7HDOIf9SDplYwk4zJcMf4fCNTw";
  b += "B+DltPi9PRv5fr3Y1gw1b8fw88c/Mj4+sY1+owr6QcxonixVREeS09jqNFB6C2PYbzS7x+Urwhu";
  b += "rC14tLENQsePpCzB5afa6X1TZxH4Qm8mGZb+DfO+BTcRw7hEcPEDy2XD9oZC1T1iJoT408ruIWi";
  b += "GPPqSF0P83JQOeoYEDxMGI+HEJo3AwKdgLLvCaUIL380MmVNpvmlM9dJEKkQDTWvQLf3S/V+BGE";
  b += "n2qjSI/l5WkloWJOGj0/eqH7cnXOHDXZr0HwX6nPT09wx+T3IGR0E3BZNGcauQVLNHa7Lq+masK";
  b += "klnSLxGMemySY2u9M7omzEgj4QOekmrg7cngkZ03Spxz8E8bEPxKLcG6/a8GRPuPc/fgnlY2avU";
  b += "HGyrgEij2j299OJl2crEox8nXuLUjDcfHt1PUxWlGV1uvZwe8rLTJ7qqEwz3ygRsY7i5xleINd0";
  b += "XasbYK72FnTa/Bz2tvMd2s3GxXHRHAQvCOmMhZ6xB56o0KKXkiH2iknBNHbDjuWcH2k22b29RB+";
  b += "13FubPtVdSDksFiTc4N+wZFDzihGpYu2oOLaE6nYWqtrldmOG25O+gNd9QNzOP7zLwHr/Bp7V4R";
  b += "jDTgR0x+kh+pb6+1VZfa2FWvtdr1NoOfcwOnjyPtlDs5B1w88nTWavqJDbM5LV0BL6ZtCHjj0An";
  b += "bUTaG8lav1Pj3wIg8vFWtIBQHDqjAp0lMLfeNhI/T1U3ZQpc+1DUTIhODydEUHC7mRTqgmB/Vx2";
  b += "QO9p25sw0wd+Yvi8Ngf0nZA6wk82buTjp6e8Z/AIJEa9IqNDr5uAqeFaha5pAgddC/dZkhNaaNF";
  b += "5wR2mEzqx0LMcyQSQ4iLtR5yDDSgNTZEiAZXjtHEe6IKb5wsQCUUL6XbALbWL4NpMHYzwVrjcLI";
  b += "8Jqe5mhanXJXbDxXTDGfLOuZk9zxCtTXe5aRJqO6wp2HpyKBRMJFx0+C+XbgxXH6LBrZ9LQAbCG";
  b += "Q+chAvjI457yFhiv0pPcv0uOvQNxsQ9vtVPFOa5qbllYt9AljdRV5QwAZXTQFaV4RDIOfH0llmm";
  b += "vcMyDRmaaRCU6FwcubC5wn27mIgeOyUxGkHVDFouAICSmmdIRnAGGagEYBqxaq7RqrYVWzX8RVy";
  b += "2DowtDS4jILUp6JZRs+RnqFVFyCEjWKqBkiYUMepyiuPFQESmrBmDcAlK6zX8chDIC03xZGfSbQ";
  b += "OBRiCDVQeAouInnwDqc+d68EvNROkmQSXLNjjz3N9ZNHTdO6pXOBaoJaFgaY6ofVBscDIVWag6g";
  b += "qfts8eZb3SoowsBHxvMWVr7bp3ZJsmzavX/KPymMIk1vCPGTmN2diWn52N1Znio1nYgn9iQT0+6";
  b += "uePmeDozAxlvpDrRDdyk1q0bTNE6RPN1Geo0VuGWz/afN70E8tj3tQce9uNOZ50nZY//19uBhXJ";
  b += "mO0RthsI23MKc9FcgRD/z0pI/gIb+bFz/oZ7YCzhDuUWUWNa7v5KOuFi60SndBxUZhcHUrGyXL+";
  b += "3tes5+xvLHdnnbi5bvlLG4YTD9jMGEKBAymGf1JX3/P+Np0gvh5Tw0SmFkpMJgV63roDNkkH6cY";
  b += "+HrBqOhzoaFuAg76+TltqOA+4Dnv/Ae1lsUyzSukcoGTmq/mFtnH3GqDl+3FVGCs7UhsZTd0eD2";
  b += "2WRDS3JzN88RhPXHJlHBqPDM1J7iiJ5yCMy7YSfBMKz4E+vR65RV4Fs842OyHL15E6XTKANPqTr";
  b += "gk2W69c4UUiat3Ll2DSkY26pEAsZocedCju7Ks/aRu3XMZV1U2lfEG+UpxSUURoUIfXRVqWVpwn";
  b += "/cyqtk0nXU1utft1AtY+5EXuPYjF7b2imDZ0uPizXgT46ro53Ev8zp1UFHO4ClKK6LOexeEqGfy";
  b += "uKd8rWnzTGlu1L9Ghqc3KHFQPJWsC+Ppv2AEPe1oZ08XGEKPU5HNhLc5naumISbDU5rGZ/axOYK";
  b += "noSRH/zlwDEo9Qgd31NE+7KpxlROeWle5gOnKrcS4/3wm6ajx7oZJyrqnk6eg05TDSRCtjQumhF";
  b += "bKRCR03nLEVVqm5u2/5Wka9gwfFstBRu7q9iwBH5p2dTL/JczgqQVmMPonmEBXD746DS0zDcKsU";
  b += "mR5YbPrltE593qVDKXW4I/M6YgPTrVvTpdgjkYubE5DKbSkOKeNC6WvZsY86HjJrntLu5KDhlrG";
  b += "R7fv6qo+u51wHY/3gic9KU17adITj9NeTyNYCIVhP0f+O5T5U0bo6b/LrZ5wG9arcecSPlM+O08";
  b += "7k44OAJZN1Wpl+th7H1cr6fqlbT+Jut4hFZ8+B8MQ6YNzjxujB0CFU7Zdq5uoprrO51ussgDv6e";
  b += "IKMBNRcccuWgUn1fyXga7zXreHb3N1dFUyMuqiyijFBxAMefodqrq5i9NoBcb4kI7aJyjYbOhNj";
  b += "cAmjF2Sq4G1ieXpLhUHxY2bpCO7bqJ5P+1F1cxzHaaLDMzWab/ShqrxgmlNA9D1ePn0RrjdUKSY";
  b += "Z31ab8vQkCqBuYQV0nbLjB6PVu3VctV8LZ8O3sdzTgCLGBu30is9b6GKM0g+kBuFrTt3DOqpR/V";
  b += "nPesY1OMZ2FNnpc96+TJX7RkYzj695z8DV61j0PMtM6yTVzKeiVlbnSqqruRHxKZ6hqyZIyKkfU";
  b += "16eMMLdIr71IxYSc5n7Mip5X61Iwc5H/Cneh45nxGbZnI+Zf2asOrmqbk0zEm5xzpt1WZsTNg3i";
  b += "c5N9WXWNN4yK/CW6VDfugbhZG3B3tbKva29oN4q4zrvvcAT5rNeFnfCsMDzXumQ2TTDrJ0HOmov";
  b += "MnREvazz8bybllM/jF2dLi6VqDoUc+NNkfGWudk+b6TROVzRuPllbVO3Ga3ysGtm42Bur++dJur";
  b += "OLObmhQ7lcwHUcHzdXI5akh/jRnM+C8Ft6Ekbgkxmzu/yXgoisWG++IjUta3RYou+5Okbd7N3DN";
  b += "NdrzlBDMPvLo4QeIyTnRrkpGBODQAUXlkP89QQTcHSObUB5ly9uZozj+xjVadkP5JqdlTlMxrew";
  b += "OCym2YZu+zMXr4GzehvAmdIvpVU05ewniqrRpIS4FlSUNwQ3vXwDG0GN9NaN/V36vV9TU2+QLnS";
  b += "hyEXj75O1buyV6wUO6XWHdDJB3oC5LL+QqgNVVGTLYiABi3o/LI0JIHD42xclOylslrsRX/Fy6E";
  b += "VsrdSTQYP3GADdqNjnoStMFzFCokP93eW8RYrabWt7QWBfDVG7tqnSqE+VeLjLEMEBLy3UQWsYv";
  b += "adZNnt0uN/eH9QD1tvQNtxbMq8n5HKVuSPgOLsYaSbnviehUhaMPuedYY7bCyUmldXVIYIEDsnQ";
  b += "EeVCNgmgyCvQ/1t65EorqljInWyDYa0hGXDuADSi9LsLdNwPHwpql025Z9201FqXdS3JXD5ooAZ";
  b += "16PPe7ZHUC6T2ra2Pe0N7q6C2JuJlz0s7T35RbVfM0yrgqaZQiNT/vp0UYdWf0+71CMgpOPN1jB";
  b += "YUZQrlPDX46m16UncZR66tM0yrES3x6Vx+LtVNcDSFW/iCkJUiRAl+SaNpOZv9GoFZAia8WJWDU";
  b += "2fxTzaxouh8DOc2ZSQPMRunnSBVI9h3J8kR9vsNONFvH4+5RvVGGBGgttlYpj8VvGbDM0kVfUcS";
  b += "6tCitpyFvGK3mlhHBwvvq7o6t5K3zuuce1NCw+PuVuYskaqi114tanC3zAdk8GPS212B0wjcKAz";
  b += "6U9tm5gF7TcqVlSU02deUG2WKu2bLz4L0sVq6PmeT+qc9MSfW+79iWdpSuapP7emZEBxz/x5xmS";
  b += "r+o+bLrqJbrtpOUoYwYZaD+5EbAdfLdUXQn+g42XMYXUWQa3kC1ZnIeFbVFVZqOOpgJLUOmJIbH";
  b += "I3wspht6iSxBeonRF9ydoZxatJiOSh4+BTjIfHV3WVT1bTAPFVKDnU4xH5+EEpl6tN4IpeO1Cxr";
  b += "br6oOukOcFWcwu0iazqEl8XcQnYfI9Go2nUAAt3j1FegkSo2iUfvQocCfZyL25tbSv/3eoKUPhm";
  b += "N91LWzBxBQwpba1glygoQVWhIhFXad1dK3GamYtUTkeggHFOCsTNGQGOnbMo34prMzSl1JIzo6c";
  b += "gBx9bCqIC6t/1YV04proaSSlpOQhQAivXzZnt86lzq2SLK7Mmcx/1ESZaekYoOfjNHiDa/01rns";
  b += "7AtcDN37s0j+/2VV2LW9tg9gSLAK/fskhPQfEh+jQC47IG/IAN7bjGb0gduKrgwnPLW3VjVAAW4";
  b += "C/1N8t2siiuXy6rmfAqSG3b1YW0r9ufTMDO2HJYnVsRT+yTYGZxbCK3ODZRsji2vGBybnnB5Nzy";
  b += "zOTciszimAfK+miyHLbtlqGVCckG23bL84aW5w0tLzW0rNDQskJDy7KGJmxDTwHQYNtOzVTykWK";
  b += "gtu3w+Jv7uFswbVfndWwEPPJgku7AryuJr8eLMrN29hvzTMFLZtCuTs41L30oK+2qQTsgLpxJEI";
  b += "Xq6be8olE7Opl4xuMC85KO5hLruopU0KobM5l1KHCepO0vGkU84UOLJPr/hf3C9rhtQvWw6uSWA";
  b += "/N50oMjppVyuufRpA5uB1dc67EC2aQvyyd9Wc+k5/bklhXsyS3L7MlllgtPebQnx76lYfrc50v2";
  b += "5MDNcTvCgdjYXecTXgOuk+npR8y0FelhkNPDgORINiKdx8CYHczeAUPVPp3cQl7igK4QFDDdOFq";
  b += "nL/ah0YZtNYhN6aSmWsfC/swgYVwf3kagCnlSHM1wgr1tE+u8MWhy0vWiB7PYK71DXlKDab8AYn";
  b += "7ZYzt8aHaQn5iOmh6yQJBISe4RAuzIhpfhuzdLskg60usdBJpfi1KhqhlhAO2bUG1f0pjDn7O8V";
  b += "eNS2V2W4aclmL4YnF0jt9C1GGp0LflZpju+6gA3ZP/ObIS46YOfMzs8XG+kx7LQsOpDkofXx9FU";
  b += "CfTisZXe5nQRdFlVlS6gFl66EU2qhMu9xMkPCxv1ioGO9gLJRdYCNohRgLwc9MvT49+EPAwPtwJ";
  b += "rsqqDmml1zOVTYkcTA1pmoJHmMTLxMoGyVdEqwxjMVVJpt73S20cFMSeFMi2QmdqR+31qRy4taE";
  b += "Y+ATXHx34V7c/jc6qsGXnC7dGMfNZTzUicZP7hmpHz7pRaNzvqkV20OpLUONSI9filzqSsbaHjs";
  b += "J28jxqdeH6+fp2qTHrQdoLaJLt9FN9RQRE77NGcZifCKWWDVLnRDC4Ntp9PZftwrkt69TpVrWbf";
  b += "c5VtqFkvrLKd64Wq38hlZh5Ko0bEIZ/eF3hZBeh5rnpe1wrVPtcKYe5aAeay8K5DfoPn9TbQeD5";
  b += "vA7WFvQ3Qv0DTyl0a5/U20Pwn9DYQWqcA1RfR20Duw6ByQa4GKmVXA0F2y0z9vdC4GmgYVwNGZM";
  b += "L5a6gE6LibwMVyPZMMFV0H8JgOfrNfMgS5dyF/PQ4h7K/fSEFY/QW6GvCsnwvvQrxgrDdWG0yya";
  b += "7wSqP+Nf44ePkJ4+MidJjxXdUMcROF9IGnQtUDib6dQxDcKgfAO4egZiFbhYyrNYDlopQH7Gy/H";
  b += "4/CmNjUJ4Nynqs59yOAbTzPssfr4gS2X9OJZii5/hJoFONrWtzOnZ3PS4U8dfnyY/25cd8PMRGu";
  b += "HZvRVASH3/eMb3z8ss136oA5/fFoUgz4CLPVyL2eKsTitPXe037Ll3CpVvmnrdvl799btVKqkIn";
  b += "dfK6aH6LkZFnq2fbtp1SiVWrPat1DChEUMbmK7DEE6C99Jm2+Gbjh8cgI94Q3I09WcgIyzAUiGa";
  b += "wg4QoHdcS6poPENHT6W8FR85Rv/grOgYNBj3qrR8OylSbtkym0M3fvA3U0SGO9NtPzcLQS8YsDP";
  b += "ArTwj4elSVVlVzWFFGEOK+pzqJhT37nkfJD6DdvKN6H+jHoAyr1yxCTqjotniOopzDpY6NCodBd";
  b += "fQdO6LnLUxqV6w4jgvgL6+Q5vR7GLQK4IOlaR1BHXuZGuwIbxylGN0pItxLOuEd+BagVnx9vr0z";
  b += "ElV2p51lS5GjYAHYzmMG3ejrEq0x+tcMGE5unAbcLx6dGqOf9zNV+qyBuqZb86bfYnNUYD7Vtqj";
  b += "i/BVRR+m0xRY81yFoluhTC5qnpmNYYO8eAtdFhyVjLNSbofZzqoR5tm298II5lxQ2JxWm3Kb16u";
  b += "lT8xlZhblXTAtqkp55pyHstJrQH9X7N0kLXKvulIrKor86DEaSV0cVXq688XpM8JF8fqfDBB8OV";
  b += "umq5FR3lFkrVxksm23jkfsxVKNtQLa/BNhm6N8cTtaDCgMR9sdBKaKqratC6NZi3PhZvPgnYlp/";
  b += "fz2TSgOb/YXN/4A4y/KquCmoQ54rzLmVN+yYGY+AbjPY3n9m1qb8jyI6nNrqpLFFv50So9IiqdN";
  b += "3al5Yy7a1aadGaSkHK6OKQ0aas6A56l4z48eJax35TUjUdsB54AU19QV3DSZ03w+uVnRMIvkg+/";
  b += "SD78IvmggaguDGDj6Agz2LE3QwwLuiqmib1CZhz6edsIU97quDPGzR5e3Kj59aqMpps4poxSG1B";
  b += "0oQqXCWFmPYj0skjPRNK45E6IKOlrkF6THbCRuDWYd/ln64TsCpgTGPDaQYIFBboARBgH1NO1WW";
  b += "6R+lCCl0mJB1eJtZ3S9+rO7em99+0LZ3m33D1PYni+xNaCiTxy0uV3uMWIrSoQunI2wQWGO9Nz9";
  b += "56tzconf7vpvXPBXWm0M/ZB1zCHTdm2wVmdxYOlHTKVKgjVxty8McrZMLW4VXf0dXdfJrWV5zEX";
  b += "+QnH5HHyPLEr+7GrXVsxCwlPb8+GIQTH/oUPTL8Kesyepq5q7X7mcdcRKJKmM5Bzi8DoFoHR7d3";
  b += "LPICjp7PH/RpVcTmFMBdy5kf7GQO9fvOroevuVbuWcGG9d2GnU2UHVOSmZoZGXc8PKtVaWG80W+";
  b += "2h4WhklMbwLzEq1x4OZivk5/Bf4Fw2Dm/A/IqpfiGH+b/xW6MDSzx2nhIjA0s8dZ4S0cASp89TY";
  b += "nhgiQe+tXCJoYEljpynRHtgiWfPU6I1sMS+by9cojmwxEPnKdEYWOLYeUrUB5Y4eZ4S4cAS3zpP";
  b += "idrAEgf+cuES1cHjOE8JPFqGbKZL184o65ZhMiv73xz1BQ0vOuoq2hMip1I+W1twwbX94QXU5g8";
  b += "czdfOMxpv8Byfp4Q7GOa/s2CJJrk82aB//juud9nej7gQgBzo2Ju4vbnAY+xGPcdRugae9yV67+";
  b += "XmLk4aMG4cZvYQX0J/PHgBzSfl1mNaI312aTf93O/MO+mfjkRHXbzge3bptPdKPD1Pj9e7mkNOo";
  b += "6c9w4A9+J8l80dHS5k9yXakZTLbrI304HC3M8GbNNyPQe0GF13zVWPzDZomNLAC1ldNm58ks+Kp";
  b += "KfM6HI1n9mXDbrJSfp7ODFnAMGxyqfw8k5m0pZnXO8wtm9Nlc5u7ySKpexFmoU5D5otyA4AavQi";
  b += "GzFflhswXlSwEng6todUzFakiXlU0ZM4Vqa70zlRsjVW9S9sn3Hcns/ddvdQ7W4HNDVZC8+2HPJ";
  b += "oE6zE7VaU4NLprkPEtv6ebftkkDDq2Rm22IDNNQ4MnGQLLlZmGDmBTzs9NQwfTnppnDtfpa2K00";
  b += "lmllqb83EI0K12lpoyR1RQsGh2DDMZ7lXHLfsizbxkqarwxpPGcMPo7YZhMUeSibZhLfZm/1QpJ";
  b += "1fSUTEEivw/IFP4bs9jV9FmJXSq/D1btalfT49SaqKaHqtbMOad6X3XKfyrkt39Qvo9Sg+9ItfO";
  b += "v8PtItXMJfo9WOz+A37lq51+jXppnOVbtps/g1XjnZRL6lt+Nk8xw93MSWpq1PRcYH3Ns9V+v80";
  b += "7BY9APrPMO4H7gknXeA/j9V+u8/fhdLT3ytUdPhVPeM+b7qGDoGd9ARaywsERmZAmvVTSsxogsb";
  b += "LyUsNEsgLAaCuqBjWYJhA9lFklh0f2lgJSPuUWLonfaytSiKP1wWDPeNBhzlxqZxhPlSLvV5oVB";
  b += "S3ihHhNJleht1jxSYA0+hewe6mAW7WgFHQ37Oqp28uq46nwpL+JoMBwZnej9gfWciD4PW9Pk9W5";
  b += "nGFF3Ja10pYpoJ7vR7/hqwXxYDfUFxh9nC7FrO8NNU3EF1lGiP3O1zjGbGUlI+DxVVO6kSDEOVj";
  b += "s/cY2D05sc3iR6RlHq9+iVMkg/4HaNn0E6Z5GWYME/s5lObypnScB0MiDie07DV6hp9G8x1IFU9";
  b += "RJp39TmpxfD3YJvAkuBifwSXL5Cv2rdeFK/PGN5hob/7oJVdj96X0C3GDJDVB0nQp7O7OL4MDgB";
  b += "Icew9Y1xqUzQKqU6MDNuaIAPApDlUxN9d+X5nnP6Mo4ZE32HrM16Pw6NzXpOYZgTJg4hzAmTn1k";
  b += "/CpUisZUwp0hZI0HZnFY7M60bwfZOO3cDEmX2FiKCLt8mCUHCFQTt2lhMAARU0ge4dNJyxWgDCZ";
  b += "DBaZGBIlrawSfMp59Vg9fL5BN2Ay9DYDEt4VO59rQmr0ALd1ESBky6SDFHrV4IJrWL5nGBh9F/p";
  b += "EuPy52QbkaNBcfLnXr0BjXfaKk/SkdFY3+BxcMRnMxMtpF4hDzBeuNOJEdZKbG+m1wMFHssM252";
  b += "uTV4eMLRiTcEQdGZlnXji1fLUl6cVq3fIy5D9F6KpPE2P7l4UEmHZq4kZYV1t0AbvRebbJFk82m";
  b += "tKIovN4tLW+y0UChD6FyhBUYKayuIwAJhwUIhJ8kaTgnQtGRpq32qtgLtuPUHgIsoTqTeiOlGSu";
  b += "jsRIL3LkzTtQGjQQ6jbcBwBOhtxyMA6nZmei1rRXq4VHIUrBSPZZ26KB4znbpIs1+ETo3lnZKKL";
  b += "iJs5KA61gOqJNorQbRzxyEk2fBXEePj7uQK0FuBRym0zwUUQ/2tQyPRuwC+K713AnQBmytQ4kFX";
  b += "oP6Khzs0M15hAvwFVwTjUCWfW4WKG4B06Qek4uOw4gV/8LBtJV2CL3YQhZ59JFY7+EQUs/q0Geh";
  b += "n5vMrl/oxTXym4xuctebCmLXCbNJbpOif0ayG+rSi6Sw2mDU0DNe+FVC1m+VnXK1VL1NT1Ytppz";
  b += "pejhusSrxinbcW8lAY3KmYhm/nQL03kI+Bt6wfg4Qvd3DCfA4Ia83sqHiLEv2tsfguo3zAhW0iT";
  b += "tx++gGwc/q8C7BDV+luUA0uB6ZyPBte4mcdiLFlRDJHK41j5RowIM4nbRX8HdUwF9CGbeHQUcNc";
  b += "jMGCKo5DNcwFfIctV99hK/LbebSa0ewa7CaSZtcA782cZtO3WDPHh/KCqQFCkO6aGiDMSHexj3m";
  b += "TTYsgSy53Ngo0CWTH5IT0Zg31aTh+qWEkY9bTlEjiRBJ3zF67NP43GaN2EgqB6cGq3YczbtywiN";
  b += "4BYRFPWBZxGL+Hq+oc4FC14yt3j+upy51HqsmSdPwmWvb9WAjjQdX0c9Xc6wr40WXKwVrOMJ0Pi";
  b += "1zjEcPFngwLHOtq59HqNe5DYcYfkmPF9wn5PmRPDSNK4NWceisz3GkZMeUPx8gftgtmL6kUYbiv";
  b += "ds59eeC+CvnMnqAWcVtqLS36I886r2olTWO1Vi3EMs9Y9FEvSwT21y53oo7iM02sFdnXxeTelDN";
  b += "dnFm7hNXMz3uaY4xmOanjGj3rlnK2Moc/LaWULevnx6i1ehmwtXqAraVQ1gK0S+XGqBgaFmLXot";
  b += "Wm3OhdS7FAM1uQLI/f+FQYL7j7MNthGC+nedLok646ZIBb70FZse1GqlptKCC34Va2TdbM/hfS0";
  b += "1PLM8ZRWwOMo7bW5flgnxErgHwV5BvppqttPri60XxNdcCg2B3GbYPdIbC7nWN3COxu59gdZrY/";
  b += "2zrT7HQ7n+lQZzo0pj/bBbP8LcuBRGbDG9FlhI1hgebYztCIamoVN8AR3evH7AYY6Zroobumnhx";
  b += "4PNQjI832KbLROX0R87lT8GyexZyyvuwzUrA5pxC3KxFQkpARiOBGIThLb+J9MJ5odwKIzjsVuq";
  b += "/jnZGvjfQe/5/y1dF1Nd1ftQvv8ZxtfXsTjYUE+JQZqUNwj6dlqrSkJ/ze/p/083GXGpv3dbwJy";
  b += "MczPjSwwtKwkyY34ow0waNLG6TGhx/AAn2qsdTt0IFlHGQceE/5Mj0pw+vMQ+zFfJjX9qDELMuO";
  b += "zkdwdM5I4u9KaDwjmutxTZe5RlNHZmHhOI9DsveAOTAfAkHk92ohmNc4v2Pib1evazGG2y4W3gw";
  b += "de57P79Zj+J2YQLdrbJKiRfg6adquoszKKW+HxMMYTqkj43QVVo2XbHAeQ7uytR7HryzTMV89dB";
  b += "3Fr8DTfiMMOOSqMOAhV4UBBwGruPmrFqYedUMQUFFvOhQPTVovpKT9iR/dR6VXMF9ewUpE2KnxR";
  b += "lG9p9HobihcCz1keXrOCwhfcKBmQElOBgfoJJFurhRoLfZkR1OLUSpuSYJc4FIrC1yIU6tyZNKc";
  b += "3IlRk26yREIU4Ma2itCUHmHVdLDziH5ClnO0ao5aKpqpGDyu9UCEv5nqjQajixsuOrG0CNW9261";
  b += "usbfnO+xmVuR3oxP0hAB3inSc5Wdzsb6rFWMqalpx3NXakWt1VvPt4MpWGtBLJgF8HtxL1hS9x4";
  b += "wMjYh+hX7FOLn7+BJObrV+SXvDWmKtmVGIhpXP8wBflizQVVBoSDlrXWQEfx4Ef4tyau5BWLAop";
  b += "+YGFpTI0P2LEnV2clFO1L1M8FeiR5Jf6XAdg16lgr86XAlClRp0xzOqhfX0rA+bIHKcTo955vnp";
  b += "KhKoOglakGXE0l1qaWG80iwZpLo+KVA9nfdVqmvRwzOvJBLfeI/zjfc4CEc71PIx3uMCnTaDG0M";
  b += "ZblSMA7khXGF5+dHPLWfzrXe4ITNvAizUrPmaZ7wD04zhk/SYZLRA9R2kWqH9eo5xNPWcT5QZvW";
  b += "nKBJTmy6oMAT7ql3p3qlI5/ZypwFufEtWZbsTiCq5Dmut05v1sSN2hnSlErEfEnFsWnAOOxyVR4";
  b += "NVTy/gWXul8YDW/FAiGDBDUVaeACzF6qX9agOOV9Cpwirooo3gFbsY0CizXWxsajzoM45HfolLu";
  b += "IXxuWOc9VqU1x+N4ynME39LWcaQ9WNXahO5E99A7Qbo4DqIPkZUb1asEXb0kINpCluxAPht2Vsc";
  b += "T6iINjrgU/iaAZ6H8rDKzPIqMq+IJXVvGh3haOZ8NrnGpf3CY9dJWsAQPDcuxIVbTs6dhnlaG9i";
  b += "zCc4I7z31gXq9hYKx5P6zWxuu8M0s1975xU8qEn12KGtNnYxn2WcSdiM1dSvQuaLOGTW1PhtJIn";
  b += "7oIaUeGs8E00v2jmB3e1+SXL2eoKX6kVYjCTQ70sk9VTMTJiwzFaWDEJy5CHXG3M8qLIgp2D1St";
  b += "QPZooCeOiJfb3Fxo0CuyomUwpnEtMjJlyKwCCidkamXezrn3Twevatv7ADjGw+P0evQ8uatU7sY";
  b += "DBLj6okb7KsMY6leT5retijAUhEN1OeaRAvAaTmkBtDUTaiFKW21ez0HIBqdjAqyVKC+Onni9PQ";
  b += "m1JyHoSKCcs+2JbGqPxpVHp+P37WOPvEKPVIB31PhBC1Z6x4JOaHxb4RO/R2GwM+9XgHdtxwNqT";
  b += "D2Lrgl/oaFDFeh9Q2x8lITzKJQVovu9UpGjQB8WqJjMj/l4D3o/bI6hNT8xX8dlz/uia3tIQaIS";
  b += "5M8HuYETtoLcj/k04yRfT7CcluJ7PjKNtbhUhGzMAc+CyxwtyLIBa2qCnmOr0SN6yJTlOQo1D5l";
  b += "575jLnWgl1GQfQ0G7GWHKY1NbPVP20prqUpPWAhuxWSXKIRTK3066HXejX+C7C9Jt2UKKQZjKqT";
  b += "FT1sIpWvrL7bhX1FmIuuNTn2iO3iuH3ehp6H95+nYBao/mEMeLXps2XkhzFWaytChPa6oDD+vXR";
  b += "0CFj0qDSwE9uKc7wfcyjwVdGanlDANNn/KOYPn3BYbuBqjxLJQnj/72vBryCGAm+oEqryL2A3Dm";
  b += "An4fwU37frNgiWeWuCLUt5K+VICJjyGkP0eCxDNqrSu9RwJY/eJjiIp5DFHhYwhuhEKNz/idVU0";
  b += "FSDyAIBjLB9W3CH7jXR2RGYt0ZRWkXGzdOhLmZSxeDY2TtVzNW374dUxqAGxcQx6q7zIs2UpvXN";
  b += "+FV1PqBZAzc/BopkovuOu88QIRMycxWhF2krq6RvDSIHog0ERuflDHtFHk3DUqRBQeSXaGjCISF";
  b += "PSGlAELY60tdZHL49NrNS0jReIXWoR9mdS+9PVxbbGP9HCyHm8J/wfNemifN6PP9PRhSodZ6Zvt";
  b += "8ONina/ojfV5V1+LvumxViqQSvDPbXCeBoVQojS0uh3aUP/QYjMbp8o1wfZIsWLv+6/4+y865xe";
  b += "m0E/3+y+4pnFT0yG/NG2n/PLaXO48C/cOpcVxzTJc7vx5nlaM/ubg6L8YHP2twdHfHhz9l4Ojv9";
  b += "MX7cPKenGSgLJDilx1FaLJsc7MVj0H8+F4WNjI4fJsHXE5XXVupKljapTtr1PXGn1bY42qednct";
  b += "+EYLG2XazvhmNrwjnoo0xLMujDEQkODCglcZ7nrtsM1Xr2Wcs8FZn21wx0v50uokx83IZhpgQrT";
  b += "ixtcfecuOJrcPiQP3zFW1feBnkX1FuuM7Nl8OC/fZ1XOQJpfoOvY8dNHHgNd56Z/zTrvSZ+0/AQ";
  b += "eth1Xun6UD958pbKk6+AhfKHrfomug0nAU2aotqc12jbko9vAemWQ1CCFwQrueLyb4OmYVLK0Da";
  b += "hHFtkFarRywjNR9Gpw93KSD6bUFcuoMlMVs3ed9eUs482j/zIlj/kqtJbefLwCs0tBOlfJnASYM";
  b += "TTT+S/nTgJkxwiyF6aVKf80lKa9tBL9QZCSgZDycXrgS+Y1K2Qyaay3+TRzZH0HBOrESc5OcCQS";
  b += "QOJClq1F9iZ3wizcMLwEnHSNZywKcsrv+lmRTMlE9Pt0n6jXujfio57U0sq29Nq4thNR2/WtSVy";
  b += "bT70d6aFD8zzwqSLQMCR5Tvon+gq8BgV+XLN9XAcCaBSu5E8cw7Xg6K+ch6tCgJrxmKtfeTx4cl";
  b += "5Tmhf3sHNp1B6GdDSpu13rTWiqHtoafj404uVcRTVfN8dh9JwX/QZP4qG+FEJMZ1h/KrBCk1Zn7";
  b += "fUlWN+KsL6mTj1PtKBTIUONvutHuPN7DPr86bEjssbPWKbrKb5aqAkFkSPE3Ukt+gQkZPs9XJh9";
  b += "i383giQxVujFDLI95AuQyu9d98zGtXs2OMc9o/AyHLdNzbCA4dm7kG9RLjpsG6Uv2mFr5BvSS1z";
  b += "CPeR2ox/FqeZy50mZUbgOhs2NZCzLOEczXe3oP+ChFLxFtqLP48I4ynIczXO0mSpkpC3/09gMvT";
  b += "a3u1fx6uPidzyyy9TCqN2838VjUcGDNl9LN6WGrwadtlBa7WzSghRgDKoPmI9WPHy586YNzpvAw";
  b += "1ILq8451PtVPsikpyvecbqzXAQFpEOwFCaruibnjQNMXiX6KuAPXj5aAqCThE8PMyPTJ82BYqxF";
  b += "03Rkh7XVAnixXSxwlO82TIFHPC2BN95wxKzPIXK+fz1bjmuMHubvcPq1h+cdfnp0/BEhCc9S0n0";
  b += "AHlt0XpIwHRV96ZLFn6TSiLWYNha91wd4WUaffZrlC28ZjjHqgDlmOiALM1gD4r0JxomM+Yl6AX";
  b += "CZpak0iNjzGM1JHj2aQ7ZPyCZLAfJwV8Jp8AnZPiGbTJ2JxZsJZHsIBzv5vVMg21PItqZRK7Zmg";
  b += "5h4c773Hl1YtmBG4hW6qMwKdCfjEGCdujAutAjnHlIAU2XqCIDY66dF5swyBODEzZ+6nw+5A6oH";
  b += "tFZekKd4HHqahisPtKbM/zkPPNaJKc4zPJEMOM88+1jxPHPMz/c6c57h2Ya7ZvE807/v7a8WzjM";
  b += "PVLmpYSPzzXnGz88zo3qi0Y7oiYb7V3YyO2lPZkIGni6cZ054hsAooVtP8x54cVEw7xHowlkjH6";
  b += "txrtnM8yyknTX1OMsNuiv0WK19VGSXXLc/uQJWIK6IV8MSx+Q+CWb2IK7I7UFcUbIHsbpghGN1w";
  b += "QjH6swIx6S1BxGC/3s0WQ1jH6vQBFqCsY/VeTur83ZWl9pZVWhnVaGdVVk7V9h2YLkNtj6qZguB";
  b += "eQW19cElxD0cbQ9WKdnr1Omel48i/YIJEM+YACE7HqXPfcZsk3i7YiyA2G/V5RAWI7MAwv0lL7z";
  b += "vs7awrwZAdH896er+UTD+QWnAXdDTAG7Dk3xF1xe3UBXoCLVwXpAzFYRfaBZWP+hSpAvDH2xj64";
  b += "RCItRBEt+epYX7oLYIn5rzeipZhfVelc/+qnz2V/XMfm71Y1XB6seqzOrHKjv7dwrDa7RbYPTDj";
  b += "NyH+Qtfna6ERfM4AGIIjHSUMoeT6T4z1TzDhIV3ydV8kz1kpUPmIVyitxzWlUSnps8b04O/Zuh2";
  b += "h+5MXTB7hz85DxduhhHAyg3h2SGI2ZuElglqf8JTyXdNoSA2MbhkQDWnbZSnasiGf9FNH5sDHuF";
  b += "9w6UyQzIhwPerrmHnVKC1Efe89ej/DvSKxM8MqPrRHwUZcU3knPR2yrcoXUpp8arKItmOQ1o3oG";
  b += "5oFV1I9cWqa9zy/AENSNJGveG1DAc4m0W2ZqP/4fP0AkHvqcD25pLu9F69q7rMfuFnhfz88Tee/";
  b += "sTHj/5fn98yhTcX03/7n77ye4e/eP+Hn6KExZv+6//64P945NH3fe+uKfKaDrStsGkLjq012/23";
  b += "aDWrwC2kpz78uNml8YgON8lJPV4UvUzvxcBFy0nMqkqA9wgNx+NR7IjnIWd9eNPySChGUrdTT/d";
  b += "0mlltRjrSTZYoB7FUu5GMG3ZlWbQacsQnfFIVMDSL4xFzi+GRkYPCog0fk/AK6ygDG6iEL8peyq";
  b += "KtxfHyeEV8UaHWJVl9S7OaxrM6lmWlm6kHWP9aSLus3jSvle5Kwkd3Q6fv/QjdndQlNGlCO5Kmh";
  b += "FITemfSktAaE9qVRBLaZEJzbjIiwStNcJ+bLJHgtSa4302WSnCtCT7gJuMSXG+CB9xkmQSvMsEH";
  b += "3WSxBK82wYNuslyCqyUotAkg0AJdPyf/hu/flVzxsEyKZFubOjcn4YTs0JBGr5r+5heO/tkQNhq";
  b += "TMYbWIrPXY2Tbp9kAYsH9cdqfrcls+zXbF3752fnK/fGa/mwtZntAswF+hRpu6s8WMdsBzXbvL3";
  b += "/4t2UQV/ZnG2G2B5FNBrw/WRVf259pCTMdZF3x2v70pUx/SNPX96ePM/2Qpl/Vn76M6Yc1/er+9";
  b += "MVMP6Lpq03CwwKViIbQfPqxX/vqz334j/edfNkUDtuCuF/4w7P3fuLZv/gFwfNjiPji2S/89Lcf";
  b += "fPK//aZEPIKIr+z7m9/+88995U9fN+UdRvjb9957/Mg3H/yPG6dgW8eb/uYXf+boR57+1CO/L6T";
  b += "gQWwdBveuwjWlQaM6Aqv3CPT+3vHffWJoj+m5QBKhZk9iVzmHCul5LHUEYDv2JGvydAw1X8arFZ";
  b += "z2CHz/veZImSNbnMQug8xIHfVN7kmymZd2yx1aZztkJz+HP3RoMr5iT7LZJq1nS+vznBKUDhFw9";
  b += "yQbbIeuZPy1zGwBC0MLkxRDsz0VEEa+Tcx3XTbAtQxnsJRszFLW2aFP25auYt4MbpKp0tDDZM2e";
  b += "5PoscVPP0G+wQ7/GltpUHPoaDP12m3Q9W7o+z4mur7NDv9F2aJrx5W7JJKZ7ktfZ0GZm6ZnKjWY";
  b += "qidyYcVPfBsZzQmV+86lsJZswlXZudLLj655nKm/JUqaYMpWlbM1SbrCTvMX24RrmvSbLe2tpkl";
  b += "vJlXuS27LEa3smedpO8svzrhYm+YpYSt9sk25jS7eVB3WDneRX2g5tYXy5W7JcKfpsQrcziy5at";
  b += "oZbzaKZSd5q67tx8KJtwrqa0OsKi5at5C1m0Uhq92Sza1aYS5fjjixalFyLRdtQXvTBi5ZBffKq";
  b += "BRftnVnKrUy5NUt5dZYybZfzDjvalzPvy7O8P1hazihZuyfZliWu71nO6+1y/tucJpSWU0q/xiZ";
  b += "tY0vbStRDOmSW8/W2Q3cwvtyt+Eos5x02dDOz9IDHqw14mOW82db3ysHgsQkQdK4IQQSSHGbeyc";
  b += "jJ+No92cwa0ODq58DwKrPu3Dv39MIDVz8HBln3sWQ91t0upEHq60pIvUuhIYeDHLfXWQB7dRmQF";
  b += "WC3Lggeb1gQPN6VpfwgU34wS/nhLOV6CzhvtPP6b5n332Z5f6QEOGPJVXuS12aJm3sA53YLOG/K";
  b += "saQEOFL6zTbptWzptWV8ut4Czltsh97I+HK34rUAnDfa0GuYpQcQf9gAogGc19j6Xj8YEDcBVs8";
  b += "VYbUHEN/FyDUAnAxiFQi3lCHsDQbC1hdAUaGOcJaDnd0OGMzJfPIGQ4huKRMigbHx5GrA2C1lGF";
  b += "UalFOQHlqTAYLAmAHmHy5j19bngbEMJG+wQPpjZZxVNLx5QVC8ZkFQfHeW8iNM+ZEs5a1Zyu0WS";
  b += "H/cruGbmPdNWd47S0A6nmzek/y7LHFDD5DeaIH0J3JULQGplO7apH/Hlv5dGalvt0D6NtuhH2d8";
  b += "uVvxVQDSH7ehNzNLD9C/1QC9AdI32/reMhjoNwEvzhXxogfo362cBIA0w47XD4Lmaww0r+8D+x5";
  b += "ofrWB5qsLlEnBnjCdg7jixxsI1ck7Zc0NQd1YgN8VyQbA7x1lWvqqEi218PuqPhIn8GtQxUJ08m";
  b += "6D5s8HwT+cQ7BBAQte8Y+xgpsHQvCP9bND0xYF3l6mPj0bbh+gv2ZBQH9PlnInU+7MUu7OUm60K";
  b += "DBrIeQnmPcnsrzbSyiwIlm3J5nJEq/rQYHXWRS4x5a6rowCUnqHTZphSzN5TiVlBgV22Q7NMr7c";
  b += "rXgzUGDWhrrM0oNSdxuUMijQtfW9bTBKbQLWnStiXQ9KvYeRa4ECGe69ZRCuvMbgyvoCM/PGQbh";
  b += "yq8GVq/uQqgdXftjgyoYCUin+vLKMK7pFAFPiawrkVTAkTq4DhryhjJO6E9yRgcOrejAkA+93Ew";
  b += "2TdwnAPi9OvCXHCYNWlhgn7zGEqRcrfqwHK96aY4VBKwuy8dsvCCvenp+8DFrtLtPLHnakD3nev";
  b += "CDy7MlStjNle5ayN0t5nUWrd1iou4d578nyzrklvIqTG/YkOwvcWxmvbrF4da+bb/IlxJLi783S";
  b += "drKxnWV+4HUWs97n2k69gwnlrsXrgFrvsKEdzNKDqnsNqhrU2mHr2zUIVTdh39tlQ7ODUHWPcqR";
  b += "ArQyn3zYIB99scHB9gd378UE4+HaDg1cXkPU1BRx8TXmjXAPUemsZWXtw8C0GB6/rQ9YeHFRkff";
  b += "UAHLwk2QgcfH0ZW+94Hhx8Q5Fvj28tctmKeW/JsmYE7D3csJN3C7F5Xlx7e45rBl3txpHsMURUs";
  b += "e3uBbHt5Tm2GXS1qBDvviBs252fvA26vt8tE/cezqwPK7sLYuV+N0sSpENahnu7kg/kibdYnL0v";
  b += "w497Nf+9ef4PltH2kmR6T3K/W5AglfF2q8XbD2Xlpsp4K+UPZGn3a3v3FzIrlTaY+0DWs/uYs6+";
  b += "DcQpCcF8WfK9m66EHH3ANQTD4+96s2ve5gynCJlKNc0Wq0UMS9mvJa4HsGfHYNQjZuwbZ1xe44d";
  b += "lByL7bIPvVBarw5kHI/nKD7Bv6qMJrysj+doPs1xWowlsLyP7WMvGZjDcWmII3LrzhDkL2lclUa";
  b += "cN9/QUh++uLVKSM7CRAGe0pbLNA8Pi2HJH7UTyjvnvIxSTvEZRV1D4PUu/OkdrQhQys97tmC3g+";
  b += "vN6b47UhDBnCxe93Lwixc0Jwo6UNP+OWd6celrWPAuw4DwH42ZwAfFATP5gn/lyeuNVShw9nyPI";
  b += "hzf+hPP+DZeqwMrl+T/KRPPnmHuqwxVKHj7r5Wpaog5T/+SztI9reR9zyGXmrpQ6/mPXswzq1vR";
  b += "0U6jDNAZjgAc3WR3V+zjVkx9CHA1nFDyxAdjaB7DyQBe8bSHZ+VmPXYZvPSZQhOT3kRBd2PajJj";
  b += "jLd6aEmBoquApV4R5nE9JCTvYacbOijOz3kZLchJ9f10Z0ecrLLkJONfXTnrWVyYnmHqcIx+22D";
  b += "yMnrB5OT1SAolyXXfP+8Qz85eWMPOfnxIpEEOXnb83MMICHxy89HRHbl+wO5vGS3oMHzko09Odk";
  b += "wpMcSEtmG7Pb1QgiHIT4ZKxD/jHtBlCOnVq/rJz7vHbRZDqIx7z0fjSkQoAc18ecGEBTsUIYA/V";
  b += "KGjR/V/B/N8/9ymQBdhkvEX8iTb+8hQKvs9N5kYw669lZ3T3IXh3dXVqOdgb54QyZs/N/beEOX+";
  b += "uLNQPriDTVkfPKQDu5X9Odj+vNx/TmkP5/ATyxdvgmQddOuZNUuGQDi5ONX7ccn7cdh+/Fr/Lhp";
  b += "l+CVoNSqHMumMBPo1E153MYBcdcNiNswIO7qAXHrB8RdOyBu04C4dEDcFXugUSBxq23cL+jsrNZ";
  b += "bbv41USycfEoDD+vPEf35tP58Rn8+qz+P6IypKBabUTZXUwi9ggmvyI6ZA+KuGxC3YUDc1QPi1g";
  b += "+Iu3ZA3KYBcSni9IY5uyv/ecVXs42m5krWbKn40QxaVfKoBn5dfz6nP0f15/OleZkuzYuEfogJP";
  b += "5TPS3/cdQPiNgyIu3pA3PoBcdcOiNuEuE3mlvxciTMwW75enk/b7R8/mkGrSr6ggd/Qn2P685ul";
  b += "wd9QGryEfpQJP5oPvj/uugFxGwbEXT0gbv2AuGsRd61RGzhX4lR2Gu0G/L3BsCP4q8laUfJFDfy";
  b += "W/hwvjG9diUCsA4H4SSb8ZB63cUDcdQPiNgyIu3pA3HooXOh9cZmdmjGX/vi7zrBL+KvJWlHyJQ";
  b += "18ubRIm0uLJKGfYsJP5YvUH3fdgLgNA+KuRtzVxRsny70pp3a1uchWrg1/marVJL9d6OdVpcm+C";
  b += "pO9T0e+z81jNw6MvW5g7AYopuhlZ4mHfK25rNcrVOUS8ZepWpHp09pSn9aiTz+t7fy0m8duHBgr";
  b += "fVqrlZT50m1Gr0Iv05T1xN9u3uyVpWavHNjslWj2SqPhUeJnX2N0Z/SWRFnWrOo1parXoGrVpFl";
  b += "T5nWVhV1jZLtZ8clS8bcUmNjJPNM7i6ddI6lW1tRUUuZiV2UMyqqspl0Zy4obpfhduwoKcKvyy6";
  b += "YyN1ssPpXrCZVY857G8mq1nJmMtxkmeMr8shPv3lXQm5vs78SqPhmPYZ0L/TL1v6ZXjJuv4dsvp";
  b += "Jt5R8wSKSBYhnyj+Z0yv+z+e3YVFPXW9Hd/sr/7q/qkzYbD7xuR6UA3197ouQDKsWDX9zPAvOsG";
  b += "sNdmAoj4ZsUj/G40v1PmlwPfvaugXHhl/8DX9A98sn/gq/qutMy5ZYG5MD3cV5CbZQoKPffDOX3";
  b += "a0zM3V30/c5OP1lAZvV1+n0ptkuuky+b0tNFwxFPm9xrze6v5xdDi63blF9n5Kq7qn9FbXyB0Xd";
  b += "U/yXc+/4yaOfntbF5/Kt92ssv1Hi2RfGsy8oJ8hq9+MWY4Vz41u8pmc0Nizle2uWSDFZT+REb+Z";
  b += "VfFeJONPL9sWGBFbiyuyMZduf5LPour+hfpxu8X7DcUNEb7wH77hS6SmdwvZ0v1pezrJwvMTXYf";
  b += "XL6Oz7XD7JF/VUGz7B9h1XIV4SLXEr9uwCq+zh6S1xmtwLJc4Z4Ck/ZirPHV/Wt8Vf8ar+1f4yv";
  b += "713hN/xpP9q/x+t7FyAQb51/39X2rfzxb4N/Kvr6Yff1ogWHPbi/L98e50qcVuawqKIy+GHCwvg";
  b += "euLgwubhkAF7csABe3WOFJT/yBkkB1XYEnvOGfDGzW94PN2n6wubIfbNb0LtRASLq2H5I+eH5Iu";
  b += "va88PSbGaAcy75+I/v6Qvb1Q4Uzb36/Vr7rzJW2rXR6VUHh+/sBrWt7QPPFAbWtA0Bt6wKgtnUB";
  b += "UNtq5XQ23sjdfrF0WdALgoZHMIA4feGAOP2PBYjX9gPilf2MxIXB5ro+3X1z+TEANjddMIR+PgO";
  b += "zo9nX57KvX8++Hs2+XlGQUeW3PeX7t/xthREUF2A1vSBY3dQD2/80sLtlAOxuWQB2tywAu1sWgN";
  b += "0tVsbcE/9LOkEfPR9Mq+DLQvZUCbKvPx9kT724kH39BUH2dBa16YKA/bq+F0L5bOZvxH65H9jT7";
  b += "wvkH8mg9bPZ12eyr09nX0eyr4ezr09lXzcVRNjm64pM0l1+nLHw8XF1SeprJOAFXJjswYW0BxfW";
  b += "9ODCph5cuLIHF67twYW1PbiwvvSSowALv+b2A8Nhtx8aPun2g8Ovuv3wcNDtB4hP5HEZ9Tjk9pP";
  b += "Ej+dxH+ub+13xr7i9y1A4D9/Vc1t3vx7wH3LLS2KuIr5/KFNN/mknx7mr+g4Ka/tYxiv7dvo1ff";
  b += "R0ckFo0zup3SBl79+lF1e7QSUkQMqzG8RFAiRPu0FjJEAathukRgIkdLtBcd5vLkN3g/Dkgali4";
  b += "Ppi4Jpi4PZiAPRoN2ww7uZj0ofTvfckYXzjw7N453j/w9vXeZfBD0x81f14VHr7w7Pb4acCMesZ";
  b += "cw1jLmHMWsZcz5iYMdcyZooxKxhzJWOmGTPOmE2M2ciYMcasYcwNjIkYkzLmOsa0GDPJmHWMCRl";
  b += "zBWM2MCZgzGrGbGYM3lafCmgNJF6Uzn/kcSd6b26gY4MzGdNKx2TibXCm8PB+C20BOXTDnk6pOZ";
  b += "DokE/T7g/RhW7ubPekef2Nh8wweupFPxBXMxMnNb7YhwtfiYczNt8++4Z/XT994lP5O3s4og6jb";
  b += "fJ3KIvic3yMsS4JUolkuB4vsX19037Us35mYBBpSM0odxbBQpZ5Y64WhGLzstxPV2Zfk0bKxhAi";
  b += "ZUnSPVwHmDGYuxuPzH2bJ+AkZC/L/dLLcp8vy09/pPCy3M9ell9mrKl0aeMrs8WuNjCNWS99We6";
  b += "bl+V+38tyrY32WlBwglUmS7QbyVLtQDIeTcKCCN+A+1yQZdlLcJ9PYhdn78F9vixfnltO4MvyFd";
  b += "nbcLS1TN+WF2qdyOpbktW0NKtjfIGX5f40LZvclXjm4TZC+rL8ChPSl+WTJqQvy1MT0pfla0zIv";
  b += "CzfZIL73GTCPjRX3/bZQ3OfL8uzh+Y+X5ZnD819vizPHpr7fFluHprjofXqnO4+DNA0T8o9fVLu";
  b += "F4kc74nxkNzTh+R+TgqzxCYT93uK0hn5z9JbTH+A6Zb/WtOfLWK2A1rNpv70EaY/qOlX9qdPMP2";
  b += "gpl/bn76E6Q9p+tr+9KVMP6Tp6/vTx5l+WNOv6k9fxvQjmn61ScATck/figP1PiLI97N7+FRcgv";
  b += "sflOC9Ph+KCzb+MVDzEy6fiUvwc38rLXxxL1+JS/Dhc+e+c+5Rl4/EJfjxr5776blfew+fiA8pC";
  b += "igqRSthHJEkcUhI4smf7ieJIRHGy3A8hEE/mCo66MKsR2gIIcx4vFRCwDZj3l0jnA3OWVfzw6iJ";
  b += "tX0E2gnrR2oLIkyPHc7tMtXSp/FsnU3RdghsdMRNY51dIwSTZmAc6qyb0EjUm+6Zjf17YGmLtq1";
  b += "Iik/Sy3c9I8GPeLTZAdNfVannG66AKgyOwAU9zHHQACFJk/y28XtPHG7vhEpsfEOlhjGoLdGfwD";
  b += "xI9FU6ZQr2pg7MYz0dwDpWycZSTe1PqTE4B16RvPQ7TpfWR3QrqahlMDWMdMK/kYa9YQQ5MzH7p";
  b += "E+TTGO9Zggf+p3MDGGPOabjveaYzvjnM0P4Qs0x0Z5gbmG2FTTTQ1+S9fs36SNfnnei/yqJfRFS";
  b += "0ns0Dq35ZljtOlQBLD4mGX5NqzsAQ+CwzH0RHGk3LneOx2kAzyM0BX48nvLnjSnwU8YU+FM0Bd7";
  b += "pNQXeMabATe59ndyAOE2BxzQF/hRNgSNuXk2Bx93oXe0aTHYzfCrOLcCjB9IabL+fiONVQgojlw";
  b += "5hT8Q0sss6ovt8Y1H8EXh2fWo5PwL5A5NVrFD+no5zZw+s9llW+xSrDUy1T9lqT9hqj7RMtcfr+";
  b += "IBLicFt0RctC8ufFL4n0pMyO+m/Sg8+IHP9AQAdJ/T00in/4HB69EOS+DL1JJs+jcAZ+RO9z3ve";
  b += "fPsfyPIVm3Sb8JgLm4djsRO/BKyYo/4VGumBjizxcDN94INSfkoifloW7wkEDtlG/7TqDe2lW95";
  b += "YLeW4nba1XT2WtNKEFp4xhcMrvSgZGnGdNtBHvZd3BM069IznxK5wEXQe73To0tKnnfAkvMxxEg";
  b += "GEW63dRJh1FzTu1Glm/HLHTTfNMvLi2U5Vfn7kFrqcre6Ig+2y+4eyq3cCk9eTvAK61R3bYX4x9";
  b += "bW2u7fCiRHssEk8q62mozvSubnTziwsejsoVUOp7Uldop9w4O8KdnY6QZP0RujWvXNB9Aq1agQz";
  b += "oHPwA4/PYfwZmlFzRPSIEFe2tX3aQJWQG3vor/wI6gDw4FwdTtU339wOmrCFpbkqmquS5aoYJ+2";
  b += "vYDYP/qBQFEa0ZmKZ69aI79BCLIxA01Ok4eJ8+LMNkhHYExt5mP2SzspqzLmdKie9Kp/kpi93li";
  b += "c0HzVxW1vQXzgkt7vBAafUuK1do2XXuEl/gPA4L4tXhZk/NiKr38HO6EgzTTAKMZZextKkmxbU7";
  b += "KUNAY7GtomOtgETbjA9tnWi04BhorhxU9uL1YBnUkO7Xty8qa0GpWPaOat1YLaxKj3Iqm+2ak1v";
  b += "b+rSmYNwcstT7CpzET9lrRCYC7ZOCC3v0iRtHM7EMM0uRDja0oabKhifFVz+n7K/Hga+cJVgAvL";
  b += "PJObvgJGegV4Zi7e5Zw2DfA2xOn4TCTMdt2lXyC0sDxAEPe+01eg1HJcN2xbd9IBt8b6q19jr7T";
  b += "H+YL3Mtj88Xss26dLntaCJd9MEDM2uTKpp5bZgL43NVuJqEx4a1B8Z7ZrCotuZM4LC/4Xm4cOOq";
  b += "x4BfN337tafg64aykoqaEAK+Tu60S6aZYd/P+sYxIPfKuGhpmWjibTkZv25kxboaHor6kavz2rz";
  b += "c4Px22m/7IzTpWWzgy6tqMGaWx0mPtVFgfC48CcVpJWtSRNbbl3jd3R8TD8NwaFzsqJpOANj586";
  b += "rJCqUMszOrEFc7cDhCIzzoy53Ru0zcrXo+XXSuIDwAHYynyulPf0Ko1frQDfPyKKYswa8TcoAbp";
  b += "FZpk1CdukG7dnNTczooKnkWsnAC1PpF2pEk7RodTNtAq/01ieBbWNcmxiTocjPOJqAIUhXxoxPq";
  b += "bIT+ABDsA1xG0bNnaQ17e7fB5O/relN7+vAnWc4kwS0UKcdctkJ0wUXC+KaBamaBanpgoDjqvYv";
  b += "SJ0GbS9oQWpSpl5YEPdCFoT2VWE4s/lcxQsVB4wBYXVOMSmwDvoFpMncIpackbvIVJMGhjzH9Ti";
  b += "tK/NpDXVaA53WsNnxVIxgpAl30p03DY96nGSsGygQjRPqtDnmNJk4QmyqM+DEQQKdzeucNbEDh0";
  b += "V++n863ZWOs85R91LwYeLpr/oLT4IMsli5S6fvUzE85LnRm5EZIGkhzmW36e+eP9Lt8PnGVVXPG";
  b += "9h+4Ge5ol6hfaIGYKhOsOzAkK2EqrCmeKMsz3bZ64SE0KsTeNw6v1p30CW0ZISVSPmpCM/fei0B";
  b += "q2c8GMgxNxtWNmc6MH+h8Uv10StjzGhtxk4BXTlDwBGocMOhvMkKfSL4fMF2LKSGdXpZax4AGzs";
  b += "WzJ3jjADRS53G/TnSUIbhA6M9WnwVuG4Yl0nA6Gon34oxR4JhRbgGOWJ20CsWAZABriu0CGnh2k";
  b += "ANumYnQfYpL3pzMyM3jiE3mdHp5ncA9cEeY0hbJUOeitlcyH28tLoTDJN8bLqFIjAQqegL2Jssy";
  b += "HCpFViaOl2HXP094aoVbh84RqATlHW70RyFB6H6eDruG6O5VewElnbL8uyNq95e7vW6J8tXxC0o";
  b += "B1XSp67pSwasSZEIssfGBGNTBzKbVMxR5s7EVYD2lcZyel0uXFMWVHrMscU8eeiyVqVJrJH8SQK";
  b += "SRtjoDGgTWKp+FE5mH+20feACXXA4yVDcft8+9Ugegiccilv7hSsBaU1cnCObt7elHx1Xh3unHV";
  b += "sFYIOOtQwa64bGTspUZh2tsIdmdRI3+rCnpDbLSkCs0J0vZiVuZr46BES61re4FDrzAeEIPump3";
  b += "wQuWQGcbJ3pEZJt6Rn3U6n8iJttqBI6AfrtKv1u2A1V4g+7HWVoyHMO2lHd2OKF5MWW6hoK7vZQ";
  b += "cPZOu8UlnXe26oICQPRrvQK8fI0rwNM+cvNcxW3uhZ+cZRbc58Zh1/llFH8mASwD+9NH5+bm5uX";
  b += "ofnYJzwwE5ueWgLmFNFVOj0vUDfqZJWr+dgntyQYpHNC3tk5k8HVmSVI1n3NLOWfSGvdRmrZ3WF";
  b += "OV7g2kjjRIj31KjbhWAVRVekIjCRTkrCj1K1hr9SkGnQS3WrLOqiJiL50bNbLUyXI6nYWA/7PBk";
  b += "zjEpB78LnA63VkuA/pkGkjdnZL9rm70KoVFGQadCx1wZ/JqkF3QI7q+SbdIGBHT0J1Onw+Wo6O9";
  b += "vTok3QDEnRpX+Do0ptT06DipaXp6UbfTSM96nWq6mj4iZGVwPsCAFpUrq6bB7M50eBZoJsdAV+e";
  b += "c3W5p9qRNW7czQNN74HMh3GksvFYoVopxfJiciRmqUQDFz7Zw1cV57mAbkIEF2cDQiKcDTILS7H";
  b += "CfZ+vR9SCGWW+Dzb3lolflRfh9ajF5An6fHLPxxUrSYEaYFX8nDw6KJZjjrAMHlgEBvth0K3szl";
  b += "x5FTibnaIZWVkLzz/XD0AsH/KviT80BGXsaJ1Y5GMmGMxdc4zZiQegpV47a6dPPute4zuCkZ5hU";
  b += "HZT0NJMqg5KOMykYlHTKQRI9QskZbBZ0oz/TE8xEdnvOmwVu9uf5T8yTs3nEiGCzB8aouUOgr9O";
  b += "pyP+eShG8zeleYOhOcMYV+I84fPZx+o+QzHDeuQXYvG0CPOJNpOrcPGs8G59zcWqqUPIAy9gBWB";
  b += "352UYOrmlTvL3yH/ip+BayVd4OaSlrZvFOAmEsVaVfr0jfLlaPip30zN/aU2YlPVLIDucMIKzLS";
  b += "VebpU6fO3fOmW2qlIQsxt57uiolkM7hGPX1Cv/IybpKyoTaiF/CneJwA0w/8ndSm6AmeKbaNsur";
  b += "CASrN6WOesiYVWnI1yvpfnscFo6VQ3XTeCtEOTxsu+k5EHhsQThdt11mmJsLuTunR/99ayY9+eW";
  b += "XbZXvP/iUfFe2bpfPjz3XnEn/exOxf/J1+fz4+NbtiN8zm37sdOMm+frVX5HoIYltY/N702x66j";
  b += "82tugh202/9p3HnfSy9JHT8vOEm57+K/n9ih/9FIRo2L++/JeNmbSadesJZyY9ff+OrU0y0+kXv";
  b += "ivZV6b3fU9+Pu6lnzgjv5/zpDQkGU3CJjisAOAHW/ItynrCLh2IYMO5xsVW+3d0fyPMmNCy9JE/";
  b += "0UmF/xxEBTvLsW3Ghj2xLca2emKbjI16YhuMHeuJrUOCt/3HU29n6gl/kTZvIzdUlT0EBP0JWbv";
  b += "VjnMN3ZrIVvRVCRsfqDKSS93qFL6UDxzqrnaZ00kbG1T4Ia0qm/6/6+AJL4302P+0vFc5pB6Omn";
  b += "9ccWt7QYKwNTsrvRWdML280yCFAFC9jDDIlARubhJ3QlIF8bo8m0GgOFuSK0m9t9HDsR/doFJSX";
  b += "9P1O/VnO3VmC7YWo3fNdloIURYgO2M3aaow6uVdSvAKAa8Y8LOA7PFw0i7UsraFPE1dLxyE46mx";
  b += "1lohZ02d2dTBAdWZ25XTYqeqUkkHvl+ld8JZ4ntMeBL5GU8gTcfAft43J2FEB0nttgvIK+fTWZ3";
  b += "iqINtZhLHIVnTWMbNspBmx1pFqFXUC1VA1DuDTrvYHgA8AjXA9zCdjOtSqZEkpu5wk/WF2MSRQq";
  b += "Ed6EKL9cNzfGTnHZXqERujls4kqHjId1wHw+vg4qqq1NTd2YHPa+GP5asKaEJnpNsUlMtccmTs+";
  b += "VjH6ekk3G3WBnQS5+lsjABt9LlmBY0ZPFQh6XWG80bL1bGhuLoVGYaxKqjF0VqaJyqet3d8j7oc";
  b += "JGsee1d5l8Wu/NmFz5X4XMnPS/B5CT9jfMb8XIHPFfwcx+c4P8fwOcbPCJ8RP1v4bPEzxGfIzwC";
  b += "flGg4EBnID+/Ktj66a1dS5YVtjX9D/q3zb4N/m/zb4t82/w7x7zD/RvJ32okjewc+bD+G7Efbfr";
  b += "TsR9N+NOxHPbMCYz9q9qNqP7xHrSrPCPR6klH+XVTU8Rlj4O81sLiYsqQYWFoMjBcDy4qB5cXAR";
  b += "DGwoqRLVHk4wTWpHClXPDwryx5l2kSVePj+hwV4JjJtoko8xJjlmTZRJW4zZlmmTVSJW4wZz7SJ";
  b += "KnGTMUszbaJK3GDMkkybSBCNMYszbaJKHDJmLNMmEsBmzKJMm6gSVxkzmmkTCVDMSsSIUSYSYI1";
  b += "+MeBZSUj1saobgMXeLAfowSy2IvEhxeHQc7EZYI9w0q853fRJxwor4CKC3q6Rr0pcd+C80mPak3";
  b += "laxQ1YxyXGrbsgVdyBm20iXdxFhKC83tNEP+MDtiWDxKzo4vsSvYMEkVCn5y6+5JTAK3BHfeeZc";
  b += "uMqZ1mByzT0QXdth+dEreSy7GtlFz5xHfYsNk3EPOas051uPU4yKGvuj1wWgttsfzL6IDq4Piu4";
  b += "1vTNgUzEtrpR+n+pPznF+CecLi4lHFN51GUpOU3dhB6PaccjCJejP/aVkr9CzlFf1omQgiD8Sig";
  b += "hNGCG21Of8+2n3k2QbXOlok/Ro9yN5D/nXACy/k7G5OwwGa7MQ3SaIn6nXdXLFC/d53LXjRzKrC";
  b += "b7Yi5jzFbcpUSUy7iYwUL1CidBt6+RUBtpvYBGHI1xeLddyCM039Mt0zf5fOaLvQ0CtdIoPdEHw";
  b += "9l18hF7nWwjjvdFfMBGQLSSLo5+Pyh/P9N2x8zBtFHw5ewJI9LOnE2nHruYbgTzAWURbwY+mWoz";
  b += "wih8xe/OJm09x0sGYYJ60pqallSkII4y4ZDvu566FdrSqWHzr9yoV7TNuD0L3RcW6NTptGgr/UH";
  b += "WhBOUdv275MufxYH7LonpJpFKCmvCICVBF5eOcRRHqX93MjqTDPEG8MY2XIdJn3fMdGT/gYyD56";
  b += "ah1LtFTiA16W10yu0Mk+kxgRE0w0vQkHKGeCQNdqATJoMM2Nu5nX4U42GpGekmLHniEFnCuI3rZ";
  b += "US24+F4RE5B4XYdWlzHLXagd9XgyaRTQ6k/0xmKW+DQWrhS9YEJjmKeIERQinAQ4TXp9OfAbzxu";
  b += "FDga6eP3vfeDAQgq9AFkqwdrcgjp/96HOkcLgwvx1cZXE1/DuC+H17IdCA2h6zUdXUPiMW9IRBg";
  b += "MV4D0QG/ON9BFL9yo17vxaHrUtBNQcNPcvj0bLRijmyR47pxvuOFAQa5l3M57cbSd7GgaRJ/w4a";
  b += "kGp1euJMIEghbG3lLnTMMSalH+26nK/yNa2yJeH0VxbUZGgO3Q30ZXQXLO9t8mk52elbjabCKLx";
  b += "esSmYmRzhC8MmO5707GZmRdfUBUuzMaDwN4yBsP3Sjn61GszygE3F1dshCOBJ1kHJBZTx+nkFpi";
  b += "vM5i/LidJelHjj3udCq4c1nteozEVLCYTMvEzONp+I5Z8tV0s51U0o9JCZ7VhfME4IzLqqSTs/E";
  b += "SLIBt5R9cr2zNmJONs/HitPoi1utJfZtmX7TqoH4bCE7g9koQRBbgNh5FJBa0cZGc7KQMN6RFOL";
  b += "y25KcF34+CbvKTnjLwuEjgnggrUJEtk9Npmg4ivd0ZLvWzdoH9DHWZ2maZhrlMtYXH/4LqdUlas";
  b += "EzNdF6Ia/VFqju9FnMrP1JgTBBzYgM4nACnllY8Ak6rFVdBZhbxDBy36CRcsKKFrSngHgCGT/gs";
  b += "XMdBbjaRQK5lPA67EA7X5c89sbe949lTST2lr2yIvnhZDSogCH/OndWLU4iLcaT2IJNradNU7pN";
  b += "Dl6d3wZFqMvnGz7ylhtKCswUE0e2hkKCIPMZ/oeaFeyt7jPMvuLLVe1UBq0Bv0nirWmvmKhjFOz";
  b += "ZoHdSUlajcpudVMAQdcq3bcN278A1tqGpU9cLmCrUUXNlOJDXes8vaUTvGhV83XF21wVw5ydDuZ";
  b += "FjOOLg2asbDdzwawzXo0B2P7sbBZ9P7qajNXrAzUDuTqW1gjaV2kMwmrnh8iiVjdLyZPvbA407a";
  b += "SU/Jj+qhhSB9OxK3y7t/f0fszuipEjTPqCGgT6ap21V0IJzptAPmrw5dyJb8HJYa6ZA93fehx3m";
  b += "FW4do6TQa+phPr9Rxpoa5sttpxDVvr07bZk4bqC1TMd06h03ZQ2Ur2TqRhMFmOgI089OKK5ym3c";
  b += "lQNj8yL7LLygzl8zNs56ei9YM3SULMT4P8OjbH8S7Zh/3fU8WZKjhstwQUyKbsd5U6SrEbPeUiK";
  b += "sKfsei4D3mpApSfl0tkPqFqgvFQhoOgquo09UJQRof7uKQOV2+SPCOB6OsBHB3H9czlLDQAISCu";
  b += "3DYBfZ0uHWjf3nbpjJleHQ/mfQ/xp5We/K7wd260G+h04K/l+yXpA89ZzcMqjgJupitv1EOqWBS";
  b += "pg5fpAapZyb3P67DOm5MK59FeLtY0+pJe5ZCwdLcIhRJmZ9aKKodUVDmkUrpaRKdMh6r6kqP5Xd";
  b += "9tgTOdr1nviW70jYA6yJw5+WloxClVZ+JvU6MO1FQtp0H3uLiYE2SJjuIQKWjByHkXl2kmspLpF";
  b += "Jyqyuykz/3qPLjvl6oDRRK9avRGSOM1f66DgOcjSPajW+GtlF59hWmUzF4656sWdcC0oz6uv+rG";
  b += "Ze8pptXiloTksIFq2W3jC9JWfyAoVV8BKWfnqlLOz1cRd3/MMh9gWDId7G5Vu1vNfSQyWevDYaf";
  b += "QrNUBsI0dqmAsFY4F9K/Kfs9V0aE28/hgHBl7tEodMNOaDOelMVwt+yxaoSa6q8kOPVO6+jnZLc";
  b += "zkfA3L/ncVt7IXp72ZBKfSYIY+19N3ziYOT+CGhvqyzSnQ8cqJqnJynux2cJj1ITKef/9XHONOH";
  b += "PgoGeHH3U2PS3ysb180Yc8sthWKGCln8JgKaZn0+N1Nq/mKU5nHK1ovfcLUDfzOGmrrPaP01Ive";
  b += "zQOpAIOtFLqw2mrWs1Jnhpss3NuXrBiv3jzqrsVO9BHstW76lJTmH6oUzCS69Um1h97LuMQJjKC";
  b += "xq+LXMHFAwFkG9zsX88+2CXaAo8L1iJM+hoof04plUpNMSMBe2QHEVDHFELjpMjq1nT2peRL/lr";
  b += "Zj54tK7ui5t9nWngTppcLNpQelxx2H11mMJh2lmFJIoJwGvGax/9/H+IC0wj+yX+ledBI6mbJa6";
  b += "RGpDKC1Nz1q+5xirP7OHYnD88pRrlLs6xM2u0s1OyRK2PU4bS0glP5gK5QJnc8mlJN0fKEJLSzz";
  b += "R3HhAE0JN1OHwzU1DsvRPBV4AtUwcZQTg0YC1Hg9lbRVjXhNugEJssq89CXdXuoTdKj22sUFIng";
  b += "1aEJTTdYz1ycefGKzxIy5Y1dVcqMzA70glVlDi0gKCpZE+8wlhUMZIfS4xlWh6TINXaJpk/rzWt";
  b += "X5wHXOJarVdYry3lxVbJya7FTvqmT6P366XxVgVnp3Gr1F1zy0CthTq7cocW+RiFDVXvRZBRmbH";
  b += "r1FL86zB3o5Sq0Xr0/r5VSut+irmv3/RuM9QAWeL1a8oFdjzTjxpjzT+O8WTID/buhwySlgTrqK";
  b += "/UrddssWArfddbhxDuFRuxHX90kwc+hczx0610sOncOCO+2w4E47zNxpN6xDZ6r4PJqEcNtdQyO";
  b += "y/dJtd5i3E+bthKV2aoV2aoV2alk7ddvOzTiaGLfdlZLbbgf+uStUG8j9c7vUfY1UrytKv3ZM9Y";
  b += "1Ao6x/bvutL1mFLGb+uX3j3NsUfiYrHBj/3C4OO3MAsKdL/rkJfndQeQkaauu82/FNiASFuEF+o";
  b += "BPL3fSkOueWXsAzN6WpW3mqoxrVaxPHfG1WKHwTD5++nlNqWNJaPsG1fIJrPROce+auFTxz1zLP";
  b += "3DU7wbfjOYT2Kw3Tp3/LjrnCHV7PO9lRki/TgGbpsd8wLryN4tn+itvYW7jcgkDc5W6AZ0p4ERv";
  b += "zGgMztVLnI9bQmP60oBdhWYBImV9PBfqYE+rYh+RUhKPHFQCUmiB7wtMQo2etGxukx9zZFAl5l8";
  b += "kxCm9srvQCiokdUhkw5siPxzU+pd9m4NDo3GLeXHh6RaCrI2eEHbw71R5syjtgDlTlfrilfrjFf";
  b += "kAxQNjWBjjhSO8IVvCafoXezl/GwLimrMRVPy9AIIqrp+apj6daosqZDHmOx2tSqh8mECSkf0Al";
  b += "HAgXWJbn/2a+hVGKaeYgr7FUXWCqq+bVVU11AaqrN7UeXErVsaI4JHDCePwaONWenWoISuSgFOp";
  b += "lOacxuE33vZiTyYOz7OTc0Vd6QWECoQGeuqp0Yq+nfr7qukbQjqceewdfUC38H66uOPalrucHlW";
  b += "otrDearfbQcDQyumhs8ZKlvHvZd0TO92H0Tb+1FMEHEKwiuATBn0WwheBisJsYqc7yx5DQSI8wn";
  b += "RCSHsP3E4xXL+sn5Tt60m2NaVHXFD2FLJ5meQZZ5t3WIjT2HBIiNDZaLrHv0+hU+kH8GA/uB+Q7";
  b += "+q9ua6Sc8xCytAbmjNDEI5+24xkuFzz+aY7nK4WCJ0zBIRR8KivYRvAZBJsIthD8zqftJELxIf0";
  b += "bVoZgQ1sJTCv3fiavft9ndOh1lHjwM3boIYKHP2NXoYbgZxAcQpB6AsezzJVy9SeQ0E7/G35CDi";
  b += "49he/TrK4wHU9Sd6o4/u99huOf+6z8BKaDn9Xx++WVf/CznOJD+KkVVv5hRNTLK++V+3e0UPuxz";
  b += "+rw3XI/nkCWyqAFbPKJiuDFN4IeCq20F29LW2W+V6m3r9QKjC+lGH/w+1LfteSiiIEJM1+WPmni";
  b += "V3oreb32aryXcqmUDGlONT9JCkJDIV212rydnZqVY8bBLW3lgWP3travdzvyFfDqBl/gnHHy1Zu";
  b += "j9A/+veovpa0diV4P5FGjO7an0U59kIGIpJGldaAoyKulpJUXqO5QBe4o9m6irnwLGtN/xeGNCT";
  b += "3nQCSurswVYqnrh+lrpdduUfL+fKUreinVXwdkpxdeSXP7oBqMIjWe6SQ10lFoZ3ktvTamdtZY9";
  b += "oRxpbcCkiJVG5/kI1Vqx5/8fatNqSuRnipEYEHS04UIrEs69x9MxF8EnrenSlormw/25Gu2yVzr";
  b += "B7QScSOVfmF4q0qa06Xbtm/n2Yeh5rbtqpEt3W8y5uKtbStjDnivz+sHbDW8M06/jUehqPIZ522";
  b += "4bEwfb5mIA/7bOm05YlIHfxbvFl3b/DPO3arOaDLefWOz00hf0qlP/5Fw1OfZESg8T4awKbSE8D";
  b += "TsxuAs0MVWc/qM06kJGZv+BbcTCjWa/k1XwmFz+mv4lfBfIz5oTv+MJ+FKc/qoJ2GvOf2fEPab6";
  b += "UXpirgxIV27uCOkDdcynJi4vpV6vwMalcLXdGrcjoUzh2LK9IEVe+IqP3fFFY3auGcX1DeHZ6BI";
  b += "I2zkt709sW+yuOnnh2fSs5gcb2fcmonbXc21K27ciHvTrdsf3R3Xdk3PfbKyB7pC5+77L+c+V3s";
  b += "trwxqUz5o50u6elPjpBd19YRLHYxAvya6sIWAr+VdXLYblQwoPYOloUYGBRutAasPoK7z6B64zb";
  b += "1kBToNMlUdlVl0WlT3qrRdc9eJ6yvzqA8nBbuaMTXJqV0LGoErbYePg8H2zpDbhKEE8t0VkogGZ";
  b += "E6gmYJxPi93HD77SvxtKvb39IWK1wlkr+kvHMAMQ14Y2SpNfTgGewwOLL6A5U5qhmespx988MhJ";
  b += "55703vv2hTNxPd17zyxUzeQMUE6pIWV7Oiehd84SNIRxlZ7eYqhA1XbLt21ol7Bm1KCB8iB65mQ";
  b += "988jNUaLW5eMoOefeRq04Jb6NLZQtVSh1Djqqk06ZTxPQJ+RKOhAm/k1tDwfllpSR1prp6We4jT";
  b += "WsKiDkfiFO4JJ7hptBna98Q4hQ8EJENRyks5W43iTZk3Nvkw9KGjn/hzaFuWg3fynwmvqaPuI1k";
  b += "F4o8TrJscvPy5LY0SsmV9qp6fub2tsgKICU/64t3Ypwk7h6qEPOXzePuBxepqRBB6+2nOyx4GZl";
  b += "Y/24AQ0GBVveWTt6mwUhEiAVLyO9uErGlmKDLmGE6q4h1YmEGggu4nrRxTNuqd5VbXhVq7+KV3F";
  b += "yWHXSp3APoWrvl8rfTluV110+gPJ2dCmnak9ld0kwo5Rrp1f1vfmhs/NOuiw9cHY+u6CiUpOrJ5";
  b += "xAz1hSvOVvLvWrqf1qXkC/ZKZwpYL31LASUJWutDoh5jBu8E0WVsbn0QSzhzly4yZvwhRwHTz2I";
  b += "qL7OqGSC/IUqPTjhFrBhQ7ffHG4lDObN1+xa27QyPx8J3BfyElASOHFs4mXXqwyBZ4xZ4bWKN1f";
  b += "vLgWLq4vxj9zMFg8It+ji3v/yWkB4HDxBifIr0tHNzghBaJefn1aDLs9Ya8n7PeEg55wpSdc7Qn";
  b += "XesJhT7jZE271hNs94aGe8HBPOOoJj/SER3vCi3rC9Z5wQ8NuGs92fLNWm7tcok3kLOfT3917c1";
  b += "u1uPJoKqNjgxmT+TerwWqXGAUfphgEXqwrZmcQ7FNlp+5WFd23SjM8IL15OPBqe3zw26cco/EVu";
  b += "2bDfB2YE/P9qtjbPgEi0Ji+aMp/rfxcDJkMf26Wn5dA1MbQeg1Namil/sQaOa6hSEOhhkCkvWl/";
  b += "enzal+Zkz55LgofTD/yh9AcY9Pnvhj8pbLD83CURjyT+tHzuoqEK5+YJCT7yK94cHgt+N9yN7zs";
  b += "mksr01/77buEXdknqb8oW7E8/+ivebvmUtOr0H+wwSd/GQ8//xd7bwOtVnXWie6398e7365yd5A";
  b += "ROObHs9zWWE4dI9CInF9CycxtCbqDgr72dOlN/t850RnwPU02IsV4JObQpUK02rWDpd1SudKZQ0";
  b += "UGlTm1DpbW21WLF249bNbXUonLbOFatloH7/P/PWmvv95wTchJSEjqB38m7P9Zee62118fzPOt5";
  b += "/v8t93X3ypHcaW35BT6EiWiLvRmeElseiW5E0HN17k+UUFXi6yDElQkli7109+5yLYcraocx08m";
  b += "LNNR970ChNAZdbvEOsYuHea3qDqBEisyzAEP6lksXhvmWS18ta4pKlO0dQ3sP3GqrhyZHd99QZj";
  b += "eIJHODVEkEnH8N4XOLQdkX7IvZW9K7qp+EJjVTduXz3lUmd5Vt+MhKnjfuvav4QTqJie4URyqg9";
  b += "BDkYpe5ZsavqSDTgelXpqWbE9u/0TitrJAliy7cdAqnOzgdwekCTudvun3T4Zvp6OSdq0+3/BPB";
  b += "xTvaK5Uob6G3915UT4/zvfTw5nFvL/28eVzspbc3j6f20uebx9N76fnN43Xc5tfjci+9wHm8fi9";
  b += "9wXk8u5ce4Tw+f6/6hSOePECqxd9vUbvUO3LHdByXq4lczZZczeVqEvy/b6hv9HDDw6XlS+8XfL";
  b += "C99MYUb3SW3pjmje7SG+t4o7f0Rskb/aU31vPGxNIbs7wx6a58v3xhaQy4VBdqs/qH2OQiVYwvU";
  b += "RRctjrHmGEMrdVWs5AgbD/lgvv+D3l9jKKOdYgm6oiJjSZ8AsAvwE1lBibKMkaEOp0tZ7fThggF";
  b += "vA0fFJF9GGStQeEqfFcR7Cy6CMGmYkVgQ7ZpNbkD+yhX7wS+QfVktFOE2dZuxSNh0Gh6SGYRbmT";
  b += "xpUO7g5lidaI1BsIG97vcqqeSvshmcIiqGDhpq/Oqz/zeAwEzq3mm62SlVhaUKJb6JLQyJAS2MG";
  b += "irVxKT5Z+iHRSM+Q6z5aaFhYUiKMaS6sf1jakKMZ/4UI1cEwPDa86qSDz2/njRG1QQdG8wzdxfq";
  b += "bnbZn5dhUzrfjJWT/rDkbfJzI5ocvkhNZfMqla8TvE4ibamhlQG0n4kYsCVUVQi+IhPcQviQ9Fo";
  b += "1tBHKMJELMugJBNx8tVF/WGxUAcf8/6oKjRuSyaos6lP6kYJYrOqZNcQ4twcHexFWUvwRipwADm";
  b += "4iCfEtMnp186qixZotWwiSjt1Lnae8dWlwRIBeCVYmy5Uj3hXt3SsbnCoV5gA1D92XvfcrwgXAJ";
  b += "ZXfSZcIEjT+VgOx5vDNQUkcpQwDW9o1gVNWcw5vZMAB3MuRIDCZQgjyPRRc5EGsel8/s8xQA4Ix";
  b += "2V9BBfcGcZcKHTnu3QRRDI+o6d2oTBLXCi4heVcKIwTZIILxUqdKOKmE0WkDuemuU3uhuZiJwqz";
  b += "2ImiLk14DPLZgnVyV/HzHKbm6C4Ahi4ApnYBMEtdAIy6i+S66U80KP0x6gLwoHfwGPepAMqD911";
  b += "0hVxco0U+Fd6dIFriTrBMXqHC3QfixlI+KYN5ckvEVXnv0GJhxCq9d5i4w3yvLs1YxffqyoxVfa";
  b += "8uzFjl9+q6jFV/ry7LkAL26qoMqWCvLsqQEvbqmgypYa8uyZAi9jJGCwBSYRW2WIUnZQH14VRco";
  b += "CxW4cl6bQ5X8xLxqVlYz8KNHm74Vbi19H7BB/OlN6Z4o730xjRvdJbeWMcb3aU3St7oLb2xnjf6";
  b += "S2/M8saEu6Kr8CRW4UldhX8uVgs5EJISupHu88qf6oFGnQ+NwoNZwoOZ7gxVWSIIl3N2s6xUdy7";
  b += "AM/NCOSIUUqJQSAk3h+XnQsJ5wSvT+SYMW8g2V3tCy/lQMi5StxRb9NHMig9b7/242Ak21lGCr6";
  b += "U4ZbNwAU65ERg8HAcddQB1vp+A7gG6SpublPRuTbcPe1RGVDHPBulTQVK1obszOXE0AWeiHiv0Y";
  b += "/GODrm6arYUmgeQiSZgPkEp28QNfDVDw4Hu7ptkkb1LhtSru6aNz3FvMj9sEea0R4fE4iOxHH8G";
  b += "1rSA1doCassQ0DjYT21tjC4lrkX1GOFVTQBGlS/QKeVCcR4hMPDbqR6+61DEw1Z1P6JucKt4ITx";
  b += "s330oCo/eivlRMm8XL5RCLWQ+itMUGxy4Cv3YZp3fCdz5NqhbB++kvHMwDY54VexQO+hrqPfkG2";
  b += "+AV58Hf/L77uqawLXyID0TvUfLEfWtxFvkfbOKMiLpMr77IfqP43oa3poe11uRaulb4W6ZKQiKG";
  b += "TF35/dY9Z527inzXQBib9U6CWW9N5RVWkPK6tvmsLtuxsp/7kl444HEv/HeeLx1nn8Scj8Ucpf3";
  b += "jOX+RHSSGv8QMj7O7nn03A6gi1SDk5TbYXaMQyenqvLtq+ceV05HkpCTu5u7keWyyDjsARP0WsX";
  b += "Zhx8vJ6+FZHzCeige1dPVo1ZRefxMJZNU8e+AvR/DL92oVEHce8n5/DKnmRNwPoi7R/72ejkJcN";
  b += "aaWTfMXSLofyLW9yDrAD8t8ySSc0bu6FVMya+QR+4FVnb3c7HC6SCaQ1H8sV0D37x/sV7UnIao6";
  b += "UTXdUSAM5WFW9qFMxdHZ0Nyrc4eXWSv5MMDgrcirlaqAOu+ZUx98ecJ0cCscyAV4Up1BlPsV9BB";
  b += "vmWb+gGto54JqCkNQ1bdCf4lxXtiVZ16WiQ6ixSSh0KAIZGC2CvimMan1BVg3IHkr4D9PdVG4ao";
  b += "pMiaxs3OHe8B2iCk0I5j2z+zSIhLFAyL1lG4YOXMh/MISuhFoBITTE8tRdb6D9jON4Ju46yTgYy";
  b += "ddYTro1er3/2Ur39ZeVv3hkz8NFQ5/O2aG0XxpruIWQAE8oJFI7fjFhsQI3/27HIA2I1YYp20IU";
  b += "kpdwwxc4Iks2ala/uVxWh0kx/md2DKzOITiMo/3YbMK0U3zEDdE76HKQGO/DLuduyrr5OwYYQYx";
  b += "r/IKXMBTHQWayGkwY4mgSv+wg8+LVNtyUrskRVt4Dc1QNYuooxD4sBhd5XAgzFgxEgeuKBNCFbt";
  b += "rAI1X7cy/NSl+uOv2haSfdd/TUlfjI2EQFct13QN2cdfdGBXFy47Wc+v9TPjLhR48gU9/1ih4GY";
  b += "sePoWQPb401pcmjPgKL1VoS4RWZ+7V50eFHEcvZPTLwj4F30thOY91e5YhPa/ddzVv9BffWNh3/";
  b += "TDV+NMUqh8dAbjDlyowtX+3vjXHqIngIl3AjLAb3rnOlQEON13eIXQapadVo+oCXQwxVyEOIteh";
  b += "csx0mYtnyzDdmHq6MW66YbnS4jdiLZeGw1U3Of9ubaQCfrb7dipGdfVqoIfIBTtfLTwRw7/+Ne7";
  b += "KQiKXFh5v4dp+f21hweDqwq37tuv+J30lLlcc02YzerjOSD1IE7dbVtBfOUftpvzoZrUSrQXtZH";
  b += "5aK1gBnY6Ie7sxwgzVVzvAVwjNP9PsKNFzLjHXwV7AW+tG1SwBYbm9q93oBZzNXe+6HLtJI87u1";
  b += "UaHyJmN8JrLFR9InnnBJaYxl2lJ/AR1genR6uSBovwGz4i9WMulUGZa1omxTt2TsjI2g8jEfNl1";
  b += "l3CHpzvSRzxOEZ1pUCmtD4rDPSCuMvr6yAH6yqy4wsH6xlMxWN94CgfrG88M1jOD9Vk6WN90Kgb";
  b += "rm07hYH3TmcF6ZrA+SwfrL5yKwfoLp3Cw/sKZwXpmsD5LB+ttp2Kw3nYKB+ttZwbrmcH6LB2st5";
  b += "+KwXr7KRyst58ZrGcG67N0sL75VAzWN5/CwfrmM4P1zGB9lg7WXzwVg/UXT+Fg/cUzg/XMYH2WD";
  b += "tY7TsVgveMUDtY7zgzWM4P1WTpY33IqButbTuFgfcuZwXpmsD5LB+tbT8VgfespHKxvPTNYzwzW";
  b += "022wfj1b0WB9+6kYrG8fG6zpSRisLj8/ZEkyjbGa61itX6yvbGGkEqgc5JUYbrvGAMtTYgpGO/q";
  b += "pGzXlksHSWjJYWssMFlxbyI8xSNLFgyQ59hTQWuFUkS4ehSxEcKzusRh8qyvNmZH3dEfek1ZHXu";
  b += "Hjx8ZiuRP1nKYvckbin0GLzvCOgdAqwd26EWOKb9AujPDsWPET83n9LdzvNH/tSP4jiXOJB3NHQ";
  b += "+HQFBXiaHeZjRD/FfvMrD5BcJgGaJjDl+TAjq5QlMdkK8by9p2MKjO7SW1K1EUiF2mAJhNX73vN";
  b += "h+DRj1gzUzwRIw6dPK2M2kw04DtRiqukeuzPH0DM1UskTfWJv3ggqv4XuTg5qhYOy/G75Z/iZmn";
  b += "Z4h1gVIIb9ydJAFYmIcSYS0juQ4kThXm5Pba5QgCViv44HkzvSSZSX1NlwUuGre3DbCsnwRbmAU";
  b += "XsJVMtADnp/z/togMAInyT9KINcQECSuXKMdXC/UrLEJWdOR3H/hWxokn1iJSJeA1zeQU4Uun+2";
  b += "cwQuNDDdtXfBgS06sZqH8a1qTqXD+OZgQgzUnk5AFBTtY9El+2qMz+R2CiyTfQxRy6qUFSxFhpV";
  b += "1XLnjXLLJKggpTlZfeKlVUiBBuB7OJ5NPSCXzhbSLUqHakigKFYb6TAzsZJdN2wZhCCf5XWxQnJ";
  b += "iRWIkn8buthTTu4VXTYElHICkrYADG3ncHWtQ11Z13xdRwOnKkpCp+q1wSr7h+91pqyvVx7zt0B";
  b += "NaJHH7I0butjiU/fEj0WhLPKcAoxfZl8nPEebxUjn6pKS5lHxFm6WCL+dRIUdX8AjVv0xfuwmh7";
  b += "4UPYG+REs6FwuOcUEjAadHXJfq6hxulWFy6h9xxokW685FjFemaUCQtXInCdXk4LYebESwpk2BG";
  b += "epBbYxPvC7IA1rgkDA+Z88eWuoRR3M2lLlGK4rGlTq9RLpSV85Z9YHziIpQzzIPEt6Z4p3XcHBd";
  b += "Hz1cBELeer7c8PGQ+TFQiMNX0bmT7RLwT0jSGKSiucI57e3btGnKVB2UZwB4TjdNVGZUP7RmmhJ";
  b += "R80pG9L1egxBUo19vt+rbF7VixvFQW2uSm/8SvqowJqp9IQg2NUu0i4lKKfolpJIolkZenup/HY";
  b += "gG0PpWqlIMaUyzidCNfDeIMo2p94u/LxM1xQ/iJEeHQwAI01ADlsrujbwkWKKJ/2ZHF2tF8g92F";
  b += "YGIlJBKl9gL5jLw19hD0ZBNyCP/9bcob1IaEIs9WD35VZuRftYQJS/SMOBjhXbreZJS/QIcEwDT";
  b += "ALPI1pPkGAhKJvOwhgG6/kAh0qQOaQPFJrgS0b35zYIigukhR3Y9V4V9V933Vs+lIS4F6gotUuz";
  b += "LXD9pocse3W5md3Y/0zMRSuj3f1e+3Q86P92lvA8XOfdZzCS5YsqdvnyHOsq5wvIdInwS3E94eZ";
  b += "mQkIi24CTRrZQ/LqpI3VReOBhNAX5sn1EqmiVqOi80Ud5NhsU0IOsjLk0R+HvSVeZ0klqSivJzs";
  b += "alyt22UmK1QDzbCPgdvFj8gXynhspVdYgDylAAzdMQNGwC4+fx+kuwmBW/po3pjJdkgf8IKgPNs";
  b += "fcS6BcIrwMwpRcXX4fk/YDNimI/cHIJTKQXkY0kC1CFVDTLsWuRpRoqyc4HBH5NlvK1VYhmYbDT";
  b += "PFfXVLuKlRZqpDv+3f0NoY9QZ1qpJYNIxLnywOEzfdFO9I+PP78lm5aFi0WP0ErylzVarjISvbj";
  b += "LUvJ8mcCc4y17ZS2VciEBSIOVBzdhePWAbgy4Riel6gCcXNFAkjvm5IPjt8JeDkKeI4Kx4XD8Zs";
  b += "F7ZExnY5Ws2XrWtGEJ3qcGgRKTxQctF/+i40VPW8oYN0sWBpK7VPpYtBhTww91WE6X0HqAkUSgu";
  b += "SIyprid1OEYHigoYSohpO2AP/AgMg/QMg5QYjE2XE8xEYiWhIxL66z41PQwxVGkoSFaXkaaCf5C";
  b += "6LKWn1fAf1C2QBsFsoIpLsoMsFgJr6njgU0r3Ol5BqwnrQWOlQihUwIUV19zmlSPtsoquQiDsMn";
  b += "rYyR3UJDL0xmlW2+qQ68lu+yaEiHvjtutMn1b3hTMT0bV3K7IzEjUMPrPuKu6hdMF7ch5Z0Kmnm";
  b += "Nqloh1Zn7bbKzhMuzLFsz4uko/aexnNdCgTrEcorKgAAJnpcUx3xF856Gs8K2a7q6MzWkz53sYi";
  b += "cESE2HR9cZ2MENleZ1i0ZLskp0491zhy6BR9qS4+8c9SZtxFdqAjAMcR7JxYjKGa7tbLmQFSkc+";
  b += "do8XA9CoiDueJsZ9XhO/y6ozqeIvVNjlDAlkcvKjsXRKkCGMnbOxtsPucL4DBmJ2rQP0X4U6hLX";
  b += "QoYC3q/1VOZ5KVtNwVCu//sRFeRl+yidcTjxMfGYklSoEoECntFqJpSRSja2k8U2vaTn3kgmo2i";
  b += "iyLVYKrfl/MNUTTH8w/WJ3bLbdLAh+wcEKEV78bKYrLFzlGoXj+q3quoQBBcMRgP/fEDZAiw1a8";
  b += "Zlf4thb9NPMJ8XpaKHQ+NQAFCin+KB6rsUwoAzumLKPSAVDPSFxp9odG3HP6Yf8u95iItmkyQw6";
  b += "h6WIru6Qtw8euf9efT4bWbQqF6zQL0lHAoaeD7m+JTiQYS1zcIm5Qo1/qAKjdNFUDrkRmN6uE3L";
  b += "ABdwbfuwJcCBhFwyGNP0UNcUfk0BUGdhkqGPqNMDUqt2PMcSI5mSLmHPOS6dLFkhqABIAQCCtiU";
  b += "0rwVIydFz5BvEW8wPl9altTIEqt6JS9YB9bJO/Z/KFKKBGKAV0U1pUjg0eUzjmcaUhqpEN2plPI";
  b += "+4BLd5wipbmRmP7nTjw/SM5WW49HXwBElAV3JQy/JcwBe4nOTTm+cxtMFKStY60JfOt31JNnKgI";
  b += "E6l44Tkre7PxPbVDVvGSnpekBSt3SMkFN6Y5QC3pkh4Vgt8irZ6fjqpqp/AjDw1+Sfsj0jGq8sx";
  b += "DMkDCTFhGIFMyGnPlAEjl2tHnyExAhjNyBhwN6H3tLifBre9s+PECN/mResA9R2iql0Rn4uHFWf";
  b += "oe7FlXyDnQJOvkhU1cxIKS4yTjTr8RuJyJ7CiL8Z16UFMV7kaGNUXhxdCqL2ORkZeBgQNhgLOYP";
  b += "T/w3NlaJeaB14DuMkELO19Eggs1L1uFZSji/UIg9aDgUPwNQAdZXHdEh0v2y9FaRwoBEKesyY+3";
  b += "gPoI1zLO55E9q4XSWQFRTauDUGbdweiNQSoI0zD23cGqQO2jhxMhVgBrnMJjXAsQy4vnUENg1IY";
  b += "scskxJrfkielTIFzZVb4ojGrYTNLEUnBhoToYpSRRNOCbqcodhl24ElwZ7RUftaqwshHFxJVNaW";
  b += "RROWVGSddBjCJLhMiErsMYSVBsZ6GpiM+h+WfC4OH7c2vTHbp+amznriluFPJMee5AhBHgDYRFQ";
  b += "WuRrAS8C4HkwQijsBhxNMUG38ZHuHrRuGuRoN8pfcQ4CSjBybCTg2U8+XAgRryQVo9MMJChnXEL";
  b += "kg3l3ipfPKPQOEZsBaStY3DDOFycvnQbeiCFDM/SX3hMwTQDpBviWF6f5rVCpEodsK/dSvM3Y5o";
  b += "diuNNe4Rzu090ziwBOXdpS4tBOISzuBuLSDJfBuT1z6lZZt39j2YCN9xe+eHU4o1pUh1hWMdaJR";
  b += "GSLC9aRtJzBRXUPSainTKoDU75YEfYCDrAajdLlqNFyD9u1yC6SkjrZF+on8ZfKXy19Hb0w2mWO";
  b += "vIXRemb6EOHnpD/QNtSm7MOyU9kaA0FoifsmQtTWeWrylvFnOylv3A4gCqWOklqv7h0SswCUg3C";
  b += "aaNN2P7TBJX3b2Dzpb1ExI0lpJl/FFKi/io+AKn91iBh3aIK6BKPcSmma3mFuB77nl+TcPyOml/";
  b += "+1z25UyWPdCjJTuNJQa/6AKlSiGTFIoQ442zGG5a0kWZVuy2w8AMWSbyjXkTjSvRCvFhwA/GLNA";
  b += "KDj6C1bZ6vml/am7hiK4y79T8zIplUU5dfnMsKgOkeWvFHlDVO6yqJ6/855h62bI42UxjzN5KYw";
  b += "xrZs1v1jT3MyvJGWbLGP05MlShkm+xfi7cTkJixvmxHISP+1Y2X+PVul4rNLpokrHqG28okqDyD";
  b += "kB0GSv5BjrERaGRzLlx7kUrCSzM0oVS7csRsNJWgg4G+a+Rj1N1i/7G+JC3rQaQ8sWt9pyjSbo4";
  b += "k60V77FBDBUJmjo6ANRsxcwg3rgtZuUqzKbF/IDgtlVMAzMcihgs6gPgtmJQU9ySbcP1+Bj9MEY";
  b += "2ytXK6sd56reUla7VZKkTj5RTg56XdC1y8DjTFSz2vU9wWyZAqy6r2AzInocueUBAM4fvsXZcP7";
  b += "ImtxZaMATnTlgfsf5qwS7YXWSBUlWGbc62bHVCcuQDatT6lcnC/x6Bd53XNDgg+Dq1ITfx9q0ZX";
  b += "xhAjEzrQYBMj8BBYsDxzcB4J8zH5ellvJrcllKuGCmKK8umrkuS22yEJQ5QO5jZYtorkdA72XJ0";
  b += "y7p2KSEWqxxTHvPD4mMU4qDXbIly2J02CpUk24+qawF7g2aBDwYaQ4DifzXUrDcSIWgIe12tm/J";
  b += "WraPhk1qn1s9YGyuALaWn5pCYg//TNFCQuYw6xIGmowqUlnS2VLmITRxF4hWhZxWAL5KFQRCCA5";
  b += "Twhq6QvMjTFFhSHUf1ypLmopGtOsW++OwfYls5dUpMWdzbg8Vr4YWKY2WOeTVfCtaj7zi+w3x4g";
  b += "vq6YV20gfvOBQVf49tjIdx9N9xdOCt7uj1SWjhWOEhVckwui/tt1GK7bTnLSxgX49giM+HUX3Xx";
  b += "dEEz3p7qsM46/Es2xNu96u4R0a4+onJxWlCFuEhXli9p2rtrI4w2yoJWoB2L+lrusK5TUnXtSmW";
  b += "QMGSBtrN5cnS6CX6InRG2A0BKHbuHoygUvfHUEk1PMBnYx2kN/QHDrXIURHRtp/SwaP4mKEgO+D";
  b += "ue75VodUdbJJTV2wFROZXcbOZ3ZBfA6haUOq4AyhXOD9ygPiOOHLdFLuZMLo7s7xZ1DLSdoe0WS";
  b += "yQJ1WPdK0zv0NVJOkEv2fq3F2ezk/CIWjRSgCETXYV6WLviE+EZ650FMITq5eyyxE297avHhJVy";
  b += "7G5merdOCUn2iqc/gZOyadGXrYP4HTC8bKZ6hPhlORrn8PpZCBf++vwLMnX/iGccuf3piP+2Q5O";
  b += "33DEP0uitXfidHUgWrs33CXR2gdxelYgWvvTcNogWgOT+N/iRkqDRHVEjkFkloxznS38nUsiStG";
  b += "tf6dJCB58B26QK46D9+Df+dKTD+punPblNNCdHbJeId00T4X0PELPRVsO/FFEiP8BNHpuTrRhbg";
  b += "Sdyzz0ciQAd4D83Lj3LhkcnmdKtCKzu/rolx6IRhdEEexNSWXnYdGVu9c5+qlFKWLJFNrGlicf+";
  b += "PQFL5FZnrTJZX6XvO6L0Q7OGxb4aSjFiNexBeLfmBw15y6d0DpXL84hWZTOoeg1E2wakYMAdjvu";
  b += "q0S+Carzyni+uArAh2jB92a2v8+iBRcCFW1+kZLFKQkyDQS8OE2obZh51gW+XvxcoQNkYr2CicP";
  b += "O0RtM6i58W10hvAfPhPKUlSO/KY+1gHsjot+9cmhImN5u0PNMQEqYcFJCAilBpr5BC7i6DSkB89";
  b += "GgL0qXUSmBVGmclXK5bEVkTBRdt2xd3Vdwv3Rrn44/JRB02zIjYuISca/A813IB51y8ntttOX5r";
  b += "xmswnWs3mTU7oy+OwLNwaqb98tVrJZDyw+eguIIbDVdKF994vKOygILfFYRw7VFSaM1yNTS4xz9";
  b += "ltL06K2Snk6JSiJaRSfz+jJ3FpfZLCpzx3Hv2aOUWc3HDfIei0YkeU8/yDWkQ+YeVHcACvsOatn";
  b += "RWmJjTD5hAiknUSqmXFue8hSEzJZrA+MIRynkpGyxCTVEK0mvCez1BkJupnDvIG2uvh5hSxTUuS";
  b += "Rvbilt7qtq7uaOI2N+8bG5m7FO1ckT1Pmo3M0Pee5mbHMY53xSm8CCo50tHvCOdtIlrfq2TZNLN";
  b += "VLW6YJk1D212DuivmGiNvWrVAvVXbvVMKgXe3SHp1DaNIWpTNQYnOtR5fcs4dNkwQCEBb0bnlZM";
  b += "/rEi+VU5sPLUr4rCq2hRb10U3G+8vRFw+wqZj6MSPARMmgVnHTIYzNb8AKCXlEkmnJ/vGA7cudo";
  b += "52fBp8SJOYfIGqIaw5BotEngRqvU1wCWpw+aCaBH22f+bVY8HTGLeK2uf7q6uk+oXDiS/JHva96";
  b += "IXyqL/GuNkqGgQOS8s6QKj6kl89erTJDraKTJuZ/uMTJwNIncp2nYsZ3sGMJRiNVoAuZr8i60tk";
  b += "d+rt3xJeVyR3QIJra1Mus7avezr5k762zANstOSx2hBFoIv+e3d8dPfiE22T8Z87OSXfWqUcdRn";
  b += "NOJlSntm1KAGXcZwQm2V2Lxy8iYgwFXOg7ZWxpf3M1LIqTZidnA0DvPq69BNduzqZxy7fW6t7iY";
  b += "yLNNd1Tfg6fAZoRj9VD2Y1FjH1dhBnhv01VldgMx6RTCXD/7PVH9CjopbqmZyZpRX9/2zzLn/iv";
  b += "lVh3H8iX85pP5oYM3ktup6+m4mrrx9AMNiu1dm4jIvvkrfN0jh9VZQTi/T3PnFxTRQ+5LCw+HAN";
  b += "+Q9ZXXvN+p53pLyGVb5XOvi+VJ8/bmcwWYdwfSc6CCGVXIxq8j5I+WQkUmk+DNb07Ge7z1wY3g+";
  b += "qHkNO9MmPBNxZ2LWPmj5qD5ksYnL4010I3RJmQr4x1+JQ1Lnz0NU1k3k4FA/QLKCEw03PFp8hsY";
  b += "v5mo8a+mFSzBsE+cOeqx0adgtdHt9qdvDOdaDdozR46PfhMbsraQteyfclL3TsyU/dLJbcgV98k";
  b += "Q75OnaGz94stvw2F3xBPvhadoJb7M2URmtRjRfBy0fcObekQX1w9n32pKO2kiA7epvLEpD65SWx";
  b += "zI1TPrZfth1ybNh4AvLpZyercyIuo0HDC+xUYz8Um16o7qJs5/F47jhicYHqKWTHr3r68omY63U";
  b += "1czNMgmXRQI/aqv887FapRwtSfMt0yq/pf4E2MYqQKVFSukFux2c0ueq04ss/SSUzuif+iPDeH5";
  b += "PZXaiqLvnq+8fdUHPvU4y9Pv82Cn12/YgMy/t7mFM2iNchKF0l/oLRaF2096Fk5pTNCS8+at2cg";
  b += "iqc6JILdVzIBHumZd/z718ZrdSGog08m17qmTnCIo30djtVqVZh0Rl1TcqIb67Ok5a9XmIao8Bt";
  b += "elOLyZbEkUvCmD28A3wlEx4pvtOZ9hXLQidg6Li5vlBVu2jkpYxsKY1hPde7EmZ8x3UdRKdo+hG";
  b += "Jw+Nhu3izQaxST1lac+HnYpbyuTajEFedoH7iilpO8sOPneLLOZokHv/yrPSQoc6FM5SZfVJmVW";
  b += "n4SDEoJwcbBDyfidJtnkE5VovoTamZoaAEX4zROFc2fVa6Kst3Tf2nTUoJPfXUSLWO0qoPjIlk+";
  b += "t5cHBWI3cxTNUDwKrV8CZbXGnJbgch/XLn1iWtusARhYlfDrcpAV5nSArA7tUwtJPiGX7JUtOr+";
  b += "xlB6yWXAXjeGASQqQhNLiHsJmLrgazwJYrgbebM1lQIe+jsmBnoC0BlppveZBQydIeldQnjlS8t";
  b += "DejGYGqADsfdlRzexiFv2mXO4zn8GtSEV7aonXSqj37DUfL9kjW2YXIdN8Dboxjg7ZgB3o4Z4O2";
  b += "yBng7ZoC3iw3wdrEB3h7dAB87A/w+ErT9ne7xSD9WZU/t1uoMlKtFWyM4zKLcFxmxVesfKiV38Y";
  b += "T1LSaK/YNhKndGiEj3nTB/Gfjh5JixaPZPMMdm6ohTcXZxrjg3ifZXpjMMPkln5MuMecpgOHCCx";
  b += "h4M96Eaz79a1c0ljyQk7eiqn/CMLtTeuyZGVA+9a2BDVO8aXqN3DSJ+YCeB2WtzybhWetfECJSh";
  b += "d01ctuBd4w2Qmyp2Rywr1vvQnEMxwTvRxMGJpqtBAamzPMXeg+aORR3Ntfj/lP2teH3S6F+/gUU";
  b += "RrbAxKhw3qciVlPiG8dWeZzNSivV8SAtxWF85JaippupVsXcc3TFTSTvO6NJi0EMKdW3Kx3LrSS";
  b += "bqpzby5rEd6AY7dtGmkJUx93PSrcrVprm4cL246XnqPPXy4KaaeA7FZIkj6qT2by0BaEgcw4dWw";
  b += "gZjmD16Ft1fcxYoJ7XX8YCJNlIq4nVpuVm4SFOMjqJ8m2UUxpA2KdMT0hujhiIer1Byb7r1esLw";
  b += "ka+8a5bjl9LvfpoN1lt5e/WeZnP1Tn1rva1tM53yYeJM12M++wTGevFrXiEU6e9KL56nCEm7Bnz";
  b += "imsxKspBgm/o5McFlDCWFxDOib2HxfqZLNJ1FvI5MOFu5uSyLjafoY5hLvWOkJbm3oZpe2WhjV5";
  b += "LYleReGxLwo7kE+M6Jmog5R6MkMfuDU1lRkgTL0D4Nh0qUFDjfxoinmXBP5h9uHVfnFQ/j6Wgbt";
  b += "rSvmKEXoH6SDBFhSW/JhZhG6GsGbbnec3yzLig4K9uwO2d1cNiKEhrSCOciEmUqyra9KCtyJERZ";
  b += "723oNhhcCzKuxn3LlszCCDDVho+V99G3v+pxbH+5PDTFLbYO4Q8fAaGs+hE0bSbJQgKSWbkEjFR";
  b += "G820e0fsaH8E2PoL1H0Fnyoxe2yRXYhgxFoky2z4jDd9g+qpIgllm82Uyg3iubdBmrphxX6DmA3";
  b += "NfwGrD6sZKo2Fjbdg4fIGVJTQUaXMfRW/rLxCi6BOnEvILaNsbrS/b3qiHjBvMkSt30E6NK3dLY";
  b += "/WpsrTqWH1N4GPcbZMkzIWB8EG7zINWH9T48xbllrE3x+7NqTYEl7m00RCRNkT96pUlhLinLcYi";
  b += "pXWLjdUF2pVuiv3q05nKV7zwPb1V73RY8n7l6bTTSte7p7XYnQYr3TtOuJFW1pOeRjc6HfrQW0+";
  b += "4eVbUgU6895wGXedmJTuk/oZAxJZGhW6jIwAsedhfLfZwKz7fM8icfW/nkPHlsKXJ1cQvwdXU/E";
  b += "QcGQtnbWSj2CoURbYi0Gfb9Rqx48+2jiXb5QNJG09G9ZOMiDYA0ZGyKSzJmto8hWi25uY8EUt4Q";
  b += "vVDJ2HfcNmo1E9BkBi4/dx2Yn1kBePnRAfP6TBy3nhirXLsYXOCY+Y0GDC/46yUDxlvA9GWcPId";
  b += "rITVY/TBsWr6tNWdsH1W1ln3E3Ce08j/CgB+iOzoXsjAsjvw/NvNcsBU/+H4GVwPEsYCR2839Tb";
  b += "EJgyNRyIwYz/OeOYLdWdhk0YXwFp7vuZEyTZz5YPVmUgS0Kb6Ua3UK6aJ2z3w1eHOAwMzuXNAoe";
  b += "e/nbK2+yVzyhuv96xtvNebZ33P++/Gm38PBA1QxrOnnaYSJ+cIr0+qc3/iblhKR99LTezAzz8Q4";
  b += "XDvDcPs+6HAbSlvvYuqGomrN3Hfzbr84PlGB7tz9zR5px2k0Ng7q0hXunnuSoXX48XcBaNBT46u";
  b += "L5OdZXq9qoXNV0prMr72cFTDsJjieXLlAOv8j2aRyVvhZbiFQ1c61SFFJYyGLY306BGk4S75PPf";
  b += "7bx5m5mrdSCMIEfHqDKawGGbBXJg60KmIec4potoiL7j1c9g2UwPAtEepiqpyxKUhOL7N6lQczj";
  b += "fh/NKQHjmtw/ZjXHw6dt3Bm6m7XzEajoBFi1Yf9fIyo+K3Dco4C+M+YudSxs7BdCO1ShE7B4JyI";
  b += "nIkxXfS3RfutU0PyxbNPoNcVUH5pPLYZmK55JrHS2sHy7YyP/PyhQM77mCZjTlYxvIMk6c6JFpH";
  b += "dbBEoTxTu1uRfn6JUZ77oRujyBkdpqrPfOOBqErqHTQGyiLLihHt3EPWjWkm//wyyZ2ZnoEpUOj";
  b += "7auhPvPXjVrjGvcnAcNAbUBCI1eAcbdOYddOPFF6LPasyFDE3Rn0ilWyM1lXJTkWBm6r2Y7fEjL";
  b += "+/r750U9XfHF56UyPfuTkWdV+LrR57Y4ld+5FHhBG1GxcMtveG8TwsYfDUi1XkBIIGaof54g2HC";
  b += "KqB0TeIw00at6t73c0IIaqXbTE3YODA0PHRiBTbCE9rXXPPDYwrxXxVfDwhLTbQIEps16OcT0Y7";
  b += "ORnofonmRcG7tWeY3MNgV59nVmYbfOSryxU02h9PGA3FAi/s24nBcUiL1lUbx0Om+3dGu8Umb/s";
  b += "sVUArvhB722dJGDwClsz6sUUrZzkXF3T5zqoCu5apwqAgxF96bvGbDB4auVFDD8sUDuw8nxoihA";
  b += "g+iqZQC4pif0033xAXwP5KWari63FjEMq85Hwb8AmKd8dlVtzOjZwUIXYZuiwMOoqN6ka+88w/S";
  b += "VUun0VVfnqdfeG9T9HZD99z2nb2I/cs6uxPrxkevO8pmuHO+07bZrjvvkXNcItbCsb0teLNySId";
  b += "rfiz5NiGDSTCs8dr1pDnTr2W9kVjzD60p3HAnTBFmeJFXQZ3fo1AptXZQMOKIDQDElGj/q6VNNp";
  b += "phqY4jAH9aYTafn7R+dejEXM6ZJo53W8aOd2H12nqR0X2eAwHj7uDWXvA0kB+wCLfX46ZrxbuYd";
  b += "vM8hO2keVHrZbuM3aE5E+Y5b725xdp5CtRxvHUs08Vvz217SDgthooBcZBXBoE0rrdt476y4laN";
  b += "IBrj9WnctdssYNBuc+q+3gGiLqev+Izpi9RRpi8RKEzcsZzFK8iZog65hn/lKYcELiAPvuAx1NQ";
  b += "OTs/bOMq5qSkbO+YkVOA6JXt7X3urmwnymp3xLAleUW7OvgWjxDH7Mu2SPEX4SDRwOkdMqtlhJq";
  b += "QZQQ4HCol9hg3LW9+iweMQin0lChdKNaB+iYUHn+PcVOsBGQ14MigHy6pMjrq4rdKE3YUVK/Db8";
  b += "noG8RwdxRqLFdFseVCbbZxq44RPgOCwhVECmwEP8Uef9rZxoZduDtY7+4gbbV9Vw3PyiCBB+2YJ";
  b += "0KsuNjVvW99QMOWyxaCZ/oufEcW67Cz06/DZcZKwR20AOO62J3BbTeFSTjgjDunwEp9y2T4XyA/";
  b += "ETclq79X/zK8XV1DZXJSUCpGBu7eVTwkqtYFUDAvsuupZ14wUudJmbd0RNrq0ciNJmqDWw4CgEM";
  b += "RqkRL2fJqOS3nPCwW5Pc73/mAk90tcFIt8rkSqiGwUu0WSXyZw/GQw82aTHGqNtENCbJ2cGUVxd";
  b += "BjVyXArgqwz09ssGdroOShbH7YXQ+QlSN2NJhE47QUy6Rf3ZGOBmvkyr2pYsV0qq9JmrVNWFxp1";
  b += "8EqleuK9QDIyHU3t/RyXiEqmd/DrbqIqXngPuAoV93iYVGjNO6rH1XZINHQakQJwSlvGBPYEzcw";
  b += "CyjocGebok8miuvXBaBrI7++RvIPjM9KuuE+j4ST61SV+1mt6mACyGlkbkQ7p9wkrTqXO3GU+hL";
  b += "eZLw8eeC9oubwdUYr2MbrRwS/Nm4CKxlBqhNY1Z1HBE3kMTLLnGJPr9o4T4y9r5ntZU/EED37Nb";
  b += "N9J91M5dpGYn2WsYwtxWfGxfblAN+4fNcMkTiDA6hUdyeeagf8eZ1+1IOJdolYvSffKQ1WfXt17";
  b += "296aNIJGd/AprGEl4joNSydgBLY9pnB2dJm8ai6YSciQqc12MsGH1jWZfWh4ZQCpE7LDFrFBHgp";
  b += "z766r3FhOWOV0ZT0CN5VLdz06v2v2klQRLknKberv6biwJSDGUWqGZzD99y4TFD66urA3zygwoL";
  b += "VnY1OV1ECZI6RKX1LJJlEg3N67S4OF906p5cvfxlOuFLc8yXbD+773/tZ44LDjFpdHZZ+tTrBUV";
  b += "++T8+CboOz98t3Vgf3Xd53eInvkucJyTtVnTvip+1BwJyqbtxZvXIbF53LrtBNFx45o13jXe59R";
  b += "8z8RGoixc+eAuQ44Rp34LEX7vI5yMDm9U1Xu5yqN0gBiOUvk4RU8ipG13LZaVaR9cY8w3aA7219";
  b += "98p+ql/kMCIe3MfBZ9JHrHvEjj3iEx6KuvV3BOyMtPY9+8tz9mMK79GxDcH3QNNSADurR1rkq+B";
  b += "nza6DfImaaxoAJw5cbge9lXsaTNajCzamvp7Ca2iQtgxah6c8j164Q3WMduD8wHgcwgen2rhNDR";
  b += "4mHNlwFIejRI8mnNVtNd4wPZhiNPgAmAHpSKcBGBYZ8w5hwtlSMOw5tcB2pNgtWmcg2Uh/QoD+1";
  b += "Qzww5kWlSXqkK1F+jofsq6hxnLBZMbFL9f1cYLujAmbAHHCbbURtcvVSNQup5CoTT/5RosYf4R5";
  b += "gRgWKfy6MVdzAqSFLadJcXpIXXmdyMk/w5tYalK+dYbB7HTkJsLYzFD6F7BgXDvDhGWbJ3HzJKl";
  b += "PMEVI+6nkzSvEmstVd0e0AVw6CG9Xve29ROmqCpj9yIMBt8kRALlAPABJDlrmhOclICypZF22uR";
  b += "ZRuORanVW5g7c1wC5SMESkd/WEx7kPT4DcRwfRTJFiMu2MzmMqRZ6tEVaVNRAI6DeVXhCtuiRyA";
  b += "EIpPYnhtMWN0KxBH9KqLzCt3pIZJduiA2zOUetU+VjKnhsG9TPNqrWIu5ry20ojFfheZyc86A2m";
  b += "dQlPcIYo7wJfHLQJvSZqbzlSUyEF+UNRHeeJ739PGd8D+LA5jXYyLvxJ8V6dBzzCWuiVxL0H+D2";
  b += "LwuNgRuG9FX3HXLS2pIfW+oujKY/syDfHWhLExxq1cyqU5TCl/zXwH4lgT/wOmJkAqrPbax+lGl";
  b += "7XDzPMKBujWe6f02YeIxxDDRAK5qOouzohMYg4hXhHOIPpMl6Kn0K888Ybx96XH+19PaJey5oJ4";
  b += "zcIFvLtEKWr73KQQgbQyOdDfKH3u0Yx8y3TMg6K2yl2l4ALaukN+javl+PzgTB8DW/LTeCg5MCL";
  b += "bmMSzOVd7XmZtjKs6qtVBZtgHXrl6tHwOdi0EcHDlBPy/2qQcTiGkQlMNnIJc/ho2Bv1ie88tYN";
  b += "hzaJrtF0JpqWv3ftbqhoROGMdDCiiRsHNMEVMh6tGwgeape3nGHssQlI99FsuloLfYJDVta+SUH";
  b += "uHSI4H9GXrq8Pu3abMFUGW8D8pwd6H6VUUiKqb7CUmImCM9LQlnyavk7RYyepgwFeWj1UdCmcxM";
  b += "wAoMcFfAJ4BCOedVXxdZfcAF36PHI40rHE9GgLY0y66AA8ROw5WREU1xrghNrOMgFJJbdZzHzEn";
  b += "TpUq/Up/gT2dOJcFOUFHWQ9cRAQXJKXDOToHYyKpnucRqjy3htvBSbAlBJWE3opSCedjOOgyXEh";
  b += "xDUoFa3Z40Zwy3OgtFP97Fea1AqFN305NbVU5jZCHVeXZCAlfpc5/qzgtYYBpcsI4R3IS8W7lbQ";
  b += "3FBpmJJA9MZIXqnijFKlTFp5NULIy6l17miwOmCWWo4PSsNobpkRJKuBqDb0L+Ody4MIsLjzYu9";
  b += "ByQbQuq6DVoQR69AAVo6ezaUmSHtTCGRKK5Y+ewXAt+DWmBoXUI/Zy5NinxRrNoJuT+guE5gJ1r";
  b += "VR+H3ytmwLUwwUxczCN+6pbUPPrf5KwvOWyILpvjrSlk9/tSaEVgXuvapaU6njRMZ9Z+zfqW6VS";
  b += "HLETtTvV163aF5fjSkfxzt0j3+627wt7hbqvG1KHoPo3s3i+LZQdmh/kGona5Rku5Bs8icfV+zW";
  b += "xN9VHrtN811YPWrUprguS1RsGa1wS5bQ0qjj5BKwULbMYKvAaThQkn6kvaEQVVK9yftXcw9qFfP";
  b += "cTK9qu3pyMpBdP3HTSqP6f1gNByUEsPwPgAHLWyz8lI6VCqO3/3kCh7xIshY0HxJ/ES9/HEacSx";
  b += "wwzyJixdoqQr8c2d4h1W14Se92M2gb+METNhs96M85fFnt2KtkMA9Nf8ZXEZO/6y5ptV95Y360v";
  b += "9Foun1yvTZfjLrPKX2SX8ZVYJwOyy/GWGgq1SmdD/3r1UX5crd9lZ4C7LqVrvGpxVYwLKjcXcZW";
  b += "ct5i7Ll3CX5ctwl+XLc5eNF51asrONnOW4y1L1c7bqGxzcla1KYzbQHDJdtky6TNOZgA3nXtDkL";
  b += "rPKXaZvdaXpevTjuMFdFkPcSmHtmBYBmtxlMfnA4pq7DF9cucticpfFY9xlvj+8gNFlgbssgRAa";
  b += "19xlCR3tHHdZgmfIXZZoPdR4PMUFAPY5x12W6HzgFwVwl8Vj3GW+rBNjvbPBXWa7+jJylyXwBIw";
  b += "b3GWJOh/U3GWkkwATV6psAsYZmf0E12p0ac7ZsBsOz4EbSNUu3m7GEkzKfHbOXcX3oKCTTHyBKQ";
  b += "ASNIkh1apW+2JMAq2/Va3xbTW5xSqGq8dUp3VSrusMHKyTzPQczGia1D0YnN0t8E+7F9nHWvKLe";
  b += "eUi+ygO2xdHj7Qc6IvOFo+0sMrnXiKepJFEKQGsQ44pY077CUMASrMhMnMBZAlgrbomaAlQZp0R";
  b += "jZsRL3QFzuvZ1Be2Xx1pudANYDEfsVvsDwCauTqc4vluYzbuVndnDnC/i7n4zkx+H/5lVOwgDi+";
  b += "+yL5ffuXo/mx0kX03jiXZ/bh3W6a5HcxGxfWEeK7Wlqb4WXobddUcKX9YSgGJLR/V/gBmGog6My";
  b += "4gDqbOw9ZZhmcQrh9J+2t9uyoTRfrteD1Htocy2D8fNdbq/sQRv0NTOuhQ5z6TuHAGK5pp9R1XN";
  b += "29l7hbCX7BzieU/qs4rLWK3n7djhoIAtRIHtvXdcF06z0VpSI/epJrFSzlEYbZ9OeXumP5XjL4p";
  b += "/k8MwFfojHCtwgcYRaDypnBlT1OgqWuJte0iJdM5m4RB0nCvctobBX3Fq/ORL9z+PF9WDWepxid";
  b += "dr3AD7//YAwjLfMk51L1U6Y2ddXkDtKi5eNpNEiooZs65q8AObIPuzoRtJYbHihSPtyQNCj7gEe";
  b += "dVT4T6J2JGqYiA3VMWPUMRd84jJsXBOenuP1FruYaVOPm0+3CIKMb+W7JesTAR6431F7UlU26Zq";
  b += "W9bWmG1oYlZ5uxtBLgnVhXxG4y3PwFVGcFKJjj0eA6aqDhklXwmJjcLzT5pDYdm1CwTNOGeEtRp";
  b += "ZTxVnXFUdR4ZStkusavoIlmtWpNEB3LOftVa9KsLnTjJ+Vna9vxhay7qEzRRG0XEx7l41rGbqI9";
  b += "Wy3uAyQzse/VNznEb2GtV1GDES9ye3h8Yk+1TbOOkgWq8j3s4iqvvEIEd+9SszGGLkdBjRUKXiu";
  b += "0N6MeKYqzw9jExIhQ3ItKYne3D1laH5pfSm7Lr7NSKIG/H3LVgmWHylHEC8D6KqBpifHhnre4HZ";
  b += "FDcCGSwEhRI3GQk4D1BjBnw327g3d8Ajz/+thRuPyXWfesl99wwSDzGPXENLJi8RMEex7iPa4x7";
  b += "FAXrWa7ZNkDuc7UeZpo9Mia+fdTtTnarz++nxf7+m53F/lNGQXUe8kInKS0U3nJKJ5crnX0ekla";
  b += "1Cdrk9hkV1hi5SC/JdSMl61RsuqlRAZ/5ini224bpDEbEKreKz9orCfooGQPdb0QOHS/FZfR7VC";
  b += "dGn0/MuH0/ba0LfpDsbtr3Iuq5scMu+VAT/dR50Spmm1/yPHqEVJM8ueMo2MEFtavS2Cwj4P2ep";
  b += "27JgD8wByel3412wqvKoIafCzGWsDYnCleZF0/GsK0oUq8yjjmkS6X6lM+pk1SscO7eEw+DLCI6";
  b += "qK4uGoaaqo+J5QyW6xHshZVxxHLUv5TnU8FNPDYcjG0JpgPHVpkGOJNZr5h3/9iYeJ8LFxGJb0d";
  b += "F2W5mF+3fqq/x/TQfHob90O+UTnYVbC51T2fzirR/dTNYcMy5NAnOpbHzLL2HgSj3bJm9WcmjaA";
  b += "WEtd9Hmffcfmz9zqg6eyxOpOuMFBGi9CxAYz9prFkOovKWZDFEpfo+/7r1zrLKQSttWHzBaErjk";
  b += "SNjdYJtujywG+m64uJhCw5u5w4bNqCTuXq5gYur840oat+IqaP6RnAP+mRU6IvfahV65FutQl/+";
  b += "VqvQX3+rVehvTqcK/aFxPmKByNphlwIzgJN3rmIekV+JXjMAEPliBmuWcla3W6Q9vqocJz69XZK";
  b += "+C5HANFzAnG9Ec4bGHY309rshgcPZ+DT1Y1TR/9gEoHl18488F1a02HE9VdQukbC2wnM91awJ4w";
  b += "Bf/zfBCz6l4zrkNYTbR27jLToHvuZAykm977pV3/V0se96ZZ7Ke/2cp3Bf73ITUb7Qfuc6VJL7o";
  b += "7pt/4f0HxSmpT5ILtBSvp4oHrewnd0RhZ7q8zj6vGMyU9+pDPsM36aADeuABwMxLlOw8qz62p8o";
  b += "61BWHSCNXa/a795o9S04dcQCelK9XhOI0J0pAEyxChuN9FudkwzcfW4SVgf0ROouiXzeIkY57hA";
  b += "tulpmpJNE8v+HTWiFRMUa+HrBrbHvoBOsMjPEgY40R+fdgSNlZki9qt1kZrBjzAxmjJkhJS6cSJ";
  b += "V/4JgZUmJzM4dC/dJUf1Ili4KRx5ut/cFUXlJWhu7H62oE70zqiEOzw1NMsCJ0dSsTiM4VthNRk";
  b += "cRVxPiKxKEisVYk1orENcWEQ4dLVDz+mE49ivvtKCaSWo1VuoBAMaFCKqX0cYqJ+LSozAdPamU+";
  b += "bTSsVQlLqlts7QkTpHY7YePIOBrp1DmD6QkyPx/MoC+kNE9maHUpo8/+Id6o3mzVaT8JeIG6+VW";
  b += "ZHbonF5HGBJ42zKW68226lVhjVWyMJp0VSAZMrTgvkWQ9+0b3z1zFDjqYGSW72RhdwQVFhv8VdB";
  b += "VJlFLx4WhEl3NnQMKGpZx/3FtK62mcLovbLzFJdadRywl1zEj9giNPbJrrUlbd5slB5IVvN6qDH";
  b += "UTy+AKTXBK9A5feZeiu4OTwW289FBVH8MUOKvp2BceDam3xB/LpKryWH/EvXfUO2PHqPW58/R43";
  b += "zQoWI/pcu/pNaP2eNMvX738gtLx6fbK4gvut1nAB68qt5D8pRj5X1nF/onW8NdE69i6JXotLtyT";
  b += "NOt4R6njALlfH16uG95vPIs/1CJ7rEVzRu+/RYtNdYd8iKWOxfJEo/G7kzJdfBR8KBIi+bRrqKG";
  b += "nEDTnA+4mHaxz1XdJqB4dc73Y57nPurnYrgyWn+14UdrEo5MUg2yioTDROymoUFoipyslzzuLyL";
  b += "l+YhpyzqEC1xDPuB6/Xul7S+Rgl0RtqWUfamVF7R26THrS++BO6r6duxpRFuPg7dZFSa1ZPWbHC";
  b += "LRHTPGIVjV1SEdS+iIfZCyL+d6T696U/jqL/ODQ7YRt7D1ExuwxmxduVKCoupF33YaEtzQyfOvz";
  b += "kk09+tXrFTJF0aynUizi/W0ttXR3Cy8hsAxjtGWTYhTGgJz8U4LqcY0oaDYqfRohM2S47xU9Lcb";
  b += "pj4ltXhbMgvFk3U6xz/Kp4bfWkwh5GgSDVkQ1MVU88QiGtvgOjPov/T0kTVAxW34SWrqxWE+C9N";
  b += "2jhJ032YRexAoXpa5OZFCfdQd6UWQ2mRAMJ1ThrTaxIQ/mo+FzsGs3rGw66OgOLfJXv3lWt3aWq";
  b += "x6FaGWipw1dDGcgUIz9TFHynDKiRN4Cf0ahLMCtujyVgJ7TFB2gj7dWJtLTXBOnpSs62Uv+hzHO";
  b += "pQp6hXXRPelG7xD5GuPh/A/NHy9VI0SfHKpIvUxHn9NYar4hpVES+t6uIUaJtXxHTqAi9DUEk+N";
  b += "vKaaz7/UUdRu0xnUwD/MkcDfypS+hLUB9QxwlZd0PeyXJ5J428k6Pn7Qgpul9wa58SbuumQA3Pn";
  b += "YcYe0hJMXf6Z0Vgv9RhS1NtuVQnNRkoMu2LthYVfw7MMb9joJjRFHKT4hvW4x4HzVWpsP9MvWj1";
  b += "NS7yvqj1zrghlBmXziyTbhGyNPXTL5mnZg4LzOItxxEWjdNo3fvgA4DF/Z0HSWRMNq2Dclx8yqi";
  b += "T5e/iRjvQcX0Ep60GHZdxXFt/iBv96nP4yZRy6/0PaD70jz+MGykeJAPXl5guMHD9LZ8ODFxff5";
  b += "B+/A0GrochSleHIiJ+25XRo9VNQPdraYOzoqVEaWdNrV3TrayIFrH8JfKXyl8mf23568hfT/42y";
  b += "d93y99q+Vsjf1Pyt1b+zpK/s+VvWv7Okb/nYiMdmS0Ydek/ZAa6nbOnKneCEOWJJ1s7q3zPrtLs";
  b += "6v5G2OxcDuNwWXzDy3RKiMMYHcMbkCf/a0wWOm9OSYp31uM1bo6pgBuIMZV620lzTKVzIRotAAd";
  b += "2/2vd4VpPtRa1dC1q6VrU0rWoNbYWDQh811iBWid9BWpp9/my25YJEwHnJtGRHndzQa8xFxQD5Y";
  b += "xbBtUjTMLHgerRMGSlzL6eDop6Oph6qumgqKeDqaeeDu6G1GNvHHN72jyiFPZDlICkwJu3Ot4o3";
  b += "eHBHr7RHRHuNn1ULyW8hL2Ty4bpHNUxecLMedDbRNmVcKuKxmxPk2GroD+q6E7NyMWzoT4YZYty";
  b += "W+DvOWr/v+WE+r8DY1CDxzer42+qWQ3Uw8JWRuO77juoViFb/Y8IPpaWHw0bXpaBa6KtEzlbvaK";
  b += "Lf4rR1VUj28ruTpMAEfOXZv6JkPkTLnOXpeM8VYIfl3HYd/rGGJFr9egXDiH8YTpwMDWnSeNWij";
  b += "yvl4rEh405gPkPPfRANIirNXV8J90Whv5ZhPvELjDC7pae//XPPhC5EEVTPfwZd5Jy2iegJ/aeU";
  b += "+fsoG4d+Sjc0i85a0vYyqyamIiHAVd73ZbPdJfLIVkkusaSIs7KClYt/CVr/NwBFrDqnXq2aoD1";
  b += "q/o1PXsOmbKrj+rZpQMsUdX+L/LsXIa2V7+iZ5/yFi1pb1cn7q03jFnOAYuzzttrk0nqhS5svZM";
  b += "DD/g2icsOmSRd6Ru0xiiYyvxV2jsYFy+T0A6eyv/7yMH4I3uAaLp9hsD47D1OlYmLW4zCLMSKzz";
  b += "JI6tIlDaXivzjrVKBWkI/W06mhxyD/Yk9lB4ypdENsGz0GOJ+Tocuo0GmXM6VzuzqZGQ2tOtapS";
  b += "yrjh3Y6K6a2JLNbBqE7v0idZTit3dPcVlD7Zlx7cSRuB6G4Te2QfsK1DuKdRkoYUI+82VuL8npz";
  b += "tI6wZrjWBs7/TsKcXjIn+Fl5+WjWRIu7U797mCkUvUg60PmerQRdHNjC1fRuSKtPxDuhmxAZkGd";
  b += "4955du9ThxFGWJDJFVjcoZYnfQPfj/A/HcJvV/xWqRK5NBlJsQzZzF4RS/F6sYdlh4curolpVtq";
  b += "+ZwVWvVGS6GjIyM6u/b65DL3drT+aVihYmbKdwOf/s2Pv/hQm7VWtlwWqv7G8wQKOU11C7mVYoE";
  b += "ZKbRySmZhf350AHAe15owfT9RVITRcY+G2+c9KxnX4PuZmrhybhcaFXthNdvig+6ATQx6L5AQ2M";
  b += "SgwNw4Rpevn2ai9fl0KUt9WSKNwkRkDj5prxm3bs5tT4zXjs5trxm8nYzbOaN92aV30uKt5HAX3";
  b += "pYmece+1R7iRHvRMf9Y496h1ztDt+IKu/hx/DY6sPP1pePfn7Jgxpmail64G7Nkatk0ZL1/fpnH";
  b += "fd/HgCWyfw3ylptHbz5prxm8nYzanxm+nYzbXjN7Oxm2c1b45/p3w5Ddc4opkxP4zwSZOjftLkq";
  b += "J80OeonTY76SZOjftJk6Sd1kx3Af0br6zxazZTeh67VUNxbyynuqYuQUFnrG8HlaNxilC6RyP8o";
  b += "YK5lzoG+ai9j30kXrVCp2ndSegw9DfvO4vJIgj8246YnikgXquF4m59BYGmAF6oJKaVXdwH3sMz";
  b += "wWmZcBT+jOHgwH8Nqki9nNcmXs5p8tmV7y60lcRi6bsUtDhptsmBli6Xxk7rxE7VJcVsqqRs/Vp";
  b += "tU7D56MrZ8JCtZPpJG43dqjNXcRfMqtKMU8jpHZdyBOpevoDv90tLu1FnSndrLdKf2SexO3WaN4";
  b += "lAjQNBvvm4wwRp1UaN0iebUJk+Dak7ZSjSnrPFeLMQUD9q+G1NA6Hl7IzFVfL9t3JJu21MEL+JP";
  b += "Nrvtokswqfc02NV323TRgqFtGPSzSQ1caepnaTk5N9bYiqffdc24jVALmwH+MFFtnh9OMFa7Kyu";
  b += "JvKjbLF1FXBKVYuSOL1G+aCDl4wNpUtFcmgMp1xLl4wMJ8VgqN/cjj2Xar3rzw74rEUdsZ1GJkg";
  b += "DN2Bkf2q3ldNiWlmiZeXWyqcP6efVttUE0DiQQtrIaTOQAPtxMRsI04wjT4F1Tz1QxUThJ1FDTk";
  b += "tcydFR1G2sYJy9yUjQoBxLF929a17u/TB9JGuuoU+y7vlq4cdcAgn48MNW/o6MubEVR9fP3KcKE";
  b += "Bga8CWcXgL8ae5dvdPfkeb1wwF0QqVuk7J/YqSU64B+Kqje4BENDwVwfZNLuiJaXbDSMIHab7uO";
  b += "xAsrWMCuXSs2K34h1+ro0TF+UZxkASfXZu7sngWRTJPGaZDMBhlTu5gmQbOaqAneuoqzjYaLzBl";
  b += "mMo8gFAhWfzpzcAzSoTJ9ZmrwjE4QCSPOZdpiZHGpVonB5iWLkpPCHXpyH4+J070l1ar+wnggzn";
  b += "QjbTuA4VrrcU0Z4g3ruQnn4YL7Mg3lzpnUu8GjovLYC0XIAWMAvmcbw6S0zfPB9nG2txfCmZZC4";
  b += "QuAmhk9AKdKvWX/9BF8/9QEAuqsouRc/w9/c32oU7r2msWz3lspMSaNwyXKF88vniRfu1qMW7i9";
  b += "PbuH+5vQYNyseMU9vrDzLRskXT+4o+fvTZo48ngnyac+Oz7KP/sjJ/ei/Wts6HX4bnXi6+lGws4";
  b += "iApuL1id6i1S/WfUJeBdIbnSQMDWQAAWUGfabqu1QKmVUlDj9cMsrAaogkE83sW3QTk6uT/qrnH";
  b += "DyRWfJ1R50lHz31U/jPHrVwnzu5hfvy6TGseysc0r2nM5x7z6qh/OWTO5T/+XSScXvHJeL2nr6E";
  b += "++z69H97cj/9kdPm0x/Hd3+6H/3Z9cX/+uR+8T8/5V8cmNnH/NZIdGJf2UFr/886mf+ck8sWGt7";
  b += "tg8htQlZPggal+jSMIJMITO1snxHBS/FxGWgvAt12FGbPgOTqSl45RHY7aHpZMNX9ILH4FXXpM9";
  b += "VblLSbuUtSxCzPF1cFJ4o3LS4O0H2Bx8gg7LEi2cVFgoMB4rmBFbmHhCHF1QrAgDJZVyZ71DJFd";
  b += "ZmiZplev4ImmnvGWsib6Epn1t1CvDyika2jJb34czskqEFEhFSGN5WJui4Bys4CwDtXVvek2B8T";
  b += "UoxuFeonMSWvfeuhyDtNeCgCd4FuWrb4C+viPia7Ubd67C2HFP75U9Zkbmebg7+0xPawpMpllIo";
  b += "iIANa9N9QUPV+LISmmZKft7/9EP1Ykuo74caSELpBo4sS9ZZBRFwNVJwQsMI5XGSNDUM4t03YyA";
  b += "BmsW+qz7ztkNwHPgKBF/t0W4iGmWIbZHxaLdJTmOCuJz6m+khMDVp6h0Z9YkbQgSJXyMwWfEwAH";
  b += "pEh4kmh6ghcxxE9JWNNbreZMQIAUr8dVpFf6neKDl3AcVx0u43gj0S37j9+tl2zL3a+De31MF7L";
  b += "VNtyc7La5Dfr7ksT3MIUn6Tv2sYoB76wev/B7ekfrYsR2hi1i5d5D8pGw0lbbPZhmNnG6FI5LuY";
  b += "nrI2x4S/naK4Lou/DbA8coKx6vsfbaZUpImrUiw9joKXuE63KBGSq7xtdQMDulnx3MDJUqyQtnM";
  b += "BgvwbGikJzVb/wXQDvgx+Pr10THcsUOz0wlm1QTRfDtciUSdYSTKgAmFAj3Rhf8Ucj5zx9S7KsY";
  b += "6iMmCsCdzGAFPokKZYhF6X8iX0uGFb94jEz/gi8gj8XwR4uh13pL/LTGXTY9APHB9zDT2vQx082";
  b += "mMBPOpjETzIo8BMPVuHHDlbruypeJb6gKf6zDW/E3rRcuxLsXy7d6nJVSLFKN6iZYlVIUZSTIcW";
  b += "k7lIzxWRIMVH2Q4o+UrQ0RT+k6JXdkKKLFLmm6IYUnTIPKQgs1na3HpuoHpqUjv7dOzBrlqvKyR";
  b += "LhCXi8+EGm55zBTSXC/sWuzUtHtQxPRH5yoNrE1wzPAqpNXJ5Vrr2reDkAOukgnewCtWbxwVi5v";
  b += "ROHghRrt+ySwvnKwVr1cLSI4fIUzujJzD9WT+42/S2vHOTe6eKhsMAybe44pBXmkdm3u3yrfz+v";
  b += "5ctca2m9mXUbWf9hFBiimbUCerAYadd/6uXTJpp2lYNKW0naSaSNV5a27wKFVpK265HUVpDW+3S";
  b += "ZJhG2wpMhnNShfsWAL0tr1K8Ys1Bao37p845hgxM3fLbc101rn63mx7X1BwvwbpgHtxJmLwEiIe";
  b += "Yh6Umu77SUocufeC+JpzdZrXoak9Vy09VkmK5aS6eryeZ05UjVJ+rpqj9IlHcs18mro5NXVyevn";
  b += "k5efZ28JnTymtTJq9DJa5VOXqt18ppyI37VMpPXmsbktSakmypX+xSNqWt1uL+qLEIORWPqKkKK";
  b += "yXIipJhoTF0TIUW/7IUUvcbU1QspumUnpOi4qQspOiEFYGQa07ACMqKR18DxqFw9KjGJQgk9OdP";
  b += "aw6bXb85rq442r/WOY0LpHP+81nFz2KrGHNY+jqm0tczzrZXNE2vcHBjwdHvqUr7Sua44jrlu4j";
  b += "jmut5xzHWd026uow/H8Ux10xD+HvK91TonzMxHCJyl4OgZIgTOnmN0R4lCeGTfs/RIHjmbRxAIk";
  b += "ajGPT/ZL4jqFyB7asDUTtohAL5NTrlc6TPhzeLGJqMb2nIxnBc4n3bnVe0JB/FcGo9Gj+J/WBfS";
  b += "0FYfhhMW5j/2LS3MX3saCvOPnBHmzwjzZ4T5M8L8CU5Wz7Aw/8gZYf6MMH9GmD8jzJ8R5p8pYf4";
  b += "9Zowkfl8TUgDbLwzIw0ZJijjM+YkEcbOL8BUOvIm08ARWuE2Oi0MOEOHON3kEhLirdJeAUfgvuK";
  b += "rh59W9LjkD1A69aQwh4Q/f5HAYAkLCgW8+BlLxruOCN3pXzSyO0GFDlGxTvf+NUvQZKTp4F9mQD";
  b += "NWMFsc9W417PvxGH/f818eOe97qeNmqI3hJgpewub6GUyungxAaXcbdvQbs1ww5BDAekJ8JZz7M";
  b += "tjz/dWW2ZfPrXiv/tm597Q1EAZLLG3E55uVMLiuAvTyYE/6+TPFcyudSPscH82GKB1M+mLoHc/1";
  b += "gdZSo7jqySlustsD6UfUpRU93qF0MJa9ijah97LDjGKr+xJDctIyuRQM5lMSB8oxOjxTzGDDyyp";
  b += "Hqmw/IiohKK17ig0gPHqW/a28HfljFOFTt7bH0dm5p3nu7NO45zZ6Mjv+x2+uO/9DtjZ58GDd6r";
  b += "if7oYK+/9jthCL5x9sdFIkMgcdvJ4RI6OT76y4V+4jqZJioA4IpvhJvdZF2m30ACsAmcAOviBUA";
  b += "Oq7WavQB12FTfAadefri6ELMm/UwIfGZjhJZbWcxSmJtpxuIseAI06RFtity3g4Geca7qdPlpDL";
  b += "HWeyAxOPLKnnl1jLZuqtvGZ410o6H+G52rxfTNyKf52qUgz4wLbOXKqdi9aQB3rjp3sJxrl6Vga";
  b += "2GSIKk0CEsNPE0alBphhS6SY9eAhXjryfraEMPseUgt4xDjFcWirx2MbANyInXy/fXMLGywV8Qj";
  b += "/MXGA7pYdLgL5jSPWjyFxjlLwCcRKBeIn/BFCDYXeSYWzRT8hc0mQVc4D/hCX86BLOH8HCzc5iK";
  b += "VOdwvRHqS15GBrekVeeVQ3T74n3xWAQbv6Rk2rluvtq0C+Gay0ZANiPXun/ast0QnT4WjpY2wtF";
  b += "SBG9163A0H7yVrwfG/PIBdv/Bx9dlR4+vay0TX9eq4dAb8XV5I74uL3MXFcZopjxEheWL4+vq4i";
  b += "iU7x8b7+FTg1xVpiJn0oXDeAZOv7EL4aULT1cNYGOBapWsB1IJH6rWXkmoWtsjeQFaoCXjdB6fh";
  b += "8LNeAhZpq48PoRsQkPXmiFkWTkxR+yI9lgIWRJCyGzXlX9xwQftcYop+UjviT3hjYuUa1fKx+2+";
  b += "Eqm5+xQ1SNjtvlKbmrn89JzDjvtKbJDWShqkFRokoJ7kDvVkaZO0VtokrWWbRGMhPZZgumhApBo";
  b += "iZ496xxztju+e4dm8mcI7PeVa6FS7ajMUcEJDAdXpKW8G3qU+8G7ziNB4m+eH3acKvEtDTK0G3n";
  b += "UXapf2ZBn4jnQMviMdh+9IPXwHKBkAGbgdEB1JA6KjgVQCPr8x2B8PIPIalMDDrDi02Ksa1DBgf";
  b += "gU5ijrOu7Kotz0A5RjTlihBrcX6Td5oWXewxvUvn1E2bkkA0TWKDETXQQNzWj/QXobcUf4oHQwx";
  b += "J2qUqa/YPpy7CSQXKXzsEO5JqxKunN416ZzSqKRJ8YSkBQ4vKiGiBbBvXN6J5izJu1+zJq9xjV0";
  b += "LYmq1CVdBRdWb5zIqbb1jJq2irvrwwPlomDtqGwpisvjUOIKYMIfWBdmOZ9YiSnJLMys+RRS3iM";
  b += "uxkkIQFZvOSol24x77rqLqaI4ZZv7MfTX9LC2p23aF25Pht+/60TDbPmzLmk9qCkxGM5LicsXHn";
  b += "R8oYHgycNDotmxtUwzQnCAijFXU8EunbnpUXUnIgEwfvx+gwJwOSaAcru25p+tBZOvUXA3DfCuE";
  b += "DKC/OISfBQM+t5gizQIgpatEjxcSnKTuBDxvIIy3DeqOroojRD0+LplENb+bFsWVeJFkSO+uRAU";
  b += "Go5SAfFNS48JEesN6YHitbWV1SX9NNoYO3B2p36gV3UW+eo0phHnA7GtYCZVUOMCjx6Q4hmhUSO";
  b += "Oud9J7Wl06qv7IKN4O4ZrT6qOPQHIBLfIn5caFJJfdRKk85We5yG7mETrWJhoEyqR4pwjZrxqDM";
  b += "TTK4gZR6wLTo7TJdehfYo9lFiAnIEgWu3cp7JiuRiuBHQtwYteaFBpSvAVtOvkaSNr+ML1xSH+4";
  b += "LeWtw9aNQ7jbGhznN94wlIObbxgmqh7JmvLiewA7eiPkrheDe4Qp94t2JJPRjVSGfvKbJdefrXL";
  b += "90UR5vLc2yersavskCaeariMsrmdSRe+ynve6T1us+hwazsRdAr3qpBoZQzjsJQhR3Tcvq2rpNI";
  b += "uA59+L5qEtVE9IV94pw+bB6HIqXdbYaFxres2HRV1aU/3ihxX7rroDB+/+cMOMIMfFJ7wZ4cMez";
  b += "pF68R/w4aYZYd9KPoQH27bN4WVrRoYVfx8LawFGXPggPzHWLpcpnZUBOw8XoURGX5dBYMDirIhH";
  b += "BSws47GwDGA0Pv8vh6JqVbXwjUOiPWp3lt4OdeMWo3RghOW8P/a1/ummKq4YbdU/wmYwSTvFYpS";
  b += "2o0C03fqm4zBVBIi2/2txixevTlbYyEThSgj7+OZEWzpZpqUhFi7b2D/WQNVySFUXs7UUykRD9r";
  b += "5olkwr2GPwLHwb3HTSU+7igD8Qk+wu0L9xOlnR+x55ht/3hWf4fX/5DL/vS8/w+x59ht/35Wf4f";
  b += "X/zDL/vb5/h9/31M/y+x07e+z6Z2E54oTrb8IUZ4X/kpzsadJwvjm74XooSMNgpRbCT3/F1xHUI";
  b += "tUlcsJOWvw52SupgJ4twpFbYyt0k+gOXze5VDMfwwU4tDThDKBMe1sf8di5ChxJN3EjXDSFPthH";
  b += "ypMnVrpuoMTjWfSrbeNhFPbmcY0cfXtuIdHswRD0dK13LUy35qKeWi3rig61lHnRGqMQJlBr1xI";
  b += "gK621QNFt02AkC8k5aRz3lAdw/1ainXGk966inXFXV3JE2pYGAOBvrUFndoTJ0qJ52qKzZoXrND";
  b += "pUdRwf+3DM8YN578t73+4GPteECocQuDThQ1dr6Rrt+C8RCWdm6GkTaVLV2KmkQ1TYH6Jno108q";
  b += "DzxH7ZqkhQZmybzmqga0ZNmaVy2dHaI1clu+SdUfC+zzu5mJwoXqBX0q9zjs7v1amsUpuovZ1me";
  b += "ptNESQXKIh+8mQmjYnHWoaWmzIfNmQ+qWrGhoMJLAk4L4A6m6DETbYLKHTu7Qq6OhaaBZK7mVw7";
  b += "M2AbV6GFF4m3TkVw7Vur7vTDRIZLp3JrbdREYFkQuE6x9RE23ixxrRx/K5eLMjJ/UQxt6e6THQw";
  b += "OEE4KcOA6YW2zrLrLjVeGunC++kMcrBcCqHAYx0kvJnjOoPwXoNcwNwagt8mjRsHaeLqAR8oKTx";
  b += "kJGaotVMkS+xmXrbKyHaiM2GafALVPbby0Bz6xhaF7BiNUhudlTzKBNKtKw5lcthdy4uCDUhc1b";
  b += "md/mjsgvx3JYdR0uhPYa0XgrgLVnTJjfrKZc1O2QWqefF+aNqvWNh7TVYlLEbWYwPW1KyOiyyfN";
  b += "D1oH5F3T27cw0WO7dD8YoASKtdxAHSJtQxnzQ752lSSsqUeyNsg4ymSzm6vox3ltn12tkTcFFvc";
  b += "hi0ifscLpDtoXj5rvjKlXbF1qKumGlXzAl+t9hNS1bG1xk/nDveEs75o118xKpPQqIYssEI3mm4";
  b += "UYx1m9Zy3aZ10rtNvky3yU/fbvNjQS1WLuNId+KUbFeaSk1dMcrxEb2HSb0HSNYvP+CIWXBjPfn";
  b += "UyxGUY3V/gioco5FKJzjQzrX4fY7V12X9VO+784tP8T73Mr72Kd+38vrtf/Rk1G/l77v/0WeoPd";
  b += "VgU9361yfSnv/ebU3PyiSxmF88VX5xpVUp46u4u5XuIGOY9PJ5Z32ELLt7pJZg4ncXv8rtKOzxF";
  b += "P+3HP5bNfPGUivSenS2w5Cix20VRQJ3cZfryh7PW1yaSyLv/OM2eUdVMS8LqRqfu/PaXmVtBoLN";
  b += "6GblokB7RcHeAwPQnV/QRrLV/fTFKBybpXfB4FxQvARPK12OZNX1G9bzK7R4fiI6AVeGK+SDvKu";
  b += "289zu6C+OuNmWVFgyxPG+4tfVgOygl+Qlo+8l6vi5P3H3DZLB4wceiHBlL5xeFYcc8di6BpjiIw";
  b += "mRVjHBQiTZBHbTjdGlpPt01bZBoA92dQd3FGuxPAY42FAf/IBIO99DfjcijkOXcowhsFyvakWBg";
  b += "9BpX8RRMPhJrnZc59xbLwNZOe8NwVge9uiSrbofZ3eLiNfiAkPWcSlBIlfaxYuwKYjdWdFJSnIZ";
  b += "JMVX42G+laykLR1KLcohmiU28VJVllI/65Zu0l2m77z9g77vfP0D3mqYj6ojcplDiRs9w8DPiNa";
  b += "h7RlLlmM1p+lSsleaRiKfs6q5sm223HKQKVR/RpVIGROMu55w4zEL6wYrpXDO3V2O7s2TCB00E0";
  b += "kUx4Yg0g9Ho+JXYyfROk4zU0Rd5bSMqteAr1FxLPJjpbyKe0RyqfvDwYejJmkpXr9E26naJ7yfs";
  b += "ewb/tIueUN6wm/4riYdEymlDPYiuSZHc76Vc294/rdNFzm/wbx46oz91Kn4DA6mYZa7hoYuR6Pi";
  b += "hqWcAD8aac7R+qi6Xzn3WLlpZ7emhRmyxON/TA5bOfoI82URz8eWbLV+dBG9xCK6j61XJpc7P+U";
  b += "7aaRvun5RX7k1afSVW+2o+DI92Bbski6w3471lmMmrDvLtU060mAJd9vD1Iij4q9iZUC1Opqolc";
  b += "FLSakJbTFTqk5LFqs87P9H3utW+UFL+x37EifWniXvOsuDSYcQr57XuNoNb4l22UbYwHnYBWOS8";
  b += "xg20EbYQHsx5HMHXgvIt8C9iK5AB4y3Un0mUreBtzqB96W1R4YM+ueWcHOqJVDGK7xMoxXke76g";
  b += "TLckc/ZSfVSqJUsIH/18NBqsiy/T/AcOmL8nL+xREmUcRK9RoV7ZCxXq1RXqoEK9xRXqSz59VGg";
  b += "V7mmFDgfw7YOG7MHFHTXJgmgIB03tUASXsOpuo84Efgff3gmvY2B8KEfxdWWCqr1C5uwsOCXJd/";
  b += "2K+h/daUaDc+X3T+X324i7Le/1WsZqKchqlYKxm1zMy+OrG8oq761mhevvtnoMMvveEO7x9Qi0V";
  b += "ufdVdxumgEerwoueiqv7zdjojx2Pt3DlBQ+ZMNDiq38j9FoiI2lnzWj4dlOb7DVX0aqF7xBrpb+";
  b += "qpy/Ts4HF0TRJWY3z3/OjHj2cp4tmNEGaUv5etfy/FZJPeTTPy5nr6ezyOA5cniACQffKYd3sLy";
  b += "Db8d6pYeYXA7q4QwKe8MA7lh/LzWYqktygdl9SbRTrv+VlHQ9PVTCnZdfYl6hdR6s1Q+xRlpwDX";
  b += "rKhJ5Pyvmkyg3yYb5jOF38qLTmJKk3tTUny8kxBTLgt0/Lg6IwTkOFe19Acn+e951DnEesotlFj";
  b += "tzKFnCumiinRQkrp1U74445tL3itfSpwaQynF7uyaicUM6sdV4Rm2AxXLIJ+hRDr5oon+e8qoIi";
  b += "hioMZvWByVoRmyhn9QF1jpr0SueaoKquLdfg5ZJorZrQ1iKLNfBut153XMsWLb9Dvdq7cubZyLR";
  b += "3STZTZd2jhqOy0ZEuiF5nXB+6IPo5OSwxm95q0Ds22AUzOE+/PAOJXm8QSbTBHjBSGbl8hxmQt+";
  b += "3tRjvIQYMoIYzcwQZ50/OWdBSzHlbq8+6S7LRIQ3XDqJ7rwlL50PrwEHr4MNbyyc86zecVko+DX";
  b += "ppC791QDtVFgiWVEpTffpEUXX6/cy5+FQp0HaqBmkslfjrU/KdYWxmaUpvvvGsArumzsemfDdS7";
  b += "GZIrTCPLDOVrXVAsRpbrDTSaefGqBRHg2jlG2NIroaWuccz2nNFwLWsavslZMuRZwHDlLzhPPHf";
  b += "UbL/1l5hpPSovMVN6tO6S6Ifk6DkXR5vl57w5u0l+JnRDOlMX8ktG5dpmNtOXRP+rHE1eHIH88v";
  b += "mjum/g7tQl0fehtS+OXiY/G+bsi+VnzUX2GvmZucheKT/nXGRF50DfRc+y6gXmWyfO0eatMNXNj";
  b += "orXKQUeZ7hMZ7ix+W1K57en6JQvP6mdMmuOhSU9NExdpX4r/6WGmf9W/ksNp+pPM1xbf5zh2fg8";
  b += "rWqNvEpjrddeEq2Sn7MvidaiQ8hbNZradQ1p5fPlZw2+VwutvF5+zoG+3UIrT8uPfC3JEt+5kJ/";
  b += "zGFPDCCjXs1DWe32gUqtczSgl9L5MFrY6SqlVtXAeopRCETwPAxZBaV525tW1ITykO4992hltV+";
  b += "tMw9UcBryN0cOG/jAycMpzg4B69uXk6PlzAwXv2yrrC5OU38Y16/N0kLxuSAfJa1UkeATTd/Eo4";
  b += "f+uGyhQ3yvIiYH1MFP7BX1Mj0Te5BcjSP1CKJAXSJ6XRN8rSeZG9B7W1yEvin/XqfBA7+qvxFBu";
  b += "kT2q4N9GqQVQYG8wTlrJPBkR7rA0SFz8ReO+Fn0TSqVRN0GWecVcPIu4OOCfqbDivFHjcC3UQzc";
  b += "9FqWjN/vXOYC8qDQmKP14uUrFqHvDhLSqOSGtgk/kj+PjrQozEVtZpKF/ABThp+NSa+hAC1mRxl";
  b += "vi2bn4pXLx3UZtic1bMuQPGiXJ4DZCsHOwseAfmsiXJ1uuddaOVbqcrcIWHVdNLe0it6IW5Tu1g";
  b += "diGDWSVfnyAcJcZyp81PF20rUr0k0V1sLOI1nQNdeFYO8XNdprWdgoQjka3GfsN+bgP5aOvUsKQ";
  b += "3bFf9oPE3GVlyDTCEYMi4Qn5ev1astAnNH2B3IJk0W1+OnlUJYuuHFLo7wcv6m7ZcyO9i5Heq0d";
  b += "6FyO9V4/0bvDN7ukQ5zt69RDXkrp0kkrHdgohRoq9LnwZkeXX0QXziqCdQICV4xcoXfplqqwQWv";
  b += "Rv9QaGFPbcIblxAKcb4ivUHJnXFU2ZlgP0Baq+YANZBygM+ZvddnCdfIO9dC6G9yQ67HMb1xH69";
  b += "1J6XI53SKo/2iGT8Q5ZaIcsQocsluuQyVE6ZDHWIQ8v6pDyoQoN+3w08p84lREOp0q0b7PgV8zF";
  b += "JVtPSib5WEUZnNZW0p7GdCV6WuFKqSXn9ysaPvj66bzC2FQXr1haoKLZ5wr3hXx+yO2AGwadxjD";
  b += "o4Pt1msOgU3bCMMhD4fIwDDo6DDr1MNAnNH2B3MIwyJtFyiWZGwaOxafmzMnLthsG2HQRDTwMgx";
  b += "zDoF0Pg5rfp63DIFemo+ma3ue8Jr1P28vkZwWZPCrPcjK5d9tDFmeFCqnJ+SwaCrxMfpYajH6oy";
  b += "cIZuDc3RkXxvthrMMvQ2zLQwxyN3jZw6tw0WJnx4pXfDOOFeuB448XbHKFUMF5karzIxowXiBBW";
  b += "40WmxovMGy+yhvEiC8aLbFnjRVb8+DfXeAEx4C0nzXiRPl3jxY9540V6LONF+hTGi198OsaL33s";
  b += "2Gi/Sb77x4j+diPHiA2eMF2eMFyfNeJE2jRfpcRkv0tPJeJGehsaL9DQwXqQnZrxIT8B4kT5bjB";
  b += "fp8Rkv0qXGi/QZNF6k3xzjRbrIeJE2jRfpMYwX6TNjvEiPz3iRHst4AdUfza7EE69ArFd6MowYs";
  b += "eqM6UqNGHHTiBGP6Yxpw4iRqs6YeiNGGnRGNcIATMFh2WtVTqo5I12pOSNd1pyRLmPOSI/DnJGe";
  b += "DuYMghZJSzbMGVkwZ1BfSVWkzWDOSPFzmaovl2KX9G/1BsLHM5gzUpozUgAdXaGBoHnd9nTC8OY";
  b += "MKjRZw5wBJCf5pzZnUBmiOSMbM2cQRonmjAzmjLGumR3bnBE3zRmLu2ZylK5ZjHXNw0ftmt6wkT";
  b += "XsCBkMG7G2dLMKNGygHWkekXZNqOZdiuwIKBWP6YVjBo54zMCRBhiqhzinZA0Dh1cpr1hasKLZC";
  b += "wv3zWoDR3ZsA0e6rIEjXcbAkR6HgSP9FjJw/Gt1Dtk3Fsx5mfr/mL5hcACADOBfw2zo6wIPtGx3";
  b += "1dpFEJ1Svlg+L03xU3fNV/GeyW4Vdd/XGUddqVFVxuE5rvP+6rbBLF4M+wpoK0n6VJENVOTWGJz";
  b += "jgQD8AWtDsthxiB5WxUe895B3boa7EP2Eakdi52HnHImta96ax+Rlvmz6Jo6tl5PMJGkSntA23y";
  b += "ZvkiM+sVULno4MDHEiYHtUwc2RYLyMWkYMkgZQ0MPMMAR+QJg8lyDCi8rs/MhU0Qup8B81V7xTh";
  b += "oUZ+fykL5l5nyWqeqiKrmAeZzPAn0FNS/Mh9FNWZ+Jy6GpEUxQaZZvGYpdaa8Ai9Ng4w3aZjwbQ";
  b += "SWEy1fhpYNmAHehySjUG7ZiUvW38KG2yRYsQgHFj5+VuACiQV6JU8wPMwERAVXCUvEzm1XqT0fM";
  b += "rQAdk1U0W0AGZQgdkjMq5GJ6lXVf0WS26VWS/WBbipu59vkc2GiaEvGBBGURhXQ/QGsWMSAe/Oq";
  b += "LR+bUNsKFyKIcA5aUqDOelgZQVjaQVbCAgtEWp3Fm19pQJCZIQx7OdIKkOfQF9QH0WM/Us0zt63";
  b += "QZUhm7je9Cl6uXs+wqOGhNYI/F0WI6u3QtSEBJTGVwfYDCa1P7lgz5yuHaQ0DVfkj5WG8DLRBee";
  b += "vqK6eLgZ95jL+tEG/EszIYPTRChKlmvxaf+2zbW1vaewU2oEj51QlIaYMw7CxNMCPRLVfF7Oy9M";
  b += "6s8gBr6eIYOem5BRTcqueklNMya16Sq7fgsnI161VT8ljVWtEunQaU3JnmSm5s2hK7oxNyQ7Z5u";
  b += "XeBbgJlaEIYFNuqCLCQLuERpLp0dg4oJsc4xYgJqjTnI6B7mdjY/chOh+WKVNbpoqHDHG5YuiVG";
  b += "PtL7iTboO9snxlCZHEuyzoHF65kxBHt0aLVuDCFn4uj2TLeks7BK51GNeBuxNx2kgVW1oLPmnrS";
  b += "vdS7e/LBzfrgJj44NYLBwT14PoSez5rwCJQmOV4/MBWUw3hjNNu3VR+gJ7heEgZu1l44kOGK+Rs";
  b += "pNsscS4xe3Nm0Q6WmdfjnfELyyN/2meLhZND4mPvg7i1zVZnMDGVu2QZElCtmEOXHwI6kbnQwo7";
  b += "mR4rYDLpsP2wE+Zu4od/x3bIDAGdet6aRNQBaHRBDLy7v/nzHZU+ABEW2yJzPYkJFfcQBASxpYO";
  b += "HBsjny15WlA2SB4FSbpHTMiKZltnFpkuiOuSGV3j+idbopXW8WZA54a/CMpOEuzXo1VjIEEQzrF";
  b += "7pjhAwkeQBzSgOTBcpMPOJgiFTcpvR4Nf+jaZbdn4AOfXBCR1qzRg5fbsgHt154V7NT8R0Xcib0";
  b += "B3kF9AFREJt4n2SJWupbRZdoBXfoTZN/SBTdWMJvIRz1wwe16NKeXe7d5+rpLB9agyeiKPiIYEa";
  b += "dYvU99hc+h7/ITDinEFE/G3SEQpxr4UJZxGvQ/R+gD/dK/4CjiCqeQ1JBIilMIH33GV2cB1ckGD";
  b += "MO46aMf00efnaeFJFrguGypc75hfBaa96sx+hn88o2OB8O6er/82K1l2LS5KGAcqQ7t/fIT9csX";
  b += "Tfid6pefVO9/5wOOqE6kpvve5V2eXQBz8Mu3WylCpMEvPx33y2f5rYIgac9vTLpu9PYcyGHk4Q7";
  b += "9BOtGJGNZbfEiN7v+RWpbgWTCS7rLoAf+qIfpawbeFcM2JF8maVPyTSH5JmOS78GwOdQGVN95xf";
  b += "9Dw9ejka6YAdUcwu613lKExAN6zl83FI3val7aNCp+N9ao+NTvDG1WLj9cvRB6s2aM8Ims+ILRP";
  b += "HOfGLdw49cZWHKtcmPYC6IfvSTCQp/RBj6v0uWHnUH2dWa0IYrmIo1z9v56DiQK75d/Ho+4pdR2";
  b += "wN1AyMV5B9q2hUwCSzxG53pE5WlucXXuSFVvnpwtLahHk7Lw6pEs8109so5Fgyb262Bij4ubExd";
  b += "qf51U30XMH6nBu1UiVnMgBb4N0kBtj/J9acCHltfW6TTm+7o63deiJQlzZ1E9GHCrYVOkpMImTJ";
  b += "qg1S2c16DVQVJB5/FvSRpo1f4ldhxtslVLKiF81wUbVjYsPa0x+UTFnBV38P/0LOzgf3Omg5/p4";
  b += "C9bhHLlYBuxBqq+p6su1rfRRQHAKi7+QJmAGLblyII0llj0T+Njiq720Tj71OBiGwYXWWe39xU+";
  b += "TN9gGYEpWjRPCPLgYPgofBb7ut3/Y6kIhFX3Z81SWYeRN8VtZgXyzotCExiHHSwC127F3lLL4jl";
  b += "ObGDUzsaop5lOsTV7IU6nqAhsxpq/bAxR++iY4o//ng+5++qxgbp8ONUPBjuWBjl91EwkJo4jSt";
  b += "33mlHxFzEDppwNa92SEKZy0RXJvkug9Bc1e0PAoYRZONnnEA8xJ33c6seP/acHOqVCh+LrsxME0";
  b += "MKfj027Bi9dnGlCViqHTFxDYi5KRTEtH0uV1ejGhyizPWivSvZVUapdWDXK1tUOJo+dl+aT/5+7";
  b += "N4Gvqjj7x89yb+7NXZITSCAQlHOvVEGWJGwJaJUTCCFA2PcumD252W9uwtIoUQJiixYVW1pc0Nr";
  b += "i26pFq75pizWx1MbtFVvUtG7U4tKWVtrqq61Uf/Ms59xzs5BLpf7fz18/5MycO/PMzPM8M/PMnJ";
  b += "nvA9crFbp8BdASDylC28WzUwkqReS0GRUxEUz5AlG0+DVEYNzQSGge/TRb4t4thpV9wiT7Hvtj4";
  b += "Oh3cdcWmKTAw033uyTeopKbgF1u+KoGD2RXgmmtGQe+LQj8Hc+1EQFnDJddlM1F2RhF00EpHX3k";
  b += "odjkwVCuccr4qbOR8U5lSBk72f6M9jT4MoDfBSiVjKY4AZwqtqu1UL5GeIm+IF64dAQ9i/h+rYH";
  b += "vJT1RzA+6Z34GjEsq1ReQgKABbthBckOdE3QXDbvIMZlaJ9tap8DuC6R0kkcx+T/E2+fOhrdx0n";
  b += "z2bGjexUCi7YqJ+i0mpNOgii7YqHDD7JguHk4YpdwwXGq0J+8jgCN3FO4IdmZgh1rB65205AZ4p";
  b += "HYlurjfDeP8biVkHN7VJWm/d+DNTMVwFBD+KtzK9JLXBqxLOzy9S6wr/I5+91Ad0XuougN9rQPA";
  b += "KHk2xwuV/S7xe7/UH4HARwgEbtyToYFZJQRF1dj7Bg3MKiKkTsLNGBqYVVQ8RB7Agyq4GOsaJft";
  b += "ZSqavPZyablTRSUjQH6DTigGfSNSViLLUvqqa+/c+bR2hbMi0gX8gkT/wizocBsCRA4q5+bRPAc";
  b += "PjcGJIu9phoXWKyW+fEnQSTvd45VYhor0KWS17YO93lwIToOCvcerqLrE+F+P+i7gDtAsXjSKwW";
  b += "yEMZszNQRAEZ/sAsiXiqMk52xXCAO5QEO85OnTzLiW44IAtDeOFDpHVi9LTniY/VQEH+zPPZ+cx";
  b += "Rvs1XeCD5B6AWbgFHdx8KCO2E302o21O6o2izA9lKvu0HOCjZadks6Y7r+GaiinzIDbtFKd+z0r";
  b += "9jpX665AasKJ0M/U7nPqklfq4lfqbkBq2b7JMLhzn1Ces1L1W6v0m7elm6l5O/YqV+qiV+jvXMJ";
  b += "tyQ9ormPoopz4mD8Hh48BhH6IUDc7h+5Evdg73nIHDPVz2M1ZNu6ya/jdQShLF9Uhmw7o4+REre";
  b += "aeV/Bdmw56xkndy8sNmcvHrUUn0qX2grIesrEcpKyq99gJmPcRZH7Jl3SObWe+xsr5sz9qLWe/h";
  b += "rPdalTxgJX/L1BrRTO0eVIQDnPxuW0nHrZL2WVnfhaz+mJL2cdZb7ZVUzKx7rKynIWtKTNY9nHW";
  b += "vVcldVvLrt5uVVMxK7uLku63k7Vbyb2xntThuJW/n5B1Wcjxyi8nvMpO3q6YGbqbUbVYvgys0Is";
  b += "UuVdhsYm3gtCM56aZOuvFzo2qeJNbx6A4gSEfxg3B5DPhB+G3JaaTTlzI3HXyBrxch7WEFNlZDd";
  b += "HTInc9HiXwUTw26hAULCwiXJtmO9aTHnJrR4Ku+A+umfYhnoByUXQq6RFY39gtothf6hVP0CyQF";
  b += "W+pOgEtzgengnGk5I2B8KeBJI7EmEhXwAdUU8DsWT3+8HUdbuwJXUcZaa3SxEndtR0US8rIEcAU";
  b += "lLrMGFyvxs2bid0Ti32DidZT4i9bYYiX+rZn4D1biZZR4lZm4x0r8tpn4j1biBZR4sZl4Tg2nfW";
  b += "879+0/WWnnUNp5Ztpck+4nkDYZvOtYaXMp7aVm2iwz7Q0dnPbPVtosSjvdTDveTHubmfYvVtrxl";
  b += "HaSmdZUTeNecy5610qrU9pxZtp0a5iDtB7w4GSJI53SjokK/UMSurUkoSUGSxy/pHKnQBS7vv3F";
  b += "Cd1kG3cTnL6xY4yDg4kONL6gk2EPuUemI3Co5WNi+lHqoFoOeyIO0yULYNUN0avSg27sVcJ+0yR";
  b += "260JdAbzQuqgrENSM2RUSKDMcHgqisx0PdKruDnunIoSYoIs+qDOZBGuu0YirqbZZzuIkTJ8HnF";
  b += "BdYmMSfsAhNtJqHRhiN4XIYiTnBkIF4MSnDAXrsOuFy2kQMUz4xgPCqEEK2kuEephPyJJjAk78p";
  b += "AEaRCGAzJdoMQ7jE+Z+sE9ujRAIU0UWmbLgvDSeWkR7h6JFHswzHne8gE4w+VNqxinlHGiGd0jN";
  b += "8LJmePtphlf3kEg9utemGS7K7LI0A24jGD+62jRDSDPQg4KHNIPJuHh9JjISS30mS0VYhz/jtHa";
  b += "HDctLYmmNEysFqKSogiZh1Ry0hnHQGkZCy81UWpmUFqFYkqBqz3SYVZNZaeFgBJ2gcpiIRKbSuk";
  b += "lpfeZQAFM3jhF7FaiczV8GW9V7hX3OtXNy7cBTCJJVzGO3B3AFpFBmxXRIJ8MiwNh7i6jeBWT7G";
  b += "8f3isgR8UbbqTAsK9zFSyR6iSY4T1ci0Eskej44SolfGPMIxp0+9STSknCfT07e1sfG5BUMWpKA";
  b += "3IQIh4m4/c3b1rSGSQURws2qdVDpVIAWvVYN4CfDnWrAB8+r1YAfnu0q+lHVQ2RGiBmNVzpiLS+";
  b += "ahO5SFBIPwePDMYkuSITnd7pEw26ViSf7ZDqjs1em2wIxlynxaOwccKACq0y+4YIjBp3skMGnnU";
  b += "w6McYKyeS2DteAYmq9qQvXgDIiiVLvF4vpxaC0cFBfztPhoL6cB8dZRDAXvg+DwwwZFY3GHNlcN";
  b += "uJ+IaxKmsnaJT1K9eM5HlyGJuAa1Jzegsm4LrWfHsH+DNNZQGMsaGiRC88YBXE1LcI1ARc6ZeFm";
  b += "Rps0Ltqy9l3cMgMd9p2TBmKjgilmGzXokcvgzzptt4OOQTn0FNBSF3zcdpFnGAZjxoNNydYxSXW";
  b += "CqufQFm0W94hdMl1D2SPj+H9KMScAJ3n5O3ZLl0RfXB0kM9ytkPUkON4v6/7ZUhostGdLI8TDO1";
  b += "saCZaIFGIMaTxUw8FXosFj0SC4ClMpeCQavNQKfXgtlA8cUsGjiqCIL4hXIwWHqjA0QoSuwFCaC";
  b += "K3DEBzyWGYJYQGGANEQdilPKnSkC9RR4XMwaNHnHRIyOYWfjGWjV8RZRljXaKaeaKYuznScM3XG";
  b += "Zro3mumeaKYDnOkoZ9oXm2l3NNOuaKZ2ztTFmcRa3p7ppMwebmRYiVttEokOiERZ3CQRvcbWpGi";
  b += "enmieLs7DiTpj89wbzXNPNM8BzqNxg2LzCGkfVeh5iJ97+HlK5t/5eYife2TqNrvhKQrZJVPHaY";
  b += "cnk95MSRvFY1LIcFNNxlkhN/ZCYzeqTDoqwCm2N6yeht/R4NOMsF9wDDmFkwXc5Ra/7ZVxAoDLO";
  b += "/CnQ9YA7RmREzx4S5tmBqc5M+DnKbzHDjtTcHqv/8xA2wHeHygEjmi3Ytx0TpBgbj+N9dIlnQPr";
  b += "JWFI6yWBrZeEftZLQtRESOhrvTjIerHQ2mDjP7qDYmG0OaJWi7fM2q3lzxiIM423yqHmnZrHdsb";
  b += "RvlOTMFghCbZC+kvEvuZAUfAZJ9tWJ0jEYUoEVjxoHuOEghJBYHyQiAMv9/ZIdBRtfGiQ+Qcpgk";
  b += "RU2opVWSIqbUsJiQB8M0iEB33VlIhK7YWVFBtDMhhDfMRxHLgsQrPIxSw1zaKo0abaVhrELEMGZ";
  b += "qnMLAefD4saa97v/yfVN+v/X9q7NkZ7nRaGoYMxDP9dhaW9fPQlp8vsF1YZzAebMqBfWCXqF9a7";
  b += "Sup/ggk9zWJ0fn+vbnRMPErU7mWW03q/4ST/frYtfFis2dDniSdwM8a+4BTMyA0m4ClBQBEhd2o";
  b += "J5DdtfAgvoxhPXI17CQ7YcxCJxsNC0wnLS9xwgmwcQvWDHEchh4o9iDPp5CVgHJ1uB9SNgBdP/S";
  b += "GIQpY5FDCBoM+2C5dAudkz+viY6yjWLpzLwPPqaImhw3QX7xe4QDNd2PFQM7EjYjyV9wsU3C9AZ";
  b += "5/jyZeF/W4N7sIlYNWgJyDaq4sQQ9wiqy92WejiXbgEaKoLduHccPUKnTh4aeshgZTcSRsyTliw";
  b += "M0805t6vTe4lmNzTKGWqmdLNKV+kDxsOw2WmdFNKH6eEcBb8mQ7rOicNeU5e18Fr7p0wE0vcJz2";
  b += "k/B7qCgTyTp9/HPQ5KK4+yQuzIgnBVZUQfaD+lF0Hzg5Y5yoN3XBoH6tBQhs2dDo2KOddbZlHuo";
  b += "Q3tNy07wGnAul2PO2iwMEBM+591Cn7uP94x8FNOljTGJJx+ltdcDg3xSnE7ZhDzn8luDzizsd7A";
  b += "dvAfgdkjyAh39IXXpVOn1AMO6CgS6gabgKfsE5sJuA1kKBzEX0kdgQ9hhwJwkdcGdxwilECPtk4";
  b += "4DgvoCwDYg2wTymEGBwd8ZDXEDC96CymYyaO9B6RAAwz/EoNJ7u9lt9UHLu1J9l5Kj7cDLiBMwp";
  b += "dK3HS4l62joAGEMuft9Hk6BFQ7KU+G84yrOUYZ9lnnef0xZ7nxCt1Hj2BEYNrFiF3hfbVIFS1S0";
  b += "z/i4gholfX6OpShCRX+IAP/I7HmeGEAz5d4q/2ElfYdKgjQWb8Gc4AiQRwcchLUlF5pU4Jab0Oj";
  b += "u/w+DN4I8+owZzmDXb4simjs8BEcIgKwLjoZx4XEInYMwj/Fo61CGG6J0up+XixBLmK+/Xw5TsQ";
  b += "lHhClDQ8a27+4PbC8YkT+7ok7W+wevQiw5IhIIaya4TV+40ugBYW8eSQ8Q5Eer7JeyiXwxQloQj";
  b += "YQwo4ShclvE+HlGgzRjIPacMxQMl2kNtbAIdyBr7JYN1VYG84dHyIfYs6Ql7LgTh00EWxsM2ob9";
  b += "qPVOr3BA09pO9S8zP/EjuKPG4S2fwEwnbKkTu6eT2AjkHxnBIdPUoP4bJaV+jcEQJxF8noPxXP1";
  b += "4jcIaO9s1vi49K6siiD1jKxZ9/ZfS/6xLWiePxqZb/KiYZuxDaSZym8lphuvPJ4N3yPQA9Cz3SL";
  b += "8Enxgra9JE5k+V6fY9GkswjmoWqJDlVLRvtrdKhaMna9Rh/4QTzGK6/xoepLJTpSdVqs6ArQp3C";
  b += "W6OYKok5bGjCeNGCc6ckTTlTBCf2bYg6cx5wtN/HfwRIR3ZIyiY4JI5UDffziTRMDDgnCSAXX8R";
  b += "FF+uYn7x6GA5WLT8rToYB0AnN3kLhkkZrlZw5UqDguvO9HA5VC049CAxVDS9DpPgs/3BEdqBxeO";
  b += "qTuoG/DJofJ3nEHpegwBZfZdKnfsXM+jV/Y9/SKKJMB/gGLnLEpkvEcVTL4lNrtICbJDOxPqmxI";
  b += "3oX/PqUuKZbUzedSUD4S1A9e+P4LUhyS8v1fldQ51d4siylphYY6CE/cJk+y/q/yZIV9MGbn42S";
  b += "6HbpejEQau6/l851C0eCt2+iBRwJdtT0qwtqvZMutbVFfknBpZyS6rzKe/IHI5+hL9Fl8S9ROiL";
  b += "DWFaUWnS1oqU/OZcWo/TifiR2osX09N3Bjl1i0+Awfn63Da/XnBegDvdatks0Dfc6BHsv5ACyM9";
  b += "xnkHa1P1ayJDCdMqpoycNUUq2qKvWpLrcNbtOdrOg7A/WvYxn7nd93MrWdkc9uMPAZAKDNEu98+";
  b += "ONl7ezz0dr9h0ns2HnqLLb/cQA9EKtqm1BiOQtGwMGkMeCk0Og5Yh6GMXXeI8J4D5jcccjKmS97";
  b += "P97NExKqKjJEB7JDcPnbIIrjv6EPH59BZ+XKxrlI10F2TbF2mxMtJasB2k4q+hODhRrd3fszJaN";
  b += "GsVBA72GvAB6HpYp4VXOIrUYIXr/MlLh9YW9Zh6HyLO7aZ/oAcc1tdIj8XHeZ9zn631Aem8nP1X";
  b += "FB5QzkXVP55TuryP2fLlwKZLnSxdw4pwCYn6pjpIASOpYj+mhEK8oU5tiIL8ax9E9hj80Ht8OYj";
  b += "OklxkAoqsKwgAtq7OEK7UV1wdCA4RasEdF2xVKZxEv0P4iBNcAuit+PFdxilTp2gEY28CIp3hky";
  b += "7MoZnPrkPlcnHjixGpSg+Ad7LTVJlhRx+yNpjqu1SKBxhddjjcp+4ApdGl/TxikLXR6mrX31AVM";
  b += "tjfO0Ajt5oGO6F8Ok7oj7M7z6APszN8fcy2RzC1fnmzQYkqfAUCStfBxnJ9DHbPRruz3npTueVV";
  b += "Bv4Nsnu8ODrmwP6pQazH94EJDctDpgOHJwYrVu8TUpemeACLCCISfiZ6p7oKdsFfMhW+x5eDqDP";
  b += "jg56evNYVBIONDLfy+AaK1RjBWssm2seEDsIEyQnRmlvjiCBXxsV+omezboahtWhgZf9yY4T+le";
  b += "g/c5hbGvWnnB455KyRfVMZT0Dv+A/l0nPVNYzlb5Ex+iZIaGm2a6IksqxXeiO2dhw88aG/U6maM";
  b += "7hX3dLNsc5Z6zTkfjqtMBagJg3VGgBohrsWo38c7npAPIYOoBMZ4rTQ7TPTgeKDzssa0xQMo5RM";
  b += "8WiBPfm5dnoiUw1vCG6gQ6rUSpXjgJ60P9WXrkmSVUcokvhGwNPuJP6T5a4/4i+qFjrpxgiezse";
  b += "x5kIb1U0OeZoJxyA8WB08Ht4wlaO5Hf0SeuXjT30IqBgyNjXDp+5JGM3v3ZgyIjeD++3bHvnV+a";
  b += "ybc9TtmXb7l/zsk3U5iwKwYrHVlKMQYKGGIh2YSLBCWoabprBlwAYuGgfyOwc+bTdJHqHg3oH3+";
  b += "U1+QtfHumIzzjc8petZsnULNnYtwPqCCAXxnERNCYavTtF170Ob+v2T95LyeG3AzvMD/iCDSf3d";
  b += "BEbTIPO2y7HbPP5qDeo1BtM2w8Wz5KFc61Y6Ev98ikx+RRdJkyWw7+jL+6Krtp8FXHDC/uOs3hK";
  b += "AFpx9C3R0uHG79/CLVohWwh8+BZukOMQ2/F2l32IvQT0YDhtlvB+fZLdmx7MmpfIUt+75iMvGag";
  b += "WXIWDMKAbLxzEaYh2ACB8Ev64qRbvHewz0NNtBMm8PM53jay7RTKeVtE0AGPwonVsu5runQGX+N";
  b += "+XEZPgGF3UHzkf9xeeUWzbCD00NcD3fLiPNSd2NNEVGjIUGjL4pgJ/dNPeVmGoQqg4+ugnap2L6";
  b += "7ZqQy7A6X6zmN11qTAMhdmv14NvQRwt4TCKmIoF09EGBYNPZoPPXMCR1cd4C2hOsEc4sP68kPer";
  b += "smU2skNBckNsM3WQk7hev5xWBoCWqf2eDSi3zfTx2Uwfdx/Thw9hmqSSdbofKuhYHWEmtkPZZr/";
  b += "Wb2oqrnBgr4o35MBe4HvtsyS8tAj77EekArjtb0Jeg02CF/xVwAPyJpMDRyQGtox3Ck2IsB+BJl";
  b += "I4wCAN0f0M+zzYoyjKNvkq3m/Ew4fCZteayN21bnpn1u4Slgzc12EcKGmCCiMab1GK2cf4BDAOj";
  b += "RzdcdBIbhKTrqcwQ8zF1BvkGkHakaetApznXQEHfsWREOUVsF4X0bU32eh8U6j8d2gtIhvfehO9";
  b += "QSP1djg+oUs1WhGdMIeFWRzVeUn6zOrj/aksq9uG5OOBKB8dvFLDSiu6I8pDCaqsYpXVEN2awi+";
  b += "XEmxxtAbwBtlSkiXUWeI6S4PWGalTnRWos8PkIdbpL7J3Fi/5rLorXHfFVvc7HJzhXbaWtT/L2F";
  b += "H72rM8ufwDzp4bd/yjy9o9uFuEtV9ZY9o064aV0u+GlWLdsDLHdTKShtxhfeh1c6o+ad9hPfw6T";
  b += "9UPKTQ6WPu+MqEPy7QZJNG92J43zHuxZDD5bNcG4VORZN7HRYNATJy3gilAEyfwwEeHvyTexCbL";
  b += "WaNKU3ekS6K+EC9R+DYtTOyAaAYjiF8x0JoQBeBI45f54wnxB7ZFANLD4g9blc/82twUl/CDCPw";
  b += "ReqbBnxStW0Zdl6Jzg4gdHzLLxQRn0yPZp445NdGZ41JaU4hJ47I++y5HfthFt4/5gxwNpPfe2M";
  b += "2rSQwJi+KQ0I0WyZuNSgEf37CnBtFjZGFGEO92N9Yke41TPxYcH2Uc/zFzfPJgX05eUgfYn5g+q";
  b += "MKeuDe6a3byXtznMjV1CvrIts1jao0uF4a5Z6DR/K4aFAOzF7jrncqKPXA/elwdoB9N4I3/Bea+";
  b += "f3pI+4mKCh5lsgZrtsxBGkB6Kai1w1z4qGLW/XfDlJHbnFdRFkRpp7uHw1EeYpYZDjut7CHTDRO";
  b += "mIRn33mp9NE0BLFcRFuqXghY2sTiJFtnDiC44VEgBvU6g731J+jA9KSOoNsFodV8wI2/Urryrr+";
  b += "nYtedAV7t8VWAMfn4XyuvG49eM8QZD6wRJCo7Wx+wIjsrbtkMfFc105fa8djOybXtglEg/Ci6Rj";
  b += "NZH58k7Y35clu9XecIOwh6BqATY9aO2Bs4TFOUr9VEivxDaeQcNtVUHPIomIwJQpYavJuiHaTMJ";
  b += "ZOBn/5jDCvCoqIeWUB44NEPOPPBzP4UAU5lCwphIAiOWQDj5K/MIYPFIGnUS6aMxfErzgwUjCio";
  b += "U65m3FDonLZHnCDA6zLMTAK0LhyCCXlFfMZG7auEUkegTPkMW9S9EvfKhNQTqhJ+c3fB5UuYPzQ";
  b += "gXJCF+pPgpqdCvAiKZ4aoX3aKyFY5XwGdMroKPqmBB+xT4VT4PAQKTAWy2SdgQgrUwt/GUCzMwi";
  b += "izPZRP0dsHuTz7+10cfvPv6Y59IHW1gGUqobTilBRVgLLbSa7iX4qEwr7AmCYLDxOyHl/BZ2IvW";
  b += "oVhq1gTSRLkyTffQL8XE6BTMgZGpHbwt62m6Uwg0KIUCyTRfizypqGLJhNaVjGvsjKCmu5qCOJi";
  b += "KGVIUa9eiIKiX4QZTIaBgI5VQQDHrD18URV5lgFyoLapQN1QvoYAinRSaBLCIgCkJzgTsOTBZgC";
  b += "4O1wCkXk2zyEEChMrjd2pRmmaMag3SolmYwCIJNAxMV3oVqRXxAONjGRGWC5zLBhsDdnOgARgjy";
  b += "GyNjSGhgaLGPsBL9IrcdKffVgC/U6Bz4MZeKqzUJGkmwm2kRoXlpSpK/SjoEi5F8YQZaKGQBpyO";
  b += "cFG/StB9ur8Gpgb6dgIAj7BnAvNkYUYAUVi1kAm7oFhIWtJ9eb6rhM7puw4KkY86GAQ4k6BTV+E";
  b += "sDNRgc5NQC/QKojsLcd/vQ1hrg+NcUHWZHRE76NQs6ZvDtqMjlE+sSkRLvHSfh9D2ZJqWVD7rrT";
  b += "tp9QVaKOQIfVOFvkknGEQrVPvnBOhYWlCigyd4Sok6Wyqhj4lQeiBVEPoEb2unig6eGNJehBM/3";
  b += "P38aE8KBmqkR6LDxYyK0DF0Px4OxNFRRj1IBp1Nhk7qRv0Nitd9spp6C5C/rLnJoWAajou2DUVd";
  b += "yQim676BFH80d5d+XQVW6IPkwCKjQ7JDH211Gl9Mp3GcodOE9PTYruFrAns3pms4Qpb6plFXgbh";
  b += "i12SFkX9saHpCNW3f8BL01FhFxcHBBXOzS/eCNh4UGghqJyztTWAiieGyBuyikbh3Kh4KXXjBtb";
  b += "Hu0TMA/9SDp+Jo8ki1phGNpxEZz1OMQO0Rc7WbJxQ3aQ8ojVuQMyfT9BCshEbp7gmqFgA0YzEPa";
  b += "zKhJ4yCY1QqjX9gQgYT9NEHg86BxzAUpcw7q7iEdIfIFtcTzjDqSbZRLwH4MAkx+1CENEn0E2KQ";
  b += "XNbQJyA4FCdE6aRD80KUCU0IeMzuFvDIL+yPyE01tImpRs/0QA7UVpCsTJaFap0Wc9vxvYWJZjj";
  b += "AeNUA+j2FthIQZdpE7jYOfJtO6riNzJDxDkR69vOXMmPfbeYBn+FkYmUPvM1zj0hn7tsfgjxRg3";
  b += "KQHGcwQTMlO3LekEdwvJMQpAc/uGnHcbNQ0m6jJykMQvPMh9NTMiaOLlBwiACZH4O1jVd7BOzbO";
  b += "xSkJWryZXNvhmB30dYE4zQG1Eehr4W4oNBcbL/CYS7rEwXsY0q8jylZu/xe7zVydKtrskSAY4ak";
  b += "vebArSAG4ISGJnujnzxlhFG9RL6UvtzwTRhHiPAMfqvSxUw7PJPb2tiBdObGDn0E9WbReWE3LD8";
  b += "U3mnCkmHJJ9m+VrZ/G3d5vc/JsYcXEK0St4QCCcL2kqOoUU4jGXQU8YslnBEZsVkmsASJTuLSlS";
  b += "rRfeDiq4GYl3BtCVB7GLwZ0C4lgmy9nLdQxeNyOHlyu2J+eldgGEog/CmfiT+VoJvzXQICl7hEB";
  b += "hONyjwxfTGrWxyalonMInROhoK7yOj9uQlCFF2/M4TX+DMsYIQO7LRUHpZRwDxQNgdsDzj5e4GY";
  b += "Go19sLUh40JJvOPdL28WyhY86NBFFesnnI4Eq5z0bdnaT5jBypZq3PYGEowrVyYth/ueHiDcT7F";
  b += "EfeWfAKxgnPon76ZPiD0mAbSSaeVIR4VuV8wNw/GWeTNZmpTkkBRFxk8SbtiQTaaPE9rrqtd7IV";
  b += "YBO49u/8rHMLOiO+EXvgutkqmbwARJYw1+Izc/kWOvT4jZ5I7ZzXbCbvZFEmOr2hPZdsITYSfcT";
  b += "DcyvnTmpj3vRHjs6dy0s+6dDR/ajpNZJux+CGHVjBPbzU8uJ7Y/bpYVs10UND8x3Qc4ws335slt";
  b += "UKklQSkD5bVdhqbLYmICa0nC61JH4SgGsBpjpyDmvccvDxd6ot2rUh/1E089ljUKF8QVYfwaKhi";
  b += "AalMwUYTEm1BQwy4hXrbBhBhIQRNLM9TGYJIYLMAukwnC1k8N8ONGMMxB+NE4UgOgVLgKkfHKh1";
  b += "Lkxx4hacflgBvHEI6Adqg4mw7DzibseUcEaHACYU4qrWGcW8XwoUTgd46LNMJSEEmGiYVkQgRfA";
  b += "taSNxzWh4UNt1gkNumuMCCliSJwJHaAbec0VEAmTsClPy+Tu6/Z8VW8/InL4kQxwyYaB34khoNf";
  b += "qrpnsuSDqsoQ8kNIglAyXuKWoLoilgQVcVJdPboHUY/hR4gnwi1v+B3WE1hRr54szBwPaFWScYj";
  b += "LgYPzolnhsFV3UQl5voh+8okKOzGwerQOdROGka6F6XiAQ7tTDY7QVcBhQ1FB3AXrMR+tAcSQCT";
  b += "zwoZsFQSmFKMHmyTYD3Ge4wNaEL3twWG00CzLoMtT6YCJWRa0VC+gUwwE/6ynGafwIGEiEDgpCb";
  b += "AwOqwkmhwIjwWWegSuaRMF7J1rXLhhskoHxySgNkkUSDcFpoIXpRjchpUyWlMBweMiBVOOGh7rp";
  b += "uKKcKaNjTVlP1zERAMJl1HQb7pYmPYEgVvCLwe0iB340kMhXd5oQkJHVJFaAQhaiKCxlILppZ0N";
  b += "XFvSUiHFpkzCnEgTd1MHppp4NXUXQu7wpOHxwcsPPhhzcG4bLzULwSQHwbQhI20LhUwzc5XICBp";
  b += "xbDGBw/px8j0iXyG60Q/VhwvYfZnSxcronS+5gEggqOSooKeDiKsLviYHEmJomx1lTN9TUB3gCK";
  b += "KhEFFTS4BxIOhu6fkGPBOVCQSUOTjfxbOgmCXpCUK7BybnOhhzMrOjXRTKOMsed4EbFp6fAzOCj";
  b += "+wBuWpD7zOMnPrRL8SiF+DNC2Ht4EAluEQRhegcoUhXBABG6L3rGRA7xYbcAbw3AdgoML2Ik+UR";
  b += "uysfBHfbfYD9ACVj3KHCZ34Q2GgAj6BpUzo9LTftsANNVAUwIsm2GgKNGXlwl8lcc3MHSndoyYc";
  b += "LK7GDGAR9UaR7lLWQ0sJ+do+yUr/Lz+cPrwCy4DiDLX5b5NPMuWbwIzcBl09iWe9vEC+PA14Vsx";
  b += "KsrYbtFNHQXcn6X+VFR1p5A81xkHK9MCn5Vvi+4CMPjg18T4cUYHhfcLcJFGNaD14vwEgyPCd4g";
  b += "wksxnB78uggvw3BqcI8IL8ewFrxRhFdg2Be8SYSzMOwO3izC2RiWgntF+II8GHeTrwoqFNgezNA";
  b += "vaBPV1i/I+5h+USmwPejt0BXxS3BGWxCeugqR4W1IzSFad19wqm6S4SRTTSJOk0haR1vQwYms1M";
  b += "HkaDUEzZlt0V9G6MlQnTZRjRjK2SZlt0k5vUN3Qu5Reoa+Fw473xcc3RZ0mdl0B5JJMMtWMeq0q";
  b += "PavlBZTqRxbpcbp2oCVyjIr5TMrNaZDd0Pu80AHoErnQ93Gtt4X9OsuICHmXsFPj0Un0apvApbg";
  b += "Nqs1og2b96lalBrTolxbiz6npw7YohVmi4aZLZrVofsg94VUPFZKH9em30ztuwgaCu0bL+aLjDb";
  b += "dg1STzKoAsLbuFTqQYrXCjSm8ZoqZenJfLtr4Q0wblEs27pwNX8bG8GW2jS8T9LED8mW5WceRJl";
  b += "8u6dCHQe5L7Xz5XJt+E/FFp5rqObpmZk22mqeZNSKVuJk4GBSGQQZoR0BPwjoMM5OJTpcSw1ehR";
  b += "hhPsbQFhWSy32slS8S4rw/zB1C/T8vSaTEs/byNpRfr0wZk6TKTL8NNll7WoY+E3JfbWTqhTb+R";
  b += "WDqHWZqrp5pZUy2WpsWy9CZiaQY1WB8nlAyeGlZkpF0724SZNxpFqQfazIFJcIpEYElqlCmCYVG";
  b += "Wz2wLTmRBRAXjixFMP4lEZfGfkML0GCkYNink6dMHlMJSk5UjTCms7tCHQ+41dilc3KbvISmsZS";
  b += "nM1seaWdMtKYyKlcKNJIV1LAUx6OAzDSsyOlYKwCd9DIgqpy04CRWhTagGpyHtPk8/HwUJkko1f";
  b += "/KLCcwSf18Rt6Fko3JFseoTo4LtK9a2vgKNivKzEmLs6DTXJsR5g4xOS0xJjDGFuL5DHwG5N9iF";
  b += "mNemf52E+AUW4uf1aWbW8ywhnh8rxD0kxC+yECfo6fgchRXxDyDEWSDp3LbgZH00phkRK0Tgr35";
  b += "hGyqZPqlNaA//jIJAFQH5WqqE2sL6YOnMeH1qVDvaqHdHVUJjIaf10QKr419k9m+rv0cVIqoK/4";
  b += "YSfErRr4wRfb5N9PP1lQOKvsiUX6Ip+i916GMg95ftop/Xpt9Aot/Iojf06WbWCy3RXxQr+q+T6";
  b += "K9g0V+sn4fP87Ei4820OMKhcPVLQD9mtwWnoLPENqGPnAY7FUpYv7QNVVOf3CZ0ztYrSUi63oYK";
  b += "Bppxvl2epHGgGZbO9VGv4Zb+2JQqjVVhlKUKfTQpqGcPrkk2FYoOKedIaT6lqgRjVEW3qUqBHhx";
  b += "QVRab8i42VaWkA/ttsNSuKvPb9OtJVcpYVeZGh3qPpSqJsapyA6lKOatKnn4hPi+KNWptI8BloE";
  b += "+fbwtm6uNjzFweBnCcvrwNVVmfYuPMMGsi1+e0oUKCJpmc4nk+Q89qC1aY70ZaWgta5YgdWPysV";
  b += "ZXWvI7VqTKjONoFqy07gPUpZGkMaWHNQFpYawmgzgrVW6EGK9RohZqsUNgKNVuhiBVqsUKtVmiT";
  b += "FdpshbZYoa2xqvUV64e2fqrli1Etr021Fug+Uq0rrexXmb+tMnOZahcs1FeZeqMgV3AFuVCQM5V";
  b += "oGxJrl4GphfpCoahtwasxJgLXmIHtZqDDDOwwAzsxsBCWVV59gVB5XVQxtlCvrbxrZSwwgH8vwE";
  b += "VtW3AcPz/Hzwn8vJifWUgG/iuAAkT3ii1AtxWQjZSn4t9pnH86P8fycxY/L+HnpUglX/w/H+iLk";
  b += "T6Wfr6Nvo6Ug/j3Ms5/OT/n8DODnxfy8yLuxHPFLBBU9Hk8YCfyKE7jNLHzPH6ez08/P0fwM52n";
  b += "DkPYEoIUrSZG8Y+j+Tmcn6n8TOPnSDY5Mvl/GDj0TBhOydImM4yML7Khyc6cgv8n8EDg5RUNrWN";
  b += "ocUirgsnifyePB24eU2jBTAuxSTjKwRBAC2sa8yrh3Yw2vQrf4UA5s00PcTfHzmLpv15tJbK9tI";
  b += "ZZvYaH3TMk0msHT+OwCFmprRlAr4vWeYgSrAGuAhPUD5UxoX+xLtuCkV81YCarinYeDlGfFfq6N";
  b += "mu/SW/kmcZOR1f6ED8D2cT+tfXYFl+WvcGBpj7FJfzbzViuf9HWjDBUe21blHlM+d9vWEr/hiXZ";
  b += "7FfLFLImOg40I5kEmzVxrlq8TL/C1uIItGdNW1Q3sCT9C+eSByP78yBqw6dGp1jLALRmZQ60ID2";
  b += "Xzcj6TzFnqV5uY04rNHR1tLtQyfqGfuzaeC7Zld6fXSOsV5aZbJnRlrltmeWWDb8JCbtti9nPio";
  b += "/Xk+Go6Jt5VrJXQV/fj6Vf7sfSsr4s1RV9SVQ2n4bBF/Vn8IXWqwzz1RwzcLkZuMxaXZgB3Qxs6";
  b += "dNMz/9nnN9NnFchAOa+om/lRXxs3fqI5Ev9RFLaTyRKP5GoetG5Ecml/UVyifVqlvlqrBmYbgam";
  b += "mYGpZiDbDHwFqlBgb7jvMxGSNw4hfY2E5IAACEnVi8GIVvQ2XnXHVnkI2ZX0k53ST3ZqP9k59MV";
  b += "Dys4bj+yy+svuYuvVBPPV58zAODNwgRkImAFhyFtLSg5cafFULAQ+Q1najNUhZPlVkqUTAiBLR9";
  b += "RMWRQ1+XltrupXCTId3CJciSlnLW81Dnk7+snbqS+yyztpIHmnxCPvnXJ/ge+IvuuwhLjdCl1jh";
  b += "a62Qu1WaFs/qVscFGtAsd5s4y0h2gOCVaWdR6P68Gh0H1UY3kcVUvuoQlofVRjZRxUGXsnkSRYL";
  b += "z2THjexr8cRl8KT3nfjpcSUo5LWoPNeirlzbZv7gwcjHFEm0/+K2R1z2SII94rRHHPaIao+ALly";
  b += "Z94m8XXTMa4P+g8a25uAuWVcONul+PWn7wTBA38Mn/GHbD8JXdfVgUxjAfOCVRq8c+GocvkqmV0";
  b += "58peOrkfQqAV+NwVdp9MqFr9LxVSq9cuOrVHw1nF4l4isNX42mVx585cNXo+iVD1+58VU6vfLiK";
  b += "we+GkGvUvAVu1iFr+/kDHQsHmPk+9K6DAdMk70EUakdVCTvxXw7TyMwjOOH8fJez2HzuqSJ6iHX";
  b += "49EFIO+g46ROXfGy60A8AiF5vysTlLLl1lTWJtnOAMMJV/EjezCeFEJAaZn8LTmN9AgAb36sNhn";
  b += "uSBguqLRiDJBsW8OiZZcSoJIaQrjOS8XDOLmHjo844OAPgosBolEWnwmSoydqGTuJ/aN+TjAJ2n";
  b += "rkZ6KtU7UnHZLtiAZd4vZK3lQ8mjjeckkLAOjeC86QFTNmSEOnSYgjjSeONOfFkWasRGKTB8Tsk";
  b += "bV3Fa93FCUQSrKN3x5z5Dt1hxc4RWcZ4XicZHS90i3R0XTj1pcpqP1RBRXDSvwGPJDYKoEVEGox";
  b += "hk68Gml4uR6PkiabAD3eFDplHsWs8p5nni2NohNFoafgoNAgLcbiFPKtOwCmAHs3lrSXzxLNiS6";
  b += "BUs4hid8h/7vE75C9GXCgWuK7snhNuYbu1S7K8J5n/dal0I9HlOivYwfhCiMSeIcTPBcDNCB4hP";
  b += "dxh5KwTb7KeIjxX6DCyhwL9oxOOePFqvFw3cAE81Ul8kukWnC/KqMnpZp4wGo6sGgS3T9AZGC8y";
  b += "qWaFz3MCBzsTRch9M8DN2rvVyHwObgzDse44Oq4zu5FwFdEOqV6TQlINqxHwBAWwxVfh1XJ8Q5c";
  b += "HVEsj7lfe7Qbb4sg8uMxiDz0MwYJDSqaM6hqCTh+0P0IVcMLYRRRNLyr3y7P5OKBth6A46tS7M0";
  b += "DvxxFRnHEIKM4TGQUBlPdDciy52nj6IRcWIxZ8Gam5bqb3I/DzXSHIc8nxjrJa4nEWCLpjHEL10";
  b += "Ykr3FAFAxe0l0YwgPTdK9mfMg4RL+ZgjPuseIYRJlQekyKAjPz6y4UJsmG3SMhhg0ViVqpDaNj+";
  b += "DRF2U93H1IV+aqEbcZhOgdOXSaLkQ1ZuyQaT6BdfsYtNN7Z3yWxjijGcTPCdxsUQpq2lFEBnXPD";
  b += "TS0YR8T4gMUBM2SjC9qDmDXwjrDrwIG28UyUJwD9KJh5JMoVCILGuoElz2AkyhLRp5AlBxFNGY/";
  b += "xOfmKjA9h3vE8O9z3AI0a4A4gnpxc5oArJeDdryag4u058oLs6HvtTzavq8p4GwtuUNHVKHRwCA";
  b += "rqQgWFO3rydnBaBUcc6ai3E6902i++qXzxjSCq4O6b15wUkVfeUZLtDg8MCq5Wwsb33qnKQpK9l";
  b += "iRJgObFIZYgRx3kqI3GEW1EgP2gdas2H2x8D2JSQNFGBkgzATtSRgR78uRl74IAwJQeICxGTjeG";
  b += "AO3SdQenc3C6UQFSYk6XSmAVWkz/NuSAA/RN0kYbcgEeH4UphhJI6PU8oHiN9kfxhtVwBPHQUqF";
  b += "EArmkVrhJ9nDoEbzpZsRgvceQE9kxBd23NLbLi5oQIIpGF8SrBwfTxit8ZULCEOFCM9PxSQBVSJ";
  b += "rxDTTojJAY5lnz/g1dJXGYN2XEDDASr17AkVb2McKA73fFwLpGBeQ2gYz8sVivhKlug8tRttE9G";
  b += "13N9xPOmoRwrjj2gVMml7YSxmA4JawaMkExiLQAkhODuEZkADIjgV4nEGSGw0TOQlB1ghNxEJyI";
  b += "w+jtIjgRh/FQF0GCOBC+opvhRAjQla/Kg+qjQ2OlH6CrhZpOtgoPYnQdkQ2YVOPw77oJndN+p8n";
  b += "88ZfwY1KfH0ehSGD8VvpchTKznfoIwQNjsyWTJB2EkuFlW1QK2jVKWE4GdtMaghUozPAeccrOba";
  b += "bjCRCBkciXW7SKoBuU3OeEi2TPfPKVRSKmIUCcGBfgWZhBt0ZqEOEvCNezAw64OGPgfQz02lSoI";
  b += "1J+uDAMgRrBVPfSsF8Gogj7lKA7QiB7U4vI97bLOHItKvB8PzgS6TIjCvgfccBFkia/k++DCwJB";
  b += "QbrQD05enNpWLAeQegpRajLf9msKG0qY7nUnAKqCaqi4HHJAFK8ECgUJs2ppxb5Er0koeZFf8bm";
  b += "9eK+uDy0H0ZKtzD6X1+ik2lr1AtvRJFWEvHXC9RXHoEQMhiFW0OVjn5qD9085WnNGHuTsVzXBuI";
  b += "v8Qr8WWBdM4UsYhF6UEy5kbgwTnF7jcExrFvkBxkabEmRPApLRZmxmUH8h9Qwh681NSJTQ+oXdC";
  b += "pfWAKzOzbgq5nu6zaYDVN3ANVOIazIzBSpCfg9ANxjnBm1kr3eENGAnDFlolHSnjPBNVPu1WLhP";
  b += "qv23qqsOgitRCHLIEcJVrHHqv8WgcKfDvBOgIk4A3YsGv+UPq+YN2jT7QIrrJlkrwHr1ffsrsUi";
  b += "SyGUNTKZp0dt8Ol4vFXNoMhjfeOmR+7hIugYNcnjHg4IgRe9Q9LbhWZOshZtUIwwATGTN0MQkTM";
  b += "ROQLSPFcNcu0q86uMZ4EeJYnQA13iSeQkWXeA5gU1u7LJwn/RqZakDw6K/69IkqV0xHtu2EG5Jf";
  b += "SJD/BPZjH+M8Y+t+L9krxgB5MIg3oAXUp8vhgby+INAAY9tWwwK59RxmEYfOKmGU4xh7gxht7b/";
  b += "WYyDAOYkouRYBfHrKDX+AJ5TnODoZQxlTrcNNEoh+rRQaU5U8G4YzkHwWxEDASlYjTkLEKcEbrR";
  b += "j03VQ2KBaiJBGiqHCtRIFr5XQ7ZGgS/QTvH/mQtNJd4UI98NdE3ARaEciNW+heQk4gTq8CukTEU";
  b += "jFnkCxErgpgdIngdo3gdongSM2gctwihdgJCaEAIBUdWxDpiCYHazrhRxcCERnySEBt4BqBJOFx";
  b += "aQyuBW2Sp6E4NQS+HSGuz3G5U0BALsd24RW/ka4dKcYCRE9IYxQICAhsCpmKuMMvCYJl9pEJmGI";
  b += "JkTCmLUREHDw1nwkTEAaijEsYoB7wiZIrlrJw0GC1Jvvd7J0xoHFIIynQtAwwExq1zCoImZZe7t";
  b += "DTHsB1uXxeKkQoFYniQHo0lCeMwfd64Abx+fYY90JWxgcOT7PYfDkeC+Hneijydj1l26J3DQ9ge";
  b += "C5TtPLby4G09FnoxPtB/DZ6ER/TuCzEULj0GejEz02zVQWwIjtxF0KVwZWFKqn5ljVeM5WDTOsU";
  b += "jV6hq7GOqsay6xqLIBZuX977QU9QU7moCoOqoqDirznz0MWeYVVJBXuswp3Y+Hg700o5mlRee17";
  b += "AMoAPdiYKGz069jKwtnDof2LowYAeHAUPC+J8O1oQOGohHYM4GZV4CShTfF6L5F4xOr/G12sEpZ";
  b += "KDWLiNlEMBt4XEUSABkylzzCrpdmWrrZx1639Rc2ncXc8ZTnxR0IVgL2ovNev++6dT738zevfk3";
  b += "ANmnfwaz/pfv7rH398nlhKenF9flQsbpoMZysSNW9cuwFAXZNiIRN4N8w+vdjeuOnNCLpYTetav";
  b += "GyNeLSwIZF37aNP/fWRZ5/rLqG6PPLsP9uP/ezme1WoS1LMLEGVP/DM1Xd1Xf3ogxdS+qcPn/7o";
  b += "vh0vv3JwG2TAFO/9+ujPn/nq4Ttf5uad7tiz8+G9x05NylG5zBOv/XLHnqM7XruSEnR/8I93nrn";
  b += "5wecNSKDFtqfA/sKNL4YPgLSs8cxF+bQ8L92iF0uH3YDA6bdmN0XzYcyQwAcwCDc5Vm5eH/2Km8";
  b += "4YgdUWbsAxrAUu3ItgFsdhzEibbya7CLZB6QfcAs9HDoLHRnWOT/ISQ2coCEoAF9Uhmi1Z0V8qi";
  b += "mObfJWFLCHWQk7CDXD4cTfOSXH0lgO37BIMB1raTthJksm3X6rxwQmEiHTY1wd0Z1F30gqLE+4g";
  b += "wIWYhMLGBtJicsB0CAydIR7TQ0bviW523IjOCHEBqxoZ6MMA37lzlHHwlMB1JMy3uTq6dtBgeFX";
  b += "B5Z8+W7oUenkOos6qOAZkIWjCmBCBtwMWKuzGZRmnqRkiPJ2hG9hnt8NMGXAyyCoM4k4AcyDEC+";
  b += "TrBNXiKwjkAsAnv0DyuiRaIPUmWACZCls4Eu0x9f0fL4gC1LVbVlSHM8Hlpp1SdKi7DPq2xL4ec";
  b += "Kn9RcAQOQG9fZ0IHRHPeTpBK8IQKBFkOnriBVReKaR9oMLqwiR4KXt30l6SGXv9F9z9oRiFilGR";
  b += "KAwDUNpuszSEg8qBOom3l6LjX1t50UrYSsZJXjRQBsGgKwdbycoQBXfaC9bOruAELxqyZnE2Hoo";
  b += "yVkVZ2WMvIz3HRm5ZtIwYyk4v7aE7iJl6TJOeGIqZvfby9LNrE1iuSFmK0YZDb5ra8A7iW8fkQR";
  b += "D98WfJh/Hx8AFBRrLOknJWPJTJPRshwNJK5FfY9FPoA+B3ckzPyuKOBVrmIKPacJJnJRe6vDLlk";
  b += "BqVDqJSC4H9oVuiL6IKob4qhHNCMGuKTl996MuqZLjIvxhhxSDa5hpCYR5n755Ad9cfmS4W6CP6";
  b += "7gEJx5Ajhoomes3pRNviXRXTWs3WWp/phKfzza6oEx5eY8rGYXxL68yuN7vICQ8vJ5cNQDSa8xn";
  b += "wHqEaz+GDvhAdg/AJ8iqBFE/eQWDjTPCAbK6FY6oZHeNgY8MBexSwyhUmMmL7s18MHpqAQ3v+1m";
  b += "UBnO/9G1bah19g7oYfEqCNiq2N3/9bl1WjQ5wc3bl0wQ8u+BRo1vB/Y2uY9e/UEJbuY+zShtXy0";
  b += "b92MWjwbyX6fC+xf3map8kZD6JqUX+UjV6RxRgd25gBKL9nUX4xDsrY7tNAOZXbjbr0DXlABYpt";
  b += "98DC6L3ZhjZ/c3dUGCfhBx/XXzY+hOjwqP4xr2Tja3u7wVUpimfv3u4YFTw5cDceql4DMuqdm7r";
  b += "PVgSnRBZhT5lN+CY04XP9mjCQuG82yzo5dFmWFG6yYX3Her+CbS/YIZJsqNYSolpHXdK4vWYumf";
  b += "qpoUbwA2gBbivJOmPM4PmCA9fTnhJisom0hJlJqE1iCfOwagJHvTZQn7VBzacan1zzOIDLxQJcq";
  b += "QRw5YeFLSCHSOTtBbVkB9j+DmSfcfwjUY+vGNfBKyfuZxl7RFj7SoA90PgA568AQn7Yp4dltbld";
  b += "HxRr8DFsfFJNyFiDjytUDVR3+OXjEwTCZf1iadgDTiX9KgXPh8wQgoI/bfB3PP7B4Dj8g0Ed/2B";
  b += "wDP7BYDr+wWAq/sGghn8w6MM/GHTjHww6+A80hVoUCmboowvvazNPhTn4Mpt1GYMvZrij1zeCHt";
  b += "uJSB9fLcWjU/7Bj3x5+t4JiN5WcPW93GCd2opej7COpGXcZ55ZSsLjUsn4V7MfZkqxH5oaZv9lu";
  b += "D2Sao+k2SMj7JGR9ki6PTIq5tCUcjA4Go5Nyfqog01i6vRbp6YU3bf9oOgM6dahKUX34puR1pkp";
  b += "RffgmxHWkSlFT8Q3adaJKUV345tU68CUorvwzXDrvJSiJ+CbYdZxKUV34psU67SUWOngG806LCV";
  b += "mFnyTbJ2VGq1nNIkXSXRSypuI6zztZZk/00S/nOGmKR6cSOR1YT6uCslM+Icc3/wGCDWG3G9+E9";
  b += "MrjNQXwvinnmlG6t17NgMtjqzH98Y7st5zi0n83bMYWaNMuEG1RV6UedFMX9Btv/xQ9r7tPCOv4";
  b += "vvfWreNMNdtiR6vz5+UrKUMG56aNgL5+vD+brJDfCMgetiKpkH05xD1QDQVos/uN6fV4RD9zX7T";
  b += "t+IwiL4K0RSIpkD0L9avGkT/ZpFKRjvAiiZBdOet4CYGon6I3gBRFaI+iN4IUT9EcaK4HaLJEPV";
  b += "A9D7r10SI/gSiSRBFtz49EE2EqAuiz99qNjABDR2LlBOib1uk0LvQe1ZeIU4FkMdUa7XoIk8NbL";
  b += "tPChnvs+2+5zbTW8P/StinDZW6myomReOw+DVEnV/CfU7Nst11wjI0NTPe8o6fi/Lk+MvruP3Tl";
  b += "2d1Dg9v9o1tsnWAHsUWOaZ6Vw+ywrA8h8Y4+bTbd+znE+27Yz+Ite+iRdzhsEX+Ig9udyBdNj3e";
  b += "/whNx/hNj48/wi/himV3nGbbU9gde093f4Z2x3XKGS3uAceQRGsMYVtXZhv8w0NR137tD5ANjv1";
  b += "wzwPmcID98M4HTO+u2A8fsKLYD7sh6rT64RMQTbD64TMPmKMDmsbHIJpumcYnITpqAOnveBDMfm";
  b += "Pfg+iCCpXgwIPsOpZZ0auc0ciPnxUDThid95sTxh556NkIudYlshhjLK69AtHzLa79E6IBi2v7f";
  b += "yiiIyyuPQDRYRbXfg7RyRbXTv0wdkEBcht/xmlP4cXLIbMVN8rxT3sXwH7wkZ+IQh4Wf5DF6MM1";
  b += "w/AbybqUAUtATHMdpLm9T5o0YySn8SA/m7T3Vduug+a9OXZ1NidEfTRPzKW56CIFhwctiDsX3CB";
  b += "06gJHD6eTBZFFr3KxUcbd6JUWWw1t3d3VzXsjMPpBrnEYNl3WQsvRkTv5ZMFtV7aOLqD9duPWrm";
  b += "76Sn3NCiVh2wbY1z4lmwsrPB31IngYlSaouYH5uPkUGIm7W4E03HwLDMc9v0ABbi8G0nF7E8D0A";
  b += "RF9mK7gNxzFcEVCAbcK8J8Kul0iP4rodiQpL3ennpTX/rG6PW/8zg4Itp92bc9Lx7ft7R8mb89z";
  b += "7+yAH9y7+IUIp++idPB+/C7MLkK5uzo6Ouj4n5vcSpEXygnqnMD58KgCsH5ozFh4ZAV0eFwRGA2";
  b += "PdYEMeIwPBOChBzDf5oAfHo2BEfBYFhgDjwWB8+CRHkiBhxZIRg9s4B0AzwYGk3LUTvgSpuWoh+";
  b += "CZnKP2wDMlR+2C53k5ai88x+SoR+E5Ikd9B57+HPW4TL6txN9DcAhVPLsAk1o8j8roaME4Lp4J2";
  b += "gdMuJMJY0FeLijABWVwQaO5IFG7XXJwIRcnYu1ycBEXukcO4fkZp07EJ6h75MBieO6TA0VEvJOJ";
  b += "Y2E6FzaWCxvFhY3gwoq4mMVcwAH46t6niANyIAjPe+TABUSyk0liEedzEedxEX4uYiEXcQEXEcQ";
  b += "iBiA+jol/joh1MrFDzP0eZhISX8TEi5j455j4uMGIX8jELyJinUzsEHO8h5nSxUzo5Roj8YuY+I";
  b += "WDER/PxCcQsU4mdog53MPs6OLm93KNkfgEJj5+MOIXM/GJRKyTiR1i3vYwO7q4+b1cYyQ+kYlfP";
  b += "BjxSUx8sqlwXACqGxeCWhX0cVGoa8FELvBCLnACFziZC5w0WIFTuMBMkcjHhSVyQRdwEUEmPp6J";
  b += "T2TimUx8ymDEs5h4NhHrZGKHmN89zKIuZkkv1xiJZzPxrAGIE9ngkhx1F8cOyMGlOWo7E+5kwoe";
  b += "Y9z3Mmi5mRS/XHgtawgUtHbygZTmC41ZBy3MEx4lwJxM+xDzvYTZ1MVt6uSVY0DIuaPlg7JrK7J";
  b += "pGxDqZ2CHmeQ+zqYvZ0su1R+LTmPjUwYhPZ+IziFgnEzvEPO9h1nQxK3q5xkh8BhOfPhjxmUw8h";
  b += "4h1MrFDzOceZkcXN7+Xa4zEc5j4zMGI5zLxWUSsk4kdYt72MDu6uPm9XGMkPouJ5w5GfDYTv4SI";
  b += "dTKxQ9ER39bR2qMdbToXlMMFXcIFzR6soEu5oM8P0NHO1KNnckGzuKDPc0GXDlbQZVzQ5QMUNI2";
  b += "LmMrEc5n4JUz8ciZ+2WDE5zBxg4h1MrFDzPMeZk0Xs6KXa4zEDSY+Z/COtiKmR6/kHj2DC5rOBe";
  b += "VwQTO5oEu5oMu5oBVc0MrBC1oV06NXc4/O4YJmckGzuKBcLugyLsjgglZxQasHY1ces2suEetkY";
  b += "oeY5z3Mpi5mSy/XHonPZeJ5gxGfx8TziVgnEzvEPO9h1nQxK3q5xkg8n4nPG4z4AiZeSMQ6mdgh";
  b += "5nMPs6OLm9/LNUbihUx8wWDE1zDxtUSsk4kdYt72MDu6uPm9XGMkvpaJrxmM+Domvp6IdTKxIXv";
  b += "0PC6okAtazwWtG6ygDVzQF86yRy/ggtZyQV/ggjYMVtCXuaAvDlDQXC4ij4mvYeLrmfgXmfiXBy";
  b += "O+kYlfQcQ6mdgh5nkPs6aLWdHLNUbiVzDxjYMRL2biJUSsk4kdYj73MDu6uPm9XGMkXsLEi/sTH";
  b += "6Yn6fP14XlTrxN/ply3Q/wded2ONj1NHynC28Xftra8u16568fX//1rv3hcagv69FQ9fYc+bDs8";
  b += "t4tA3rjrxJ/zr4PgKJEVboWLV0n4KgleoUPI1B3b4e92QVvTR7bpPoAbA0eUaeKHtB1w91/UwYd";
  b += "18GEd8p59+tE7brrp+f1/FcUmwhcLQVZDshqS1YCwyC3+AtlkPa1NT9TTRWJBfbj4YfgOuA4vyC";
  b += "Yi2UQi+/x1T9929c7uO56Srgx64HOIIJuMZJORLHiU0JCsBmRTAJ/Yo6e2BT2Cuk/84NsBt+4FW";
  b += "Q+S9RDZIz29fz/4teu+O+LK4JcAMEFQTUGqKUg1RdAFqslE1av72gQ/REqvoOoRPyTCW6DqRape";
  b += "otr5x7u+/djTh34wqw2o+oCqD6n6kKpP0EtBqilANVEPtIl6fwlY4NG94gfPgCz41oFvHtr/syM";
  b += "f/kZwNjCgwHxI1kdkPQBbqQGMILAAyHoHZMGbx7997cM/uOP4nwVn9QEF5tOTkGwS8WAsSE0fig";
  b += "fv/OvJe+/67jt/PSbIjh1aYIn6+SC1sUMx4Wcf/f3t9++95fRFVwbPH1pgHv08UNrzh+LBz17v/";
  b += "sHe4y92D2sLnje0wLyACZwkSA/Bgt1v3vTBif/+3b5xbcExQ8srEaDKNUF6CA688YePf/ho5x07";
  b += "XxBqkDG0vDz6aJBXxlAsePemv9z83P3ffP1vguzooeXlRfRpQXsIHjz3q+8evLXr13s+EWowami";
  b += "BJQLGvE/QHoIJT7/8++ev/8HHN54QZEcMLTGP7geJjRiKCScffLnjR89vf/CyK4P+oSXmBYAPv6";
  b += "4NxYP7//iTXW/98rsPZiDVoQSWqC8CqslDseC2h37+6K1f/8sBDakOJS+PXgRUU4biwMM/+NEr7";
  b += "3S+fVwU749nQFwM4vIPxYE3Ox989Jc/vmfnOKQ69IB4AdQ1aSgOvN9x75PvX//0e5Pb4pGWRw+y";
  b += "tM7Mge1P7n//e7fc+ZOnpLZ4xOUFgH0U15lZcOyDa//49E+/3/sKkR16PBzH8jozDx4++It99+x";
  b += "/4/T/SnEJzAMw0yiwMzPhha4Tu59/4U/H35aujEdiXgDPRomdmQmn9v/wpvsevOHtl6S4OlgiIO";
  b += "2jyM7MhO5Hb+78352PfPycFFcP8+jjWWRnZsKtb/x8V8e1B37dJcXVxbz6RBbZmZnws+Ov3vTM1";
  b += "f/6+qwr45FYIuDco8TOzIOXH3jh7Z0v7b/34rgE5tEns8CGmBU6bmi//Y/73kxoi29AnBTXgHjq";
  b += "lR8fPXXvU3tT4+phmYIWSstvY4AfiPqRqB+JtuWdfr3nkWNHH3/5IjQ8hx4QpwBzsYN5dT9zoD9";
  b += "fv3fT/t/tONhz/ZQ2sDuHkla2Dm7RfMRWIOofiK1teX9+Yc+Lv3hs/zeeFd3WO7S4/HoWcHfI/v";
  b += "X62y+e/PFd22/9tRSXvJYgZ7UhOfvaLx99teePt+54c1Cbvk//WgqsTR6Ktfe8+drvf/TSNQ/D2";
  b += "BWHTb8MeZsyJG+/fdeTXft/++ztH4tu6x1aZH59OVn2Q/D2F7d88PL97773xJ/jGxKnIW+ThuTt";
  b += "rf/46b4//WnHgVcF2cR4ZrGpwFttKN5+cscHtx155K2/vUTrpaFENgN5mzwkb989etuHf7vxtt9";
  b += "+Hlk7lMT8+nRg7ZAj4tHt9z373NN/ejI3rhExB1Z0MCAOwdl3Xn68543Tv3hkCjJ26BFxJjA2aS";
  b += "jGnrrvD8d+8tOf/WgC8nUocc1CvmpD8vXFx3565PvP/e1DL/J1KGn59Vzg65A2R+d33r1l+w33P";
  b += "KzFZXJcghqbMiRfe+58+ok/3XXoV6NwMBja4pgNfPUNxddfv7jzqzuufnn/+TgWDCWtzyNfk4bk";
  b += "67de+unpZ/9w290X4TA7lLT84AjCO/T8dc+Nf9792jd+2Ds9rvnr8jjnr98/9N37D39j+w2z4py";
  b += "/Lotr/nr6lp3fvv/J75/8HymuCcyIcwL7+xNf/+kHTz74Py/HO4HNiWsC+85fn3r40Y/3f/Od+C";
  b += "awFXFOYKff/Nm7b756/JfvxTuBrYxrAjv+2iv73vtz768+jG8CWxXnBHbDfz166uF//W7/R/FOY";
  b += "KvjmsD27n733o9/9titf49vApsb5wTW+/O/n3i1vevAu/FOYHlxTWDf7Hj/a4+/ceKll+ObwPLj";
  b += "nMD+dP1bf+i4+pvbu6U4Z7B5cc1gL/zmkRPP/+7OX8Zn0xfGOYOdOPzW/Td+79DJGXHOYAvimsH";
  b += "+8dHpv17/9vOHp8Q1g62NcwZ7479O77n5F8dvSotzBlsT1wy269Uju6/ec2+3J64V2Po4Z7CfvP";
  b += "7qnoPvf+vDhDhnsHVxzWDfe+Cub/y28/UHPHHNYF+Icwa7f/+JD55uf+uOlDhnsA1xzWD7b/jrv";
  b += "ufferwzI64Z7ItxzmAdH92471cfv/rn8XHOYF+Oawa7+clbdz707vffnBrXBHZFnBPY4X997/47";
  b += "u3/43KVxzl8b45q/nvl21/EnP/zNDT+Pb/4qiXP+emTHP35z8pvvv/FMvPNXMc9fyTbOJgPdZKS";
  b += "bTLX9/ulbfv/cj5567Dc0fyUC2UQkm4hkE2MFht+yzDksBTSC2ZsClFOQcgrX+OT7L7/4o/dffv";
  b += "N1sg9AGEApkUUPJXmwJA9+f9L99MWMJzKL+wN+Yvrmodt+deSBnXedRNqBYfihJ5Aqqjlc5G8LD";
  b += "McPSoF0wY60tkCa4E5BW6BAKMrItsBIQXl+W2A+AjgCkpGb7mdJ+nw8WqmPzFHh4GRajgqHvIfn";
  b += "qHBJpQAA/iQ9PUeF896pCGugD4PDgqpxSobzoIcVAMG1DmwelUwEIgmuyeN5zDnGNnRIrALYECE";
  b += "L4VFO7U28ZKYZ8nyEqYUs4ynLOIqNoUvjcHhVJCaIALcJMYjHIhmZFk75WZkn0UlduCS9+0g31Q";
  b += "OOis7ji7HT8cBnlnXfeRJc1ueL67lw+JOgBwCkrijsl6PU9lnUJKL2TDe8sOf0y4inR/crud62C";
  b += "3USYywdlfBSHJ0nPfwUnyfF2MnXODaasBfaOx5nwLMHRDEZKZIkeXc7CL+IrvMphEAIgkVMP/L8";
  b += "LiM+jAzPdgfAzgBg3+VNIlEY/FhDzNdqHIeYD2MJrdbPfgMPF9tzJPdNY5GwMuGLYa2Gq0noBpA";
  b += "1iA+EoAdMmI+wlyZ0HsKywXlNEysxmGDIkSCAwyi6szAjqBhuOJS6KCPoNLY1G2NbA6ADCSAeBz";
  b += "QyHZHwAJBhDMHgpesEDzVTSfUi+h0QQqw87TFEVxZKAw83oSA56S6Uwn6sLWg8WccqAdSEhiCng";
  b += "I5HmHiEwIdtCij2E/N4glkJAeI0ErPzzm/yrovYongD8qAwxEfkKHWmqSKmLiMAwxlgUaCXb1My";
  b += "CAiCWKDaeBAHVATzvF2KrG5TbNc/22WL9aQyALYh6OC9A9XQm0Dbo8AdKD3w9y7hAWRHyPhEChl";
  b += "ZxktQYHKTyOkpzNDVEPiQVwDtSRQsXjpa0aO4Bk7nEbEohJiRi/zofNz41pt4tQHpid8AaqpGK8";
  b += "Lj6gOUlXPuiwIptsPgRVAC7XCRvVvSvqNIfaPeucDAOagOKgKWSHBtFh5OxDSGEU0yXaoriG+Fg";
  b += "CSgls4aRKDydiqyC4kEhTpBR5QI+QkxC2sMFbBIAZGEftHlQAJyIAGhBCRAMQX/8dRTRLdgPFOH";
  b += "rtYE3UZbU9AVwm4hA2SVKsghLpa02I8IeBFRaHpTIFGERdIEwyEqKsp11MBb0XVAM6A8p56gJ7b";
  b += "SXZQE3REhuDpMDmBIcIhagaKh4khdsB3xW50mKt1Aqb26W1QI0F91UUvorA4SLjmoR05CG6MMxN";
  b += "PblFXy/hAvLxNYjGLyTu7HOwfzDuFkAS+FCIo5zkGUHHB6XogGWKBCQWKIBPgwJ8LcXH1Nh7sWK";
  b += "+QwUTZNiEMJQWFFC2B0oGP5IZx2YotRzArf7ERRKyxuhKRchPkcIcRJdoQQhQEUwa8A9HtbU0Al";
  b += "sDUhHUBRS+DkoOPYFVCpUPWgRAnfE6wboeEKIdYIwYqmOaBXOAWng05SAwcICmAZVYAsFwJ3ibB";
  b += "I6AbYNJlYiMrhxgECp2hAIhA1TIyQLki6q9XUhRoQEUkHeo6DlAwwDfG3aHabRtjzyF5AjBykDz";
  b += "jBNHBafYBGAVuroZ/F6gdi1IvxDBXb7ANOq/EJVL2BGh8apPGAaNdqtjsxpg8QoH60DyRQH3BSs";
  b += "/v2AXtqYBT2ASdg0kEfyPfTkMSNHLgTSCabE4A7gHMEnb4mALOjVINAb6AKclRFbHSA6xIXT/d2";
  b += "EaTLTfdYLvT6JKPrBriZo+1QzbcTbAk9dCNHzJf4K3QT8xLMHQ58JaaufK+LxIc/wTQ5xqQ11uu";
  b += "VjFcIYTPf+1eHLHrENpr5FRNZl29fSXz7im8Ek50wE0FYEEZANl44CoO49ghYji8d7bbu+b9yFC";
  b += "7XAYj1bGm4cdL8ZXjIOIW/RCHIUw0ZIMgFEx1ofRrP9XZL4yVppkSAKMYvRXyChEjrkvFYNKLk7";
  b += "QW8dQXw1hGyPNVofx4umopyUkPGruehHO0OJYDAPOn5fhWeqdpKvFgKbRPmgBsTBxnkdt/zWM+Y";
  b += "+4WQhlDP6J5hIssBMQSAD9Sim+SgoOgOyniLELG14R4h6H0+oW07UPcAxBnKTkQsU7pY6Jep+A6";
  b += "CxpL7YGgx3pTboNGV0v7xeP+0Qaqs0D827RzYL1NB3WXj1ufxut8jAPXAApGs6n/F5J1k3B1lHI";
  b += "E3ovUn4Q0s4+vH4JJgv/zGLccQBQY5f+sxRIEJ4KxPFhkCKxupaKt5f+SUE7Yhgv9x+4JkOi0EJ";
  b += "pEFbnTd1sWXX9XZEuAY6YiGBClX0WNOdCFD64TFlqcDYeYn4O+5YsgR7BIDUecbcI8aYQERlhxw";
  b += "0J2APUa42AHAtBnDYIcK+O14glHwp0eDKjBBMQ68QZfzFAYTy8WQG2HFFIQunARvYM2jII47Gb8";
  b += "uxGfX1vglE7paxXngyBtoCDkJCE2Be3SqDTce4JTUqAsDQRhD45nieKCoMHQv6h3B8iJKUoqECP";
  b += "E2tLsdqLPwysLD29GxDCzq2IoA4pmK8OtgCNMrryEBfid5hCBTH24lBgHIY3qIR1lAdFIm4QoVE";
  b += "Otl4/TtXXDrfLeDAI38QUVL4nUmoKKLP2O0G1VaLApB0RLQYd0U1IIq8JM8weyGzrnzji4Yc5Dg";
  b += "nBqAyLYKVnW6iujmRezbahQ8T0tGNYGrgzFOE0AN2f9Cr9A5NGr1kLEHqn1S/EH3CwTh9qjiVSU";
  b += "Z/3n/eVoeKQzS9i7J+4vEK1rqN4WLGzdGqsINm67QK4qra8vLxGLQIdF/svjnFP8SxD+X+Je5ur";
  b += "k83JxZWhWubs6cUlocrmzIDJdXVjdHwlsym8OlmdX1ZeWbp5SGiyPlzVOqGybPrMjOKZs6taSkO";
  b += "HtGVlZ2RWZV+ebJWVOmT5mGyWurS6aEmyUpS9KkNYL+XFFgmhQbnyGeK6sr64sjLWFR+MZwuahD";
  b += "a3nZqtKSNSJe3VBf0tAQqW0oLisPR8rLm+sb66pLww2lDWXlRkRUI1IcEWlWlDc2hCOtlKGyRbz";
  b += "e2Nxa39hQW126paK4rrp2y8bqsuq64spy8Wyta6xtrq7cWFxb2VDaEg6X10c2RkpLGmuLIxur6y";
  b += "saNha3RKoawhtryrdsLK+3arQxK4ylbCwrjhTXlRc3iwrXibxVDc30rroMs5RVV0K1ojToBWeuL";
  b += "rMCG+uKKSxoi/KjBWWXVlU3igSlDXV11RH+2axpSUt1bZkZqauubwhbkeKQKNGiMjWanfJYUcoV";
  b += "jcbmm1Zb3FJfWhVbpenNpowKgLvLkLPLBMcqGsJ1hYJpS+tLy/XqetFwCFQVN+uN4fLW6oaW5to";
  b += "tekl5eb3e2FDd3FAPClgrNPxiIXcRmxyproN81ZHq4trqrShMva54i17fEBHZ9MbyMJRQXqaHy0";
  b += "U7m6tby2u3HBD5c0X+0uJaodD6FUsbIdvs2aTu4ydcoQsixfoVS0QBV+itxbUt5ZnhluZIaWZZR";
  b += "W5OdkVJRdaMaWXl04pzZ8yYNit31szppWVZMyqKy0rKZ2WXVkyvKAPVDReD1kfKUJWbt9SXZjaI";
  b += "poFCe1VNWizKv0X8mwr95vKS2pXLFn/+QqGg+BRais8WUFMISRLUGf7r+6wStKAfVosn9MFG8XS";
  b += "L52Z+tounB9JFIo3NszMza8qaq+sjFVOK68qmCBFKz4jfR0IdWkvLazJbszNF+KR4l2grA+jczf";
  b += "0e3gM9n0JxL4T5N/jnF/+S+rxLFv+0czI+bCpurptcIpJVltdPrmgBfWqmASPXNmIsc2hSlSjvV";
  b += "QnGC+PodWI0u3nYFcUgBL2i/gqhC80toBPFFZHysC7Y0FhbDioAM4tV82Hi33DxL1X8K9bnVTeL";
  b += "Dr5Fr4a00G1J1cLlog71QKpeLw+HG8J6S3355sbyUtExarfgaGWOlCOAA/+mGglFbSglRYqEq+s";
  b += "rQYtWOTVpkaA5zUMcN7V5hWhcbaSvNtfrV+SHw6zNKHE3tzNd/LOPtiedpDHrxb8xUjS+oU98hf";
  b += "g32hbP6hOfxO2msVWHEU4vayhvxq5ZVxwprZqi66uqqpt1IczysKi94G59WXUpSF+PVBVHxJ9yz";
  b += "DdJL62C1tVXlmfWQy+apAtOW0NKsy4GQr2kuMwq+7I+dcnhunx6DaTBWOhcdtaUHMxS2hAu31jc";
  b += "WJ1ZGtnYWhyuLi6pxV5+LEGTakSZbeLfuHNSdolQgprJJS0VFeVhqsF0u9a7NOkK7qm6+GfG72d";
  b += "emPHbxL/P2eK5gjHn2+IzZNKJT1/f0ob65oba8o3YMTY2FtdXl26samiogboz80ylcxOvbpFidT";
  b += "mOkVkaZdPl0eek3s1VxVOJv7kxEsaaSp2irl8Sz908PrifPPz3yrcSQ5ccfKpjx/2VP5344d6Pw";
  b += "3+vv/SvM8/bOPv9pd99/pq37tu2Imn52NrLJu6ucu6vedT46Ae/2T52S+Cq4aOePf6FNjeNsnMb";
  b += "WmrLsHMIvglTJBJVej3SoJdsEdWF2rREqmubRVX2Jmo4Vo3gWaS+AXoGdJdoxzDTXMojtRkXy1B";
  b += "YuA9QpjA4oDQaZkR/pH5bV9xo5R3HMuqfF+UxSO5o2eM5f4ZthoBxJbuidPq0rNLiyTNKciomT5";
  b += "86a8bkWVPLyidPm1ZaMbUke/qMsmm5/cskCwgKXdi8Bsq3a5X03x7q/zCGg6VYVF0r7IvaBrC9R";
  b += "PVaG2piLQMYVmhSKCmHFpSFGxobhcmh2+oakABYBHS0HipSXFoq5CKUclVVuLy4TF/cIJRXXxlp";
  b += "CAtrkVlS1oL8sIiXgT3XUopTjnSBbY4Y9ynmCNPUiGA9MmuhHsCFzV5NWiro/u856x9DzcJNLeU";
  b += "tOARKvaLsEI83U6RoHHRggi1+2WdWN9E7ajKFCVQpZnxkFNYz4tOkVpZtGtf3QvHvIltdzTQV/P";
  b += "u5kv/E/7T8/bHy/4T/6xXvjVP7hW30K4cuGnMRGsyiP4HRXh8BmwaatbC4tXhlabi6MaLXt9SVl";
  b += "IchH/x3Sjwn8Tx/Dsbc8rDo6zHSy5oyc0p2zCwhZSVpUjn3ZRhD8mFmEc/Jtv4JepZps+PALsn+";
  b += "lHbc1P+gHacnx9pxHs/KSHFpzWyP+G8azM/cjunniM+l2YKzObzEFouq+gjxdp+oB9h8MA+PhRV";
  b += "FvVDe6jI9Ulxp/dbNui/zv2z+V8zPxIt3Ltj5gV+WPZJx/IBQrSNKS31zSyOtUqMWmw5r53B1pK";
  b += "puNgytV2gadj2zyBUrDb2xpUSsEWE+mq3vFr+DSUI7EDDYl9fD0kiPlDRvLBXTQHUFmo2gsfPyV";
  b += "yDNe0WeCX1oWuWLFMc1WvjA5gEsAmxULCvVzIN/ysvtibAMKUWTZtnKWJZfhO/nifd+23uzTl/k";
  b += "989MNm5r2pXiPjl18dbe+yZ8MEXRR+3X/7bpja/evPcvi3J+v1dXxr4XmPjIPx5besWiFPezknH";
  b += "sO4KZKbKt+5I6Gnu/K35IM+XR58ce+PHP8jmw5MJbGiMNomdWCnUR6jOD1adFRDNRFqzMUs8wGt";
  b += "G/DdyB0fPhrsKKlqOfz/2fFw+8sfn3en1RxqrTs2+99pOk76zv2LmqbOJrS4ov+CDz6uFpt094/";
  b += "L7ZRR/frS667/OOC+79r4e+8tg9j9257ND2KWvevu9rv/nkvapRK37+xJx7qmddqLS/+odfpG14";
  b += "/AebJw7Q6mMHRauvOC1eqNxtIfzRJ2f+7+xlsve/RDnfcn3W64p9qZ/tuiI1LXadYMbP3TrhzPb";
  b += "23rRYe/uz5LVjxGfL6/YRsWs4M26u4cy4uYYz46ZszPi5k024uVhUcxb3d2vYbs5sbG7mOXmkhu";
  b += "P/RebuLMeny7Q7bMZnySS/czAcNbeURGrLJ08V41BWjIHwi5E0Tz2mwE6VsecB0UO/kSN/FlqaH";
  b += "qul8F/v7c7uL93206ddL7TNvHjCt0tGvtqYtUFef+Os9Ukf9J7MTMv2dn1SeeG0ypS0dVXXLnzo";
  b += "hoNf/0eZf4rv5buX/vNn5y14uOCz1PQFoz5bTT8yKlbTzbip6Wbc1HQzbmq6GT93mi6sW3OCE2w";
  b += "TNc7lCouXLWQl/Se7E69EfjOaeksK72rY48CHyGiygK8U/87rE5/yGeh5W8b/RT0/s65ljYnVrZ";
  b += "XCsCzX64QJDyse2GRsLq4r12GrJVIFNiS8Kg6Hi7d8+prh3mZ16WQkB1WbHrvz9dQYku8XFbL+z";
  b += "wU/o2ZyGXx/wS8j5TbjuyLcUKc3i+VhcbgZ7NL287T+ujOvobQF1kfNmWsbwjUrI4K3mYsLV4kF";
  b += "RCvWv6I6XLepOFyeiZ/LMiNbGsubM5vrG0WjOgW9BYJeWKZV2Op6GGVwY8iqDW5nicK18zXcCRq";
  b += "4ztFFAFdarF6srNJ0kRdWZmvm5i+KGu1osKMEo9/3eJtIZGoUeWDFPTd/xarC+YVzjVX5k+G/vP";
  b += "yCwiV637eeosLCgvVb587Ny1tUaWwqzDMqC+cZyw2jKH99wdyVTQUrC0umzVuenzc3ZMxoMHI3z";
  b += "Vu+fuH6wg2FxtrV8/KMwrmevOVzqxbMM4rzKmuaqmqqC2Ztysozllf2SyjSVUMBRYuK5hmV+XlF";
  b += "C5o3z59nrPTkVS5Zk2c0F83NWtOyYWpty4a1a7YUr51RX7S8edPc5evnrVm+vCB/08I1q7fmry7";
  b += "KKywwslfn523atHj11PktZQX5lZ7lUzdXldblb5671VhIxCqLjJoleUUrcjctIAKL5uVtyNuwYE";
  b += "NVSd2S2g1z85YUr12ypWRLXv6GdRsaPeunrtlatKJwU76BiefNM2rzVtc0R1atrW1ev3b6pgVVp";
  b += "UuKQsbmonmFW4pWlW4p2mpkrxXvlsxbje881stQXk7RiuWb8iuR0OJ5RmR+SV1ZY0ndmtrSOtG0";
  b += "rfmLRdWoCVVFc9esKbLzoLRobvaSqpL6FVWF+Uua169bWGXjgRDLwnnLV+VXFOVlIYG5lZvWLl+";
  b += "7Yur6tTNCng1rl1eK6oZK63IrVxSsmSraV1u6NX9lUZ6BiY1NmxYuX7Nw8eLV2Y0lBfNbhNjnFo";
  b += "aMJabUPCS2/PmGsXSuUZlrQIK5lYtEON/IWlw2Y+qKhUvLyqsX1jYtmrqwrHlN3byc+TWRlobI2";
  b += "k3rsiuWVHrWTs9et37Wuq3ZC/KrVq6uq1q8ddbcllnzFqyoba1cuHLJ5pLy9eub6xdWtG4Jbc4u";
  b += "qlidtWZGpGZR9ers/PLmJfMjxZ7smlVGVvPWJdXNZetLZ1U3N9Xk1K1bNWPiooqCFSUVpdPXZM7";
  b += "auqKwND83VLtgyczsldmhltx1s6ZNnFm2ed7qcMFUz8qtm5sWTs+ratqyvm71vHDLsnULV66b3r";
  b += "q6NCt7WU5oVm5RY9PSlbNmhJeuKCtYUF44Y+qS4q0z6qbmTVw6sTXUPDfLMzOrbFpOaP2sxfPLW";
  b += "5Yum14kemluU2VF9dSVM2oWNVVmFs+fWbws0mJsWL5mRU7LtEXz169bNmPWurqFlZHShsqsGZ7K";
  b += "usKsVZlLqyOLq1q2rmlt3FC6uLEqq6GsKjO7cNm6ps3TJhbVh+bNyjFyKtY1NhWUZW7JXbR5XU6";
  b += "opnlV/lZjaaWnZJFRXlw3rbZu4rQtiwpLV60vqm1eUbRuWWloSUlha11z3paaeZmZm1fWV7c0ty";
  b += "zIq6msr81fkr92c/bq0pLly8PNnomVa+bVtKxZVtVcv7VwxZLK9a1F03PXT8xZXFC9cH19uC4/d";
  b += "3NpuHxzeU3e5nBr8dQ1s1YtXN5Uv2Ta8hnTaiIzWqs9y6unTaycW1FXs2lu1vysSHW4cEPJ4pp1";
  b += "y8LLNm3dkFU0q3zJ5qrCLStLptY3LqyorG/aOmNGYVbLtGmbqqaHszYsWe4pX1VQsSlrWlHe6si";
  b += "Wlq0F5c0FNaWbJtY2NBUVN2U3rZgeCRWULFu/eW5r49ymnIlLKxvnzm0oWlIdmdqyuGFWUXaup2";
  b += "LB1uys2qVFq3Lr1xqrW1dsmL81Ur5ubt3EnGULytYvq61bvmn1pmmLW8vrF2YWLl7XsHzZgoqSm";
  b += "gVZc7csq6iqzQ551lYtnL+huHmuITq0UbxkYtGCTZvmQY9ckbXMWL4gU+g5jEAF3JHK5lUuX5uX";
  b += "t3J+OC+8YnlmRaEnPH/d6s0rsvNWLmpdU54fXr16q7EMeuiCFaI7VeTm560y5gGhonkNSGDBpuX";
  b += "/r70vj2/rKhO9V7tlJ3baNHtSpasTxbb2xVlarZYsWbss202baLnaLOnK0tVilYKTtMPW0rLzYG";
  b += "BaXqGFQlmGZaZ0aMvQFmagLQylDNOhhQdD3xsGwkzZhiXznXvOla/ddIFJ894fz/md3Pude9bvn";
  b += "POd73zLUW/G7ekELQ6OdbWm1IFUUZfzOXvhkg2QHOsBOdMtlMzFTCramjfYuaBxobyQarZzZU+b";
  b += "EJn2vHG6KRBd9ctR3ZcjuuoXo7oOE9D+qMtS1S2665Ze2xQu5wvL2l6FYYrNroWt6NhsYZapqD0";
  b += "JNlPvaj0tV3Np1huLBPTlBX2zPlFZztm1unxU17BYatbFdCG2aHKljfaCxZKaSkzPMNO5pflGqa";
  b += "OOJ8pltyswG4kzzdTcfGTWsewuViPmmqGtdc6X6gupYr29VE+XwlrPVMDsd0a0ZqstyqQmmnF2s";
  b += "RFQ53zpoKM7ZQgWF7ple9prNeaXXNawY3rBnI6wtY4p5jHY7d7ZdKOoT3QNTMLYiRcW3YUW50o4";
  b += "9fNL6l7C7G512g5Gm2UNLv+sHwYpXZ1vxb3lSEjndBXYcsU6q80k2JY1N9Nc8rcmEqmJRsQ1Z5/";
  b += "wJLN1dWAqsBSJGiPakL2hL5Y93nl9veIs2I2c2RgOsyb7VMivndX32nORoN/S9Xtnm0VtlWMNMa";
  b += "7gmZtg1PXqTCARClnqzZQNKIk1qy8mUlzIMpOJtaK6dhUoz4SBCzi9hqIt4cvYTeF22+djve56x";
  b += "uUJVpbUvpp/vthd1s0H5qZgU9SHyvlksNtoVLuzsC9la2aPbSqXq7ZDaQsQPVszO50ueEp6Y7U4";
  b += "1TJNLxXVxmjS2MzbSsl4sqGzd6Pujo8LR5Oz/qWuqZp2LkScXHwmr11KurnyXDy+ZKvkU9mcLRN";
  b += "s2Ku5ZrKmnl6Y1mm5VmQmUHXW4j6bRVepBBa1s/XZaLOwlOm5/e1wsO22pPTJ6pLBnGG7rvlpba";
  b += "LlZNOmptbnU7tmS452IWFfhLOBc0mf05baZUtzcdHXbfWy3cyivtu2LEx1Gxwz3Z31WQOVOet8L";
  b += "LdgYRyxQCfImNQO7wJsX2zAFT18WM0zLZ6Q+4WMzMsxOaUEMDnukpjJcf5/JufFmJzCcsjt76xj";
  b += "ckjk/9NMDvAVqT+JyaklDblGI5TIZ4qhqL9SyWtThmVtLOzKxHv+nD4dWMhzakPC3isvRMO98lQ";
  b += "2W9FbS/qqP5CqWEOJrFM3Oz/HGae7C/FeeKHcLAdDsw5PyDAzVbYnSkwuqI0yHXVgYU43XY16Wv";
  b += "PlqjYVWGwGuW4hF6zbPVbPQqgTci/N6hu6pVjEzDlt4dTicjTjzwWZlint6lnLE3F1Re9ddML5o";
  b += "G1vZrxTPc6a7dTKvZK9aq2xS81FbSs266wbtf6a0RyN5LJl23y+4qnWfM5Qu5V0TxfVQdf0TMoW";
  b += "CJcjFq02Usw0jSVXiZvOOkIeLmVaSoS8bCBldPkqmWzcVU7M2ALNUCbZNTpszKLZMxtUw87l09c";
  b += "5u8eYyNdjlrnlfDRQm7csVsxpjz/SyaWMjHc+veTyRhp+1l6PJiypljseMU0DYcgs1Bh1IODPLJ";
  b += "R7c4vTnDEUnTIaPK3FeX/VmbHHXYtVuzYfNwcXvAU7W+61MjNzRm1o0cnG5/zWcKRd88101eVW3";
  b += "V7tmJuMBSiZdWqp7nIYEqHlOluptqLarCPdnbVOL/k8tlzFXk/ltfPGdCOjtZdKXlfHy5kqakdl";
  b += "umN261yJWMKlnzfPp7xup6vhmGhP1aqJ2tKUzaUtl5OOuDVbLsdsS6ZwpLjsrk7HIrW0a2Jhyqx";
  b += "uRXQBXc8yxYYnjC2mZu8sNYuulo8pBBP1MOPzTMcCjai3YYrM+juzYadOy2TCZm+BXQ53TMbasl";
  b += "ftNicDTnfX4zQ5A+yEruUoBXzBWLtdCGbCsUzSFnDE/E29h13ylKteW5JrVKOpWUMxWe70ljptn";
  b += "1fNlGyNSHeGMDlhJ9tzOVm3I8fzKVGTx1uIJsO2hdaUq+GeSOhLC55SxmTN+YLBhK09UeiofR2e";
  b += "Iyo7nYWOl3Uki+lOWpeMAN/ZndXPJHPRZKmhnysG9N4ZvNRjugTmngodJ5A29QQipG5HGNdow5y";
  b += "RA1oUjXbCOEPe6Z7pzCQcbdZlKARM8/W0L6bL+mYswWV7Q73gC9WBDlSDVS+34DKXMwZdOwekK7";
  b += "1sN8zE7UC+usVMyQ7LvdOJFeanA+yCv9jOhmAFA3mtFtTuHlrblUJxseBciM54gKx7HQFPdsbJr";
  b += "iXr7rOl87vVsO47bAc12eMuFKA7/gKTjMazjryx4p5fKqSS+lmu4s5U/SFb3JBzmRer0V5zYcLH";
  b += "OcrRWtCjjvj15aKxMJ0JdoOWQt4YsJW7Wa4XTtUW57OZXH4mHG4YbIGE0exPO2IGXYNZDMS8dS7";
  b += "hKzJat7ehNjq8vYWg223NpgIG+8RUPVLiItPugKvttzpMyYLO0li0Tut6Tkaf700sMaaSYcKrNz";
  b += "Ta+Y5rar6YVce6kWVr1GtcsuVjlinXdM6pT0bN8UrHVfZ23aYW00vGepy/4neUZxY5q9vbDsSKW";
  b += "kMvoDXXK7NTU2pvs+ye5mZ6hlbOvqyrt8MeU9mY85n9KXt5qpuOT8W5pVAjnanV6l6D0eJJNPQT";
  b += "aZMxY/N6A0FzNKSucrbZhr1bm4vVe7UlV6y9VG5oF2cbGUuukm8lKpXSHBNNzFScbCzlnQ7HgjZ";
  b += "H1jndnVowBQzVOSCqwLMnzYkgUzQH5oL2UMqanlhyhP3JpsFbCheXGlzPUZyOFez+si26GLVHFr";
  b += "XZwFSvY/FUjAnjIiDRU7D0FrvV9kwrnVkIN3OBfGwxlS/6DAuBbKLizld9ep+ut6SLGjJTxlY7P";
  b += "ZsruThg5oKV1LLTaJtWxw35UDM2EVm2cOZMwzPt8obavbR7cdkSYFymElubyM4WkumStdeLGzNT";
  b += "0VQv4A4kjeb4UihpSC1G1H5b17Wg06U4fykQ8NbmUslot10JVKuFBad/PsLo9D23LmRLc95uNVW";
  b += "K1/LTFYtd57Q3puuhGDpypMtdV8oYZ0qdpqWhX6hqOVdrNjNTCnH1uD1RLIfmTK02Y+aKy3mPwV";
  b += "1guzFve17varJe88xLMEXEMkqwFDi8Dj5C4j6mG6GugufVEBwQnEh+hKwmiZkTljthVW+LA3aSq";
  b += "H1bNk2nWKowmhyDNaSaDMtWssV0Y00eLl3Q5NmGhqm1qms+OEtYy41EW8g8gyjSNbytxOSke1VQ";
  b += "1picFInNjqVry7xUE4nQKqVqieMNqnkr6gaTzhaZftHZdE3D1irLgkK9ySwBwc4ik8paDhluEUv";
  b += "MYrrNaNKaxRrb4WV5fNHpIjJ4YfMaZIRdYrHhxKSG+oUeW10hGd1zOmJDbBihJMhaRCOYVWh0yC";
  b += "BGfwD63oK6qNW0uyDtdhEsJBHgiAHbNovxg0V/BEF8518BkjRVhiuyuaIByyuRVWGcrTJTImsS3";
  b += "7nROPJiaSuRqKebNf1Ek+GOsXleqP4E1H8dMgsgGjIxjEwYHIKawJ9jasgAgWmwpRxF+Yl1EtJv";
  b += "TSPb73QjDT1iUJkBUR+C50s/gvRgxrX6CTE8LrYQoSnHl597kBr8+lC62UR2FWyNeJhMaqqweA4";
  b += "dhiGs5McrTG1036uuxyyYsBj+IaJ2EeBHicGPAH+FqD0E+Ovr0n+PdFuA/xcxiZ8hpAUNR2gdHC";
  b += "Zxo+YRKgLPKDGujkNIQIBJy9tfAYZG9yECkUM2WsgIJXdQ02oygk2TQHbq6RxPbJqw0KuA+5uh3";
  b += "C18ObwZB0I0v1I/BvFoQbVhSfBGLf0vFPVl+IYM4KtMs5nmDVBZTYWtFZ4leUq1eovrq1CAugBN";
  b += "+TV8Q0ZWtXoD6EGz//XIYY1hswV/Q+XkmY6GJAHaUSi1gSwR3QvHEmNwZMtT4+1vFpllpESG/Ga";
  b += "RRQ2fnxgA1+HbhaJvVTbXqrSa1M0QPyyKB8IDC7zG3WkR+oDjsyyTh/6X4BN1PymLlIH7DdMNTe";
  b += "HvwDekhiNKCaE4Pk2zmq5U4NvzFky6zpZGKGebFadB40Lx7YAlW0tXBNy74TtSBVXSGabSxzxFH";
  b += "SXx68cZ4w5wa8Xj7MffI/hznJ8F7v7Yz4pGewaPboJlg1CDH41piOV8/GiG8BDBtzjqGzy9TCfC";
  b += "xwkVIIC8z2B8EchDuk1A1yqCSTpUI8JGhEeTkFyo6wWxOO1itqlPicjaHNoKIBIZyInj53kcYJw";
  b += "GEQ77/RPwEmRqKG/AFb9Ur3HEQ+N6Ye+634bnKfmG7Z4KjXS9iEYTjw9KQ62mIV5j+KsDSPs1or";
  b += "YcRawCXwhu6TXr2kl81KhXQAOzxVZtEW+8wsqqsbUx2NdYilq0YzXaC8vhKSMqCQo5B8phND5tJ";
  b += "jumH9fr11ln3gttQP19XoHdhM7XlrNrEm8xX+RNCRy3/wJ2lQeUSPtXrfOW4blSu5RDKkcNRlY/";
  b += "x0PEmUkw7aRE3+wSzOgJ8KQEm2AK8EEJNgMX4B+v+/6/JVhhL8BdJTZ0EODXKLHhggCfAnirCB5";
  b += "WYaX/2sbvpYoHMVUT0hUGXnVsi3ZLoCmA9NugDRWyE+44b3U3iw2oe+gQrhvhBpnOC/AFxJDEWS";
  b += "okoRjkeMAbKgir7bo/0kXqmMit5Pi5Max40bVz+hBeObM0ZpKy6Xo6W+KWNSwQl3yF7SBza5LGQ";
  b += "2P3DQH+Bxk2HHjhyq8xnWNQEtp/Ye0L6T8gwxzJn2rCjMxBsAUzsqKYKAGd5Zfhg4dHeC7mcTk2";
  b += "A3up9fcKqB3leO53sI5v2/Qqzq0qW+OWUeOLR0aoLJlTyGRNgPcSFwA0rw4dwVT/J0eww+X6p5D";
  b += "HsK6MAHElEOAgcYgUYISz/SLYQdwNxLBbBCOatFUEu9al964r/yRZpwL88XX5P0PcbwT4QeISKM";
  b += "B3k3V2ljEbR4vsGt21mis0es3hwxq9uE75Kxvn87JJTF2NaWVUda5MSF8Jvaqms1D3/Vdj+rST4";
  b += "Blqa6wubME1pAr0qFSvEL4MzTsh36WExgqwm5QlwK8nJxQBfg+hhQL8P9bB/0BcIgT4qXXwdwh8";
  b += "vmg68lF51oHrRv3c/srmDXKhKdXwmQWJKppsq5GFUz8iSk0srsiVkDkY4r4xh9ykXucc4ffojGh";
  b += "fyJ7nvfNrzrV75x/jhH5emgnUGtHEpgu3cy+54OGl6LmQFs0buwh2EFcSAY6T07EAI7fAPSL4el";
  b += "KGAJ8g80GAT66Dr6DOJ++D5+rN7rVz9XzyPirPWt7nPNXdQjyKC7u7IdPrRjoLxw9skZeGc0g2j";
  b += "aQQGSSa4M+4DSQzhMk7ftqD19uNpN3aF90X0seKpfFS8xiaYsuj+0R5fCSPAAfWwXGy3wlwgsC5";
  b += "dWvcRXiqMKG8DuSKBfxeJb3MtjiK3x+E9MjF75ZvTxrf+S8XXnjTXPjzM//+o7s03/zK4Gs//ec";
  b += "2ynHbWx6iBnXNfQ9/rbz9Jz/p3fVJ36c37Jh7Zsz6/ImZ7KMv5l9COU6jfGfz4bn9VlSgEEGRBH";
  b += "94GYcVyrFyG+R78sD5dO+hfNi9501kFv6xWCiIsIyuaFj1yJrkffk01xNKPqlBklh+JjwFdaIRf";
  b += "9qHOS1EETU3rJqzCmJnuR+LmNEZvPwSZ3DxN2TyHkE+cB7SS3Ig58/2trWygYRfJBuwrZMNIBNV";
  b += "4uxcwTeOkGT9haRZFc+uJhIZuArdoO73Y9kb6kd1XT8CzPJMv4J+eatRfHGQSJyvdnYR8pr2lJr";
  b += "IJ3ZNd6npaeytFo8E/C/b21YN6QZqE2J3v9Wuh/3uSc1NUN6l4raIOkDqhx7jXeHF+hwu5ZK4Jl";
  b += "4CvibtEjI5Jo6SMuIk+qqI7tM1dGoQxHCO0DxwdoERXraDvMFsr0K9yKWXHLSodwSwk0uPyJZfn";
  b += "bom6kwV10cFscn/QeJYK8ApwnkKcImcZAR4kezQAlylzpWrxku395Okvr8gztwC/HGyYwvw3xLu";
  b += "5lWZI0ioCzvhBDmBXD0zwu9I4zTmHPY5w+GgxxHyhxKeKU/M6U9o4omYPzQVdiU8wnsoGQyGndM";
  b += "eV0Ljd3tCSHfpicU8jqAnlJzxxBwJjzuZ8NrivBoy7okmPSGXJ+5JhFpV5HOA4yPwH4d0dhhMMB";
  b += "VYcV0MzAIbx/Yhv8OMX5IJV6JUZabwtSylHpND4GypWeoX45yJ4BdHJBJEGlV/OKS55loNUkfdE";
  b += "MJ0403wRB6Yn5nBdBsJlEtcqc2ge0F4/3cmd3cIXzX0KXiiCypcYUDIXGIsHvG4kKpWA4vqayFM";
  b += "D9eXF4n5ZwEHKAn1a1LO+jSJdGFU153U7AqP8FzsJWG8R/S/N0rY6wAYrFJtEb2lBSZGkMIcgjy";
  b += "XnROn70a6cwy6D/OhGMZXQN1LYw4W1YH+HLVl5G9NIYmPlEglu0hHw8ukKGpZRO96vC4AxggZPD";
  b += "XDnRqTE1QBa9Jdvw5GLl6mCK5Pk+aQdzLvU8FLOSJ47IC4MxP83VpY6J2IYKkjW0fKmVXOrRLBu";
  b += "pQ8UnMj/pDX1AI3FsG6CryjoBoETRIwiUhty1+5BLt8Xxt8QANcZStd0VB/HsHXez0SwWPqnwj3";
  b += "96RnI3ieoCWZR9d+9d12cqUmQnSHyT0PaXbxabJsowGlC0mQkh3RoOgITxdw2/BtIukaWytl+Tu";
  b += "IsCY8R3zJkctZFM+dI/BEp5n+noe2NTSvoxhnZ9sC+Y0Pvr0hinU+sDo1YS+6vYRLl2pNOP7jQz";
  b += "8a24+tTcM2gKwg2QBRO1BPkHYT0tKXIZyO4jE4K65X1UeUKjbCn74inpk+PnUxjE8YVp4HgIEFB";
  b += "qHEX/PnjmF9F6avZ9eyN5C9QBP1tD8zqOOQb2IVH+gCAaSTY94TW6t3Q/H4SgmgyTG8xldvXdCs";
  b += "dgcSIiR+DdIg2imaMtTpGJ4jv4nhdV2A9g3FR/h5frbxWFeoDq2tbZCed61rwJTmb31BnA0sDKb";
  b += "GWzeIMDqJTTmgIOyFdIA8AQ9VGM8Sj2cflIcupGjFsZnCDXHc79V5s9oKfD8Inph3Q7o9wqUWiy";
  b += "W0jKhT5IIN1J8b0TixzRJC8inRer4JjRVMIUSkvfyq9MJ/IZbzorXo7y82AW/HYDmcWkcf8NpDX";
  b += "3Cdwrc/Q+uPXRu3wuvXhPUX5NcW/p8nXWvSvh7z6/31Bfzbi/Jyp9bxcnGGcwvLA97DZD0IBzj0";
  b += "xAs7wlTFed+A5nh/Prv56Rzj5zDsBjMweqRWgEL89COKQYCT/eknPKGsN4po8Zv6uOJT8+WgGSC";
  b += "u/838voLnEoxLmkyZ/hRJcnmbOD1ypeSvLhLsT9Dpc90Y3LIOp+eaZ+k0kCAfy/QRF/V8coTXgJ";
  b += "wi7sBBsrGI2/EWCLeeD347U+KO9e9LEajHKst08+wIL9GL01jSKTJ175t+IZrnTDcZi2n1nHVZC";
  b += "tMc9A0ZZcG4Mg2NcNzF6fq0El1mBZ/S9WargiwvNMA2cehrkZ9ZTdH+gwRjMa/LarLYUALkGanB";
  b += "unzSdhRLtiRRTB3obBXZVvU3B6GrPD0aBW6QJzb71rQJco2ttgvR7wxa9cB3rE3GNrkXSSciuWu";
  b += "bK2zOCBmXXEJRV82N8Pw8M4d5J4xPinqbaE68HfFwAi6FM7VHhLcEoM3Ho8zdRxivpMczLEKQAE";
  b += "+PuLVOoVPQj7N+WF25CegAX6IQIW7fO86Nazvf8yw3ph+3kBsIRFIS3Tx2NxYk9QJ8lJw3BPg6I";
  b += "kMR4O8RF28BfpacXwT4G8J5inIsPHgG6FDvPvhfZ5dTtPYq/mIFZKBIb1dQtPGzZ+jDPz9DH5G+";
  b += "Elm6aMH893EDx7CxRj6LZj+/jjF6CnDSr6bxATa4gNfr7edMinmW8cBEl6/wwQVMy35EY1olhl0";
  b += "i+P/Q+PwqwD8g5ncC/BCNNTgC/Bi51lQMXyqCv0UuihPDVhH8T2S8BbhDpOVieEIEv4FoF9+5bq";
  b += "95tfFHHcX1e2l8fhbDV5yH9bRydPWqh4GX0kT0twZM6DGJXRcplCtYKq0FhW2OwlwdulYUcbyI0";
  b += "+0TSWSBQyWuxWeB8yl7fc21WPY6LGg9zrEG/9fXYg3+b5WILjmevf8havBf1S+l93kXfzpAN6cB";
  b += "ikrNc3UjHvXuV/lKvB9et/ZKvD/hRshXJDnoHjv3koM7j62VHJBrL3lJOXUcnzhUx/EO/SGRMfu";
  b += "HIdxFrsF7JW03HT/3bT9+fG3b7xZRso8QWLC5+eg5u4KWG4PzBW/8a8Y8ZSNLri56+jiWBFoJpR";
  b += "XgQwSG0/uqhFv0vXrOdH9nax+2CXpNGtvr3E3GLJwpA/1ZFd+jAX8ujU/ov0nj8f7acSzVQTZEm";
  b += "zM47u51HLujkSXEDvAAQIJlnaUCoo56g80NVIjzEEqHzzkepJHDdBGOlJ4a2yoUIVuzf8JhBTNP";
  b += "H9Pts35Z6h5RvR8jEht02hbHI4lsOEeoLikFixVx1H+fwnGNiTqiYI0aGvGnM3jd/6Uc41QM7xX";
  b += "Bd62DrbJzdikSvwsdq5QKRf5apjVDTjl++SjQ3MgR6gh1lclssdrskwcPHRaUgrREKpMrlKoB9e";
  b += "DQho3DI5suuHDzRVu2buP35KuoHTt37d5zsWbvJZdedvkVV47u2689MDY+odMbjJTj778K5T68d";
  b += "wMydqxk8fbdI4YhAnz9Ovg16+AbCPzH3M38aREB+ktibPRZNAn5LQLf3jnC4EmLJja3vCpEfIFI";
  b += "CtZKjcmS61zyrea6mCbD/5SCplXjfVyQyLvGcB22sSiOEmVJZ3iZELlNuIbnfA7O6U109EKW9QL";
  b += "E72ptmO/iQnPo6N+A/QJOV6U6Q5qfrqCtZhnYBZgVzVVxaYe/uZi/p4gvDTZTJJpkG8ulphjqv/";
  b += "CV8upwVOAY76SDpKzN5SZsyPz952RHBdpUalVF3yosW9fw5z5cGqofuwGNMuOFcU1zuVpBZB+l2";
  b += "9fk0kh0SzrFy3GL6VquwgiMEzb17ysLxYdSJCDOadgWx4sPeK6gxvbb1YSNBEaFWUQTo1VDb7zv";
  b += "EKpD1NqlFgvHW6abZZgck+Mb0LeWB+xju55Mq7nMdGFb5vpF8HE5wA3CabbBNptjOaaNbnbiOwf";
  b += "9bzA11GYorIqcfVB0X3yASkBfoRb+miP42uT60tLVceON8xutOodUnH05oujMTISEqDxABHqtMl";
  b += "UYPxaYxgY+gLdqSISFlJ49lAFFhZuIvaY+JyKGn0cqMxiyvxLdr/rXqy4Ya9bSfUgtCmmF+28/J";
  b += "9o4v4DE+qNskxz+9wnr6zNFLOp9oIg3BtxMDb9P475C24k4U/ipl+8Uscj534pYxL2eseIzI6Pc";
  b += "Er6gNUM2dsIJVoF5zS/z7DN/+7sG3f4u2I3wMYuIp8LsmamEjUXW19FPB/XUS1i0/3rCAgtwQoI";
  b += "NicQ4un8dXv5mHYzMxR8gBo8jJA4ZhH+JqAYFBvTL/A1W/aF3wZbEVolMXjx+D/OiTix0XS9+dP";
  b += "WpTgxTLnEEEC4fEK7kKpEK4dUoillN78BUC2pyCUTLAWTKX4O9Cb3AB4dAqkg5bqBUTp5SRYBQO";
  b += "TCF8vAEKoXIkhOtIJTPLRAff3P1vf+Ctn9Ej5AsNQzkyNtfw6tvQSApcURRSNXoi48nJ2R7551M";
  b += "yDsSjiKhdS7c4lKIgiwAASHnBG+rUoEK44RorNYQReTCQ6gFihb8Q2KEVjiBLHj6pAKlQDFuQih";
  b += "ciFAwTTdPKZAfygyQhiCiDKRRXkIYHIQwBAFNfQeSPi1YFTd52Dw0P5yf4ZdTGK36pHi9r5KSZo";
  b += "vf9fKtCj/fNpH9dISECwks/ILKRWQuD5L3i8jRbyNJewW5G3o7MegdEv06ywiJ207SbyBMpIqIp";
  b += "DaSNFtIuYPkfQN55w2GgW50IbwRwvsg3APhCxAeg/AshH+D8FsII3lYgxCuhHAIQhTCcQg1CCcg";
  b += "3AXhGQi/hjBcGKF2QrgMwjiEIxCSEGoQXgPhjRDeD+FDEB6E8BiE70F4HsIA0KDNEPZDsEJwFvF";
  b += "hR8DlMAkXEFjAxwjpk5r0T3gOicZgI+m/gG8VyTtIgoDfIZJeJfqVm2GCLyGtgEM5eT9QBroGwQ";
  b += "0hCSEHoQnhJgjvgvBBCPdA+AKERyA8AeGfIfwYwvMQqEVg8iFcCkEPYQpCHMJ1EPIQWAg9CDdB+";
  b += "HMId0P4DIRHIDwG4WkIz0H4FQR1ZYSSQZkXwfMSCGMQDBCQy5cGb60v8D34YQ3T2Ik/6Qe9oGBg";
  b += "kjo1fPWhQTgQTsDWgAwa2RHeYG+OeLI+IqLfjxJ3y6+K9oSzHSrP5ixxO4sPRjeyuO1bJcTwEKn";
  b += "aqnAg4LcdOMFwL3sRPPV36+5+f2Fb8lVk4jFSJ3ugBDsM/BF8smZUrzl0SLOPstXxXp2t419zKt";
  b += "fxXv2Cgw1USVA4jg57f1HH6k/E7eODQzqTzTF5Jwtd6PBcAn6daXE8JLCpGT4WSYWpJ+tYHSJ8q";
  b += "vIEdE0S6nQdq2CFdk5es/q+awm3VXjifRthktNMqrH4U8Djk1iNWynBwGFGAObAkuDeiBzWCC/F";
  b += "KymakzwLAXQZabSB78MSOZwQYqAuyItwftsS7sPhw3sP8z8xxDRX5d/Hge3kNJoGOnsJv2an1mh";
  b += "Q7KRGjeOhkw8sYXXt40v4gvh/WcIq5rUZUQ6SFfERJI+qgZ/bGjiPkBclEvDkbuCx+rZorj9FDO";
  b += "//EdWD/q7XHID/1AfUN2huGB2FJ04v8BrfhXCtrnvWaVFrYTuo9zWwS2CJ0C8dLEidQWfUmXRmn";
  b += "UVn1dl0dr1Or9cb9Ea9SW/WW/RWvU1vN+gMeoPBYDSYDGaDxWA12Ax2o86oNxqMRqPJaDZajFaj";
  b += "zWg36Ux6k8FkNJlMZpPFZDXZTHazzqw3G8xGs8lsNlvMVrPNbLfoLHqLwWK0mCxmi8Vitdgsdqv";
  b += "OqrcarEaryWq2WqxWq81qt+lsepvBZrSZbGabxWa12Wx2OzTRDtXboWg7ZINjv/3GOu6XYQAL7w";
  b += "RYO4DF7Y00+sUcONY0ODJFhMmEvyBlOy/5RFFEDffJJp43X4LnahmItcclPN/E4yp8x/nxN76mJ";
  b += "prl/MyETDxAbeawO+5+DvPOYg8Fod7Rfet+Eksj9mtYm9THYV78Wg7fYCrQhv5tE1x+zNa/wEHM";
  b += "zCN+G7f1dg6v3/s43N9VSxySnbcD6pchyklRT3PYLIf+v/xHOb75rw9Rg0bJS/5J1/3J0B/luO0";
  b += "nkPWWrS8nKBppY/G+U054NBE8KoLNCsw/CXB2HZwj8DXj4+PXZmDnrCHNG5pXo+hln6ZTZPA4ow";
  b += "3p+PGb2pgGvr2NTVje3cbz7q42Hmt+eMikJjeFpHnddV+be1CD9jQkwGgiWb1mFM+BfWg+HKe+0";
  b += "sZnwH9oY1Xub9qYh6I72MRJqAeVsIYC4+z9/LoOnttC+rPiE+9P1PEOXp9SGpuyvCBtC8g/HIYn";
  b += "6oKlIhbO3tzBZjk7yO9VCbCaOBJQCpqW0jKJXKmUqFQDErV8ULJRNkJvklwgv3DTZvoiyVbJ9g2";
  b += "75LtVF9OX0WXZouQT0k9J7pc8LvmG5FtDTw58W/KU5Lv0s/LvS34se07yU81p2a8l/yn9LT105c";
  b += "EjofCtH/jAX1z/5re/64Ofvu/PPqVQDlgOH5n9jye+Idu8zWKdTb3uo/d+4m/Mz17w+je+5QOyD";
  b += "Rs3XbBPb5r0eP3ToXCOOfq5z+/cpVSpBzdvtdgn7/7Id/5xwHrbW+9Wqg8eyZdufdsm9tgDP/3Z";
  b += "Qub5352JJ977vvGJK0eT77/9jv955113f/y++7+sGBy6aPfkVZ7oh+/62tdvV27fccnlR6768U9";
  b += "+dubhR2SaSy+/YtRom/RNByPx5OzcwtHrjmeZ/GKze8Pr3nTnRz/xyQefuPcTNfaLb7/ukuvlUt";
  b += "mYNC+lJ8ZXTu6W6od3yS4b2CPXyt2yjftXPqq4THaZbFRlGgy5TlgHtqhV2w567NKsakC3Rb5Xu";
  b += "lNOX22TBeQTMrVyQHm15krZ0IBFOinfoZQNKSN+q3GDUTmuUp+4IhbQqvZv2XHFrs1bB0JQgXvD";
  b += "dqVa4VNdOdAadB7ZrzgoVyuiClo+IpWvvDmzx6dSr3z4uks8g2rFhgsnFWrLAdnWlb8+lIsP+Qb";
  b += "UXs9Onyq+wa9Ur/zSq94tnfJbpRtVaoVdqT5h2a48KN01Sw8bNpx6X741uPLlNwWzG27UjWy59a";
  b += "Mnp+7465N25X7ZUcUVaq96VH7hyU9ewwRkduWmq9GUePevVTd+e//AB398wjhM71ZslKlO3PxG2";
  b += "aJ8g3RAOfK241MD3KGVX6qbqvpF3t7moc1DqYHtK68/MSW9yTl80Y2RixWKlSe18iN76fqYdIdM";
  b += "cuLqizdNyukTT+w/+S8rv9oXlKllklOb3MHDK186pKBlSflOk+TExgOy3NCseuVe2+4NB2QDSsl";
  b += "Gxcp7T31Htkm6QdqRHVMMyejhIZkNOjequiR0IjG0G9piUW2EpAPKlb+/XH2jgqKlcrlCIVEqVM";
  b += "qBTepdg9uHdmwY2Tg0LBuRXnDBhQNb6K2ybfR26Q7lTnqX5OItGqlWOjY4TuukeomBvkvyEclHZ";
  b += "feo/lPyW/nvJX+Qnhn4eHf5zbd8UJeae/PNt+36543DgeBvfzc+cdXRa4/94MZb3vLWt33kU/d9";
  b += "4eFHvvp33/vhj85QMn5CWycPHvZPX3vjW+DjZ+77wiN/99jjP/wR1Z/uB9F8vy7H3PjW973/q48";
  b += "9vmHTPojyp645et2xHHPLWz8CWR7+6jM//NHpDZs8/hyzcuOn7//iA08+dfrnp256850f/uIDDz";
  b += "/6+Hf/yfeev/n6I4897g+FU/PXHXvjW2791Oc+/8BDjzz61KYtW685+stf/eHMSnXpe89svLjG7";
  b += "tp97IbX3vuJ133h/i1b91zsnQqF0fx/7es++/C3nnz69M9/0WjeyrXedcX4xF2f+PwDjz7+1DPv";
  b += "vfrd79HdevE3v/XYmVB44Rqlanjkyomf/qzGWg9f5fTc9tZ4ofWVrz7xje/844//cIbSHLvk5DO";
  b += "yk27VTpli04mPbVy5R37xwImd0u0qWjYhM8mUUlqpUG5SR4YvUCaVUtku9YBUJVVK0UYzJJNLBx";
  b += "X0xovkIeVOZUopUWwdishc0jEgT5sUw0OTst2XH9NUZeXLV74iP/lJ6Q7Fyd9L55VbBrYNoAlXV";
  b += "qgVOxTzSq3cqz4gg7kh1Q8ekO1QDEpXPgafJvQz0pU7VYekw9JDSptKKz95ZtM21cSmMene4b3D";
  b += "KzfLTr57++BFb3iHfEJ+EGbatoGVL17CDa18e8eQfOWMfOWZoX9/v9Q6cOLo5pW/Uq38vVy97aB";
  b += "UrbCpvKohBTe4R7ogmx9YObVtl3rLQFC28ibFPXcObZXp75Cd+O4VyiG5fOXDIyd+oaQ1+xXw9R";
  b += "bZyhelO6XDG16UhpMn/3vG6Dcpbxjh98sIOd8J8NF1Z6l+OQw6zuEN4D03YF7FRM7TR1vX9+Myx";
  b += "NRCsJgT88bfFEwokZ0d/8LzR8da9WMci3+KkjdzFOdBphjIxu+UTEO9VX6cuvbC26kLtmouHtIc";
  b += "v/hnB27X7tdpDrAffvaA5O7jY3t+e3yc+oPG8oEzxy2/p79vodV7rZdt+L71no1p+8S2O+y6XWn";
  b += "ff+y5I3i1KR05Xb4jGmb3xt5//x0x6vF0nPnGHXHqu3sT1LPfT977g3TqJz/cO//Ec3fMa6ifzp";
  b += "+mX7dA1eHYNwZMjgT+0b5B3UUjNAPzSSKhZZfSe3ZeMzg5MEBvk9EDsPXJtdJDqv3baI0VMshUM";
  b += "G+UasluehJll6kgiVqyg5ZI7LBHyhBDRO+RSOlBBMshAb1ZsgV20ElUF6RWStWSPfRByDsEOUeh";
  b += "eChVKocZrJQM8qWiJkGlEgTvktglq7Xspn20jIbCaRUdpSXKIVWGlgwMKv2SnTzHZt1IQ43yQfq";
  b += "yATovoxXQKMl2iUw6ItsArwp6mAbcS3dL9sC/qyW0UkVLBgdoWD10S3IJ3ZbKJAO0QvpPgARorR";
  b += "KVKFEp1BJad7FepgNYTo8ODEk00ElaaqP5hkgnVRLJe6T0BlqJKpRKHrmaov92LyW9hT6uoRQlC";
  b += "SWj1RpJREIhHoLeLpHT75bsuGADfYVq++C4VEcjlF1JuxSIlxyCfk3QRihVIpFDv/dLVPRPEdpo";
  b += "YH5GRtBxjv4B/U45sDgSuWxUKqM/BOVTkojUO6iXXU9bhvdBP9VSPZSppA9LL5PTqiP0kMQ0AJs";
  b += "HfUyKUAlIod9PS1UX8Zil6S30RqVU/rcq1JmtCKsKNFBoEP4V2qaA505JUoViyjSfnWakMKhyao";
  b += "CW/ALGBGYEfRvUJ6M16lEFP1IKiXQcEE4pASF0bAs0BUrpKaSoVMCiD1VFUzC6JrkcvdGKYQpIC";
  b += "kVfJYtCPDUu2QrMv1QmV6kkyj2yd0gpq8ygojfSW+T0MJS6iS9RnqNvhzyHZYABZVVJHV85TQV5";
  b += "H0tkOAMrsbBu7T1NOT5z6kvUILTsFD1Qb7C5VpZpNCWqChzCWukCQ8tirSZHDcEnJD9lcmOZZam";
  b += "cVw1frh+3msd1YzV0NK8sa0b7qmINHGONY3rdmMG0T9FJVyC5Qjeut4/rhsQ/MniBbtwwbrNpRn";
  b += "UZc17HMFnDPurAMIfkydyxPIN/RVWiHcbCEGasUGEz6UpTq0Luh2NMl/svFr4sXA==";
  var input = pako3.inflate(base64ToUint8Array4(b));
  return __wbg_init2(input);
}

// packages/nacl/src/index.ts
init_shim();

// packages/nacl/src/lib/nacl.ts
init_shim();
var u64 = function(h, l2) {
  this.hi = h | 0 >>> 0;
  this.lo = l2 | 0 >>> 0;
};
var gf = function(init3) {
  var i2, r3 = new Float64Array(16);
  if (init3)
    for (i2 = 0; i2 < init3.length; i2++)
      r3[i2] = init3[i2];
  return r3;
};
var randombytes = function() {
  throw new Error("no PRNG");
};
var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32);
_9[0] = 9;
var gf0 = gf();
var gf1 = gf([1]);
var _121665 = gf([56129, 1]);
var D = gf([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]);
var D2 = gf([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]);
var X = gf([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]);
var Y = gf([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]);
var I = gf([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function L32(x, c) {
  return x << c | x >>> 32 - c;
}
function ld32(x, i2) {
  var u = x[i2 + 3] & 255;
  u = u << 8 | x[i2 + 2] & 255;
  u = u << 8 | x[i2 + 1] & 255;
  return u << 8 | x[i2 + 0] & 255;
}
function dl64(x, i2) {
  var h = x[i2] << 24 | x[i2 + 1] << 16 | x[i2 + 2] << 8 | x[i2 + 3];
  var l2 = x[i2 + 4] << 24 | x[i2 + 5] << 16 | x[i2 + 6] << 8 | x[i2 + 7];
  return new u64(h, l2);
}
function st32(x, j, u) {
  var i2;
  for (i2 = 0; i2 < 4; i2++) {
    x[j + i2] = u & 255;
    u >>>= 8;
  }
}
function ts64(x, i2, u) {
  x[i2] = u.hi >> 24 & 255;
  x[i2 + 1] = u.hi >> 16 & 255;
  x[i2 + 2] = u.hi >> 8 & 255;
  x[i2 + 3] = u.hi & 255;
  x[i2 + 4] = u.lo >> 24 & 255;
  x[i2 + 5] = u.lo >> 16 & 255;
  x[i2 + 6] = u.lo >> 8 & 255;
  x[i2 + 7] = u.lo & 255;
}
function vn(x, xi, y, yi, n2) {
  var i2, d = 0;
  for (i2 = 0; i2 < n2; i2++)
    d |= x[xi + i2] ^ y[yi + i2];
  return (1 & d - 1 >>> 8) - 1;
}
function crypto_verify_16(x, xi, y, yi) {
  return vn(x, xi, y, yi, 16);
}
function crypto_verify_32(x, xi, y, yi) {
  return vn(x, xi, y, yi, 32);
}
function core(out, inp, k, c, h) {
  var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t2 = new Uint32Array(4);
  var i2, j, m;
  for (i2 = 0; i2 < 4; i2++) {
    x[5 * i2] = ld32(c, 4 * i2);
    x[1 + i2] = ld32(k, 4 * i2);
    x[6 + i2] = ld32(inp, 4 * i2);
    x[11 + i2] = ld32(k, 16 + 4 * i2);
  }
  for (i2 = 0; i2 < 16; i2++)
    y[i2] = x[i2];
  for (i2 = 0; i2 < 20; i2++) {
    for (j = 0; j < 4; j++) {
      for (m = 0; m < 4; m++)
        t2[m] = x[(5 * j + 4 * m) % 16];
      t2[1] ^= L32(t2[0] + t2[3] | 0, 7);
      t2[2] ^= L32(t2[1] + t2[0] | 0, 9);
      t2[3] ^= L32(t2[2] + t2[1] | 0, 13);
      t2[0] ^= L32(t2[3] + t2[2] | 0, 18);
      for (m = 0; m < 4; m++)
        w[4 * j + (j + m) % 4] = t2[m];
    }
    for (m = 0; m < 16; m++)
      x[m] = w[m];
  }
  if (h) {
    for (i2 = 0; i2 < 16; i2++)
      x[i2] = x[i2] + y[i2] | 0;
    for (i2 = 0; i2 < 4; i2++) {
      x[5 * i2] = x[5 * i2] - ld32(c, 4 * i2) | 0;
      x[6 + i2] = x[6 + i2] - ld32(inp, 4 * i2) | 0;
    }
    for (i2 = 0; i2 < 4; i2++) {
      st32(out, 4 * i2, x[5 * i2]);
      st32(out, 16 + 4 * i2, x[6 + i2]);
    }
  } else {
    for (i2 = 0; i2 < 16; i2++)
      st32(out, 4 * i2, x[i2] + y[i2] | 0);
  }
}
function crypto_core_salsa20(out, inp, k, c) {
  core(out, inp, k, c, false);
  return 0;
}
function crypto_core_hsalsa20(out, inp, k, c) {
  core(out, inp, k, c, true);
  return 0;
}
var sigma = new Uint8Array([
  101,
  120,
  112,
  97,
  110,
  100,
  32,
  51,
  50,
  45,
  98,
  121,
  116,
  101,
  32,
  107
]);
function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n2, k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i2;
  if (!b)
    return 0;
  for (i2 = 0; i2 < 16; i2++)
    z[i2] = 0;
  for (i2 = 0; i2 < 8; i2++)
    z[i2] = n2[i2];
  while (b >= 64) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i2 = 0; i2 < 64; i2++)
      c[cpos + i2] = (m ? m[mpos + i2] : 0) ^ x[i2];
    u = 1;
    for (i2 = 8; i2 < 16; i2++) {
      u = u + (z[i2] & 255) | 0;
      z[i2] = u & 255;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    if (m)
      mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i2 = 0; i2 < b; i2++)
      c[cpos + i2] = (m ? m[mpos + i2] : 0) ^ x[i2];
  }
  return 0;
}
function crypto_stream_salsa20(c, cpos, d, n2, k) {
  return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n2, k);
}
function crypto_stream(c, cpos, d, n2, k) {
  var s2 = new Uint8Array(32);
  crypto_core_hsalsa20(s2, n2, k, sigma);
  return crypto_stream_salsa20(c, cpos, d, n2.subarray(16), s2);
}
function crypto_stream_xor(c, cpos, m, mpos, d, n2, k) {
  var s2 = new Uint8Array(32);
  crypto_core_hsalsa20(s2, n2, k, sigma);
  return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n2.subarray(16), s2);
}
function add1305(h, c) {
  var j, u = 0;
  for (j = 0; j < 17; j++) {
    u = u + (h[j] + c[j] | 0) | 0;
    h[j] = u & 255;
    u >>>= 8;
  }
}
var minusp = new Uint32Array([
  5,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  252
]);
function crypto_onetimeauth(out, outpos, m, mpos, n2, k) {
  var s2, i2, j, u;
  var x = new Uint32Array(17), r3 = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);
  for (j = 0; j < 17; j++)
    r3[j] = h[j] = 0;
  for (j = 0; j < 16; j++)
    r3[j] = k[j];
  r3[3] &= 15;
  r3[4] &= 252;
  r3[7] &= 15;
  r3[8] &= 252;
  r3[11] &= 15;
  r3[12] &= 252;
  r3[15] &= 15;
  while (n2 > 0) {
    for (j = 0; j < 17; j++)
      c[j] = 0;
    for (j = 0; j < 16 && j < n2; ++j)
      c[j] = m[mpos + j];
    c[j] = 1;
    mpos += j;
    n2 -= j;
    add1305(h, c);
    for (i2 = 0; i2 < 17; i2++) {
      x[i2] = 0;
      for (j = 0; j < 17; j++)
        x[i2] = x[i2] + h[j] * (j <= i2 ? r3[i2 - j] : 320 * r3[i2 + 17 - j] | 0) | 0 | 0;
    }
    for (i2 = 0; i2 < 17; i2++)
      h[i2] = x[i2];
    u = 0;
    for (j = 0; j < 16; j++) {
      u = u + h[j] | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = u + h[16] | 0;
    h[16] = u & 3;
    u = 5 * (u >>> 2) | 0;
    for (j = 0; j < 16; j++) {
      u = u + h[j] | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = u + h[16] | 0;
    h[16] = u;
  }
  for (j = 0; j < 17; j++)
    g[j] = h[j];
  add1305(h, minusp);
  s2 = -(h[16] >>> 7) | 0;
  for (j = 0; j < 17; j++)
    h[j] ^= s2 & (g[j] ^ h[j]);
  for (j = 0; j < 16; j++)
    c[j] = k[j + 16];
  c[16] = 0;
  add1305(h, c);
  for (j = 0; j < 16; j++)
    out[outpos + j] = h[j];
  return 0;
}
function crypto_onetimeauth_verify(h, hpos, m, mpos, n2, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x, 0, m, mpos, n2, k);
  return crypto_verify_16(h, hpos, x, 0);
}
function crypto_secretbox(c, m, d, n2, k) {
  var i2;
  if (d < 32)
    return -1;
  crypto_stream_xor(c, 0, m, 0, d, n2, k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i2 = 0; i2 < 16; i2++)
    c[i2] = 0;
  return 0;
}
function crypto_secretbox_open(m, c, d, n2, k) {
  var i2;
  var x = new Uint8Array(32);
  if (d < 32)
    return -1;
  crypto_stream(x, 0, 32, n2, k);
  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
    return -1;
  crypto_stream_xor(m, 0, c, 0, d, n2, k);
  for (i2 = 0; i2 < 32; i2++)
    m[i2] = 0;
  return 0;
}
function set25519(r3, a2) {
  var i2;
  for (i2 = 0; i2 < 16; i2++)
    r3[i2] = a2[i2] | 0;
}
function car25519(o2) {
  var c;
  var i2;
  for (i2 = 0; i2 < 16; i2++) {
    o2[i2] += 65536;
    c = Math.floor(o2[i2] / 65536);
    o2[(i2 + 1) * (i2 < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i2 === 15 ? 1 : 0);
    o2[i2] -= c * 65536;
  }
}
function sel25519(p, q, b) {
  var t2, c = ~(b - 1);
  for (var i2 = 0; i2 < 16; i2++) {
    t2 = c & (p[i2] ^ q[i2]);
    p[i2] ^= t2;
    q[i2] ^= t2;
  }
}
function pack25519(o2, n2) {
  var i2, j, b;
  var m = gf(), t2 = gf();
  for (i2 = 0; i2 < 16; i2++)
    t2[i2] = n2[i2];
  car25519(t2);
  car25519(t2);
  car25519(t2);
  for (j = 0; j < 2; j++) {
    m[0] = t2[0] - 65517;
    for (i2 = 1; i2 < 15; i2++) {
      m[i2] = t2[i2] - 65535 - (m[i2 - 1] >> 16 & 1);
      m[i2 - 1] &= 65535;
    }
    m[15] = t2[15] - 32767 - (m[14] >> 16 & 1);
    b = m[15] >> 16 & 1;
    m[14] &= 65535;
    sel25519(t2, m, 1 - b);
  }
  for (i2 = 0; i2 < 16; i2++) {
    o2[2 * i2] = t2[i2] & 255;
    o2[2 * i2 + 1] = t2[i2] >> 8;
  }
}
function neq25519(a2, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a2);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}
function par25519(a2) {
  var d = new Uint8Array(32);
  pack25519(d, a2);
  return d[0] & 1;
}
function unpack25519(o2, n2) {
  var i2;
  for (i2 = 0; i2 < 16; i2++)
    o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
  o2[15] &= 32767;
}
function A(o2, a2, b) {
  var i2;
  for (i2 = 0; i2 < 16; i2++)
    o2[i2] = a2[i2] + b[i2] | 0;
}
function Z(o2, a2, b) {
  var i2;
  for (i2 = 0; i2 < 16; i2++)
    o2[i2] = a2[i2] - b[i2] | 0;
}
function M(o2, a2, b) {
  var i2, j, t2 = new Float64Array(31);
  for (i2 = 0; i2 < 31; i2++)
    t2[i2] = 0;
  for (i2 = 0; i2 < 16; i2++) {
    for (j = 0; j < 16; j++) {
      t2[i2 + j] += a2[i2] * b[j];
    }
  }
  for (i2 = 0; i2 < 15; i2++) {
    t2[i2] += 38 * t2[i2 + 16];
  }
  for (i2 = 0; i2 < 16; i2++)
    o2[i2] = t2[i2];
  car25519(o2);
  car25519(o2);
}
function S(o2, a2) {
  M(o2, a2, a2);
}
function inv25519(o2, i2) {
  var c = gf();
  var a2;
  for (a2 = 0; a2 < 16; a2++)
    c[a2] = i2[a2];
  for (a2 = 253; a2 >= 0; a2--) {
    S(c, c);
    if (a2 !== 2 && a2 !== 4)
      M(c, c, i2);
  }
  for (a2 = 0; a2 < 16; a2++)
    o2[a2] = c[a2];
}
function pow2523(o2, i2) {
  var c = gf();
  var a2;
  for (a2 = 0; a2 < 16; a2++)
    c[a2] = i2[a2];
  for (a2 = 250; a2 >= 0; a2--) {
    S(c, c);
    if (a2 !== 1)
      M(c, c, i2);
  }
  for (a2 = 0; a2 < 16; a2++)
    o2[a2] = c[a2];
}
function crypto_scalarmult(q, n2, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r3, i2;
  var a2 = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf();
  for (i2 = 0; i2 < 31; i2++)
    z[i2] = n2[i2];
  z[31] = n2[31] & 127 | 64;
  z[0] &= 248;
  unpack25519(x, p);
  for (i2 = 0; i2 < 16; i2++) {
    b[i2] = x[i2];
    d[i2] = a2[i2] = c[i2] = 0;
  }
  a2[0] = d[0] = 1;
  for (i2 = 254; i2 >= 0; --i2) {
    r3 = z[i2 >>> 3] >>> (i2 & 7) & 1;
    sel25519(a2, b, r3);
    sel25519(c, d, r3);
    A(e2, a2, c);
    Z(a2, a2, c);
    A(c, b, d);
    Z(b, b, d);
    S(d, e2);
    S(f, a2);
    M(a2, c, a2);
    M(c, b, e2);
    A(e2, a2, c);
    Z(a2, a2, c);
    S(b, a2);
    Z(c, d, f);
    M(a2, c, _121665);
    A(a2, a2, d);
    M(c, c, a2);
    M(a2, d, f);
    M(d, b, x);
    S(b, e2);
    sel25519(a2, b, r3);
    sel25519(c, d, r3);
  }
  for (i2 = 0; i2 < 16; i2++) {
    x[i2 + 16] = a2[i2];
    x[i2 + 32] = c[i2];
    x[i2 + 48] = b[i2];
    x[i2 + 64] = d[i2];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32, x32);
  M(x16, x16, x32);
  pack25519(q, x16);
  return 0;
}
function crypto_scalarmult_base(q, n2) {
  return crypto_scalarmult(q, n2, _9);
}
function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}
function crypto_box_beforenm(k, y, x) {
  var s2 = new Uint8Array(32);
  crypto_scalarmult(s2, x, y);
  return crypto_core_hsalsa20(k, _0, s2, sigma);
}
var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;
function crypto_box(c, m, d, n2, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n2, k);
}
function crypto_box_open(m, c, d, n2, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n2, k);
}
function add64() {
  var a2 = 0, b = 0, c = 0, d = 0, m16 = 65535, l2, h, i2;
  for (i2 = 0; i2 < arguments.length; i2++) {
    l2 = arguments[i2].lo;
    h = arguments[i2].hi;
    a2 += l2 & m16;
    b += l2 >>> 16;
    c += h & m16;
    d += h >>> 16;
  }
  b += a2 >>> 16;
  c += b >>> 16;
  d += c >>> 16;
  return new u64(c & m16 | d << 16, a2 & m16 | b << 16);
}
function shr64(x, c) {
  return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);
}
function xor64() {
  var l2 = 0, h = 0, i2;
  for (i2 = 0; i2 < arguments.length; i2++) {
    l2 ^= arguments[i2].lo;
    h ^= arguments[i2].hi;
  }
  return new u64(h, l2);
}
function R(x, c) {
  var h, l2, c1 = 32 - c;
  if (c < 32) {
    h = x.hi >>> c | x.lo << c1;
    l2 = x.lo >>> c | x.hi << c1;
  } else if (c < 64) {
    h = x.lo >>> c | x.hi << c1;
    l2 = x.hi >>> c | x.lo << c1;
  }
  return new u64(h, l2);
}
function Ch(x, y, z) {
  var h = x.hi & y.hi ^ ~x.hi & z.hi, l2 = x.lo & y.lo ^ ~x.lo & z.lo;
  return new u64(h, l2);
}
function Maj(x, y, z) {
  var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l2 = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;
  return new u64(h, l2);
}
function Sigma0(x) {
  return xor64(R(x, 28), R(x, 34), R(x, 39));
}
function Sigma1(x) {
  return xor64(R(x, 14), R(x, 18), R(x, 41));
}
function sigma0(x) {
  return xor64(R(x, 1), R(x, 8), shr64(x, 7));
}
function sigma1(x) {
  return xor64(R(x, 19), R(x, 61), shr64(x, 6));
}
var K = [
  new u64(1116352408, 3609767458),
  new u64(1899447441, 602891725),
  new u64(3049323471, 3964484399),
  new u64(3921009573, 2173295548),
  new u64(961987163, 4081628472),
  new u64(1508970993, 3053834265),
  new u64(2453635748, 2937671579),
  new u64(2870763221, 3664609560),
  new u64(3624381080, 2734883394),
  new u64(310598401, 1164996542),
  new u64(607225278, 1323610764),
  new u64(1426881987, 3590304994),
  new u64(1925078388, 4068182383),
  new u64(2162078206, 991336113),
  new u64(2614888103, 633803317),
  new u64(3248222580, 3479774868),
  new u64(3835390401, 2666613458),
  new u64(4022224774, 944711139),
  new u64(264347078, 2341262773),
  new u64(604807628, 2007800933),
  new u64(770255983, 1495990901),
  new u64(1249150122, 1856431235),
  new u64(1555081692, 3175218132),
  new u64(1996064986, 2198950837),
  new u64(2554220882, 3999719339),
  new u64(2821834349, 766784016),
  new u64(2952996808, 2566594879),
  new u64(3210313671, 3203337956),
  new u64(3336571891, 1034457026),
  new u64(3584528711, 2466948901),
  new u64(113926993, 3758326383),
  new u64(338241895, 168717936),
  new u64(666307205, 1188179964),
  new u64(773529912, 1546045734),
  new u64(1294757372, 1522805485),
  new u64(1396182291, 2643833823),
  new u64(1695183700, 2343527390),
  new u64(1986661051, 1014477480),
  new u64(2177026350, 1206759142),
  new u64(2456956037, 344077627),
  new u64(2730485921, 1290863460),
  new u64(2820302411, 3158454273),
  new u64(3259730800, 3505952657),
  new u64(3345764771, 106217008),
  new u64(3516065817, 3606008344),
  new u64(3600352804, 1432725776),
  new u64(4094571909, 1467031594),
  new u64(275423344, 851169720),
  new u64(430227734, 3100823752),
  new u64(506948616, 1363258195),
  new u64(659060556, 3750685593),
  new u64(883997877, 3785050280),
  new u64(958139571, 3318307427),
  new u64(1322822218, 3812723403),
  new u64(1537002063, 2003034995),
  new u64(1747873779, 3602036899),
  new u64(1955562222, 1575990012),
  new u64(2024104815, 1125592928),
  new u64(2227730452, 2716904306),
  new u64(2361852424, 442776044),
  new u64(2428436474, 593698344),
  new u64(2756734187, 3733110249),
  new u64(3204031479, 2999351573),
  new u64(3329325298, 3815920427),
  new u64(3391569614, 3928383900),
  new u64(3515267271, 566280711),
  new u64(3940187606, 3454069534),
  new u64(4118630271, 4000239992),
  new u64(116418474, 1914138554),
  new u64(174292421, 2731055270),
  new u64(289380356, 3203993006),
  new u64(460393269, 320620315),
  new u64(685471733, 587496836),
  new u64(852142971, 1086792851),
  new u64(1017036298, 365543100),
  new u64(1126000580, 2618297676),
  new u64(1288033470, 3409855158),
  new u64(1501505948, 4234509866),
  new u64(1607167915, 987167468),
  new u64(1816402316, 1246189591)
];
function crypto_hashblocks(x, m, n2) {
  var z = [], b = [], a2 = [], w = [], t2, i2, j;
  for (i2 = 0; i2 < 8; i2++)
    z[i2] = a2[i2] = dl64(x, 8 * i2);
  var pos = 0;
  while (n2 >= 128) {
    for (i2 = 0; i2 < 16; i2++)
      w[i2] = dl64(m, 8 * i2 + pos);
    for (i2 = 0; i2 < 80; i2++) {
      for (j = 0; j < 8; j++)
        b[j] = a2[j];
      t2 = add64(a2[7], Sigma1(a2[4]), Ch(a2[4], a2[5], a2[6]), K[i2], w[i2 % 16]);
      b[7] = add64(t2, Sigma0(a2[0]), Maj(a2[0], a2[1], a2[2]));
      b[3] = add64(b[3], t2);
      for (j = 0; j < 8; j++)
        a2[(j + 1) % 8] = b[j];
      if (i2 % 16 === 15) {
        for (j = 0; j < 16; j++) {
          w[j] = add64(
            w[j],
            w[(j + 9) % 16],
            sigma0(w[(j + 1) % 16]),
            sigma1(w[(j + 14) % 16])
          );
        }
      }
    }
    for (i2 = 0; i2 < 8; i2++) {
      a2[i2] = add64(a2[i2], z[i2]);
      z[i2] = a2[i2];
    }
    pos += 128;
    n2 -= 128;
  }
  for (i2 = 0; i2 < 8; i2++)
    ts64(x, 8 * i2, z[i2]);
  return n2;
}
var iv = new Uint8Array([
  106,
  9,
  230,
  103,
  243,
  188,
  201,
  8,
  187,
  103,
  174,
  133,
  132,
  202,
  167,
  59,
  60,
  110,
  243,
  114,
  254,
  148,
  248,
  43,
  165,
  79,
  245,
  58,
  95,
  29,
  54,
  241,
  81,
  14,
  82,
  127,
  173,
  230,
  130,
  209,
  155,
  5,
  104,
  140,
  43,
  62,
  108,
  31,
  31,
  131,
  217,
  171,
  251,
  65,
  189,
  107,
  91,
  224,
  205,
  25,
  19,
  126,
  33,
  121
]);
function crypto_hash(out, m, n2) {
  var h = new Uint8Array(64), x = new Uint8Array(256);
  var i2, b = n2;
  for (i2 = 0; i2 < 64; i2++)
    h[i2] = iv[i2];
  crypto_hashblocks(h, m, n2);
  n2 %= 128;
  for (i2 = 0; i2 < 256; i2++)
    x[i2] = 0;
  for (i2 = 0; i2 < n2; i2++)
    x[i2] = m[b - n2 + i2];
  x[n2] = 128;
  n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
  x[n2 - 9] = 0;
  ts64(x, n2 - 8, new u64(b / 536870912 | 0, b << 3));
  crypto_hashblocks(h, x, n2);
  for (i2 = 0; i2 < 64; i2++)
    out[i2] = h[i2];
  return 0;
}
function add4(p, q) {
  var a2 = gf(), b = gf(), c = gf(), d = gf(), e2 = gf(), f = gf(), g = gf(), h = gf(), t2 = gf();
  Z(a2, p[1], p[0]);
  Z(t2, q[1], q[0]);
  M(a2, a2, t2);
  A(b, p[0], p[1]);
  A(t2, q[0], q[1]);
  M(b, b, t2);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e2, b, a2);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a2);
  M(p[0], e2, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e2, h);
}
function cswap(p, q, b) {
  var i2;
  for (i2 = 0; i2 < 4; i2++) {
    sel25519(p[i2], q[i2], b);
  }
}
function pack3(r3, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r3, ty);
  r3[31] ^= par25519(tx) << 7;
}
function scalarmult(p, q, s2) {
  var b, i2;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i2 = 255; i2 >= 0; --i2) {
    b = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
    cswap(p, q, b);
    add4(q, p);
    add4(p, p);
    cswap(p, q, b);
  }
}
function scalarbase(p, s2) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s2);
}
function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i2;
  if (!seeded)
    randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  scalarbase(p, d);
  pack3(pk, p);
  for (i2 = 0; i2 < 32; i2++)
    sk[i2 + 32] = pk[i2];
  return 0;
}
var L = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]);
function modL(r3, x) {
  var carry, i2, j, k;
  for (i2 = 63; i2 >= 32; --i2) {
    carry = 0;
    for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i2] * L[j - (i2 - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i2] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++)
    x[j] -= carry * L[j];
  for (i2 = 0; i2 < 32; i2++) {
    x[i2 + 1] += x[i2] >> 8;
    r3[i2] = x[i2] & 255;
  }
}
function reduce(r3) {
  var x = new Float64Array(64), i2;
  for (i2 = 0; i2 < 64; i2++)
    x[i2] = r3[i2];
  for (i2 = 0; i2 < 64; i2++)
    r3[i2] = 0;
  modL(r3, x);
}
function crypto_sign(sm, m, n2, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r3 = new Uint8Array(64);
  var i2, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;
  var smlen = n2 + 64;
  for (i2 = 0; i2 < n2; i2++)
    sm[64 + i2] = m[i2];
  for (i2 = 0; i2 < 32; i2++)
    sm[32 + i2] = d[32 + i2];
  crypto_hash(r3, sm.subarray(32), n2 + 32);
  reduce(r3);
  scalarbase(p, r3);
  pack3(sm, p);
  for (i2 = 32; i2 < 64; i2++)
    sm[i2] = sk[i2];
  crypto_hash(h, sm, n2 + 64);
  reduce(h);
  for (i2 = 0; i2 < 64; i2++)
    x[i2] = 0;
  for (i2 = 0; i2 < 32; i2++)
    x[i2] = r3[i2];
  for (i2 = 0; i2 < 32; i2++) {
    for (j = 0; j < 32; j++) {
      x[i2 + j] += h[i2] * d[j];
    }
  }
  modL(sm.subarray(32), x);
  return smlen;
}
function unpackneg(r3, p) {
  var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
  set25519(r3[2], gf1);
  unpack25519(r3[1], p);
  S(num, r3[1]);
  M(den, num, D);
  Z(num, num, r3[2]);
  A(den, r3[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t2, den6, num);
  M(t2, t2, den);
  pow2523(t2, t2);
  M(t2, t2, num);
  M(t2, t2, den);
  M(t2, t2, den);
  M(r3[0], t2, den);
  S(chk, r3[0]);
  M(chk, chk, den);
  if (neq25519(chk, num))
    M(r3[0], r3[0], I);
  S(chk, r3[0]);
  M(chk, chk, den);
  if (neq25519(chk, num))
    return -1;
  if (par25519(r3[0]) === p[31] >> 7)
    Z(r3[0], gf0, r3[0]);
  M(r3[3], r3[0], r3[1]);
  return 0;
}
function crypto_sign_open(m, sm, n2, pk) {
  var i2;
  var t2 = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
  if (n2 < 64)
    return -1;
  if (unpackneg(q, pk))
    return -1;
  for (i2 = 0; i2 < n2; i2++)
    m[i2] = sm[i2];
  for (i2 = 0; i2 < 32; i2++)
    m[i2 + 32] = pk[i2];
  crypto_hash(h, m, n2);
  reduce(h);
  scalarmult(p, q, h);
  scalarbase(q, sm.subarray(32));
  add4(p, q);
  pack3(t2, p);
  n2 -= 64;
  if (crypto_verify_32(sm, 0, t2, 0)) {
    for (i2 = 0; i2 < n2; i2++)
      m[i2] = 0;
    return -1;
  }
  for (i2 = 0; i2 < n2; i2++)
    m[i2] = sm[i2 + 64];
  return n2;
}
var crypto_secretbox_KEYBYTES = 32;
var crypto_secretbox_NONCEBYTES = 24;
var crypto_secretbox_ZEROBYTES = 32;
var crypto_secretbox_BOXZEROBYTES = 16;
var crypto_scalarmult_BYTES = 32;
var crypto_scalarmult_SCALARBYTES = 32;
var crypto_box_PUBLICKEYBYTES = 32;
var crypto_box_SECRETKEYBYTES = 32;
var crypto_box_BEFORENMBYTES = 32;
var crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES;
var crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES;
var crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES;
var crypto_sign_BYTES = 64;
var crypto_sign_PUBLICKEYBYTES = 32;
var crypto_sign_SECRETKEYBYTES = 64;
var crypto_sign_SEEDBYTES = 32;
var crypto_hash_BYTES = 64;
var _nacl = {
  lowlevel: {}
};
_nacl.lowlevel = {
  crypto_core_hsalsa20,
  crypto_stream_xor,
  crypto_stream,
  crypto_stream_salsa20_xor,
  crypto_stream_salsa20,
  crypto_onetimeauth,
  crypto_onetimeauth_verify,
  crypto_verify_16,
  crypto_verify_32,
  crypto_secretbox,
  crypto_secretbox_open,
  crypto_scalarmult,
  crypto_scalarmult_base,
  crypto_box_beforenm,
  crypto_box_afternm,
  crypto_box,
  crypto_box_open,
  crypto_box_keypair,
  crypto_hash,
  crypto_sign,
  crypto_sign_keypair,
  crypto_sign_open,
  crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES,
  crypto_hash_BYTES,
  gf,
  D,
  L,
  pack25519,
  unpack25519,
  M,
  A,
  S,
  Z,
  pow2523,
  add: add4,
  set25519,
  modL,
  scalarmult,
  scalarbase
};
function checkLengths(k, n2) {
  if (k.length !== crypto_secretbox_KEYBYTES)
    throw new Error("bad key size");
  if (n2.length !== crypto_secretbox_NONCEBYTES)
    throw new Error("bad nonce size");
}
function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES)
    throw new Error("bad public key size");
  if (sk.length !== crypto_box_SECRETKEYBYTES)
    throw new Error("bad secret key size");
}
function checkArrayTypes() {
  for (var i2 = 0; i2 < arguments.length; i2++) {
    if (!(arguments[i2] instanceof Uint8Array))
      throw new TypeError("unexpected type, use Uint8Array");
  }
}
function cleanup(arr) {
  for (var i2 = 0; i2 < arr.length; i2++)
    arr[i2] = 0;
}
_nacl.randomBytes = function(n2) {
  var b = new Uint8Array(n2);
  randombytes(b, n2);
  return b;
};
_nacl.secretbox = function(msg, nonce, key2) {
  checkArrayTypes(msg, nonce, key2);
  checkLengths(key2, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i2 = 0; i2 < msg.length; i2++)
    m[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
  crypto_secretbox(c, m, m.length, nonce, key2);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};
_nacl.secretbox.open = function(box2, nonce, key2) {
  checkArrayTypes(box2, nonce, key2);
  checkLengths(key2, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box2.length);
  var m = new Uint8Array(c.length);
  for (var i2 = 0; i2 < box2.length; i2++)
    c[i2 + crypto_secretbox_BOXZEROBYTES] = box2[i2];
  if (c.length < 32)
    return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key2) !== 0)
    return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};
_nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
_nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
_nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
_nacl.scalarMult = function(n2, p) {
  checkArrayTypes(n2, p);
  if (n2.length !== crypto_scalarmult_SCALARBYTES)
    throw new Error("bad n size");
  if (p.length !== crypto_scalarmult_BYTES)
    throw new Error("bad p size");
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n2, p);
  return q;
};
_nacl.scalarMult.base = function(n2) {
  checkArrayTypes(n2);
  if (n2.length !== crypto_scalarmult_SCALARBYTES)
    throw new Error("bad n size");
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n2);
  return q;
};
_nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
_nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
_nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = _nacl.box.before(publicKey, secretKey);
  return _nacl.secretbox(msg, nonce, k);
};
_nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};
_nacl.box.after = _nacl.secretbox;
_nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = _nacl.box.before(publicKey, secretKey);
  return _nacl.secretbox.open(msg, nonce, k);
};
_nacl.box.open.after = _nacl.secretbox.open;
_nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return { publicKey: pk, secretKey: sk };
};
_nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error("bad secret key size");
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
};
_nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
_nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
_nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
_nacl.box.nonceLength = crypto_box_NONCEBYTES;
_nacl.box.overheadLength = _nacl.secretbox.overheadLength;
_nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error("bad secret key size");
  var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};
_nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error("bad public key size");
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0)
    return null;
  var m = new Uint8Array(mlen);
  for (var i2 = 0; i2 < m.length; i2++)
    m[i2] = tmp[i2];
  return m;
};
_nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = _nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i2 = 0; i2 < sig.length; i2++)
    sig[i2] = signedMsg[i2];
  return sig;
};
_nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error("bad signature size");
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error("bad public key size");
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i2;
  for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
    sm[i2] = sig[i2];
  for (i2 = 0; i2 < msg.length; i2++)
    sm[i2 + crypto_sign_BYTES] = msg[i2];
  return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
};
_nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return { publicKey: pk, secretKey: sk };
};
_nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error("bad secret key size");
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i2 = 0; i2 < pk.length; i2++)
    pk[i2] = secretKey[32 + i2];
  return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
};
_nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error("bad seed size");
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i2 = 0; i2 < 32; i2++)
    sk[i2] = seed[i2];
  crypto_sign_keypair(pk, sk, true);
  return { publicKey: pk, secretKey: sk };
};
_nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
_nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
_nacl.sign.seedLength = crypto_sign_SEEDBYTES;
_nacl.sign.signatureLength = crypto_sign_BYTES;
_nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};
_nacl.hash.hashLength = crypto_hash_BYTES;
_nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  if (x.length === 0 || y.length === 0)
    return false;
  if (x.length !== y.length)
    return false;
  return vn(x, 0, y, 0, x.length) === 0 ? true : false;
};
_nacl.setPRNG = function(fn) {
  randombytes = fn;
};
(function() {
  var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
  if (crypto3 && crypto3.getRandomValues) {
    var QUOTA = 65536;
    _nacl.setPRNG(function(x, n2) {
      var i2, v = new Uint8Array(n2);
      for (i2 = 0; i2 < n2; i2 += QUOTA) {
        crypto3.getRandomValues(v.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
      }
      for (i2 = 0; i2 < n2; i2++)
        x[i2] = v[i2];
      cleanup(v);
    });
  } else if (typeof __require !== "undefined") {
    crypto3 = __require("crypto");
    if (crypto3 && crypto3.randomBytes) {
      _nacl.setPRNG(function(x, n2) {
        var i2, v = crypto3.randomBytes(n2);
        for (i2 = 0; i2 < n2; i2++)
          x[i2] = v[i2];
        cleanup(v);
      });
    }
  }
})();
var nacl = _nacl.default || _nacl;

// packages/crypto/src/lib/crypto.ts
if (!globalThis.wasmExports) {
  initWasmBlsSdk().then((exports) => {
    globalThis.wasmExports = exports;
    if (!globalThis.jestTesting) {
      log(
        `\u2705 [BLS SDK] wasmExports loaded. ${Object.keys(exports).length} functions available. Run 'wasmExports' in the console to see them.`
      );
    }
  });
}
if (!globalThis.wasmECDSA) {
  let init3 = initWasmEcdsaSdk;
  let env;
  if (isBrowser()) {
    env = "Browser";
  } else {
    env = "NodeJS";
  }
  init3().then((sdk) => {
    globalThis.wasmECDSA = sdk;
    if (!globalThis.jestTesting) {
      log(
        `\u2705 [ECDSA SDK ${env}] wasmECDSA loaded. ${Object.keys(wasmECDSA).length} functions available. Run 'wasmECDSA' in the console to see them.`
      );
    }
  });
}
if (!globalThis.wasmSevSnpUtils) {
  initWasmSevSnpUtilsSdk().then((exports) => {
    globalThis.wasmSevSnpUtils = exports;
    if (!globalThis.jestTesting) {
      log(
        `\u2705 [SEV SNP Utils SDK] wasmSevSnpUtils loaded. ${Object.keys(exports).length} functions available. Run 'wasmSevSnpUtils' in the console to see them.`
      );
    }
  });
}
var encrypt3 = (publicKey, data, identity) => {
  return encrypt2(
    publicKey,
    uint8arrayToString(data, "base64"),
    uint8arrayToString(identity, "base64")
  );
};
var verifyAndDecryptWithSignatureShares = (publicKey, identity, ciphertext, shares) => {
  const sigShares = shares.map((s2) => JSON.stringify(s2));
  const base64Identity = uint8ArrayToBase64(identity);
  const privateData = verify_and_decrypt_with_signature_shares(
    publicKey,
    base64Identity,
    ciphertext,
    sigShares
  );
  return uint8arrayFromString(privateData, "base64");
};
var combineSignatureShares = (shares) => {
  const sigShares = shares.map((s2) => JSON.stringify(s2));
  return combine_signature_shares(sigShares);
};
var combineEcdsaShares = (sigShares) => {
  const type = sigShares[0].sigType;
  if (!type) {
    throw new Error(
      "Sig type is not defined! Here's your sigShares:",
      sigShares
    );
  }
  const validShares = sigShares.reduce((acc, val) => {
    if (val.signatureShare !== "") {
      const newVal = _remapKeyShareForEcdsa(val);
      if (!newVal.sig_name) {
        newVal.sig_name = "sig-created-by-lit-sdk";
      }
      acc.push(JSON.stringify(newVal));
    }
    return acc;
  }, []);
  log("[combineEcdsaShares] Valid Shares:", validShares);
  if (validShares.length === 0) {
    return throwError({
      message: "No valid shares to combine",
      errorKind: LIT_ERROR.NO_VALID_SHARES.kind,
      errorCode: LIT_ERROR.NO_VALID_SHARES.name
    });
  }
  let sig;
  try {
    let res = "";
    switch (type) {
      case "ECDSA_CAIT_SITH" /* EcdsaCaitSith */:
      case "K256" /* EcdsaK256 */:
        res = combine_signature(validShares, 2);
        try {
          sig = JSON.parse(res);
        } catch (e2) {
          logError(
            "[combineEcdsaShares] Error while combining signatures shares",
            validShares
          );
          throwError({
            message: e2.message,
            name: LIT_ERROR.SIGNATURE_VALIDATION_ERROR.name,
            kind: LIT_ERROR.SIGNATURE_VALIDATION_ERROR.kind
          });
        }
        if (sig && sig.r && sig.r.length > 64) {
          while (sig.r.length > 64) {
            sig.r = sig.r.slice(1);
          }
        }
        if (sig && sig.s && sig.s.length > 64) {
          while (sig.s.length > 64) {
            sig.s = sig.s.slice(1);
          }
        }
        break;
      case LIT_CURVE.ECDSCAITSITHP256:
        res = combine_signature(validShares, 3);
        log("[combineEcdsaShares] response from combine_signature", res);
        sig = JSON.parse(res);
        break;
      default:
        throw new Error(
          "Unsupported signature type present in signature shares. Please report this issue"
        );
    }
  } catch (e2) {
    log("Failed to combine signatures:", e2);
  }
  log("[combineEcdsaShares] signature", sig);
  return sig;
};
var computeHDPubKey = (pubkeys, keyId, sigType) => {
  try {
    switch (sigType) {
      case "ECDSA_CAIT_SITH" /* EcdsaCaitSith */:
      case "K256" /* EcdsaK256 */:
        pubkeys = pubkeys.map((value) => {
          return value.replace("0x", "");
        });
        keyId = keyId.replace("0x", "");
        return compute_public_key(keyId, pubkeys, 2);
      default:
        throw new Error("Non supported signature type");
    }
  } catch (e2) {
    log("Failed to derive public key", e2);
  }
};
var generateSessionKeyPair = () => {
  const keyPair2 = nacl.sign.keyPair();
  const sessionKeyPair = {
    publicKey: uint8arrayToString(keyPair2.publicKey, "base16"),
    secretKey: uint8arrayToString(keyPair2.secretKey, "base16")
  };
  return sessionKeyPair;
};
var _remapKeyShareForEcdsa = (share) => {
  const keys = Object.keys(share);
  let newShare = {};
  for (const key2 of keys) {
    const new_key = key2.replace(
      /[A-Z]/g,
      (letter) => `_${letter.toLowerCase()}`
    );
    newShare = Object.defineProperty(
      newShare,
      new_key,
      Object.getOwnPropertyDescriptor(share, key2)
    );
  }
  return newShare;
};
async function getAmdCert(url) {
  if (isBrowser()) {
    url = `https://cors.litgateway.com/${url}`;
  }
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  return new Uint8Array(arrayBuffer);
}
var checkSevSnpAttestation = async (attestation, challenge, url) => {
  const { noonce, data, signatures, report, type } = attestation;
  const decodedNoonce = Buffer.from(noonce, "base64").toString("hex");
  if (decodedNoonce !== challenge) {
    throw new Error(
      `Attestation noonce ${decodedNoonce} does not match challenge ${challenge}`
    );
  }
  const parsedUrl = new URL(url);
  let ipWeTalkedTo = parsedUrl.hostname;
  let portWeTalkedTo = parsedUrl.port;
  if (portWeTalkedTo === "") {
    if (url.startsWith("https://")) {
      portWeTalkedTo = "443";
    } else if (url.startsWith("http://")) {
      portWeTalkedTo = "80";
    } else {
      throw new Error(`Unknown port in URL ${url}`);
    }
  }
  let ipAndAddrFromReport = Buffer.from(
    data["EXTERNAL_ADDR"],
    "base64"
  ).toString("utf8");
  let ipFromReport = ipAndAddrFromReport.split(":")[0];
  let portFromReport = ipAndAddrFromReport.split(":")[1];
  if (ipWeTalkedTo !== ipFromReport) {
    throw new Error(
      `Attestation external address ${ipFromReport} does not match IP we talked to ${ipWeTalkedTo}`
    );
  }
  if (portWeTalkedTo !== portFromReport) {
    throw new Error(
      `Attestation external port ${portFromReport} does not match port we talked to ${portWeTalkedTo}`
    );
  }
  let vcekCert;
  const vcekUrl = get_vcek_url(report);
  if (isBrowser()) {
    vcekCert = localStorage.getItem(vcekUrl);
    if (vcekCert) {
      vcekCert = uint8arrayFromString(vcekCert, "base64");
    } else {
      vcekCert = await getAmdCert(vcekUrl);
      localStorage.setItem(vcekUrl, uint8arrayToString(vcekCert, "base64"));
    }
  } else {
    if (!globalThis.amdCertStore) {
      globalThis.amdCertStore = {};
    }
    vcekCert = globalThis.amdCertStore[vcekUrl];
    if (!vcekCert) {
      vcekCert = await getAmdCert(vcekUrl);
      globalThis.amdCertStore[vcekUrl] = vcekCert;
    }
  }
  if (!vcekCert || vcekCert.length === 0 || vcekCert.length < 256) {
    throw new Error("Unable to retrieve VCEK certificate from AMD");
  }
  return verify_attestation_report_and_check_challenge(
    report,
    data,
    signatures,
    challenge,
    vcekCert
  );
};

// packages/core/src/lib/endpoint-version.ts
init_shim();
var getLitEndpointPath = () => {
  let endpointPath = "/v1" /* V1 */;
  if (isNode()) {
    const versionArg = process.argv.find(
      (arg) => arg.startsWith("--version=" /* VERSION */)
    );
    const version28 = versionArg ? versionArg.split("=")[1] : null;
    let detectedVersion = version28 || // check for --version flag
    process.env["LIT_ENDPOINT_VERSION" /* LIT_ENDPOINT_VERSION */] || // check for environment variable
    "/v1" /* V1 */;
    detectedVersion = detectedVersion.toLowerCase();
    detectedVersion = detectedVersion.startsWith("/") ? detectedVersion : `/${detectedVersion}`;
    const keys = Object.values(LIT_ENDPOINT_VERSION);
    if (!keys.includes(detectedVersion)) {
      log(
        `[getLitEndpointPath] Invalid Lit endpoint version: "${detectedVersion}" - must be one of: "${keys.join(
          '", "'
        )}. Defaulting to "${"/v1" /* V1 */}".`
      );
    }
    endpointPath = detectedVersion === "/v1" /* V1 */ ? "/v1" /* V1 */ : "/" /* LEGACY */;
  }
  log(`\u{1F525} [getLitEndpointPath] Using Lit endpoint version: "${endpointPath}"`);
  return endpointPath;
};
var composeLitUrl = (params) => {
  try {
    new URL(params.url);
  } catch (error) {
    throw new Error(`[composeLitUrl] Invalid URL: "${params.url}"`);
  }
  if (params.version) {
    if (params.version === "/" /* LEGACY */) {
      log(
        `[composeLitUrl] Using legacy Lit endpoint version: "${params.version}"`
      );
    }
    return `${params.url}${params.endpoint}${params.version}`;
  }
  const endpointVersion = getLitEndpointPath();
  return `${params.url}${params.endpoint}${endpointVersion}`;
};

// packages/core/src/lib/lit-core.ts
var EPOCH_PROPAGATION_DELAY = 3e4;
var NETWORK_SYNC_INTERVAL = 3e4;
var LitCore = class {
  // ========== Constructor ==========
  constructor(config) {
    this.config = {
      alertWhenUnauthorized: false,
      debug: true,
      connectTimeout: 2e4,
      checkNodeAttestation: false,
      litNetwork: "cayenne",
      // Default to cayenne network. will be replaced by custom config.
      minNodeCount: 2,
      // Default value, should be replaced
      bootstrapUrls: [],
      // Default value, should be replaced
      retryTolerance: {
        timeout: 31e3,
        maxRetryCount: 3,
        interval: 100
      },
      rpcUrl: null
    };
    this.connectedNodes = /* @__PURE__ */ new Set();
    this.serverKeys = {};
    this.ready = false;
    this.subnetPubKey = null;
    this.networkPubKey = null;
    this.networkPubKeySet = null;
    this.hdRootPubkeys = null;
    this.latestBlockhash = null;
    this.lastBlockHashRetrieved = null;
    this._networkSyncInterval = null;
    this._epochUpdateTimeout = null;
    this._stakingContract = null;
    this._stakingContractListener = null;
    this._connectingPromise = null;
    this._epochCache = {
      currentNumber: null,
      lastUpdateTime: null
    };
    // ========== Logger utilities ==========
    this.getLogsForRequestId = (id2) => {
      return globalThis.logManager.getLogsForId(id2);
    };
    // ========== Scoped Class Helpers ==========
    /**
     * Asynchronously updates the configuration settings for the LitNodeClient.
     * This function fetches the minimum node count and bootstrap URLs for the
     * specified Lit network.
     *
     * It validates these values and updates the client's
     * configuration accordingly.
     *
     * It also stashes a handle on the Staking Contract so that we can use it for polling for epoch-related state changes
     *
     * @throws Will throw an error if the minimum node count is invalid or if
     *         the bootstrap URLs array is empty.
     * @returns {Promise<void>} A promise that resolves when the configuration is updated.
     */
    this.setNewConfig = async () => {
      const IS_LOCAL_NODE_SDK_DEVELOPMENT = this.config.litNetwork === "custom" /* Custom */ && this.config.bootstrapUrls.length >= 1 && this.config.rpcUrl;
      if (this.config.litNetwork === "manzano" /* Manzano */ || this.config.litNetwork === "habanero" /* Habanero */) {
        const minNodeCount = await LitContracts.getMinNodeCount(
          this.config.litNetwork
        );
        const bootstrapUrls = await LitContracts.getValidators(
          this.config.litNetwork
        );
        this._stakingContract = await LitContracts.getStakingContract(
          this.config.litNetwork
        );
        log("Bootstrap urls: ", bootstrapUrls);
        if (minNodeCount <= 0) {
          throwError({
            message: `minNodeCount is ${minNodeCount}, which is invalid. Please check your network connection and try again.`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        }
        if (bootstrapUrls.length <= 0) {
          throwError({
            message: `bootstrapUrls is empty, which is invalid. Please check your network connection and try again.`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        }
        this.config.minNodeCount = parseInt(minNodeCount, 10);
        this.config.bootstrapUrls = bootstrapUrls;
      } else if (this.config.litNetwork === "cayenne" /* Cayenne */) {
        this._stakingContract = await LitContracts.getStakingContract(
          this.config.litNetwork
        );
        this.config.bootstrapUrls = LIT_NETWORKS.cayenne;
        this.config.minNodeCount = LIT_NETWORKS.cayenne.length == 2 ? 2 : LIT_NETWORKS.cayenne.length * 2 / 3;
      } else if (this.config.litNetwork === "custom" /* Custom */ && this.config.bootstrapUrls.length < 1) {
        log("using custom contracts: ", this.config.contractContext);
        const minNodeCount = await LitContracts.getMinNodeCount(
          this.config.litNetwork,
          this.config.contractContext
        );
        const bootstrapUrls = await LitContracts.getValidators(
          this.config.litNetwork,
          this.config.contractContext
        );
        this._stakingContract = await LitContracts.getStakingContract(
          this.config.litNetwork,
          this.config.contractContext
        );
        log("Bootstrap urls: ", bootstrapUrls);
        if (minNodeCount <= 0) {
          throwError({
            message: `minNodeCount is ${minNodeCount}, which is invalid. Please check your network connection and try again.`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        }
        if (bootstrapUrls.length <= 0) {
          throwError({
            message: `bootstrapUrls is empty, which is invalid. Please check your network connection and try again.`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        }
        this.config.minNodeCount = parseInt(minNodeCount, 10);
        this.config.bootstrapUrls = bootstrapUrls;
      } else if (IS_LOCAL_NODE_SDK_DEVELOPMENT) {
        log("Using custom bootstrap urls:", this.config.bootstrapUrls);
        const minNodeCount = await LitContracts.getMinNodeCount(
          this.config.litNetwork,
          this.config.contractContext,
          this.config.rpcUrl
        );
        this.config.minNodeCount = parseInt(minNodeCount, 10);
        const bootstrapUrls = await LitContracts.getValidators(
          this.config.litNetwork,
          this.config.contractContext,
          this.config.rpcUrl
        );
        this.config.bootstrapUrls = bootstrapUrls;
        this._stakingContract = await LitContracts.getStakingContract(
          this.config.litNetwork,
          this.config.contractContext,
          this.config.rpcUrl
        );
      }
    };
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    this.setCustomBootstrapUrls = () => {
      if (this.config.litNetwork === "custom")
        return;
      const hasNetwork = this.config.litNetwork in LIT_NETWORKS;
      if (!hasNetwork) {
        throwError({
          message: "the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS",
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR.name
        });
        return;
      }
      this.config.bootstrapUrls = LIT_NETWORKS[this.config.litNetwork];
    };
    /**
     * Handshake with Node
     *
     * @param { HandshakeWithNode } params
     * @param { string } requestId
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    this.handshakeWithNode = async (params, requestId) => {
      const res = await executeWithRetry(
        async () => {
          const { url } = params;
          const urlWithPath = composeLitUrl({
            url,
            endpoint: "/web/handshake" /* HANDSHAKE */,
            version: "/" /* LEGACY */
          });
          log(`handshakeWithNode ${urlWithPath}`);
          const data = {
            clientPublicKey: "test",
            challenge: params.challenge
          };
          return await this.sendCommandToNode({
            url: urlWithPath,
            data,
            requestId
          }).catch((err) => {
            return err;
          });
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (_error, _requestId, isFinal) => {
          if (!isFinal) {
            logError("an error occurred, attempting to retry");
          }
        },
        this.config.retryTolerance
      );
      return res;
    };
    // ==================== SENDING COMMAND ====================
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    this.sendCommandToNode = async ({
      url,
      data,
      requestId
    }) => {
      data = { ...data, epochNumber: this.currentEpochNumber };
      logWithRequestId(
        requestId,
        `sendCommandToNode with url ${url} and data`,
        data
      );
      const req = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Lit-SDK-Version": version,
          "X-Lit-SDK-Type": "Typescript",
          "X-Request-Id": "lit_" + requestId
        },
        body: JSON.stringify(data)
      };
      return sendRequest(url, req, requestId);
    };
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    this.getNodePromises = (callback) => {
      const nodePromises = [];
      for (const url of this.connectedNodes) {
        nodePromises.push(callback(url));
      }
      return nodePromises;
    };
    /**
     *
     * Get either auth sig or session auth sig
     *
     */
    this.getSessionOrAuthSig = ({
      authSig,
      sessionSigs,
      url,
      mustHave = true
    }) => {
      if (!authSig && !sessionSigs) {
        if (mustHave) {
          throwError({
            message: `You must pass either authSig, or sessionSigs`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        } else {
          log(`authSig or sessionSigs not found. This may be using authMethod`);
        }
      }
      if (sessionSigs) {
        const sigToPassToNode = sessionSigs[url];
        if (!sigToPassToNode) {
          throwError({
            message: `You passed sessionSigs but we could not find session sig for node ${url}`,
            errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
          });
        }
        return sigToPassToNode;
      }
      return authSig;
    };
    this.validateAccessControlConditionsSchema = async (params) => {
      const {
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions
      } = params;
      if (accessControlConditions) {
        await validateAccessControlConditionsSchema(accessControlConditions);
      } else if (evmContractConditions) {
        await validateEVMContractConditionsSchema(evmContractConditions);
      } else if (solRpcConditions) {
        await validateSolRpcConditionsSchema(solRpcConditions);
      } else if (unifiedAccessControlConditions) {
        await validateUnifiedAccessControlConditionsSchema(
          unifiedAccessControlConditions
        );
      }
      return true;
    };
    /**
     *
     * Get hash of access control conditions
     *
     * @param { MultipleAccessControlConditions } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    this.getHashedAccessControlConditions = async (params) => {
      let hashOfConditions;
      const {
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions
      } = params;
      if (accessControlConditions) {
        hashOfConditions = await hashAccessControlConditions(
          accessControlConditions
        );
      } else if (evmContractConditions) {
        hashOfConditions = await hashEVMContractConditions(evmContractConditions);
      } else if (solRpcConditions) {
        hashOfConditions = await hashSolRpcConditions(solRpcConditions);
      } else if (unifiedAccessControlConditions) {
        hashOfConditions = await hashUnifiedAccessControlConditions(
          unifiedAccessControlConditions
        );
      } else {
        return;
      }
      return hashOfConditions;
    };
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @param { string } requestId requestId to be logged in case of error
     * @param { number } minNodeCount number of nodes we need valid results from in order to resolve
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     */
    this.handleNodePromises = async (nodePromises, requestId, minNodeCount) => {
      async function waitForNSuccessesWithErrors(promises, n2) {
        let responses = 0;
        const successes2 = [];
        const errors2 = [];
        return new Promise((resolve) => {
          promises.forEach((promise) => {
            promise.then((result) => {
              successes2.push(result);
              if (successes2.length >= n2) {
                resolve({ successes: successes2, errors: errors2 });
              }
            }).catch((error) => {
              errors2.push(error);
            }).finally(() => {
              responses++;
              if (responses === promises.length) {
                resolve({ successes: successes2, errors: errors2 });
              }
            });
          });
        });
      }
      const { successes, errors } = await waitForNSuccessesWithErrors(
        nodePromises,
        minNodeCount
      );
      if (successes.length >= minNodeCount) {
        return {
          success: true,
          values: successes
        };
      }
      const mostCommonError = JSON.parse(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        mostCommonString(errors.map((r3) => JSON.stringify(r3)))
      );
      logErrorWithRequestId(
        requestId || "",
        `most common error: ${JSON.stringify(mostCommonError)}`
      );
      return {
        success: false,
        error: mostCommonError
      };
    };
    /**
     *
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     *
     * @returns { void }
     *
     */
    this._throwNodeError = (res, requestId) => {
      if (res.error) {
        if ((res.error.errorCode && res.error.errorCode === LIT_ERROR_CODE.NODE_NOT_AUTHORIZED || res.error.errorCode === "not_authorized") && this.config.alertWhenUnauthorized) {
          log("You are not authorized to access this content");
        }
        throwError({
          ...res.error,
          message: res.error.message || "There was an error getting the signing shares from the nodes",
          errorCode: res.error.errorCode || LIT_ERROR.UNKNOWN_ERROR.code,
          requestId
        });
      } else {
        throwError({
          message: `There was an error getting the signing shares from the nodes.  Response from the nodes: ${JSON.stringify(
            res
          )}`,
          error: LIT_ERROR.UNKNOWN_ERROR,
          requestId
        });
      }
    };
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    this.getFormattedAccessControlConditions = (params) => {
      const {
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions
      } = params;
      let formattedAccessControlConditions;
      let formattedEVMContractConditions;
      let formattedSolRpcConditions;
      let formattedUnifiedAccessControlConditions;
      let error = false;
      if (accessControlConditions) {
        formattedAccessControlConditions = accessControlConditions.map(
          (c) => canonicalAccessControlConditionFormatter(c)
        );
        log(
          "formattedAccessControlConditions",
          JSON.stringify(formattedAccessControlConditions)
        );
      } else if (evmContractConditions) {
        formattedEVMContractConditions = evmContractConditions.map(
          (c) => canonicalEVMContractConditionFormatter(c)
        );
        log(
          "formattedEVMContractConditions",
          JSON.stringify(formattedEVMContractConditions)
        );
      } else if (solRpcConditions) {
        formattedSolRpcConditions = solRpcConditions.map(
          (c) => canonicalSolRpcConditionFormatter(c)
        );
        log(
          "formattedSolRpcConditions",
          JSON.stringify(formattedSolRpcConditions)
        );
      } else if (unifiedAccessControlConditions) {
        formattedUnifiedAccessControlConditions = unifiedAccessControlConditions.map(
          (c) => canonicalUnifiedAccessControlConditionFormatter(c)
        );
        log(
          "formattedUnifiedAccessControlConditions",
          JSON.stringify(formattedUnifiedAccessControlConditions)
        );
      } else {
        error = true;
      }
      return {
        error,
        formattedAccessControlConditions,
        formattedEVMContractConditions,
        formattedSolRpcConditions,
        formattedUnifiedAccessControlConditions
      };
    };
    /**
     * Calculates an HD public key from a given keyId
     * The curve type or signature type is assumed to be k256 unless provided
     * @param keyId
     * @param {LIT_CURVE} sigType
     * @returns {string} public key
     */
    this.computeHDPubKey = (keyId, sigType = "ECDSA_CAIT_SITH" /* EcdsaCaitSith */) => {
      if (!this.hdRootPubkeys) {
        logError("root public keys not found, have you connected to the nodes?");
        throwError({
          message: `root public keys not found, have you connected to the nodes?`,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.code
        });
      }
      return computeHDPubKey(this.hdRootPubkeys, keyId, sigType);
    };
    switch (config?.litNetwork) {
      case "cayenne" /* Cayenne */:
        this.config = {
          ...this.config,
          ...config
        };
        break;
      case "manzano" /* Manzano */:
        this.config = {
          ...this.config,
          checkNodeAttestation: true,
          ...config
        };
        break;
      case "habanero" /* Habanero */:
        this.config = {
          ...this.config,
          checkNodeAttestation: true,
          ...config
        };
        break;
      default:
        this.config = {
          ...this.config,
          ...config
        };
    }
    this.setCustomBootstrapUrls();
    globalThis.litConfig = this.config;
    bootstrapLogManager("core");
    if (this.config.storageProvider?.provider) {
      log(
        "[LitCore constructor] localstorage api not found, injecting persistence instance found in config"
      );
      Object.defineProperty(globalThis, "localStorage", {
        value: this.config.storageProvider?.provider
      });
    } else if (isNode() && !globalThis.localStorage && !this.config.storageProvider?.provider) {
      log(
        "[LitCore constructor] Looks like you are running in NodeJS and did not provide a storage provider, your sessions will not be cached"
      );
    }
  }
  /** Schedule an update to the current epoch number for EPOCH_PROPAGATION_DELAY seconds from now
   * We don't immediately update this value on `NextValidatorSetLocked` state changes because we want to give the nodes
   * a few seconds to update to the new epoch before we start sending the new epoch number with requests
   *
   * This function should only be called as a result of a rare state change (`NextValidatorSetLocked`)
   * So we don't debounce setting the timeout handler.
   * @private
   */
  _scheduleEpochNumberUpdate() {
    if (this._epochUpdateTimeout) {
      clearTimeout(this._epochUpdateTimeout);
    }
    this._epochUpdateTimeout = setTimeout(async () => {
      try {
        this.currentEpochNumber = await this.fetchCurrentEpochNumber();
      } catch (e2) {
        logError("Error while attempting to fetch current epoch number");
      }
    }, EPOCH_PROPAGATION_DELAY);
    if (this._epochUpdateTimeout.unref && typeof this._epochUpdateTimeout.unref === "function") {
      this._epochUpdateTimeout.unref();
    }
  }
  async _handleStakingContractStateChange(state) {
    log(`New state detected: "${state}"`);
    if (state === 1 /* NextValidatorSetLocked */) {
      this._scheduleEpochNumberUpdate();
      if (this.config.litNetwork === "manzano" /* Manzano */ || this.config.litNetwork === "habanero" /* Habanero */ || this.config.litNetwork === "custom" /* Custom */) {
        try {
          log(
            "State found to be new validator set locked, checking validator set"
          );
          const oldNodeUrls = [...this.config.bootstrapUrls].sort();
          await this.setNewConfig();
          const currentNodeUrls = this.config.bootstrapUrls.sort();
          const delta = currentNodeUrls.filter(
            (item) => oldNodeUrls.includes(item)
          );
          if (delta.length > 1) {
            log(
              "Active validator sets changed, new validators ",
              delta,
              "starting node connection"
            );
          }
          await this.connect();
        } catch (err) {
          const { message = "" } = err;
          logError(
            "Error while attempting to reconnect to nodes after epoch transition:",
            message
          );
        }
      }
    }
  }
  /**
   * Sets up a listener to detect state changes (new epochs) in the staking contract.
   * When a new epoch is detected, it triggers the `setNewConfig` function to update
   * the client's configuration based on the new state of the network. This ensures
   * that the client's configuration is always in sync with the current state of the
   * staking contract.
   *
   * @returns {Promise<void>} A promise that resolves when the listener is successfully set up.
   */
  _listenForNewEpoch() {
    if (this._stakingContractListener) {
      return;
    }
    if (this._stakingContract) {
      log(
        "listening for state change on staking contract: ",
        this._stakingContract.address
      );
      this._stakingContractListener = (state) => {
        this._handleStakingContractStateChange(state);
      };
      this._stakingContract.on("StateChanged", this._stakingContractListener);
    }
  }
  /**
   *  Stops internal listeners/polling that refresh network state and watch for epoch changes
   */
  async disconnect() {
    this._stopListeningForNewEpoch();
    this._stopNetworkPolling();
  }
  _stopNetworkPolling() {
    if (this._networkSyncInterval) {
      clearInterval(this._networkSyncInterval);
      this._networkSyncInterval = null;
    }
  }
  _stopListeningForNewEpoch() {
    if (this._stakingContract && this._stakingContractListener) {
      this._stakingContract.off("StateChanged", this._stakingContractListener);
      this._stakingContractListener = null;
    }
  }
  /**
   * Connect to the LIT nodes
   *
   * @returns { Promise } A promise that resolves when the nodes are connected.
   *
   */
  async connect() {
    if (this._connectingPromise) {
      return this._connectingPromise;
    }
    this._connectingPromise = this._connect();
    await this._connectingPromise.finally(() => {
      this._connectingPromise = null;
    });
  }
  async _connect() {
    this._stopListeningForNewEpoch();
    this._stopNetworkPolling();
    await this.setNewConfig();
    if (!this._epochUpdateTimeout) {
      this.currentEpochNumber = await this.fetchCurrentEpochNumber();
    }
    const { connectedNodes, serverKeys, coreNodeConfig } = await this._runHandshakeWithBootstrapUrls();
    Object.assign(this, { ...coreNodeConfig, connectedNodes, serverKeys });
    this._scheduleNetworkSync();
    this._listenForNewEpoch();
    globalThis.litNodeClient = this;
    this.ready = true;
    log(`\u{1F525} lit is ready. "litNodeClient" variable is ready to use globally.`);
    log("current network config", {
      networkPubkey: this.networkPubKey,
      networkPubKeySet: this.networkPubKeySet,
      hdRootPubkeys: this.hdRootPubkeys,
      subnetPubkey: this.subnetPubKey,
      latestBlockhash: this.latestBlockhash
    });
    if (isBrowser()) {
      document.dispatchEvent(new Event("lit-ready"));
    }
  }
  async handshakeAndVerifyNodeAttestation({
    url,
    requestId
  }) {
    const challenge = this.getRandomHexString(64);
    const handshakeResult = await this.handshakeWithNode(
      { url, challenge },
      requestId
    );
    const keys = {
      serverPubKey: handshakeResult.serverPublicKey,
      subnetPubKey: handshakeResult.subnetPublicKey,
      networkPubKey: handshakeResult.networkPublicKey,
      networkPubKeySet: handshakeResult.networkPublicKeySet,
      hdRootPubkeys: handshakeResult.hdRootPubkeys,
      latestBlockhash: handshakeResult.latestBlockhash
    };
    if (keys.serverPubKey === "ERR" || keys.subnetPubKey === "ERR" || keys.networkPubKey === "ERR" || keys.networkPubKeySet === "ERR") {
      logErrorWithRequestId(
        requestId,
        'Error connecting to node. Detected "ERR" in keys',
        url,
        keys
      );
    }
    log(`Handshake with ${url} returned keys: `, keys);
    if (!keys.latestBlockhash) {
      logErrorWithRequestId(
        requestId,
        `Error getting latest blockhash from the node ${url}.`
      );
    }
    if (this.config.checkNodeAttestation || this.config.litNetwork === "manzano" /* Manzano */ || this.config.litNetwork === "habanero" /* Habanero */) {
      const attestation = handshakeResult.attestation;
      if (!attestation) {
        throwError({
          message: `Missing attestation in handshake response from ${url}`,
          errorKind: LIT_ERROR.INVALID_NODE_ATTESTATION.kind,
          errorCode: LIT_ERROR.INVALID_NODE_ATTESTATION.name
        });
      }
      log("Checking attestation against amd certs...");
      try {
        await checkSevSnpAttestation(attestation, challenge, url);
        log(`Lit Node Attestation verified for ${url}`);
      } catch (e2) {
        throwError({
          message: `Lit Node Attestation failed verification for ${url} - ${e2.message}`,
          errorKind: LIT_ERROR.INVALID_NODE_ATTESTATION.kind,
          errorCode: LIT_ERROR.INVALID_NODE_ATTESTATION.name
        });
      }
    }
    return keys;
  }
  /** Handshakes with all nodes that are in `bootstrapUrls`
   * @private
   *
   * @returns {Promise<{connectedNodes: Set<string>, serverKeys: {}}>} Returns a set of the urls of nodes that we
   * successfully connected to, an object containing their returned keys, and our 'core' config (most common values for
   * critical values)
   */
  async _runHandshakeWithBootstrapUrls() {
    const requestId = this.getRequestId();
    const connectedNodes = /* @__PURE__ */ new Set();
    const serverKeys = {};
    if (this.config.bootstrapUrls.length <= 0) {
      throwError({
        message: `Failed to get bootstrapUrls for network ${this.config.litNetwork}`,
        errorKind: LIT_ERROR.INIT_ERROR.kind,
        errorCode: LIT_ERROR.INIT_ERROR.name
      });
    }
    let timeoutHandle;
    await Promise.race([
      new Promise((_resolve, reject) => {
        timeoutHandle = setTimeout(() => {
          const msg = `Error: Could not connect to enough nodes after timeout of ${this.config.connectTimeout}ms.  Could only connect to ${Object.keys(serverKeys).length} of ${this.config.minNodeCount} required nodes, from ${this.config.bootstrapUrls.length} possible nodes.  Please check your network connection and try again.  Note that you can control this timeout with the connectTimeout config option which takes milliseconds.`;
          try {
            throwError({
              message: msg,
              errorKind: LIT_ERROR.INIT_ERROR.kind,
              errorCode: LIT_ERROR.INIT_ERROR.name
            });
          } catch (e2) {
            reject(e2);
          }
        }, this.config.connectTimeout);
      }),
      Promise.all(
        this.config.bootstrapUrls.map(async (url) => {
          serverKeys[url] = await this.handshakeAndVerifyNodeAttestation({
            url,
            requestId
          });
          connectedNodes.add(url);
        })
      ).finally(() => {
        clearTimeout(timeoutHandle);
      })
    ]);
    const coreNodeConfig = this._getCoreNodeConfigFromHandshakeResults({
      serverKeys,
      requestId
    });
    return { connectedNodes, serverKeys, coreNodeConfig };
  }
  _getCoreNodeConfigFromHandshakeResults({
    serverKeys,
    requestId
  }) {
    const latestBlockhash = mostCommonString(
      Object.values(serverKeys).map(
        (keysFromSingleNode) => keysFromSingleNode.latestBlockhash
      )
    );
    if (!latestBlockhash) {
      logErrorWithRequestId(
        requestId,
        "Error getting latest blockhash from the nodes."
      );
      throwError({
        message: "Error getting latest blockhash from the nodes.",
        errorKind: LIT_ERROR.INVALID_ETH_BLOCKHASH.kind,
        errorCode: LIT_ERROR.INVALID_ETH_BLOCKHASH.name
      });
    }
    return {
      subnetPubKey: mostCommonString(
        Object.values(serverKeys).map(
          (keysFromSingleNode) => keysFromSingleNode.subnetPubKey
        )
      ),
      networkPubKey: mostCommonString(
        Object.values(serverKeys).map(
          (keysFromSingleNode) => keysFromSingleNode.networkPubKey
        )
      ),
      networkPubKeySet: mostCommonString(
        Object.values(serverKeys).map(
          (keysFromSingleNode) => keysFromSingleNode.networkPubKeySet
        )
      ),
      hdRootPubkeys: mostCommonString(
        Object.values(serverKeys).map(
          (keysFromSingleNode) => keysFromSingleNode.hdRootPubkeys
        )
      ),
      latestBlockhash,
      lastBlockHashRetrieved: Date.now()
    };
  }
  /** Currently, we perform a full sync every 30s, including handshaking with every node
   * However, we also have a state change listener that watches for staking contract state change events, which
   * _should_ be the only time that we need to perform handshakes with every node.
   *
   * However, the current block hash does need to be updated regularly, and we currently update it only when we
   * handshake with every node.
   *
   * We can remove this network sync code entirely if we refactor our code to fetch latest blockhash on-demand.
   * @private
   */
  _scheduleNetworkSync() {
    if (this._networkSyncInterval) {
      clearInterval(this._networkSyncInterval);
    }
    this._networkSyncInterval = setInterval(async () => {
      if (!this.lastBlockHashRetrieved || Date.now() - this.lastBlockHashRetrieved >= NETWORK_SYNC_INTERVAL) {
        log(
          "Syncing state for new network context current config: ",
          this.config,
          "current blockhash: ",
          this.lastBlockHashRetrieved
        );
        try {
          await this.connect();
          log(
            "Done syncing state new config: ",
            this.config,
            "new blockhash: ",
            this.lastBlockHashRetrieved
          );
        } catch (err) {
          const { message = "" } = err;
          logError(
            "Error while attempting to refresh nodes to fetch new latestBlockhash:",
            message
          );
        }
      }
    }, NETWORK_SYNC_INTERVAL);
  }
  /**
   *
   * Get a random request ID
   *
   * @returns { string }
   *
   */
  getRequestId() {
    return Math.random().toString(16).slice(2);
  }
  /**
   *
   * Get a random hex string for use as an attestation challenge
   *
   * @returns { string }
   */
  getRandomHexString(size) {
    return [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join("");
  }
  async fetchCurrentEpochNumber() {
    if (!this._stakingContract) {
      return throwError({
        message: "Unable to fetch current epoch number; no staking contract configured. Did you forget to `connect()`?",
        errorKind: LIT_ERROR.INIT_ERROR.kind,
        errorCode: LIT_ERROR.INIT_ERROR.name
      });
    }
    try {
      const epoch = await this._stakingContract["epoch"]();
      return epoch.number.toNumber();
    } catch (error) {
      return throwError({
        message: `Error getting current epoch number: ${error}`,
        errorKind: LIT_ERROR.UNKNOWN_ERROR.kind,
        errorCode: LIT_ERROR.UNKNOWN_ERROR.name
      });
    }
  }
  get currentEpochNumber() {
    return this._epochCache.currentNumber;
  }
  set currentEpochNumber(epochNumber) {
    this._epochCache.currentNumber = epochNumber;
    this._epochCache.lastUpdateTime = Date.now();
  }
  /**
   * Calculates a Key Id for claiming a pkp based on a user identifier and an app identifier.
   * The key Identifier is an Auth Method Id which scopes the key uniquely to a specific application context.
   * These identifiers are specific to each auth method and will derive the public key portion of a pkp which will be persisted
   * when a key is claimed.
   * | Auth Method | User ID | App ID |
   * |:------------|:--------|:-------|
   * | Google OAuth | token `sub` | token `aud` |
   * | Discord OAuth | user id | client app identifier |
   * | Stytch OTP |token `sub` | token `aud`|
   * | Lit Actions | user defined | ipfs cid |
   * *Note* Lit Action claiming uses a different schema than other auth methods
   *
   * @param {string} userId user identifier for the Key Identifier
   * @param {string} appId app identifier for the Key Identifier
   * @param {boolean} isForActionContext should be set for true if using claiming through actions
   *
   * @returns {string} public key of pkp when claimed
   */
  computeHDKeyId(userId, appId, isForActionContext = false) {
    if (!isForActionContext) {
      return ethers_exports.utils.keccak256(
        ethers_exports.utils.toUtf8Bytes(`${userId}:${appId}`)
      );
    } else {
      return ethers_exports.utils.keccak256(
        ethers_exports.utils.toUtf8Bytes(`${appId}:${userId}`)
      );
    }
  }
};

// packages/encryption/src/index.ts
init_shim();

// packages/encryption/src/lib/encryption.ts
init_shim();
import * as JSZip from "jszip/dist/jszip.js";

// packages/encryption/src/lib/params-validators.ts
init_shim();
var import_utils8 = __toESM(require_utils2());

// packages/encryption/src/lib/utils.ts
init_shim();
function isTokenOperator(token) {
  const OPERATORS = ["and", "or"];
  return token.hasOwnProperty("operator") && OPERATORS.includes(token.operator);
}
function isValidBooleanExpression(expression) {
  const STATES = {
    START: "start",
    CONDITION: "condition",
    OPERATOR: "operator"
  };
  let currentState = STATES.START;
  for (const token of expression) {
    switch (currentState) {
      case STATES.START:
      case STATES.OPERATOR:
        if (isTokenOperator(token)) {
          return false;
        }
        if (Array.isArray(token) && !isValidBooleanExpression(token)) {
          return false;
        }
        currentState = STATES.CONDITION;
        break;
      default:
        if (!isTokenOperator(token)) {
          return false;
        }
        currentState = STATES.OPERATOR;
    }
  }
  return currentState === STATES.CONDITION;
}

// packages/encryption/src/lib/params-validators.ts
var safeParams = ({
  functionName,
  params
}) => {
  if (!paramsValidators[functionName]) {
    log(`This function ${functionName} is skipping params safe guarding.`);
    return ERight(void 0);
  }
  const paramValidators = paramsValidators[functionName](params);
  for (const validator of paramValidators) {
    const validationResponse = validator.validate();
    if (validationResponse.type === "ERROR" /* ERROR */) {
      return validationResponse;
    }
  }
  return ERight(void 0);
};
var paramsValidators = {
  executeJs: (params) => [
    new AuthMaterialValidator("executeJs", params),
    new ExecuteJsValidator("executeJs", params),
    new AuthMethodValidator("executeJs", params.authMethods)
  ],
  encrypt: (params) => [
    new AccessControlConditionsValidator("encrypt", params),
    new AuthMaterialValidator("encrypt", params, true)
  ],
  encryptFile: (params) => [
    new AccessControlConditionsValidator("encryptFile", params),
    new AuthMaterialValidator("encryptFile", params),
    new FileValidator("encryptFile", params.file)
  ],
  encryptString: (params) => [
    new AccessControlConditionsValidator("encryptString", params),
    new AuthMaterialValidator("encryptString", params, true),
    new StringValidator("encryptString", params.dataToEncrypt, "dataToEncrypt")
  ],
  encryptZip: (params) => [
    new AccessControlConditionsValidator("encryptZip", params),
    new AuthMaterialValidator("encryptZip", params)
  ],
  zipAndEncryptString: (params) => [
    new StringValidator("zipAndEncryptString", params.dataToEncrypt)
  ],
  decrypt: (params) => [
    new AccessControlConditionsValidator("decrypt", params),
    new AuthMaterialValidator("decrypt", params, true),
    new StringValidator("decrypt", params.ciphertext, "ciphertext")
  ],
  decryptZipFileWithMetadata: (params) => [
    new AuthMaterialValidator("decryptZipFileWithMetadata", params),
    new FileValidator("decryptZipFileWithMetadata", params.file)
  ],
  decryptToZip: (params) => [
    new FileValidator("decryptToZip", params.encryptedZipBlob)
  ],
  encryptToIpfs: (params) => [
    new AccessControlConditionsValidator("encryptToIpfs", params),
    new AuthMaterialValidator("encryptToIpfs", params, true),
    new IpfsValidator("encryptToIpfs", params)
  ],
  decryptFromIpfs: (params) => [
    new AuthMaterialValidator("decryptFromIpfs", params)
  ],
  encryptFileAndZipWithMetadata: (params) => [
    new AuthMaterialValidator("encryptFileAndZipWithMetadata", params, true),
    new AccessControlConditionsValidator(
      "encryptFileAndZipWithMetadata",
      params
    ),
    new FileValidator("encryptFileAndZipWithMetadata", params.file),
    new StringValidator(
      "encryptFileAndZipWithMetadata",
      params.readme,
      "readme"
    )
  ],
  getSignedToken: (params) => [
    new AccessControlConditionsValidator("decrypt", params),
    new AuthMaterialValidator("decrypt", params, true)
  ]
};
var IpfsValidator = class {
  constructor(fnName, params) {
    this.fnName = fnName;
    this.params = params;
  }
  validate() {
    const validators = [
      new FileValidator(this.fnName, this.params.file),
      new StringValidator(this.fnName, this.params.string)
    ];
    for (const validator of validators) {
      const validationResponse = validator.validate();
      if (validationResponse.type === "ERROR" /* ERROR */) {
        return validationResponse;
      }
    }
    const { file, string, infuraId, infuraSecretKey } = this.params;
    if (string === void 0 && file === void 0)
      return ELeft({
        message: `Either string or file must be provided`,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (!infuraId || !infuraSecretKey)
      return ELeft({
        message: "Please provide your Infura Project Id and Infura API Key Secret to add the encrypted metadata on IPFS",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (string !== void 0 && file !== void 0)
      return ELeft({
        message: "Provide only either a string or file to encrypt",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    return ERight(void 0);
  }
};
var StringValidator = class {
  constructor(fnName, str, paramName = "string", checkIsHex = false) {
    this.fnName = fnName;
    this.paramName = paramName;
    this.checkIsHex = checkIsHex;
    this.str = str;
  }
  validate() {
    if (!this.str) {
      return ELeft({
        message: "string is undefined",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    }
    if (!checkType({
      value: this.str,
      allowedTypes: ["String"],
      paramName: this.paramName,
      functionName: this.fnName
    }))
      return ELeft({
        message: `${this.paramName} is not a string`,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (this.checkIsHex && !(0, import_utils8.isHexString)(this.str)) {
      return ELeft({
        message: `${this.paramName} is not a valid hex string`,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    }
    return ERight(void 0);
  }
};
var AuthMethodValidator = class {
  constructor(fnName, authMethods) {
    this.fnName = fnName;
    this.authMethods = authMethods;
  }
  validate() {
    const { fnName, authMethods } = this;
    if (authMethods && authMethods.length > 0 && !checkType({
      value: authMethods,
      allowedTypes: ["Array"],
      paramName: "authMethods",
      functionName: this.fnName
    }))
      return ELeft({
        message: `authMethods is not an array`,
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    return ERight(void 0);
  }
};
var ExecuteJsValidator = class {
  constructor(fnName, params) {
    this.fnName = fnName;
    this.params = params;
  }
  validate() {
    const { code, ipfsId } = this.params;
    if (!code && !ipfsId) {
      return ELeft({
        message: "You must pass either code or ipfsId",
        errorKind: LIT_ERROR.PARAMS_MISSING_ERROR.kind,
        errorCode: LIT_ERROR.PARAMS_MISSING_ERROR.name
      });
    }
    if (code && ipfsId) {
      return ELeft({
        message: "You cannot have both 'code' and 'ipfs' at the same time",
        errorKind: LIT_ERROR.PARAMS_MISSING_ERROR.kind,
        errorCode: LIT_ERROR.PARAMS_MISSING_ERROR.name
      });
    }
    return ERight(void 0);
  }
};
var FileValidator = class {
  constructor(fnName, file) {
    this.fnName = fnName;
    this.file = file;
  }
  validate() {
    if (!this.file) {
      return ELeft({
        message: "You must pass file param",
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    }
    if (!checkType({
      value: this.file,
      allowedTypes: ["Blob", "File", "Uint8Array"],
      paramName: "file",
      functionName: this.fnName
    }))
      return ELeft({
        message: "File param is not a valid Blob or File object",
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    return ERight(void 0);
  }
};
var AuthMaterialValidator = class {
  constructor(fnName, params, checkIfAuthSigRequiresChainParam2 = false) {
    this.fnName = fnName;
    this.authMaterial = params;
    this.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam2;
  }
  validate() {
    const { authSig, sessionSigs } = this.authMaterial;
    if (authSig && !is(authSig, "Object", "authSig", this.fnName))
      return ELeft({
        message: "authSig is not an object",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (this.checkIfAuthSigRequiresChainParam) {
      if (!this.authMaterial.chain)
        return ELeft({
          message: "You must pass chain param",
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      if (authSig && !checkIfAuthSigRequiresChainParam(
        authSig,
        this.authMaterial.chain,
        this.fnName
      ))
        return ELeft({
          message: "authSig is not valid",
          errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
          errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
        });
    }
    if (sessionSigs && !is(sessionSigs, "Object", "sessionSigs", this.fnName))
      return ELeft({
        message: "sessionSigs is not an object",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (!sessionSigs && !authSig)
      return ELeft({
        message: "You must pass either authSig or sessionSigs",
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    if (sessionSigs && authSig)
      return ELeft({
        message: "You cannot have both authSig and sessionSigs",
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    return ERight(void 0);
  }
};
var AccessControlConditionsValidator = class {
  constructor(fnName, params) {
    this.fnName = fnName;
    this.conditions = params;
  }
  validate() {
    const {
      accessControlConditions,
      evmContractConditions,
      solRpcConditions,
      unifiedAccessControlConditions
    } = this.conditions;
    if (accessControlConditions && !is(
      accessControlConditions,
      "Array",
      "accessControlConditions",
      this.fnName
    ))
      return ELeft({
        message: "accessControlConditions is not an array",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (evmContractConditions && !is(evmContractConditions, "Array", "evmContractConditions", this.fnName))
      return ELeft({
        message: "evmContractConditions is not an array",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (solRpcConditions && !is(solRpcConditions, "Array", "solRpcConditions", this.fnName))
      return ELeft({
        message: "solRpcConditions is not an array",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (unifiedAccessControlConditions && !is(
      unifiedAccessControlConditions,
      "Array",
      "unifiedAccessControlConditions",
      this.fnName
    ))
      return ELeft({
        message: "unifiedAccessControlConditions is not an array",
        errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
        errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
      });
    if (!accessControlConditions && !evmContractConditions && !solRpcConditions && !unifiedAccessControlConditions)
      return ELeft({
        message: "You must pass either accessControlConditions, evmContractConditions, solRpcConditions or unifiedAccessControlConditions",
        errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
      });
    if (accessControlConditions && !isValidBooleanExpression(accessControlConditions))
      return ELeft({
        message: "Invalid boolean Access Control Conditions",
        errorKind: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name
      });
    if (evmContractConditions && !isValidBooleanExpression(evmContractConditions))
      return ELeft({
        message: "Invalid boolean EVM Access Control Conditions",
        errorKind: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name
      });
    if (solRpcConditions && !isValidBooleanExpression(solRpcConditions))
      return ELeft({
        message: "Invalid boolean Solana Access Control Conditions",
        errorKind: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name
      });
    if (unifiedAccessControlConditions && !isValidBooleanExpression(unifiedAccessControlConditions))
      return ELeft({
        message: "Invalid boolean Unified Access Control Conditions",
        errorKind: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
        errorCode: LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name
      });
    return ERight(void 0);
  }
};

// packages/encryption/src/lib/encryption.ts
import * as ipfsClient from "ipfs-http-client";
var encryptString = async (params, litNodeClient) => {
  const paramsIsSafe = safeParams({
    functionName: "encryptString",
    params
  });
  if (paramsIsSafe.type === "ERROR" /* ERROR */)
    return throwError({
      message: `Invalid params: ${paramsIsSafe.result.message}`,
      errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
      errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
    });
  return litNodeClient.encrypt({
    ...params,
    dataToEncrypt: uint8arrayFromString(params.dataToEncrypt, "utf8")
  });
};
var decryptToString = async (params, litNodeClient) => {
  const paramsIsSafe = safeParams({
    functionName: "decrypt",
    params
  });
  if (paramsIsSafe.type === "ERROR" /* ERROR */)
    return throwError({
      message: `Invalid params: ${paramsIsSafe.result.message}`,
      errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
      errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
    });
  const { decryptedData } = await litNodeClient.decrypt(params);
  return uint8arrayToString(decryptedData, "utf8");
};

// packages/misc-browser/src/index.ts
init_shim();

// packages/misc-browser/src/lib/misc-browser.ts
init_shim();
var getStorageItem = (key2) => {
  let item;
  try {
    item = localStorage.getItem(key2);
  } catch (e2) {
  }
  if (!item) {
    return ELeft({
      message: `Failed to get ${key2} from local storage`,
      errorKind: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.kind,
      errorCode: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.name
    });
  }
  return ERight(item);
};
var setStorageItem = (key2, value) => {
  try {
    localStorage.setItem(key2, value);
    return ERight(value);
  } catch (e2) {
    return ELeft({
      message: `Failed to set ${key2} in local storage`,
      error: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_SET_EXCEPTION
    });
  }
};
var removeStorageItem = (key2) => {
  try {
    localStorage.removeItem(key2);
    return ERight(key2);
  } catch (e2) {
    return ELeft({
      message: `Failed to remove ${key2} from local storage`,
      error: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_REMOVED_EXCEPTION
    });
  }
};

// packages/lit-node-client-nodejs/src/lib/lit-node-client-nodejs.ts
var sessionKeyCache = null;
var LitNodeClientNodeJs = class _LitNodeClientNodeJs extends LitCore {
  // ========== Constructor ==========
  constructor(args) {
    super(args);
    // ========== Rate Limit NFT ==========
    // TODO: Add support for browser feature/lit-2321-js-sdk-add-browser-support-for-createCapacityDelegationAuthSig
    this.createCapacityDelegationAuthSig = async (params) => {
      const {
        dAppOwnerWallet,
        capacityTokenId,
        delegateeAddresses,
        uses,
        domain,
        expiration,
        statement
      } = params;
      if (!params.delegateeAddresses || params.delegateeAddresses.length === 0) {
        log(
          `[createCapacityDelegationAuthSig] No delegatee addresses provided. It means that the capability will not restrict access based on delegatee list, but it may still enforce other restrictions such as usage limits and specific NFT IDs.`
        );
      }
      const dAppOwnerWalletAddress = ethers_exports.utils.getAddress(
        await dAppOwnerWallet.getAddress()
      );
      if (!this.ready) {
        await this.connect();
      }
      if (!dAppOwnerWallet) {
        throw new Error("dAppOwnerWallet must exist");
      }
      const nonce = this.getLatestBlockhash();
      const siweMessage = await createSiweMessageWithCapacityDelegation({
        uri: "lit:capability:delegation" /* CAPABILITY_DELEGATION */,
        litNodeClient: this,
        walletAddress: dAppOwnerWalletAddress,
        nonce,
        // -- default configuration for recap object capability
        expiration: expiration ?? new Date(Date.now() + 1e3 * 60 * 7).toISOString(),
        domain: domain ?? "example.com",
        statement: statement ?? "This is a test statement.  You can put anything you want here.",
        // -- capacity delegation specific configuration
        uses: uses ?? "1",
        delegateeAddresses,
        capacityTokenId
      });
      const authSig = await craftAuthSig({
        signer: dAppOwnerWallet,
        toSign: siweMessage
      });
      return { capacityDelegationAuthSig: authSig };
    };
    // ========== Scoped Class Helpers ==========
    /**
     *
     * Get the request body of the lit action
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { JsonExecutionRequest }
     *
     */
    this.getLitActionRequestBody = (params) => {
      const reqBody = {
        ...params.authSig && { authSig: params.authSig },
        ...params.sessionSigs && { sessionSigs: params.sessionSigs },
        ...params.authMethods && { authMethods: params.authMethods },
        jsParams: convertLitActionsParams(params.jsParams),
        // singleNode: params.singleNode ?? false,
        targetNodeRange: params.targetNodeRange ?? 0
      };
      if (params.code) {
        const _uint8Array = uint8arrayFromString(params.code, "utf8");
        const encodedJs = uint8arrayToString(_uint8Array, "base64");
        reqBody.code = encodedJs;
      }
      if (params.ipfsId) {
        reqBody.ipfsId = params.ipfsId;
      }
      if (params.authMethods && params.authMethods.length > 0) {
        reqBody.authMethods = params.authMethods;
      }
      return reqBody;
    };
    /**
     *
     * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
     *
     */
    this.getJWTParams = () => {
      const now2 = Date.now();
      const iat = Math.floor(now2 / 1e3);
      const exp = iat + 12 * 60 * 60;
      return { iat, exp };
    };
    /**
     *
     * Parse the response string to JSON
     *
     * @param { string } responseString
     *
     * @returns { any } JSON object
     *
     */
    this.parseResponses = (responseString) => {
      let response;
      try {
        response = JSON.parse(responseString);
      } catch (e2) {
        log(
          "Error parsing response as json.  Swallowing and returning as string.",
          responseString
        );
      }
      return response;
    };
    // ==================== SESSIONS ====================
    /**
     * Try to get the session key in the local storage,
     * if not, generates one.
     * @return { SessionKeyPair } session key pair
     */
    this.getSessionKey = () => {
      const storageKey = LOCAL_STORAGE_KEYS.SESSION_KEY;
      const storedSessionKeyOrError = getStorageItem(storageKey);
      log(`[getSessionKey] storageKey: ${storageKey}`);
      log(
        `[getSessionKey] storedSessionKeyOrError: ${JSON.stringify(
          storedSessionKeyOrError
        )}`
      );
      if (storedSessionKeyOrError.type === "ERROR" /* ERROR */ || !storedSessionKeyOrError.result || storedSessionKeyOrError.result === "") {
        log(
          `[getSessionKey] Storage key "${storageKey}" is missing.Not a problem.Contiune...`
        );
        if (sessionKeyCache && Date.now() - sessionKeyCache.timestamp < 3e4) {
          log(`[getSessionKey] Returning session key from cache.`);
          return sessionKeyCache.value;
        }
        const newSessionKey = generateSessionKeyPair();
        log(`[getSessionKey] newSessionKey: ${JSON.stringify(newSessionKey)}`);
        try {
          localStorage.setItem(storageKey, JSON.stringify(newSessionKey));
          log(`[getSessionKey] newSessionKey set to local storage`);
        } catch (e2) {
          log(
            `[getSessionKey] Localstorage not available.Not a problem.Contiune...`
          );
          sessionKeyCache = {
            value: newSessionKey,
            timestamp: Date.now()
          };
          log(`[getSessionKey] newSessionKey set to cache: `, sessionKeyCache);
        }
        return newSessionKey;
      } else {
        log(`[getSessionKey] Storage key "${storageKey}" found.Continue...`);
        return JSON.parse(storedSessionKeyOrError.result);
      }
    };
    // backward compatibility
    this.getExpiration = () => {
      return _LitNodeClientNodeJs.getExpiration();
    };
    /**
     * returns the latest block hash.
     * will call refresh if the block hash is expired
     * @returns {Promise<string>} latest block hash from `handhsake` with the lit network.
     */
    this.getLatestBlockhash = () => {
      if (!this.ready) {
        logError("Client not connected, remember to call connect");
        throwError({
          message: "Client not connected",
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.code
        });
      }
      return this.latestBlockhash;
    };
    /**
     *
     * Get the signature from local storage, if not, generates one
     *
     */
    this.getWalletSig = async ({
      authNeededCallback,
      chain,
      sessionCapabilityObject,
      switchChain,
      expiration,
      sessionKeyUri,
      nonce,
      resourceAbilityRequests,
      litActionCode,
      ipfsId,
      jsParams
    }) => {
      let walletSig;
      const storageKey = LOCAL_STORAGE_KEYS.WALLET_SIGNATURE;
      const storedWalletSigOrError = getStorageItem(storageKey);
      log(`[getWalletSig] flow starts
        storageKey: ${storageKey}
        storedWalletSigOrError: ${JSON.stringify(storedWalletSigOrError)}
  `);
      if (storedWalletSigOrError.type === "ERROR" /* ERROR */ || !storedWalletSigOrError.result || storedWalletSigOrError.result == "") {
        log("[getWalletSig] flow 1");
        log(
          `[getWalletSig] storageKey: ${storageKey} is missing.Not a problem.Continue...`
        );
        if (authNeededCallback) {
          log("[getWalletSig] flow 1.1");
          log(
            `[getWalletSig] authNeededCallback found from params.Creating a callback body...`
          );
          const body = {
            chain,
            statement: sessionCapabilityObject?.statement,
            resources: sessionCapabilityObject ? [sessionCapabilityObject.encodeAsSiweResource()] : void 0,
            ...switchChain && { switchChain },
            expiration,
            uri: sessionKeyUri,
            nonce,
            ...resourceAbilityRequests && { resourceAbilityRequests },
            ...litActionCode && { litActionCode },
            ...ipfsId && { ipfsId },
            ...jsParams && { jsParams }
          };
          log("[getWalletSig] callback body:", body);
          log(
            `[getWalletSig] passing the callback body to the authNeededCallback.Please note that the implementation differs based on user's implementation.`
          );
          walletSig = await authNeededCallback(body);
          log(
            `[getWalletSig] walletSig from user's authNeededCallback`,
            walletSig
          );
        } else {
          log("[getWalletSig] flow 1.2");
          if (!this.defaultAuthCallback) {
            log("[getWalletSig] flow 1.2.1");
            return throwError({
              message: "No default auth callback provided",
              errorKind: LIT_ERROR.PARAMS_MISSING_ERROR.kind,
              errorCode: LIT_ERROR.PARAMS_MISSING_ERROR.name
            });
          }
          log("[getWalletSig] flow 1.2.2");
          walletSig = await this.defaultAuthCallback({
            chain,
            statement: sessionCapabilityObject.statement,
            resources: sessionCapabilityObject ? [sessionCapabilityObject.encodeAsSiweResource()] : void 0,
            switchChain,
            expiration,
            uri: sessionKeyUri,
            nonce
          });
        }
        log("[getWalletSig] flow 1.3");
        const storeNewWalletSigOrError = setStorageItem(
          storageKey,
          JSON.stringify(walletSig)
        );
        if (storeNewWalletSigOrError.type === "ERROR") {
          log("[getWalletSig] flow 1.4");
          console.warn(
            `Unable to store walletSig in local storage. Not a problem. Continue...`
          );
        }
      } else {
        log("[getWalletSig] flow 2");
        try {
          walletSig = JSON.parse(storedWalletSigOrError.result);
          log("[getWalletSig] flow 2.1");
        } catch (e2) {
          console.warn("Error parsing walletSig", e2);
          log("[getWalletSig] flow 2.2");
        }
      }
      log("[getWalletSig] flow 3");
      return walletSig;
    };
    this.#authCallbackAndUpdateStorageItem = async ({
      authCallbackParams,
      authCallback
    }) => {
      let authSig;
      if (authCallback) {
        authSig = await authCallback(authCallbackParams);
      } else {
        if (!this.defaultAuthCallback) {
          return throwError({
            message: "No default auth callback provided",
            errorKind: LIT_ERROR.PARAMS_MISSING_ERROR.kind,
            errorCode: LIT_ERROR.PARAMS_MISSING_ERROR.name
          });
        }
        authSig = await this.defaultAuthCallback(authCallbackParams);
      }
      const storeNewWalletSigOrError = setStorageItem(
        LOCAL_STORAGE_KEYS.WALLET_SIGNATURE,
        JSON.stringify(authSig)
      );
      if (storeNewWalletSigOrError.type === "SUCCESS" /* SUCCESS */) {
        return authSig;
      }
      console.warn(
        `Unable to store walletSig in local storage. Not a problem. Continuing to remove item key...`
      );
      const removeWalletSigOrError = removeStorageItem(
        LOCAL_STORAGE_KEYS.WALLET_SIGNATURE
      );
      if (removeWalletSigOrError.type === "ERROR" /* ERROR */) {
        console.warn(
          `Unable to remove walletSig in local storage. Not a problem. Continuing...`
        );
      }
      return authSig;
    };
    /**
     *
     * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
     * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
     * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
     * 3. The authSig.signedMessage does not contain at least one session capability object
     *
     */
    this.checkNeedToResignSessionKey = async ({
      authSig,
      sessionKeyUri,
      resourceAbilityRequests
    }) => {
      const authSigSiweMessage = new siwe2.SiweMessage(authSig.signedMessage);
      try {
        await authSigSiweMessage.validate(authSig.sig);
      } catch (e2) {
        console.debug("Need retry because verify failed", e2);
        return true;
      }
      if (authSigSiweMessage.uri !== sessionKeyUri) {
        console.debug("Need retry because uri does not match");
        return true;
      }
      if (!authSigSiweMessage.resources || authSigSiweMessage.resources.length === 0) {
        console.debug("Need retry because empty resources");
        return true;
      }
      const authSigSessionCapabilityObject = decode3(
        authSigSiweMessage.resources[0]
      );
      for (const resourceAbilityRequest of resourceAbilityRequests) {
        if (!authSigSessionCapabilityObject.verifyCapabilitiesForResource(
          resourceAbilityRequest.resource,
          resourceAbilityRequest.ability
        )) {
          console.debug("Need retry because capabilities do not match", {
            authSigSessionCapabilityObject,
            resourceAbilityRequest
          });
          return true;
        }
      }
      return false;
    };
    // ==================== API Calls to Nodes ====================
    /**
     *
     * Get JS Execution Shares from Nodes
     *
     * @param { JsonExecutionRequest } params
     *
     * @returns { Promise<any> }
     */
    this.getJsExecutionShares = async (url, params, requestId) => {
      const { code, ipfsId, authSig, jsParams, authMethods } = params;
      logWithRequestId(requestId, "getJsExecutionShares");
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/execute" /* EXECUTE_JS */
      });
      if (!authSig) {
        throw new Error("authSig or sessionSig is required");
      }
      const data = {
        ...authSig ? { authSig } : {},
        ...code ? { code } : {},
        ...ipfsId ? { ipfsId } : {},
        ...authMethods ? { authMethods } : {},
        ...jsParams ? { jsParams } : {}
      };
      const res = await this.sendCommandToNode({
        url: urlWithPath,
        data,
        requestId
      });
      logWithRequestId(
        requestId,
        `response node with url: ${url} from endpoint ${urlWithPath}`,
        res
      );
      return res;
    };
    this.getPkpSignExecutionShares = async (url, params, requestId) => {
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/pkp/sign" /* PKP_SIGN */
      });
      logWithRequestId(requestId, `[getPkpSigningShares] ${urlWithPath}`);
      if (!params.authSig) {
        throw new Error("authSig is required");
      }
      return await this.sendCommandToNode({
        url: urlWithPath,
        data: params,
        requestId
      });
    };
    this.getClaimKeyExecutionShares = async (url, params, requestId) => {
      logWithRequestId(requestId, "getPkpSigningShares");
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/pkp/claim" /* PKP_CLAIM */
      });
      if (!params.authMethod) {
        throw new Error("authMethod is required");
      }
      return await this.sendCommandToNode({
        url: urlWithPath,
        data: params,
        requestId
      });
    };
    /**
     * Get Signing Shares for Token containing Access Control Condition
     *
     * @param { string } url
     * @param { SigningAccessControlConditionRequest } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    this.getSigningShareForToken = async (url, params, requestId) => {
      logWithRequestId(requestId, "getSigningShareForToken");
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/signing/access_control_condition" /* SIGN_ACCS */
      });
      return this.sendCommandToNode({
        url: urlWithPath,
        data: params,
        requestId
      });
    };
    /**
     *
     * Get signature shares for decryption.
     *
     * @param url
     * @param params
     * @param requestId
     * @returns
     */
    this.getSigningShareForDecryption = async (url, params, requestId) => {
      log("getSigningShareForDecryption");
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/encryption/sign" /* ENCRYPTION_SIGN */
      });
      return await this.sendCommandToNode({
        url: urlWithPath,
        data: params,
        requestId
      });
    };
    /**
     *
     * Sign Condition ECDSA
     *
     * @param { string } url
     * @param { SignConditionECDSA } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    this.signConditionEcdsa = async (url, params, requestId) => {
      const wrapper = async (id2) => {
        log("signConditionEcdsa");
        const urlWithPath = composeLitUrl({
          url,
          endpoint: "/web/signing/signConditionEcdsa" /* SIGN_ECDSA */
        });
        const data = {
          access_control_conditions: params.accessControlConditions,
          evmContractConditions: params.evmContractConditions,
          solRpcConditions: params.solRpcConditions,
          auth_sig: params.auth_sig,
          chain: params.chain,
          iat: params.iat,
          exp: params.exp
        };
        return await this.sendCommandToNode({
          url: urlWithPath,
          data,
          requestId: id2
        });
      };
      const res = await executeWithRetry(
        wrapper,
        (_error, _requestid, isFinal) => {
          if (!isFinal) {
            logError("An error occured. attempting to retry: ");
          }
        },
        this.config.retryTolerance
      );
      return res;
    };
    /**
     *
     * Combine Shares from network public key set and signature shares
     *
     * @param { NodeBlsSigningShare } signatureShares
     *
     * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
     *
     */
    this.combineSharesAndGetJWT = (signatureShares, requestId = "") => {
      if (!signatureShares.every(
        (val, i2, arr) => val.unsignedJwt === arr[0].unsignedJwt
      )) {
        const msg = "Unsigned JWT is not the same from all the nodes.  This means the combined signature will be bad because the nodes signed the wrong things";
        logErrorWithRequestId(requestId, msg);
      }
      signatureShares.sort((a2, b) => a2.shareIndex - b.shareIndex);
      const signature2 = combineSignatureShares(
        signatureShares.map((s2) => s2.signatureShare)
      );
      logWithRequestId(requestId, "signature is", signature2);
      const unsignedJwt = mostCommonString(
        signatureShares.map((s2) => s2.unsignedJwt)
      );
      const finalJwt = `${unsignedJwt}.${uint8arrayToString(
        uint8arrayFromString(signature2, "base16"),
        "base64urlpad"
      )}`;
      return finalJwt;
    };
    this.#decryptWithSignatureShares = (networkPubKey, identityParam, ciphertext, signatureShares) => {
      const sigShares = signatureShares.map((s2) => s2.signatureShare);
      return verifyAndDecryptWithSignatureShares(
        networkPubKey,
        identityParam,
        ciphertext,
        sigShares
      );
    };
    // ========== Promise Handlers ==========
    // to be deprecated
    this.getIpfsId = async ({
      dataToHash,
      authSig,
      debug = false
    }) => {
      const laRes = await this.executeJs({
        authSig,
        ipfsId: LIT_ACTION_IPFS_HASH,
        authMethods: [],
        jsParams: {
          dataToHash
        },
        debug
      }).catch((e2) => {
        logError("Error getting IPFS ID", e2);
        throw e2;
      });
      const data = JSON.parse(laRes.response).res;
      if (!data.success) {
        logError("Error getting IPFS ID", data.data);
      }
      return data.data;
    };
    /**
     * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
     *
     * Lit Action: dataToHash -> IPFS CID
     * QmUjX8MW6StQ7NKNdaS6g4RMkvN5hcgtKmEi8Mca6oX4t3
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     *
     */
    this.runOnTargetedNodes = async (params) => {
      const {
        code,
        authMethods,
        authSig,
        jsParams,
        debug,
        sessionSigs,
        targetNodeRange
      } = params;
      log("running runOnTargetedNodes:", targetNodeRange);
      if (!targetNodeRange) {
        return throwError({
          message: "targetNodeRange is required",
          errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
          errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
        });
      }
      const ipfsId = await this.getIpfsId({
        dataToHash: code,
        authSig,
        debug
      });
      const randomSelectedNodeIndexes = [];
      let nodeCounter = 0;
      while (randomSelectedNodeIndexes.length < targetNodeRange) {
        const str = `${nodeCounter}:${ipfsId.toString()}`;
        const cidBuffer = Buffer.from(str);
        const hash3 = (0, import_utils10.sha256)(cidBuffer);
        const hashAsNumber = BigNumber.from(hash3);
        const nodeIndex = hashAsNumber.mod(this.config.bootstrapUrls.length).toNumber();
        log("nodeIndex:", nodeIndex);
        if (!randomSelectedNodeIndexes.includes(nodeIndex) && nodeIndex < this.config.bootstrapUrls.length) {
          randomSelectedNodeIndexes.push(nodeIndex);
        }
        nodeCounter++;
      }
      log("Final Selected Indexes:", randomSelectedNodeIndexes);
      const wrapper = async (id2) => {
        const nodePromises = [];
        for (let i2 = 0; i2 < randomSelectedNodeIndexes.length; i2++) {
          const nodeIndex = randomSelectedNodeIndexes[i2];
          const url = this.config.bootstrapUrls[nodeIndex];
          log(`running on node ${nodeIndex} at ${url}`);
          const reqBody = this.getLitActionRequestBody(params);
          const sigToPassToNode = this.getSessionOrAuthSig({
            authSig,
            sessionSigs,
            url
          });
          reqBody.authSig = sigToPassToNode;
          const singleNodePromise = this.getJsExecutionShares(url, reqBody, id2);
          nodePromises.push(singleNodePromise);
        }
        const handledPromise = await this.handleNodePromises(
          nodePromises,
          id2,
          targetNodeRange
        );
        return handledPromise;
      };
      return executeWithRetry(
        wrapper,
        (_error, _requestId, isFinal) => {
          if (!isFinal) {
            logError("error has occured, attempting to retry");
          }
        },
        this.config.retryTolerance
      );
    };
    // ========== Shares Resolvers ==========
    this._getFlattenShare = (share) => {
      const flattenObj = Object.entries(share).map(([key2, item]) => {
        if (item === null || item === void 0) {
          return null;
        }
        const typedItem = item;
        const requiredShareProps = [
          "sigType",
          "dataSigned",
          "signatureShare",
          "shareIndex",
          "bigR",
          "publicKey"
        ];
        const requiredSessionSigsShareProps = [
          ...requiredShareProps,
          "siweMessage"
        ];
        const requiredSignatureShareProps = [
          ...requiredShareProps,
          "sigName"
        ];
        const hasProps = (props) => {
          return [...props].every(
            (prop) => typedItem[prop] !== void 0 && typedItem[prop] !== null
          );
        };
        if (hasProps(requiredSessionSigsShareProps) || hasProps(requiredSignatureShareProps)) {
          const bigR = typedItem.bigR ?? typedItem.bigr;
          typedItem.signatureShare = typedItem.signatureShare.replaceAll('"', "");
          typedItem.bigR = bigR?.replaceAll('"', "");
          typedItem.publicKey = typedItem.publicKey.replaceAll('"', "");
          typedItem.dataSigned = typedItem.dataSigned.replaceAll('"', "");
          return typedItem;
        }
        return null;
      });
      const flattenShare = flattenObj.filter(
        (item) => item !== null
      )[0];
      if (flattenShare === null || flattenShare === void 0) {
        return share;
      }
      return flattenShare;
    };
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    this.getSessionSignatures = (signedData) => {
      const signatures = {};
      const keys = Object.keys(signedData[0]);
      const sanitise = (str) => {
        if (typeof str === "string") {
          let newStr = str.replace(/\\+/g, "");
          newStr = newStr.replace(/^"|"$/g, "");
          return newStr;
        }
        return str;
      };
      keys.forEach((key2) => {
        log("[getSessionSignatures] key:", key2);
        const shares = signedData.map((r3) => r3[key2]);
        log("[getSessionSignatures] shares:", shares);
        shares.sort((a2, b) => a2.shareIndex - b.shareIndex);
        const sigShares = shares.map((s2, index) => {
          log("[getSessionSignatures] Original Share Struct:", s2);
          const share = this._getFlattenShare(s2);
          log("[getSessionSignatures] share:", share);
          if (!share) {
            throw new Error("share is null or undefined");
          }
          if (!share.bigr) {
            throw new Error(
              `bigR is missing in share ${index}. share ${JSON.stringify(share)}`
            );
          }
          const sanitisedBigR = sanitise(share.bigr);
          const sanitisedSigShare = sanitise(share.publicKey);
          log("[getSessionSignatures] sanitisedBigR:", sanitisedBigR);
          log("[getSessionSignatures] sanitisedSigShare:", sanitisedSigShare);
          return {
            sigType: share.sigType,
            signatureShare: sanitise(share.signatureShare),
            shareIndex: share.shareIndex,
            bigR: sanitise(share.bigr),
            publicKey: share.publicKey,
            dataSigned: share.dataSigned,
            siweMessage: share.siweMessage
          };
        });
        log("[getSessionSignatures] sigShares", sigShares);
        const sigType = mostCommonString(sigShares.map((s2) => s2.sigType));
        if (this.networkPubKeySet === null) {
          throwError({
            message: "[getSessionSignatures] networkPubKeySet cannot be null",
            errorKind: LIT_ERROR.PARAM_NULL_ERROR.kind,
            errorCode: LIT_ERROR.PARAM_NULL_ERROR.name
          });
          return;
        }
        if (sigType !== "ECDSA_CAIT_SITH" /* EcdsaCaitSith */ && sigType !== "K256" /* EcdsaK256 */ && sigType !== "EcdsaCaitSithP256" /* EcdsaCAITSITHP256 */) {
          throwError({
            message: `[getSessionSignatures] signature type is ${sigType} which is invalid`,
            errorKind: LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.kind,
            errorCode: LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.name
          });
          return;
        }
        const signature2 = combineEcdsaShares(sigShares);
        if (!signature2.r) {
          throwError({
            message: "[getSessionSignatures] siganture could not be combined",
            errorKind: LIT_ERROR.UNKNOWN_SIGNATURE_ERROR.kind,
            errorCode: LIT_ERROR.UNKNOWN_SIGNATURE_ERROR.name
          });
        }
        const encodedSig = (0, import_utils10.joinSignature)({
          r: "0x" + signature2.r,
          s: "0x" + signature2.s,
          v: signature2.recid
        });
        log(`[getSessionSignatures] encodedSig: ${encodedSig}`);
        signatures[key2] = {
          ...signature2,
          signature: encodedSig,
          publicKey: mostCommonString(sigShares.map((s2) => s2.publicKey)),
          dataSigned: mostCommonString(sigShares.map((s2) => s2.dataSigned)),
          siweMessage: mostCommonString(sigShares.map((s2) => s2.siweMessage))
        };
        log(`[getSessionSignatures] signatures[${key2}]:`, signatures[key2]);
      });
      return signatures;
    };
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    this.getSignatures = (signedData, requestId = "") => {
      const initialKeys = [...new Set(signedData.flatMap((i3) => Object.keys(i3)))];
      for (const signatureResponse of signedData) {
        for (const sigName of Object.keys(signatureResponse)) {
          const requiredFields = ["signatureShare"];
          for (const field of requiredFields) {
            if (!signatureResponse[sigName][field]) {
              logWithRequestId(
                requestId,
                `invalid field ${field} in signature share: ${sigName}, continuing with share processing`
              );
              delete signatureResponse[sigName];
            } else {
              let share = this._getFlattenShare(signatureResponse[sigName]);
              share = {
                sigType: share.sigType,
                signatureShare: share.signatureShare,
                shareIndex: share.shareIndex,
                bigR: share.bigR,
                publicKey: share.publicKey,
                dataSigned: share.dataSigned,
                sigName: share.sigName ? share.sigName : "sig"
              };
              signatureResponse[sigName] = share;
            }
          }
        }
      }
      const validatedSignedData = signedData;
      const signatures = {};
      const allKeys = [
        ...new Set(validatedSignedData.flatMap((i3) => Object.keys(i3)))
      ];
      if (allKeys.length !== initialKeys.length) {
        throwError({
          message: "total number of valid signatures does not match requested",
          errorKind: LIT_ERROR.NO_VALID_SHARES.kind,
          errorCode: LIT_ERROR.NO_VALID_SHARES.code
        });
      }
      for (var i2 = 0; i2 < allKeys.length; i2++) {
        const shares = validatedSignedData.map((r3) => r3[allKeys[i2]]).filter((r3) => r3 !== void 0);
        shares.sort((a2, b) => a2.shareIndex - b.shareIndex);
        const sigName = shares[0].sigName;
        logWithRequestId(
          requestId,
          `[getSignatures] starting signature combine for sig name: ${sigName}`,
          shares
        );
        logWithRequestId(
          requestId,
          `[getSignatures] number of shares for ${sigName}:`,
          signedData.length
        );
        logWithRequestId(
          requestId,
          `[getSignatures] validated length for signature: ${sigName}`,
          shares.length
        );
        logWithRequestId(
          requestId,
          "[getSignatures] minimum required shares for threshold:",
          this.config.minNodeCount
        );
        if (shares.length < this.config.minNodeCount) {
          logErrorWithRequestId(
            requestId,
            `[getSignatures] not enough nodes to get the signatures.  Expected ${this.config.minNodeCount}, got ${shares.length}`
          );
          throwError({
            message: `[getSignatures] The total number of valid signatures shares ${shares.length} does not meet the threshold of ${this.config.minNodeCount}`,
            errorKind: LIT_ERROR.NO_VALID_SHARES.kind,
            errorCode: LIT_ERROR.NO_VALID_SHARES.code,
            requestId
          });
        }
        const sigType = mostCommonString(shares.map((s2) => s2.sigType));
        if (this.networkPubKeySet === null) {
          throwError({
            message: "[getSignatures] networkPubKeySet cannot be null",
            errorKind: LIT_ERROR.PARAM_NULL_ERROR.kind,
            errorCode: LIT_ERROR.PARAM_NULL_ERROR.name
          });
          return;
        }
        if (sigType !== "ECDSA_CAIT_SITH" /* EcdsaCaitSith */ && sigType !== "K256" /* EcdsaK256 */ && sigType !== "EcdsaCaitSithP256" /* EcdsaCAITSITHP256 */) {
          throwError({
            message: `[getSignatures] signature type is ${sigType} which is invalid`,
            errorKind: LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.kind,
            errorCode: LIT_ERROR.UNKNOWN_SIGNATURE_TYPE.name
          });
          return;
        }
        const signature2 = combineEcdsaShares(shares);
        if (!signature2.r) {
          throwError({
            message: "[getSignatures] siganture could not be combined",
            errorKind: LIT_ERROR.UNKNOWN_SIGNATURE_ERROR.kind,
            errorCode: LIT_ERROR.UNKNOWN_SIGNATURE_ERROR.name
          });
        }
        const encodedSig = (0, import_utils10.joinSignature)({
          r: "0x" + signature2.r,
          s: "0x" + signature2.s,
          v: signature2.recid
        });
        signatures[allKeys[i2]] = {
          ...signature2,
          signature: encodedSig,
          publicKey: mostCommonString(shares.map((s2) => s2.publicKey)),
          dataSigned: mostCommonString(shares.map((s2) => s2.dataSigned))
        };
      }
      return signatures;
    };
    /**
     *
     * Get a single signature
     *
     * @param { Array<any> } shareData from all node promises
     *
     * @returns { string } signature
     *
     */
    this.getSignature = async (shareData, requestId) => {
      const R_x = shareData[0].local_x;
      const R_y = shareData[0].local_y;
      const valid_shares = shareData.map((s2) => s2.signature_share);
      const shares = JSON.stringify(valid_shares);
      await wasmECDSA.initWasmEcdsaSdk();
      const signature2 = wasmECDSA.combine_signature(R_x, R_y, shares);
      logWithRequestId(requestId, "raw ecdsa sig", signature2);
      return signature2;
    };
    /**
     *
     * Execute JS on the nodes and combine and return any resulting signatures
     *
     * @param { ExecuteJsRequest } params
     *
     * @returns { ExecuteJsResponse }
     *
     */
    this.executeJs = async (params) => {
      const {
        authMethods,
        code,
        ipfsId,
        authSig,
        jsParams,
        debug,
        sessionSigs,
        targetNodeRange
      } = params;
      if (!this.ready) {
        const message = "1 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      const paramsIsSafe = safeParams({
        functionName: "executeJs",
        params
      });
      if (!paramsIsSafe) {
        return throwError({
          message: "executeJs params are not valid",
          errorKind: LIT_ERROR.INVALID_PARAM_TYPE.kind,
          errorCode: LIT_ERROR.INVALID_PARAM_TYPE.name
        });
      }
      params = _LitNodeClientNodeJs.normalizeParams(params);
      let res;
      let requestId = "";
      if (targetNodeRange) {
        res = await this.runOnTargetedNodes(params);
      } else {
        const reqBody = this.getLitActionRequestBody(params);
        const wrapper = async (requestId2) => {
          const nodePromises = this.getNodePromises((url) => {
            const sigToPassToNode = this.getSessionOrAuthSig({
              authSig,
              sessionSigs,
              url
            });
            reqBody.authSig = sigToPassToNode;
            const shares = this.getJsExecutionShares(url, reqBody, requestId2);
            return shares;
          });
          res = await this.handleNodePromises(
            nodePromises,
            requestId2,
            this.connectedNodes.size
          );
          return res;
        };
        res = await executeWithRetry(
          wrapper,
          (error, requestId2, isFinal) => {
            logError("an error occured, attempting to retry operation");
          },
          this.config.retryTolerance
        );
        requestId = res.requestId;
      }
      if (res.success === false) {
        this._throwNodeError(res, requestId);
      }
      const responseData = res.values;
      logWithRequestId(
        requestId,
        "[executeJs] responseData from node : ",
        JSON.stringify(responseData, null, 2)
      );
      if (responseData[0].success && Object.keys(responseData[0].signedData).length <= 0 && Object.keys(responseData[0].claimData).length <= 0) {
        return responseData[0];
      }
      if (Object.keys(responseData[0].signedData).length <= 0 && Object.keys(responseData[0].claimData).length <= 0) {
        return {
          claims: {},
          signatures: null,
          decryptions: [],
          response: responseData[0].response,
          logs: responseData[0].logs
        };
      }
      const signedDataList = responseData.map((r3) => {
        const { signedData } = r3;
        for (const key2 of Object.keys(signedData)) {
          for (const subkey of Object.keys(signedData[key2])) {
            if (typeof signedData[key2][subkey] === "string") {
              signedData[key2][subkey] = signedData[key2][subkey].replaceAll(
                '"',
                ""
              );
            }
          }
        }
        return signedData;
      });
      logWithRequestId(
        requestId,
        "signatures shares to combine: ",
        signedDataList
      );
      const signatures = this.getSignatures(signedDataList, requestId);
      let response = mostCommonString(
        responseData.map((r3) => r3.response)
      );
      response = this.parseResponses(response);
      const mostCommonLogs = mostCommonString(
        responseData.map((r3) => r3.logs)
      );
      const claimsList = responseData.map((r3) => {
        const { claimData } = r3;
        if (claimData) {
          for (const key2 of Object.keys(claimData)) {
            for (const subkey of Object.keys(claimData[key2])) {
              if (typeof claimData[key2][subkey] == "string") {
                claimData[key2][subkey] = claimData[key2][subkey].replaceAll(
                  '"',
                  ""
                );
              }
            }
          }
          return claimData;
        }
        return null;
      }).filter((item) => item !== null);
      let claims = void 0;
      if (claimsList.length > 0) {
        claims = _LitNodeClientNodeJs.getClaims(claimsList);
      }
      const returnVal = {
        claims,
        signatures,
        decryptions: [],
        // FIXME: Fix if and when we enable decryptions from within a Lit Action.
        response,
        logs: mostCommonLogs
      };
      log("[executeJs] returnVal:", returnVal);
      if (debug) {
        const allNodeResponses = responseData.map(
          (r3) => r3.response
        );
        const allNodeLogs = responseData.map((r3) => r3.logs);
        returnVal.debug = {
          allNodeResponses,
          allNodeLogs,
          rawNodeHTTPResponses: responseData
        };
      }
      return returnVal;
    };
    this.pkpSign = async (params) => {
      let { authSig, sessionSigs, toSign, pubKey, authMethods } = params;
      log("[pkpSign] params:", params);
      pubKey = hexPrefixed(pubKey);
      ["toSign", "pubKey"].forEach((key2) => {
        if (!params[key2]) {
          throwError({
            message: `[pkpSign] "${key2}" cannot be undefined, empty, or null. Please provide a valid value.`,
            errorKind: LIT_ERROR.PARAM_NULL_ERROR.kind,
            errorCode: LIT_ERROR.PARAM_NULL_ERROR.name
          });
        }
      });
      if (!authSig && !sessionSigs && (!authMethods || authMethods.length <= 0)) {
        throwError({
          message: `[pkpSign] Either authSig, sessionSigs, or authMethods (length > 0) must be present.`,
          errorKind: LIT_ERROR.PARAM_NULL_ERROR.kind,
          errorCode: LIT_ERROR.PARAM_NULL_ERROR.name
        });
      }
      const arr = [];
      for (let i2 = 0; i2 < toSign.length; i2++) {
        arr.push(toSign[i2]);
      }
      toSign = arr;
      const wrapper = async (id2) => {
        const nodePromises = this.getNodePromises((url) => {
          const sigToPassToNode = this.getSessionOrAuthSig({
            authSig,
            sessionSigs,
            url,
            mustHave: false
          });
          logWithRequestId(id2, "[pkpSign] sigToPassToNode:", sigToPassToNode);
          const reqBody = {
            toSign,
            pubkey: pubKey,
            ...sigToPassToNode && sigToPassToNode !== void 0 && { authSig: sigToPassToNode },
            ...authMethods && authMethods.length > 0 && { authMethods }
          };
          logWithRequestId(id2, "[pkpSign] reqBody:", reqBody);
          return this.getPkpSignExecutionShares(url, reqBody, id2);
        });
        const res2 = await this.handleNodePromises(
          nodePromises,
          id2,
          this.connectedNodes.size
          // ECDSA requires responses from all nodes, but only shares from minNodeCount.
        );
        return res2;
      };
      const res = await executeWithRetry(
        wrapper,
        (error, requestId2, isFinal) => {
          if (!isFinal) {
            logError("[pkpSign] error occured, retrying operation");
          }
        },
        this.config.retryTolerance
      );
      const requestId = res.requestId;
      if (!res.success) {
        this._throwNodeError(res, requestId);
      }
      const responseData = res.values;
      logWithRequestId(
        requestId,
        "[pkpSign] responseData",
        JSON.stringify(responseData, null, 2)
      );
      const signedDataList = responseData.map((r3) => {
        delete r3.signatureShare.result;
        const snakeToCamel = (s2) => s2.replace(/(_\w)/g, (k) => k[1].toUpperCase());
        const convertShare = (share) => {
          const keys2 = Object.keys(share);
          let convertedShare2 = {};
          for (const key2 of keys2) {
            convertedShare2 = Object.defineProperty(
              convertedShare2,
              snakeToCamel(key2),
              Object.getOwnPropertyDescriptor(share, key2)
            );
          }
          return convertedShare2;
        };
        const convertedShare = convertShare(r3.signatureShare);
        const keys = Object.keys(convertedShare);
        for (const key2 of keys) {
          if (typeof convertedShare[key2] === "string") {
            convertedShare[key2] = convertedShare[key2].replace('"', "").replace('"', "");
          }
        }
        convertedShare.dataSigned = convertedShare.digest;
        return {
          signature: convertedShare
        };
      });
      const signatures = this.getSignatures(signedDataList, requestId);
      logWithRequestId(requestId, `[pkpSign] signature combination`, signatures);
      return signatures.signature;
    };
    /**
     *
     * Request a signed JWT from the LIT network. Before calling this function, you must know the access control conditions for the item you wish to gain authorization for.
     *
     * @param { GetSignedTokenRequest } params
     *
     * @returns { Promise<string> } final JWT
     *
     */
    this.getSignedToken = async (params) => {
      const { chain, authSig, sessionSigs } = params;
      if (!this.ready) {
        const message = "3 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      if (this.networkPubKeySet === null) {
        return throwError({
          message: "networkPubKeySet cannot be null",
          errorKind: LIT_ERROR.PARAM_NULL_ERROR.kind,
          errorCode: LIT_ERROR.PARAM_NULL_ERROR.name
        });
      }
      const paramsIsSafe = safeParams({
        functionName: "getSignedToken",
        params
      });
      if (!paramsIsSafe) {
        return throwError({
          message: `Parameter validation failed.`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const { iat, exp } = this.getJWTParams();
      const {
        error,
        formattedAccessControlConditions,
        formattedEVMContractConditions,
        formattedSolRpcConditions,
        formattedUnifiedAccessControlConditions
      } = this.getFormattedAccessControlConditions(params);
      if (error) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const wrapper = async (id2) => {
        const nodePromises = this.getNodePromises((url) => {
          const authSigToSend = sessionSigs ? sessionSigs[url] : authSig;
          return this.getSigningShareForToken(
            url,
            {
              accessControlConditions: formattedAccessControlConditions,
              evmContractConditions: formattedEVMContractConditions,
              solRpcConditions: formattedSolRpcConditions,
              unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
              chain,
              authSig: authSigToSend,
              iat,
              exp
            },
            id2
          );
        });
        const res2 = await this.handleNodePromises(
          nodePromises,
          id2,
          this.config.minNodeCount
        );
        return res2;
      };
      const res = await executeWithRetry(
        wrapper,
        (error2, requestId2, isFinal) => {
          if (!isFinal) {
            logError("an error occured, attempting to retry ");
          }
        },
        this.config.retryTolerance
      );
      const requestId = res.requestId;
      if (res.success === false) {
        this._throwNodeError(res, requestId);
      }
      const signatureShares = res.values;
      log("signatureShares", signatureShares);
      const finalJwt = this.combineSharesAndGetJWT(
        signatureShares,
        requestId
      );
      return finalJwt;
    };
    /**
     *
     * Encrypt data using the LIT network public key.
     *
     */
    this.encrypt = async (params) => {
      if (!this.ready) {
        const message = "6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      if (!this.subnetPubKey) {
        const message = "subnetPubKey cannot be null";
        return throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      const paramsIsSafe = safeParams({
        functionName: "encrypt",
        params
      });
      if (!paramsIsSafe) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      await this.validateAccessControlConditionsSchema(params);
      const hashOfConditions = await this.getHashedAccessControlConditions(params);
      if (!hashOfConditions) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const hashOfConditionsStr = uint8arrayToString(
        new Uint8Array(hashOfConditions),
        "base16"
      );
      const hashOfPrivateData = await crypto.subtle.digest(
        "SHA-256",
        params.dataToEncrypt
      );
      const hashOfPrivateDataStr = uint8arrayToString(
        new Uint8Array(hashOfPrivateData),
        "base16"
      );
      const identityParam = this.#getIdentityParamForEncryption(
        hashOfConditionsStr,
        hashOfPrivateDataStr
      );
      const ciphertext = encrypt3(
        this.subnetPubKey,
        params.dataToEncrypt,
        uint8arrayFromString(identityParam, "utf8")
      );
      return { ciphertext, dataToEncryptHash: hashOfPrivateDataStr };
    };
    /**
     *
     * Decrypt ciphertext with the LIT network.
     *
     */
    this.decrypt = async (params) => {
      const { authSig, sessionSigs, chain, ciphertext, dataToEncryptHash } = params;
      if (!this.ready) {
        const message = "6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      if (!this.subnetPubKey) {
        const message = "subnetPubKey cannot be null";
        return throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      const paramsIsSafe = safeParams({
        functionName: "decrypt",
        params
      });
      if (!paramsIsSafe) {
        return throwError({
          message: `Parameter validation failed.`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const hashOfConditions = await this.getHashedAccessControlConditions(params);
      if (!hashOfConditions) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const hashOfConditionsStr = uint8arrayToString(
        new Uint8Array(hashOfConditions),
        "base16"
      );
      const {
        error,
        formattedAccessControlConditions,
        formattedEVMContractConditions,
        formattedSolRpcConditions,
        formattedUnifiedAccessControlConditions
      } = this.getFormattedAccessControlConditions(params);
      if (error) {
        throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const identityParam = this.#getIdentityParamForEncryption(
        hashOfConditionsStr,
        dataToEncryptHash
      );
      log("identityParam", identityParam);
      const wrapper = async (id2) => {
        const nodePromises = this.getNodePromises((url) => {
          const authSigToSend = sessionSigs ? sessionSigs[url] : authSig;
          return this.getSigningShareForDecryption(
            url,
            {
              accessControlConditions: formattedAccessControlConditions,
              evmContractConditions: formattedEVMContractConditions,
              solRpcConditions: formattedSolRpcConditions,
              unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
              dataToEncryptHash,
              chain,
              authSig: authSigToSend
            },
            id2
          );
        });
        const res2 = await this.handleNodePromises(
          nodePromises,
          id2,
          this.config.minNodeCount
        );
        return res2;
      };
      const res = await executeWithRetry(
        wrapper,
        (_error, _requestId, _isFinal) => {
          logError("an error occured attempting to retry");
        },
        this.config.retryTolerance
      );
      const requestId = res.requestId;
      if (res.success === false) {
        this._throwNodeError(res, requestId);
      }
      const signatureShares = res.values;
      logWithRequestId(requestId, "signatureShares", signatureShares);
      const decryptedData = this.#decryptWithSignatureShares(
        this.subnetPubKey,
        uint8arrayFromString(identityParam, "utf8"),
        ciphertext,
        signatureShares
      );
      return { decryptedData };
    };
    this.getLitResourceForEncryption = async (params) => {
      const hashOfConditions = await this.getHashedAccessControlConditions(params);
      if (!hashOfConditions) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      const hashOfConditionsStr = uint8arrayToString(
        new Uint8Array(hashOfConditions),
        "base16"
      );
      const hashOfPrivateData = await crypto.subtle.digest(
        "SHA-256",
        params.dataToEncrypt
      );
      const hashOfPrivateDataStr = uint8arrayToString(
        new Uint8Array(hashOfPrivateData),
        "base16"
      );
      return new LitAccessControlConditionResource(
        `${hashOfConditionsStr}/${hashOfPrivateDataStr}`
      );
    };
    this.#getIdentityParamForEncryption = (hashOfConditionsStr, hashOfPrivateDataStr) => {
      return new LitAccessControlConditionResource(
        `${hashOfConditionsStr}/${hashOfPrivateDataStr}`
      ).getResourceKey();
    };
    /**
     *
     * Validates a condition, and then signs the condition if the validation returns true.
     * Before calling this function, you must know the on chain conditions that you wish to validate.
     *
     * @param { ValidateAndSignECDSA } params
     *
     * @returns { Promise<string> }
     */
    this.validateAndSignEcdsa = async (params) => {
      if (!this.ready) {
        const message = "7 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      const { accessControlConditions, chain, auth_sig } = params;
      const { iat, exp } = this.getJWTParams();
      if (!accessControlConditions) {
        return throwError({
          message: `You must provide either accessControlConditions or evmContractConditions or solRpcConditions`,
          errorKind: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
          errorCode: LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name
        });
      }
      let formattedAccessControlConditions;
      formattedAccessControlConditions = accessControlConditions.map(
        (c) => canonicalAccessControlConditionFormatter(c)
      );
      log(
        "formattedAccessControlConditions",
        JSON.stringify(formattedAccessControlConditions)
      );
      const wrapper = async (id2) => {
        const nodePromises = this.getNodePromises((url) => {
          return this.signConditionEcdsa(
            url,
            {
              accessControlConditions: formattedAccessControlConditions,
              evmContractConditions: void 0,
              solRpcConditions: void 0,
              auth_sig,
              chain,
              iat,
              exp
            },
            id2
          );
        });
        const responses = await this.handleNodePromises(
          nodePromises,
          id2,
          this.connectedNodes.size
        );
        return responses;
      };
      const res = await executeWithRetry(
        wrapper,
        (_error, _requestId, isFinal) => {
          if (!isFinal) {
            logError("an error has occured, attempting to retry ");
          }
        },
        this.config.retryTolerance
      );
      const requestId = res.requestId;
      try {
        if (res.success === false) {
          return "Condition Failed";
        }
        const shareData = res.values;
        const signature2 = this.getSignature(shareData, requestId);
        return signature2;
      } catch (e2) {
        logErrorWithRequestId(requestId, "Error - signed_ecdsa_messages - ", e2);
        const signed_ecdsa_message = res;
        return signed_ecdsa_message;
      }
    };
    /** ============================== SESSION ============================== */
    /**
     * Sign a session public key using a PKP, which generates an authSig.
     * @returns {Object} An object containing the resulting signature.
     */
    this.signSessionKey = async (params) => {
      log(`[signSessionKey] params:`, params);
      if (!this.ready) {
        const message = "[signSessionKey] ]LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
        throwError({
          message,
          errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
          errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
        });
      }
      const _expiration = params.expiration || new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
      let sessionKeyUri;
      if (params?.sessionKeyUri) {
        sessionKeyUri = params.sessionKeyUri;
        log(`[signSessionKey] sessionKeyUri found in params:`, sessionKeyUri);
      } else {
        let sessionKey = params.sessionKey ?? this.getSessionKey();
        sessionKeyUri = "lit:session:" /* SESSION_KEY */ + sessionKey.publicKey;
        log(
          `[signSessionKey] sessionKeyUri is not found in params, generating a new one`,
          sessionKeyUri
        );
      }
      if (!sessionKeyUri) {
        throw new Error(
          "[signSessionKey] sessionKeyUri is not defined. Please provide a sessionKeyUri or a sessionKey."
        );
      }
      const pkpEthAddress = function() {
        params.pkpPublicKey = hexPrefixed(params.pkpPublicKey);
        if (params.pkpPublicKey)
          return computeAddress(params.pkpPublicKey);
        return "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
      }();
      let siwe_statement = "Lit Protocol PKP session signature";
      if (params.statement) {
        siwe_statement += " " + params.statement;
        log(`[signSessionKey] statement found in params: "${params.statement}"`);
      }
      let siweMessage;
      const siweParams = {
        domain: params?.domain || globalThis.location?.host || "litprotocol.com",
        walletAddress: pkpEthAddress,
        statement: siwe_statement,
        uri: sessionKeyUri,
        version: "1",
        chainId: params.chainId ?? 1,
        expiration: _expiration,
        nonce: this.latestBlockhash
      };
      if (params.resourceAbilityRequests) {
        siweMessage = await createSiweMessageWithRecaps({
          ...siweParams,
          resources: params.resourceAbilityRequests,
          litNodeClient: this
        });
      } else {
        siweMessage = await createSiweMessage(siweParams);
      }
      const body = {
        sessionKey: sessionKeyUri,
        authMethods: params.authMethods,
        ...params?.pkpPublicKey && { pkpPublicKey: params.pkpPublicKey },
        ...params?.authSig && { authSig: params.authSig },
        siweMessage,
        curveType: "BLS" /* BLS */,
        // -- custom auths
        ...params?.litActionCode && { code: params.litActionCode },
        ...params?.jsParams && { jsParams: params.jsParams },
        ...this.currentEpochNumber && { epoch: this.currentEpochNumber }
      };
      log(`[signSessionKey] body:`, body);
      const wrapper = async (id2) => {
        logWithRequestId(id2, "signSessionKey body", body);
        const nodePromises = this.getNodePromises((url) => {
          return this.getSignSessionKeyShares(
            url,
            {
              body
            },
            id2
          );
        });
        let res2;
        try {
          res2 = await this.handleNodePromises(
            nodePromises,
            id2,
            this.connectedNodes.size
          );
          log("signSessionKey node promises:", res2);
        } catch (e2) {
          throw new Error(`Error when handling node promises: ${e2}`);
        }
        return res2;
      };
      const res = await executeWithRetry(
        wrapper,
        (_error, _requestId, isFinal) => {
          if (!isFinal) {
            logError("an error occured, attempting to retry ");
          }
        },
        this.config.retryTolerance
      );
      const requestId = res.requestId;
      logWithRequestId(requestId, "handleNodePromises res:", res);
      if (!this.#isSuccessNodePromises(res)) {
        this._throwNodeError(res, requestId);
        return {};
      }
      const responseData = res.values;
      logWithRequestId(
        requestId,
        "[signSessionKey] responseData",
        JSON.stringify(responseData, null, 2)
      );
      let curveType = responseData[0]?.curveType;
      if (!curveType) {
        log(`[signSessionKey] curveType not found. Defaulting to ECDSA.`);
        curveType = "ECDSA";
      }
      log(`[signSessionKey] curveType is "${curveType}"`);
      let signedDataList = [];
      if (curveType === "BLS" /* BLS */) {
        let _responseData = responseData;
        const signatureShares = _responseData.map((s2) => ({
          ProofOfPossession: s2.signatureShare.ProofOfPossession
        }));
        log(`[signSessionKey] signatureShares:`, signatureShares);
        signedDataList = _responseData.map((s2) => {
          return s2.dataSigned;
        });
        signedDataList = _responseData;
      } else {
        signedDataList = responseData.map(
          (r3) => r3.signedData
        );
      }
      if (signedDataList.length <= 0) {
        const err = `[signSessionKey] signedDataList is empty.`;
        log(err);
        throw new Error(err);
      }
      logWithRequestId(
        requestId,
        "[signSessionKey] signedDataList",
        signedDataList
      );
      const validatedSignedDataList = signedDataList.map((signedData) => {
        const sessionSig2 = signedData["sessionSig"] ?? signedData;
        if (sessionSig2["curveType"] && !sessionSig2["sigType"]) {
          sessionSig2["sigType"] = sessionSig2["curveType"];
        }
        let requiredFields = curveType === "BLS" /* BLS */ ? [
          "signatureShare",
          "curveType",
          "shareIndex",
          "siweMessage",
          "dataSigned",
          "blsRootPubkey",
          "result"
        ] : [
          "sigType",
          "dataSigned",
          "signatureShare",
          "bigr",
          "publicKey",
          "sigName",
          "siweMessage"
        ];
        for (const field of requiredFields) {
          if (!sessionSig2[field] || sessionSig2[field] === "") {
            log(
              `[signSessionKey] Invalid signed data. "${field}" is missing. Not a problem, we only need ${this.config.minNodeCount} nodes to sign the session key.`
            );
            return null;
          }
        }
        if (curveType === "BLS" /* BLS */) {
          if (!sessionSig2.signatureShare.ProofOfPossession) {
            const err = `[signSessionKey] Invalid signed data. "ProofOfPossession" is missing.`;
            log(err);
            throw new Error(err);
          }
        }
        return signedData;
      }).filter((item) => item !== null);
      logWithRequestId(
        requestId,
        "[signSessionKey] requested length:",
        signedDataList.length
      );
      logWithRequestId(
        requestId,
        "[signSessionKey] validated length:",
        validatedSignedDataList.length
      );
      logWithRequestId(
        requestId,
        "[signSessionKey] minimum required length:",
        this.config.minNodeCount
      );
      if (validatedSignedDataList.length < this.config.minNodeCount) {
        throw new Error(
          `[signSessionKey] not enough nodes signed the session key.  Expected ${this.config.minNodeCount}, got ${validatedSignedDataList.length}`
        );
      }
      let signatures;
      if (curveType === "BLS" /* BLS */) {
        const blsSignedData = validatedSignedDataList;
        const sigType = mostCommonString(
          blsSignedData.map((s2) => s2.sigType)
        );
        log(`[signSessionKey] sigType:`, sigType);
        const signatureShares = blsSignedData.map((s2) => ({
          ProofOfPossession: s2.signatureShare.ProofOfPossession
        }));
        log(`[signSessionKey] signatureShares:`, signatureShares);
        const blsCombinedSignature = combine_signature_shares(
          signatureShares.map((s2) => JSON.stringify(s2))
        );
        log(`[signSessionKey] blsCombinedSignature:`, blsCombinedSignature);
        const publicKey = params.pkpPublicKey.startsWith("0x") ? params.pkpPublicKey.slice(2) : params.pkpPublicKey;
        const dataSigned = mostCommonString(
          blsSignedData.map((s2) => s2.dataSigned)
        );
        const siweMessage2 = mostCommonString(
          blsSignedData.map((s2) => s2.siweMessage)
        );
        signatures = {
          sessionSig: {
            signature: blsCombinedSignature,
            publicKey,
            dataSigned,
            siweMessage: siweMessage2
          }
        };
      } else {
        signatures = this.getSessionSignatures(validatedSignedDataList);
      }
      log("[signSessionKey] signatures:", signatures);
      const { sessionSig } = signatures;
      const signedMessage = normalizeAndStringify(sessionSig.siweMessage);
      log(`[signSessionKey] signedMessage:`, signedMessage);
      if (curveType === "BLS" /* BLS */) {
        return {
          authSig: {
            sig: JSON.stringify({
              ProofOfPossession: sessionSig.signature
            }),
            algo: "LIT_BLS" /* BLS */,
            derivedVia: "lit.bls" /* BLS */,
            signedMessage,
            address: computeAddress("0x" + sessionSig.publicKey)
          },
          pkpPublicKey: sessionSig.publicKey
        };
      }
      return {
        authSig: {
          sig: sessionSig.signature,
          derivedVia: "web3.eth.personal.sign via Lit PKP" /* LIT_ETH_PERSONAL_SIGN */,
          signedMessage,
          address: computeAddress("0x" + sessionSig.publicKey)
        },
        pkpPublicKey: sessionSig.publicKey
      };
    };
    this.#isSuccessNodePromises = (res) => {
      return res.success === true;
    };
    this.getSignSessionKeyShares = async (url, params, requestId) => {
      const urlWithPath = composeLitUrl({
        url,
        endpoint: "/web/sign_session_key" /* SIGN_SESSION_KEY */
      });
      log(`[getSignSessionKeyShares] from ${urlWithPath}`);
      return await this.sendCommandToNode({
        url: urlWithPath,
        data: params.body,
        requestId
      });
    };
    this.generateAuthMethodForWebAuthn = (params) => ({
      authMethodType: AUTH_METHOD_TYPE_IDS.WEBAUTHN,
      accessToken: JSON.stringify(params)
    });
    this.generateAuthMethodForDiscord = (access_token) => ({
      authMethodType: AUTH_METHOD_TYPE_IDS.DISCORD,
      accessToken: access_token
    });
    this.generateAuthMethodForGoogle = (access_token) => ({
      authMethodType: AUTH_METHOD_TYPE_IDS.GOOGLE,
      accessToken: access_token
    });
    this.generateAuthMethodForGoogleJWT = (access_token) => ({
      authMethodType: AUTH_METHOD_TYPE_IDS.GOOGLE_JWT,
      accessToken: access_token
    });
    /**
     * Get session signatures for a set of resources
     *
     * High level, how this works:
     * 1. Generate or retrieve session key
     * 2. Generate or retrieve the wallet signature of the session key
     * 3. Sign the specific resources with the session key
     *
     * Note: When generating session signatures for different PKPs or auth methods,
     * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
     *
     * @param { GetSessionSigsProps } params
     */
    this.getSessionSigs = async (params) => {
      const sessionKey = params.sessionKey ?? this.getSessionKey();
      log("[getSessionSigs] sessionKey:", sessionKey);
      const sessionKeyUri = this.getSessionKeyUri(sessionKey.publicKey);
      log("[getSessionSigs] sessionKeyUri:", sessionKeyUri);
      const sessionCapabilityObject = params.sessionCapabilityObject ? params.sessionCapabilityObject : await this.generateSessionCapabilityObjectWithWildcards(
        params.resourceAbilityRequests.map((r3) => r3.resource)
      );
      const expiration = params.expiration || _LitNodeClientNodeJs.getExpiration();
      if (!this.latestBlockhash) {
        throwError({
          message: "Eth Blockhash is undefined.",
          errorKind: LIT_ERROR.INVALID_ETH_BLOCKHASH.kind,
          errorCode: LIT_ERROR.INVALID_ETH_BLOCKHASH.name
        });
      }
      const nonce = this.latestBlockhash;
      log("[getSessionSigs] Trying to get wallet signature for session key");
      let authSig = await this.getWalletSig({
        authNeededCallback: params.authNeededCallback,
        chain: params.chain || "ethereum",
        sessionCapabilityObject,
        switchChain: params.switchChain,
        expiration,
        sessionKeyUri,
        nonce,
        resourceAbilityRequests: params.resourceAbilityRequests,
        // -- optional fields
        ...params.litActionCode && { litActionCode: params.litActionCode },
        ...params.ipfsId && { ipfsId: params.ipfsId },
        ...params.jsParams && { jsParams: params.jsParams }
      });
      const needToResignSessionKey = await this.checkNeedToResignSessionKey({
        authSig,
        sessionKeyUri,
        resourceAbilityRequests: params.resourceAbilityRequests
      });
      log("[getSessionSigs] needToResignSessionKey:", needToResignSessionKey);
      if (needToResignSessionKey) {
        log("[getSessionSigs] need to re-sign session key.  Signing...");
        authSig = await this.#authCallbackAndUpdateStorageItem({
          authCallback: params.authNeededCallback,
          authCallbackParams: {
            chain: params.chain || "ethereum",
            statement: sessionCapabilityObject.statement,
            resources: [sessionCapabilityObject.encodeAsSiweResource()],
            switchChain: params.switchChain,
            expiration,
            uri: sessionKeyUri,
            nonce,
            resourceAbilityRequests: params.resourceAbilityRequests
          }
        });
      }
      if (authSig.address === "" || authSig.derivedVia === "" || authSig.sig === "" || authSig.signedMessage === "") {
        throwError({
          message: "[getSessionSigs] No wallet signature found",
          errorKind: LIT_ERROR.WALLET_SIGNATURE_NOT_FOUND_ERROR.kind,
          errorCode: LIT_ERROR.WALLET_SIGNATURE_NOT_FOUND_ERROR.name
        });
        return;
      }
      const sessionExpiration = new Date(Date.now() + 1e3 * 60 * 5);
      const capabilities = params.capacityDelegationAuthSig ? [
        ...params.capabilityAuthSigs ?? [],
        params.capacityDelegationAuthSig,
        authSig
      ] : [...params.capabilityAuthSigs ?? [], authSig];
      log("[getSessionSigs] capabilities:", capabilities);
      const signingTemplate = {
        sessionKey: sessionKey.publicKey,
        resourceAbilityRequests: params.resourceAbilityRequests,
        capabilities,
        issuedAt: (/* @__PURE__ */ new Date()).toISOString(),
        expiration: sessionExpiration.toISOString()
      };
      log("[getSessionSigs] signingTemplate:", signingTemplate);
      const signatures = {};
      this.connectedNodes.forEach((nodeAddress) => {
        const toSign = {
          ...signingTemplate,
          nodeAddress
        };
        log(`[getSessionSigs] toSign:`, toSign);
        const signedMessage = JSON.stringify(toSign);
        log(`[getSessionSigs] signedMessage: ${signedMessage}`);
        const uint8arrayKey = uint8arrayFromString(
          sessionKey.secretKey,
          "base16"
        );
        const uint8arrayMessage = uint8arrayFromString(signedMessage, "utf8");
        const signature2 = nacl.sign.detached(uint8arrayMessage, uint8arrayKey);
        log(`[getSessionSigs] signature:`, signature2);
        const signatureObject = {
          sig: uint8arrayToString(signature2, "base16"),
          derivedVia: "litSessionSignViaNacl" /* LIT_SESSION_SIGN */,
          signedMessage,
          address: sessionKey.publicKey,
          algo: "ed25519" /* ED25519 */
        };
        signatures[nodeAddress] = signatureObject;
        log(
          `[getSessionSigs] signatureObject from ${nodeAddress}`,
          signatureObject
        );
      });
      log("[getSessionSigs] sessionSigs:", signatures);
      return signatures;
    };
    /**
     * Get PKP session sigs
     */
    this.getPkpSessionSigs = async (params) => {
      const chain = params?.chain || "ethereum";
      const pkpSessionSigs = this.getSessionSigs({
        chain,
        ...params,
        authNeededCallback: async (props) => {
          if (!props.expiration) {
            throw new Error(
              "[getPkpSessionSigs/callback] expiration is required"
            );
          }
          if (!props.resources) {
            throw new Error("[getPkpSessionSigs/callback]resources is required");
          }
          if (!props.resourceAbilityRequests) {
            throw new Error(
              "[getPkpSessionSigs/callback]resourceAbilityRequests is required"
            );
          }
          if (props.litActionCode && props.ipfsId) {
            throw new Error(
              "[getPkpSessionSigs/callback]litActionCode and ipfsId cannot exist at the same time"
            );
          }
          const response = await this.signSessionKey({
            statement: props.statement || "Some custom statement.",
            authMethods: [...params.authMethods],
            pkpPublicKey: params.pkpPublicKey,
            expiration: props.expiration,
            resources: props.resources,
            chainId: 1,
            // -- required fields
            resourceAbilityRequests: props.resourceAbilityRequests,
            // -- optional fields
            ...props.litActionCode && { litActionCode: props.litActionCode },
            ...props.ipfsId && { ipfsId: props.ipfsId },
            ...props.jsParams && { jsParams: props.jsParams }
          });
          return response.authSig;
        }
      });
      return pkpSessionSigs;
    };
    /**
     *
     * Get Session Key URI eg. lit:session:0x1234
     *
     * @param publicKey is the public key of the session key
     * @returns { string } the session key uri
     */
    this.getSessionKeyUri = (publicKey) => {
      return "lit:session:" /* SESSION_KEY */ + publicKey;
    };
    if ("defaultAuthCallback" in args) {
      this.defaultAuthCallback = args.defaultAuthCallback;
    }
  }
  static {
    // ========== STATIC METHODS ==========
    this.getClaims = (claims) => {
      const keys = Object.keys(claims[0]);
      const signatures = {};
      const claimRes = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        const claimSet = claims.map((c) => c[keys[i2]]);
        signatures[keys[i2]] = [];
        claimSet.map((c) => {
          const sig = ethers_exports.utils.splitSignature(`0x${c.signature}`);
          const convertedSig = {
            r: sig.r,
            s: sig.s,
            v: sig.v
          };
          signatures[keys[i2]].push(convertedSig);
        });
        claimRes[keys[i2]] = {
          signatures: signatures[keys[i2]],
          derivedKeyId: claimSet[0].derivedKeyId
        };
      }
      return claimRes;
    };
  }
  /**
   * Check if a given object is of type SessionKeyPair.
   *
   * @param obj - The object to check.
   * @returns True if the object is of type SessionKeyPair.
   */
  isSessionKeyPair(obj) {
    return typeof obj === "object" && "publicKey" in obj && "secretKey" in obj && typeof obj.publicKey === "string" && typeof obj.secretKey === "string";
  }
  /**
   * Generates wildcard capability for each of the LIT resources
   * specified.
   * @param litResources is an array of LIT resources
   * @param addAllCapabilities is a boolean that specifies whether to add all capabilities for each resource
   */
  static async generateSessionCapabilityObjectWithWildcards(litResources, addAllCapabilities, rateLimitAuthSig) {
    const sessionCapabilityObject = new RecapSessionCapabilityObject({}, []);
    const _addAllCapabilities = addAllCapabilities ?? false;
    if (_addAllCapabilities) {
      for (const litResource of litResources) {
        sessionCapabilityObject.addAllCapabilitiesForResource(litResource);
      }
    }
    if (rateLimitAuthSig) {
      throw new Error("Not implemented yet.");
    }
    return sessionCapabilityObject;
  }
  // backward compatibility
  async generateSessionCapabilityObjectWithWildcards(litResources) {
    return await _LitNodeClientNodeJs.generateSessionCapabilityObjectWithWildcards(
      litResources
    );
  }
  static {
    /**
     *
     * Get expiration for session
     *
     */
    this.getExpiration = () => {
      return new Date(Date.now() + 1e3 * 60 * 60 * 24).toISOString();
    };
  }
  #authCallbackAndUpdateStorageItem;
  #decryptWithSignatureShares;
  // ========== Scoped Business Logics ==========
  //  the data to a basic array
  static normalizeParams(params) {
    if (!params.jsParams) {
      params.jsParams = {};
      return params;
    }
    for (const key2 of Object.keys(params.jsParams)) {
      if (Array.isArray(params.jsParams[key2]) || ArrayBuffer.isView(params.jsParams[key2])) {
        const arr = [];
        for (let i2 = 0; i2 < params.jsParams[key2].length; i2++) {
          arr.push(params.jsParams[key2][i2]);
        }
        params.jsParams[key2] = arr;
      }
    }
    return params;
  }
  #getIdentityParamForEncryption;
  #isSuccessNodePromises;
  /**
   * Authenticates an Auth Method for claiming a Programmable Key Pair (PKP).
   * A {@link MintCallback} can be defined for custom on chain interactions
   * by default the callback will forward to a relay server for minting on chain.
   * @param {ClaimKeyRequest} params an Auth Method and {@link MintCallback}
   * @returns {Promise<ClaimKeyResponse>}
   */
  async claimKeyId(params) {
    if (!this.ready) {
      const message = "LitNodeClient is not ready.  Please call await litNodeClient.connect() first.";
      throwError({
        message,
        errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
        errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
      });
    }
    if (params.authMethod.authMethodType == 3 /* WebAuthn */) {
      throwError({
        message: "Unsupported auth method type. Webauthn, and Lit Actions are not supported for claiming",
        errorKind: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.kind,
        errorCode: LIT_ERROR.LIT_NODE_CLIENT_NOT_READY_ERROR.name
      });
    }
    let requestId;
    const wrapper = async (id2) => {
      const nodePromises = await this.getNodePromises((url) => {
        const nodeRequestParams = {
          authMethod: params.authMethod
        };
        return this.getClaimKeyExecutionShares(url, nodeRequestParams, id2);
      });
      const responseData2 = await this.handleNodePromises(
        nodePromises,
        id2,
        this.connectedNodes.size
      );
      return responseData2;
    };
    const responseData = await executeWithRetry(
      wrapper,
      (_error, _requestId, isFinal) => {
        if (!isFinal) {
          logError("an error occured, attempting to retry");
        }
      },
      this.config.retryTolerance
    );
    requestId = responseData.requestId;
    if (responseData.success === true) {
      const nodeSignatures = responseData.values.map((r3) => {
        const sig = ethers_exports.utils.splitSignature(`0x${r3.signature}`);
        return {
          r: sig.r,
          s: sig.s,
          v: sig.v
        };
      });
      logWithRequestId(
        requestId,
        `[claimKeyId] responseData: ${JSON.stringify(responseData, null, 2)}`
      );
      const derivedKeyId = responseData.values[0].derivedKeyId;
      const pubkey = this.computeHDPubKey(derivedKeyId);
      logWithRequestId(
        requestId,
        `pubkey ${pubkey} derived from key id ${derivedKeyId}`
      );
      const relayParams = params;
      let mintTx = "";
      if (params.mintCallback && "signer" in params) {
        mintTx = await params.mintCallback(
          {
            derivedKeyId,
            authMethodType: params.authMethod.authMethodType,
            signatures: nodeSignatures,
            pubkey,
            signer: params.signer,
            ...relayParams
          },
          this.config.litNetwork
        );
      } else {
        mintTx = await defaultMintClaimCallback(
          {
            derivedKeyId,
            authMethodType: params.authMethod.authMethodType,
            signatures: nodeSignatures,
            pubkey,
            ...relayParams
          },
          this.config.litNetwork
        );
      }
      return {
        signatures: nodeSignatures,
        claimedKeyId: derivedKeyId,
        pubkey,
        mintTx
      };
    } else {
      return throwError({
        message: `Claim request has failed. Request trace id: lit_${requestId} `,
        errorKind: LIT_ERROR.UNKNOWN_ERROR.kind,
        errorCode: LIT_ERROR.UNKNOWN_ERROR.code
      });
    }
  }
};

// packages/lit-node-client-nodejs/src/index.ts
if (isNode()) {
  log("Oh hey you are running in Node.js!");
  const fetch2 = __require("node-fetch");
  globalThis.fetch = fetch2;
}
var LitNodeClientNodeJs2 = LitNodeClientNodeJs;
if (!globalThis.LitNodeClientNodeJs) {
  globalThis.LitNodeClientNodeJs = LitNodeClientNodeJs2;
}

// packages/auth-browser/src/index.ts
init_shim();

// packages/auth-browser/src/lib/auth-browser.ts
init_shim();

// packages/auth-browser/src/lib/chains/cosmos.ts
init_shim();
var getProvider = (walletType) => {
  switch (walletType) {
    case "keplr":
      if ("keplr" in window) {
        return window?.keplr;
      }
      break;
    case "leap":
      if ("leap" in window) {
        return window?.leap;
      }
  }
  const message = "No web3 wallet was found that works with Cosmos.  Install a Cosmos wallet or choose another chain";
  const error = LIT_ERROR.NO_WALLET_EXCEPTION;
  throwError({
    message,
    errorKind: error.kind,
    errorCode: error.name
  });
};
var connectCosmosProvider = async ({
  chain,
  walletType
}) => {
  const chainId = LIT_COSMOS_CHAINS[chain].chainId;
  const wallet = getProvider(walletType);
  await wallet.enable(chainId);
  const offlineSigner = wallet.getOfflineSigner(chainId);
  const accounts = await offlineSigner.getAccounts();
  return { provider: wallet, account: accounts[0].address, chainId };
};
var checkAndSignCosmosAuthMessage = async ({
  chain,
  walletType
}) => {
  const connectedCosmosProvider = await connectCosmosProvider({
    chain,
    walletType
  });
  const storageKey = LOCAL_STORAGE_KEYS.AUTH_COSMOS_SIGNATURE;
  let authSig = localStorage.getItem(storageKey);
  if (!authSig) {
    log("signing auth message because sig is not in local storage");
    await signAndSaveAuthMessage(connectedCosmosProvider);
    authSig = localStorage.getItem(storageKey);
  }
  authSig = JSON.parse(authSig);
  if (connectedCosmosProvider.account != authSig.address) {
    log(
      "signing auth message because account is not the same as the address in the auth sig"
    );
    await signAndSaveAuthMessage(connectedCosmosProvider);
    authSig = localStorage.getItem(storageKey);
    authSig = JSON.parse(authSig);
  }
  log("authSig", authSig);
  return authSig;
};
var signAndSaveAuthMessage = async (connectedCosmosProvider) => {
  const { provider, account, chainId } = connectedCosmosProvider;
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const body = AUTH_SIGNATURE_BODY.replace("{{timestamp}}", now2);
  const signed2 = await provider.signArbitrary(chainId, account, body);
  const data = uint8arrayToString(uint8arrayFromString(body, "utf8"), "base64");
  const signDoc = {
    chain_id: "",
    account_number: "0",
    sequence: "0",
    fee: {
      gas: "0",
      amount: []
    },
    msgs: [
      {
        type: "sign/MsgSignData",
        value: {
          signer: account,
          data
        }
      }
    ],
    memo: ""
  };
  const encodedSignedMsg = serializeSignDoc(signDoc);
  const digest = await crypto.subtle.digest("SHA-256", encodedSignedMsg);
  const digest_hex = uint8arrayToString(new Uint8Array(digest), "base16");
  let authSig = {
    sig: signed2.signature,
    derivedVia: "cosmos.signArbitrary",
    signedMessage: digest_hex,
    address: account
  };
  localStorage.setItem(
    LOCAL_STORAGE_KEYS.AUTH_COSMOS_SIGNATURE,
    JSON.stringify(authSig)
  );
};
var serializeSignDoc = (signDoc) => {
  const sorted = JSON.stringify(sortedObject(signDoc));
  return uint8arrayFromString(sorted, "utf8");
};

// packages/auth-browser/src/lib/chains/eth.ts
init_shim();
init_lib10();
init_lib2();
init_lib28();
import { EthereumProvider } from "@walletconnect/ethereum-provider";

// packages/auth-browser/src/lib/connect-modal/modal.ts
init_shim();
function e(e2, t2) {
  for (var o2 = 0; o2 < t2.length; o2++) {
    var n2 = t2[o2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
  }
}
function t(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return o(e3);
  }(e2) || function(e3) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
      return Array.from(e3);
  }(e2) || function(e3, t2) {
    if (!e3)
      return;
    if ("string" == typeof e3)
      return o(e3, t2);
    var n2 = Object.prototype.toString.call(e3).slice(8, -1);
    "Object" === n2 && e3.constructor && (n2 = e3.constructor.name);
    if ("Map" === n2 || "Set" === n2)
      return Array.from(e3);
    if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return o(e3, t2);
  }(e2) || function() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }();
}
function o(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var o2 = 0, n2 = new Array(t2); o2 < t2; o2++)
    n2[o2] = e2[o2];
  return n2;
}
var n;
var i;
var a;
var r2;
var s;
var l = (n = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([aria-hidden])",
  "textarea:not([disabled]):not([aria-hidden])",
  "button:not([disabled]):not([aria-hidden])",
  "iframe",
  "object",
  "embed",
  "[contenteditable]",
  '[tabindex]:not([tabindex^="-"])'
], i = function() {
  function o2(e2) {
    var n2 = e2.targetModal, i3 = e2.triggers, a3 = void 0 === i3 ? [] : i3, r3 = e2.onShow, s2 = void 0 === r3 ? function() {
    } : r3, l2 = e2.onClose, c = void 0 === l2 ? function() {
    } : l2, d = e2.openTrigger, u = void 0 === d ? "data-micromodal-trigger" : d, f = e2.closeTrigger, h = void 0 === f ? "data-micromodal-close" : f, v = e2.openClass, g = void 0 === v ? "is-open" : v, m = e2.disableScroll, b = void 0 !== m && m, y = e2.disableFocus, p = void 0 !== y && y, w = e2.awaitCloseAnimation, E = void 0 !== w && w, k = e2.awaitOpenAnimation, M2 = void 0 !== k && k, A2 = e2.debugMode, C = void 0 !== A2 && A2;
    !function(e3, t2) {
      if (!(e3 instanceof t2))
        throw new TypeError("Cannot call a class as a function");
    }(this, o2), this.modal = document.getElementById(n2), this.config = {
      debugMode: C,
      disableScroll: b,
      openTrigger: u,
      closeTrigger: h,
      openClass: g,
      onShow: s2,
      onClose: c,
      awaitCloseAnimation: E,
      awaitOpenAnimation: M2,
      disableFocus: p
    }, a3.length > 0 && this.registerTriggers.apply(this, t(a3)), this.onClick = this.onClick.bind(this), this.onKeydown = this.onKeydown.bind(this);
  }
  var i2, a2, r22;
  return i2 = o2, (a2 = [
    {
      key: "registerTriggers",
      value: function() {
        for (var e2 = this, t2 = arguments.length, o3 = new Array(t2), n2 = 0; n2 < t2; n2++)
          o3[n2] = arguments[n2];
        o3.filter(Boolean).forEach(function(t3) {
          t3.addEventListener("click", function(t4) {
            return e2.showModal(t4);
          });
        });
      }
    },
    {
      key: "showModal",
      value: function() {
        var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        if (this.activeElement = document.activeElement, this.modal.setAttribute("aria-hidden", "false"), this.modal.classList.add(this.config.openClass), this.scrollBehaviour("disable"), this.addEventListeners(), this.config.awaitOpenAnimation) {
          var o3 = function t3() {
            e2.modal.removeEventListener("animationend", t3, false), e2.setFocusToFirstNode();
          };
          this.modal.addEventListener("animationend", o3, false);
        } else
          this.setFocusToFirstNode();
        this.config.onShow(this.modal, this.activeElement, t2);
      }
    },
    {
      key: "closeModal",
      value: function() {
        var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t2 = this.modal;
        if (this.modal.setAttribute("aria-hidden", "true"), this.removeEventListeners(), this.scrollBehaviour("enable"), this.activeElement && this.activeElement.focus && this.activeElement.focus(), this.config.onClose(this.modal, this.activeElement, e2), this.config.awaitCloseAnimation) {
          var o3 = this.config.openClass;
          this.modal.addEventListener(
            "animationend",
            function e3() {
              t2.classList.remove(o3), t2.removeEventListener("animationend", e3, false);
            },
            false
          );
        } else
          t2.classList.remove(this.config.openClass);
      }
    },
    {
      key: "closeModalById",
      value: function(e2) {
        this.modal = document.getElementById(e2), this.modal && this.closeModal();
      }
    },
    {
      key: "scrollBehaviour",
      value: function(e2) {
        if (this.config.disableScroll) {
          var t2 = document.querySelector("body");
          switch (e2) {
            case "enable":
              Object.assign(t2.style, { overflow: "" });
              break;
            case "disable":
              Object.assign(t2.style, { overflow: "hidden" });
          }
        }
      }
    },
    {
      key: "addEventListeners",
      value: function() {
        this.modal.addEventListener("touchstart", this.onClick), this.modal.addEventListener("click", this.onClick), document.addEventListener("keydown", this.onKeydown);
      }
    },
    {
      key: "removeEventListeners",
      value: function() {
        this.modal.removeEventListener("touchstart", this.onClick), this.modal.removeEventListener("click", this.onClick), document.removeEventListener("keydown", this.onKeydown);
      }
    },
    {
      key: "onClick",
      value: function(e2) {
        (e2.target.hasAttribute(this.config.closeTrigger) || e2.target.parentNode.hasAttribute(this.config.closeTrigger)) && (e2.preventDefault(), e2.stopPropagation(), this.closeModal(e2));
      }
    },
    {
      key: "onKeydown",
      value: function(e2) {
        27 === e2.keyCode && this.closeModal(e2), 9 === e2.keyCode && this.retainFocus(e2);
      }
    },
    {
      key: "getFocusableNodes",
      value: function() {
        var e2 = this.modal.querySelectorAll(n);
        return Array.apply(void 0, t(e2));
      }
    },
    {
      key: "setFocusToFirstNode",
      value: function() {
        var e2 = this;
        if (!this.config.disableFocus) {
          var t2 = this.getFocusableNodes();
          if (0 !== t2.length) {
            var o3 = t2.filter(function(t3) {
              return !t3.hasAttribute(e2.config.closeTrigger);
            });
            o3.length > 0 && o3[0].focus(), 0 === o3.length && t2[0].focus();
          }
        }
      }
    },
    {
      key: "retainFocus",
      value: function(e2) {
        var t2 = this.getFocusableNodes();
        if (0 !== t2.length)
          if (t2 = t2.filter(function(e3) {
            return null !== e3.offsetParent;
          }), this.modal.contains(document.activeElement)) {
            var o3 = t2.indexOf(document.activeElement);
            e2.shiftKey && 0 === o3 && (t2[t2.length - 1].focus(), e2.preventDefault()), !e2.shiftKey && t2.length > 0 && o3 === t2.length - 1 && (t2[0].focus(), e2.preventDefault());
          } else
            t2[0].focus();
      }
    }
  ]) && e(i2.prototype, a2), r22 && e(i2, r22), o2;
}(), a = null, r2 = function(e2) {
  if (!document.getElementById(e2))
    return console.warn(
      "MicroModal: \u2757Seems like you have missed %c'".concat(e2, "'"),
      "background-color: #f8f9fa;color: #50596c;font-weight: bold;",
      "ID somewhere in your code. Refer example below to resolve it."
    ), console.warn(
      "%cExample:",
      "background-color: #f8f9fa;color: #50596c;font-weight: bold;",
      '<div class="modal" id="'.concat(e2, '"></div>')
    ), false;
}, s = function(e2, t2) {
  if (function(e3) {
    e3.length <= 0 && (console.warn(
      "MicroModal: \u2757Please specify at least one %c'micromodal-trigger'",
      "background-color: #f8f9fa;color: #50596c;font-weight: bold;",
      "data attribute."
    ), console.warn(
      "%cExample:",
      "background-color: #f8f9fa;color: #50596c;font-weight: bold;",
      '<a href="#" data-micromodal-trigger="my-modal"></a>'
    ));
  }(e2), !t2)
    return true;
  for (var o2 in t2)
    r2(o2);
  return true;
}, {
  init: function(e2) {
    var o2 = Object.assign(
      {},
      { openTrigger: "data-micromodal-trigger" },
      e2
    ), n2 = t(document.querySelectorAll("[".concat(o2.openTrigger, "]"))), r22 = function(e3, t2) {
      var o3 = [];
      return e3.forEach(function(e4) {
        var n3 = e4.attributes[t2].value;
        void 0 === o3[n3] && (o3[n3] = []), o3[n3].push(e4);
      }), o3;
    }(n2, o2.openTrigger);
    if (true !== o2.debugMode || false !== s(n2, r22))
      for (var l2 in r22) {
        var c = r22[l2];
        o2.targetModal = l2, o2.triggers = t(c), a = new i(o2);
      }
  },
  show: function(e2, t2) {
    var o2 = t2 || {};
    o2.targetModal = e2, true === o2.debugMode && false === r2(e2) || (a && a.removeEventListeners(), (a = new i(o2)).showModal());
  },
  close: function(e2) {
    e2 ? a.closeModalById(e2) : a.closeModal();
  }
});
"undefined" != typeof window && (window.MicroModal = l);
var micromodal_es_default = l;
var modal_default = '.modal {\n  font-family: -apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;\n}\n\n.lcm-modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0,0,0,0.6);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 12;\n}\n\n.lcm-modal-container {\n  border: 1px solid rgba(129, 89, 217, 1);\n  background-color: #fff;\n  padding: 0 1.5rem;\n  max-width: 500px;\n  max-height: 100vh;\n  border-radius: 0.25rem;\n  overflow-y: auto;\n  box-sizing: border-box;\n}\n\n.lcm-modal-content {\n  margin-top: 2rem;\n  margin-bottom: 2rem;\n  line-height: 1.5;\n  color: rgba(0,0,0,.8);\n}\n\n.lcm-wallet-container {\n  display: flex;\n  align-items: center;\n  margin: 2rem 0.5rem;\n  transition-duration: 0.2s;\n  border-radius: 0.25rem;\n  padding: 2rem;\n  cursor: pointer;\n}\n\n.lcm-wallet-container:hover {\n  background-color: #d4d4d4;\n}\n\n.lcm-wallet-logo {\n  height: 2.5rem;\n  width: 3.75rem;\n  margin-right: 1.5rem;\n}\n\n.lcm-text-column {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}\n\n.lcm-wallet-name {\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0;\n}\n\n.lcm-wallet-synopsis {\n  color: #777;\n  font-size: 0.9rem;\n  margin: 0;\n}\n\n\n@keyframes mmfadeIn {\n    from { opacity: 0; }\n      to { opacity: 1; }\n}\n\n@keyframes mmfadeOut {\n    from { opacity: 1; }\n      to { opacity: 0; }\n}\n\n@keyframes mmslideIn {\n  from { transform: translateY(15%); }\n    to { transform: translateY(0); }\n}\n\n@keyframes mmslideOut {\n    from { transform: translateY(0); }\n    to { transform: translateY(-10%); }\n}\n\n.micromodal-slide {\n  display: none;\n}\n\n.micromodal-slide.is-open {\n  display: block;\n}\n\n.micromodal-slide[aria-hidden="false"] .lcm-modal-overlay {\n  animation: mmfadeIn .3s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n\n.micromodal-slide[aria-hidden="false"] .lcm-modal-container {\n  animation: mmslideIn .3s cubic-bezier(0, 0, .2, 1);\n}\n\n.micromodal-slide[aria-hidden="true"] .lcm-modal-overlay {\n  animation: mmfadeOut .3s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n\n.micromodal-slide[aria-hidden="true"] .lcm-modal-container {\n  animation: mmslideOut .3s cubic-bezier(0, 0, .2, 1);\n}\n\n.micromodal-slide .lcm-modal-container,\n.micromodal-slide .lcm-modal-overlay {\n  will-change: transform;\n}\n';
var metamask_default = 'data:image/svg+xml,<svg height="355" viewBox="0 0 397 355" width="397" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd" transform="translate(-1 -1)"><path d="m114.622644 327.195472 52.004717 13.810198v-18.05949l4.245283-4.249292h29.716982v21.246459 14.872523h-31.839624l-39.268868-16.997169z" fill="%23cdbdb2"/><path d="m199.528305 327.195472 50.943397 13.810198v-18.05949l4.245283-4.249292h29.716981v21.246459 14.872523h-31.839623l-39.268868-16.997169z" fill="%23cdbdb2" transform="matrix(-1 0 0 1 483.96227 0)"/><path d="m170.872644 287.889523-4.245283 35.056657 5.306604-4.249292h55.18868l6.367925 4.249292-4.245284-35.056657-8.490565-5.311615-42.452832 1.062323z" fill="%23393939"/><path d="m142.216984 50.9915022 25.471698 59.4900858 11.674528 173.158643h41.391511l12.735849-173.158643 23.349056-59.4900858z" fill="%23f89c35"/><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="%23f89d35"/><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="%23d87c30"/><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="%23ea8d3a"/><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="%23f89d35"/><path d="m123.113209 261.331448-8.490565 65.864024 56.25-39.305949z" fill="%23eb8f35"/><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="%23ea8e3a"/><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="%23d87c30"/><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="%23eb8f35"/><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="%23e8821e"/><path d="m114.622644 327.195472 56.25-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="%23dfcec3"/><path d="m229.245286 327.195472 55.18868-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="%23dfcec3" transform="matrix(-1 0 0 1 513.679252 0)"/><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="%23393939" transform="matrix(-1 0 0 1 283.372646 0)"/><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="%23e88f35"/><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="%238e5a30"/><g transform="matrix(-1 0 0 1 399.056611 0)"><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="%23f89d35"/><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="%23d87c30"/><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="%23ea8d3a"/><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="%23f89d35"/><path d="m123.113209 261.331448-8.490565 65.864024 55.18868-38.243626z" fill="%23eb8f35"/><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="%23ea8e3a"/><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="%23d87c30"/><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="%23eb8f35"/><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="%23e8821e"/><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="%23393939" transform="matrix(-1 0 0 1 283.372646 0)"/><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="%23e88f35"/><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="%238e5a30"/></g></g></svg>';
var coinbase_default = 'data:image/svg+xml,<?xml version="1.0" encoding="utf-8"?>%0A<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->%0A<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"%0A%09 viewBox="0 0 1101.64 196.79" style="enable-background:new 0 0 1101.64 196.79;" xml:space="preserve">%0A<style type="text/css">%0A%09.st0{fill:%230052FF;}%0A</style>%0A<path class="st0" d="M222.34,54.94c-40.02,0-71.29,30.38-71.29,71.05s30.48,70.79,71.29,70.79c40.81,0,71.82-30.64,71.82-71.05%0A%09C294.16,85.58,263.68,54.94,222.34,54.94z M222.61,167.47c-22.79,0-39.49-17.7-39.49-41.47c0-24.04,16.43-41.73,39.22-41.73%0A%09c23.06,0,39.75,17.96,39.75,41.73S245.4,167.47,222.61,167.47z M302.9,85.85h19.88v108.3h31.8V57.58H302.9V85.85z M71.02,84.26%0A%09c16.7,0,29.95,10.3,34.98,25.62h33.66c-6.1-32.75-33.13-54.94-68.37-54.94C31.27,54.94,0,85.32,0,126s30.48,70.79,71.29,70.79%0A%09c34.45,0,62.01-22.19,68.11-55.21H106c-4.77,15.32-18.02,25.89-34.72,25.89c-23.06,0-39.22-17.7-39.22-41.47%0A%09C32.07,101.96,47.97,84.26,71.02,84.26z M907.12,112.79l-23.32-3.43c-11.13-1.58-19.08-5.28-19.08-14%0A%09c0-9.51,10.34-14.26,24.38-14.26c15.37,0,25.18,6.6,27.3,17.43h30.74c-3.45-27.47-24.65-43.58-57.24-43.58%0A%09c-33.66,0-55.92,17.17-55.92,41.47c0,23.24,14.58,36.72,43.99,40.94l23.32,3.43c11.4,1.58,17.76,6.08,17.76,14.53%0A%09c0,10.83-11.13,15.32-26.5,15.32c-18.82,0-29.42-7.66-31.01-19.28h-31.27c2.92,26.68,23.85,45.43,62.01,45.43%0A%09c34.72,0,57.77-15.85,57.77-43.06C950.05,129.43,933.36,116.75,907.12,112.79z M338.68,1.32c-11.66,0-20.41,8.45-20.41,20.07%0A%09s8.74,20.07,20.41,20.07c11.66,0,20.41-8.45,20.41-20.07S350.34,1.32,338.68,1.32z M805.36,104.34c0-29.58-18.02-49.39-56.18-49.39%0A%09c-36.04,0-56.18,18.23-60.16,46.23h31.54c1.59-10.83,10.07-19.81,28.09-19.81c16.17,0,24.12,7.13,24.12,15.85%0A%09c0,11.36-14.58,14.26-32.6,16.11c-24.38,2.64-54.59,11.09-54.59,42.79c0,24.57,18.29,40.41,47.44,40.41%0A%09c22.79,0,37.1-9.51,44.26-24.57c1.06,13.47,11.13,22.19,25.18,22.19h18.55v-28.26h-15.64V104.34z M774.09,138.68%0A%09c0,18.23-15.9,31.7-35.25,31.7c-11.93,0-22-5.02-22-15.58c0-13.47,16.17-17.17,31.01-18.75c14.31-1.32,22.26-4.49,26.24-10.57%0A%09V138.68z M605.28,54.94c-17.76,0-32.6,7.4-43.2,19.81V0h-31.8v194.15h31.27v-17.96c10.6,12.94,25.71,20.6,43.73,20.6%0A%09c38.16,0,67.05-30.11,67.05-70.79S642.91,54.94,605.28,54.94z M600.51,167.47c-22.79,0-39.49-17.7-39.49-41.47%0A%09s16.96-41.73,39.75-41.73c23.06,0,39.22,17.7,39.22,41.73C639.99,149.77,623.3,167.47,600.51,167.47z M454.22,54.94%0A%09c-20.67,0-34.19,8.45-42.14,20.34v-17.7h-31.54v136.56h31.8v-74.22c0-20.87,13.25-35.66,32.86-35.66c18.29,0,29.68,12.94,29.68,31.7%0A%09v78.19h31.8v-80.56C506.69,79.24,488.94,54.94,454.22,54.94z M1101.64,121.51c0-39.09-28.62-66.56-67.05-66.56%0A%09c-40.81,0-70.76,30.64-70.76,71.05c0,42.53,32.07,70.79,71.29,70.79c33.13,0,59.1-19.55,65.72-47.28h-33.13%0A%09c-4.77,12.15-16.43,19.02-32.07,19.02c-20.41,0-35.78-12.68-39.22-34.87h105.21V121.51z M998.28,110.94%0A%09c5.04-19.02,19.35-28.26,35.78-28.26c18.02,0,31.8,10.3,34.98,28.26H998.28z"/>%0A</svg>%0A';
var walletconnect_default = 'data:image/svg+xml,<svg height="246" viewBox="0 0 400 246" width="400" xmlns="http://www.w3.org/2000/svg"><path d="m81.9180572 48.3416816c65.2149658-63.8508884 170.9493158-63.8508884 236.1642788 0l7.848727 7.6845565c3.260748 3.1925442 3.260748 8.3686816 0 11.5612272l-26.848927 26.2873374c-1.630375 1.5962734-4.273733 1.5962734-5.904108 0l-10.800779-10.5748639c-45.495589-44.5439756-119.258514-44.5439756-164.754105 0l-11.566741 11.3248068c-1.630376 1.5962721-4.273735 1.5962721-5.904108 0l-26.8489263-26.2873375c-3.2607483-3.1925456-3.2607483-8.3686829 0-11.5612272zm291.6903948 54.3649934 23.895596 23.395862c3.260732 3.19253 3.260751 8.368636.000041 11.561187l-107.746894 105.494845c-3.260726 3.192568-8.547443 3.192604-11.808214.000083-.000013-.000013-.000029-.000029-.000042-.000043l-76.472191-74.872762c-.815187-.798136-2.136867-.798136-2.952053 0-.000006.000005-.00001.00001-.000015.000014l-76.470562 74.872708c-3.260715 3.192576-8.547434 3.19263-11.808215.000116-.000019-.000018-.000039-.000037-.000059-.000058l-107.74989297-105.496247c-3.26074695-3.192544-3.26074695-8.368682 0-11.561226l23.89563947-23.395823c3.260747-3.1925446 8.5474652-3.1925446 11.8082136 0l76.4733029 74.873809c.815188.798136 2.136866.798136 2.952054 0 .000012-.000012.000023-.000023.000035-.000032l76.469471-74.873777c3.260673-3.1926181 8.547392-3.1927378 11.808214-.000267.000046.000045.000091.00009.000135.000135l76.473203 74.873909c.815186.798135 2.136866.798135 2.952053 0l76.471967-74.872433c3.260748-3.1925458 8.547465-3.1925458 11.808213 0z" fill="%233b99fc"/></svg>';
var metaMaskSingle = {
  htmlId: "lcm-metaMask",
  id: "metamask",
  logo: metamask_default,
  name: "MetaMask",
  provider: globalThis.ethereum,
  synopsis: "Connect your MetaMask Wallet",
  checkIfPresent: () => {
    if (typeof globalThis.ethereum !== "undefined" && globalThis.ethereum.isMetaMask) {
      return true;
    } else {
      return false;
    }
  }
};
var coinbaseSingle = {
  htmlId: "lcm-coinbase",
  id: "coinbase",
  logo: coinbase_default,
  name: "Coinbase",
  provider: globalThis.ethereum,
  synopsis: "Connect your Coinbase Wallet",
  checkIfPresent: () => {
    if (typeof globalThis.ethereum !== "undefined" && globalThis.ethereum.isCoinbaseWallet) {
      return true;
    } else {
      return false;
    }
  }
};
var rawListOfWalletsArray = [
  {
    htmlId: "lcm-metaMask",
    id: "metamask",
    logo: metamask_default,
    name: "MetaMask",
    provider: globalThis.ethereum?.providers?.find((p) => p.isMetaMask),
    synopsis: "Connect your MetaMask Wallet",
    checkIfPresent: () => {
      return !!globalThis.ethereum?.providers?.find((p) => p.isMetaMask);
    }
  },
  {
    htmlId: "lcm-coinbase",
    id: "coinbase",
    logo: coinbase_default,
    name: "Coinbase",
    provider: globalThis.ethereum?.providers?.find((p) => p.isCoinbaseWallet),
    synopsis: "Connect your Coinbase Wallet",
    checkIfPresent: () => {
      return !!globalThis.ethereum?.providers?.find((p) => p.isCoinbaseWallet);
    }
  },
  {
    htmlId: "lcm-walletConnect",
    id: "walletconnect",
    logo: walletconnect_default,
    name: "WalletConnect",
    provider: null,
    synopsis: "Scan with WalletConnect to connect"
  }
];
var providerMethods = {
  walletconnect: (providerOptions, id2) => {
    const walletConnectData = providerOptions.walletconnect;
    const walletConnectProvider = walletConnectData.provider;
    return walletConnectProvider;
  }
};
var providerMethods_default = providerMethods;
var LitConnectModal = class {
  constructor({ providerOptions }) {
    this.dialog = micromodal_es_default;
    this.closeAction = void 0;
    this.parent = document.body;
    this.filteredListOfWalletsArray = [];
    this.providerOptions = providerOptions;
    this._filterListOfWallets();
    this._instantiateLitConnectModal();
    var style = document.createElement("style");
    style.innerHTML = modal_default;
    document.head.appendChild(style);
  }
  getWalletProvider() {
    const currentProvider = localStorage.getItem("lit-web3-provider");
    this.dialog.show("lit-connect-modal");
    return new Promise((resolve, reject) => {
      if (!!currentProvider) {
        const foundProvider = this.filteredListOfWalletsArray.find(
          (w) => w.id === currentProvider
        );
        resolve(foundProvider.provider);
        this._destroy();
        return;
      }
      this.filteredListOfWalletsArray.forEach((w) => {
        let walletEntry = document.getElementById(w.id);
        walletEntry.addEventListener("click", () => {
          localStorage.setItem("lit-web3-provider", w.id);
          resolve(w.provider);
          this._destroy();
          return;
        });
      });
      this.closeAction.addEventListener("click", () => {
        resolve(false);
        this._destroy();
        return;
      });
    });
  }
  _filterListOfWallets() {
    const filteredListOfWalletsArray = [];
    rawListOfWalletsArray.forEach((w) => {
      if (!!w["checkIfPresent"] && w["checkIfPresent"]() === true) {
        filteredListOfWalletsArray.push(w);
      }
    });
    if (filteredListOfWalletsArray.length === 0) {
      if (globalThis.ethereum) {
        if (globalThis.ethereum.isMetaMask) {
          filteredListOfWalletsArray.push(metaMaskSingle);
        }
        if (globalThis.ethereum.isCoinbaseWallet) {
          filteredListOfWalletsArray.push(coinbaseSingle);
        }
      }
    }
    if (!!this.providerOptions["walletconnect"]) {
      const cloneWalletInfo = rawListOfWalletsArray.find(
        (w) => w.id === "walletconnect"
      );
      cloneWalletInfo["provider"] = providerMethods_default["walletconnect"](
        this.providerOptions,
        "walletconnect"
      );
      filteredListOfWalletsArray.push(cloneWalletInfo);
    }
    if (filteredListOfWalletsArray.length === 0) {
      alert("No wallets installed or provided.");
      throw new Error("No wallets installed or provided.");
    }
    this.filteredListOfWalletsArray = filteredListOfWalletsArray;
  }
  _instantiateLitConnectModal() {
    const connectModal = document.createElement("div");
    connectModal.setAttribute("id", "lit-connect-modal-container");
    connectModal.innerHTML = `
        <div class="modal micromodal-slide" id="lit-connect-modal" aria-hidden="true">
            <div class="lcm-modal-overlay" id="lcm-modal-overlay" tabindex="-1" data-micromodal-close>
                <div class="lcm-modal-container" role="dialog" aria-modal="true" aria-labelledby="lit-connect-modal-title">
                    <main class="lcm-modal-content" id="lit-connect-modal-content">
                    </main>
                </div>
            </div>
        </div>
    `;
    this.parent.appendChild(connectModal);
    Object.assign(this, {
      trueButton: document.getElementById("lcm-continue-button"),
      closeAction: document.getElementById("lcm-modal-overlay")
    });
    this._buildListOfWallets();
    this.dialog.init({
      disableScroll: true,
      disableFocus: false,
      awaitOpenAnimation: false,
      awaitCloseAnimation: false,
      debugMode: false
    });
  }
  _buildListOfWallets() {
    const contentContainer = document.getElementById(
      "lit-connect-modal-content"
    );
    let walletListHtml = ``;
    this.filteredListOfWalletsArray.forEach((w) => {
      walletListHtml += `
        <div class="lcm-wallet-container" id="${w.id}">
          <img class="lcm-wallet-logo"  src='${w.logo}' />
          <div class="lcm-text-column">
            <p class="lcm-wallet-name" >${w.name}</p>
            <p class="lcm-wallet-synopsis" >${w.synopsis}</p>
          </div>
        </div>
      `;
    });
    contentContainer.innerHTML = walletListHtml;
  }
  _destroy() {
    const dialog = document.getElementById("lit-connect-modal-container");
    if (!!dialog) {
      dialog.remove();
    }
  }
};

// packages/auth-browser/src/lib/chains/eth.ts
var import_utils11 = __toESM(require_utils2());
import { SiweMessage as SiweMessage3 } from "siwe";
import * as naclUtil from "tweetnacl-util";
import * as nacl2 from "tweetnacl";
import { Buffer as BufferPolyfill } from "buffer";
if (typeof global.Buffer === "undefined") {
  global.Buffer = BufferPolyfill;
}
var getChainId = async (chain, web3) => {
  let resultOrError;
  try {
    const resp = await web3.getNetwork();
    resultOrError = ERight(resp.chainId);
  } catch (e2) {
    log("getNetwork threw an exception", e2);
    resultOrError = ELeft({
      message: `Incorrect network selected.  Please switch to the ${chain} network in your wallet and try again.`,
      errorKind: LIT_ERROR.WRONG_NETWORK_EXCEPTION.kind,
      errorCode: LIT_ERROR.WRONG_NETWORK_EXCEPTION.name
    });
  }
  return resultOrError;
};
function isSignedMessageExpired(signedMessage) {
  const dateStr = signedMessage.split("\n")[9]?.replace("Expiration Time: ", "");
  const expirationTime = new Date(dateStr);
  const currentTime = /* @__PURE__ */ new Date();
  return currentTime > expirationTime;
}
var getMustResign = (authSig, resources) => {
  let mustResign;
  if (!isSignedMessageExpired(authSig.signedMessage)) {
    return false;
  }
  try {
    const parsedSiwe = new SiweMessage3(authSig.signedMessage);
    log("parsedSiwe.resources", parsedSiwe.resources);
    if (JSON.stringify(parsedSiwe.resources) !== JSON.stringify(resources)) {
      log(
        "signing auth message because resources differ from the resources in the auth sig"
      );
      mustResign = true;
    }
    if (parsedSiwe.address !== (0, import_utils11.getAddress)(parsedSiwe.address)) {
      log(
        "signing auth message because parsedSig.address is not equal to the same address but checksummed.  This usually means the user had a non-checksummed address saved and so they need to re-sign."
      );
      mustResign = true;
    }
  } catch (e2) {
    log("error parsing siwe sig.  making the user sign again: ", e2);
    mustResign = true;
  }
  return mustResign;
};
var getRPCUrls = () => {
  const rpcUrls = {};
  const keys = Object.keys(LIT_CHAINS);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const chainName = keys[i2];
    const chainId = LIT_CHAINS[chainName].chainId;
    const rpcUrl = LIT_CHAINS[chainName].rpcUrls[0];
    rpcUrls[chainId.toString()] = rpcUrl;
  }
  return rpcUrls;
};
var connectWeb3 = async ({
  chainId = 1,
  walletConnectProjectId
}) => {
  if (isNode()) {
    log("connectWeb3 is not supported in nodejs.");
    return { web3: null, account: null };
  }
  const rpcUrls = getRPCUrls();
  let providerOptions = {};
  if (walletConnectProjectId) {
    const wcProvider = await EthereumProvider.init({
      projectId: walletConnectProjectId,
      chains: [chainId],
      showQrModal: true,
      optionalMethods: ["eth_sign"],
      rpcMap: rpcUrls
    });
    providerOptions = {
      walletconnect: {
        provider: wcProvider
      }
    };
    if (isBrowser()) {
      globalThis.litWCProvider = wcProvider;
    }
  }
  log("getting provider via lit connect modal");
  const dialog = new LitConnectModal({ providerOptions });
  const provider = await dialog.getWalletProvider();
  log("got provider");
  const web3 = new Web3Provider(provider);
  try {
    log(
      "@deprecated soon to be removed. - trying to enable provider.  this will trigger the metamask popup."
    );
    await provider.enable();
  } catch (e2) {
    log(
      "error enabling provider but swallowed it because it's not important.  most wallets use a different function now to enable the wallet so you can ignore this error, because those other methods will be tried.",
      e2
    );
  }
  log("listing accounts");
  const accounts = await web3.listAccounts();
  log("accounts", accounts);
  const account = accounts[0].toLowerCase();
  return { web3, account };
};
var checkAndSignEVMAuthMessage = async ({
  chain,
  resources,
  switchChain,
  expiration,
  uri,
  walletConnectProjectId,
  nonce
}) => {
  if (isNode()) {
    log(
      "checkAndSignEVMAuthMessage is not supported in nodejs.  You can create a SIWE on your own using the SIWE package."
    );
    return {
      sig: "",
      derivedVia: "",
      signedMessage: "",
      address: ""
    };
  }
  const _throwIncorrectNetworkError = (error) => {
    if (error.code === -32601 /* NO_SUCH_METHOD */) {
      throwError({
        message: `Incorrect network selected.  Please switch to the ${chain} network in your wallet and try again.`,
        errorKind: LIT_ERROR.WRONG_NETWORK_EXCEPTION.kind,
        errorCode: LIT_ERROR.WRONG_NETWORK_EXCEPTION.name
      });
    } else {
      throw error;
    }
  };
  const selectedChain = LIT_CHAINS[chain];
  const expirationString = expiration ?? getDefaultExpiration();
  const { web3, account } = await connectWeb3({
    chainId: selectedChain.chainId,
    walletConnectProjectId
  });
  log(`got web3 and account: ${account}`);
  const currentChainIdOrError = await getChainId(chain, web3);
  const selectedChainId = selectedChain.chainId;
  const selectedChainIdHex = numberToHex(selectedChainId);
  const authSigOrError = getStorageItem(LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
  log("currentChainIdOrError:", currentChainIdOrError);
  log("selectedChainId:", selectedChainId);
  log("selectedChainIdHex:", selectedChainIdHex);
  log("authSigOrError:", authSigOrError);
  if (currentChainIdOrError.type === "ERROR" /* ERROR */) {
    return throwError(currentChainIdOrError.result);
  }
  log("chainId from web3", currentChainIdOrError);
  log(
    `checkAndSignAuthMessage with chainId ${currentChainIdOrError} and chain set to ${chain} and selectedChain is `,
    selectedChain
  );
  if (currentChainIdOrError.result !== selectedChainId && switchChain) {
    const provider = web3.provider;
    try {
      log("trying to switch to chainId", selectedChainIdHex);
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: selectedChainIdHex }]
      });
    } catch (switchError) {
      log("error switching to chainId", switchError);
      if (switchError.code === 4902 /* REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED */) {
        try {
          const data = [
            {
              chainId: selectedChainIdHex,
              chainName: selectedChain.name,
              nativeCurrency: {
                name: selectedChain.name,
                symbol: selectedChain.symbol,
                decimals: selectedChain.decimals
              },
              rpcUrls: selectedChain.rpcUrls,
              blockExplorerUrls: selectedChain.blockExplorerUrls
            }
          ];
          await provider.request({
            method: "wallet_addEthereumChain",
            params: data
          });
        } catch (addError) {
          _throwIncorrectNetworkError(addError);
        }
      } else {
        _throwIncorrectNetworkError(switchError);
      }
    }
    currentChainIdOrError.result = selectedChain.chainId;
  }
  log("checking if sig is in local storage");
  if (authSigOrError.type === "ERROR" /* ERROR */) {
    log("signing auth message because sig is not in local storage");
    try {
      authSigOrError.result = await _signAndGetAuth({
        web3,
        account,
        chainId: selectedChain.chainId,
        resources,
        expiration: expirationString,
        uri,
        nonce
      });
    } catch (e2) {
      log(e2);
      return throwError({
        message: e2.message,
        errorKind: LIT_ERROR.UNKNOWN_ERROR.kind,
        errorCode: LIT_ERROR.UNKNOWN_ERROR.name
      });
    }
    authSigOrError.type = "SUCCESS" /* SUCCESS */;
    log("5. authSigOrError:", authSigOrError);
  }
  let authSig = authSigOrError.result;
  if (typeof authSig === "string") {
    authSig = JSON.parse(authSig);
  }
  log("6. authSig:", authSig);
  if (account.toLowerCase() !== authSig.address.toLowerCase()) {
    log(
      "signing auth message because account is not the same as the address in the auth sig"
    );
    authSig = await _signAndGetAuth({
      web3,
      account,
      chainId: selectedChain.chainId,
      resources,
      expiration: expirationString,
      uri,
      nonce
    });
    log("7. authSig:", authSig);
  } else {
    let mustResign = getMustResign(authSig, resources);
    if (mustResign) {
      authSig = await _signAndGetAuth({
        web3,
        account,
        chainId: selectedChain.chainId,
        resources,
        expiration: expirationString,
        uri,
        nonce
      });
    }
    log("8. mustResign:", mustResign);
  }
  if (isSignedMessageExpired(authSig.signedMessage)) {
    log("9. authSig expired!, resigning..");
    authSig = await _signAndGetAuth({
      web3,
      account,
      chainId: selectedChain.chainId,
      resources,
      expiration: expirationString,
      uri,
      nonce
    });
  }
  return authSig;
};
var getDefaultExpiration = () => {
  return new Date(Date.now() + 1e3 * 60 * 60 * 24).toISOString();
};
var _signAndGetAuth = async ({
  web3,
  account,
  chainId,
  resources,
  expiration,
  uri,
  nonce
}) => {
  await signAndSaveAuthMessage2({
    web3,
    account,
    chainId,
    resources,
    expiration,
    uri,
    nonce
  });
  let authSigOrError = getStorageItem(LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
  if (authSigOrError.type === "ERROR") {
    throwError({
      message: "Failed to get authSig from local storage",
      errorKind: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.kind,
      errorCode: LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.name
    });
  }
  let authSig = typeof authSigOrError.result === "string" ? JSON.parse(authSigOrError.result) : authSigOrError.result;
  return authSig;
};
var signAndSaveAuthMessage2 = async ({
  web3,
  account,
  chainId,
  resources,
  expiration,
  uri,
  nonce
}) => {
  if (isNode()) {
    log("checkAndSignEVMAuthMessage is not supported in nodejs.");
    return {
      sig: "",
      derivedVia: "",
      signedMessage: "",
      address: ""
    };
  }
  const preparedMessage = {
    domain: globalThis.location.host,
    address: (0, import_utils11.getAddress)(account),
    // convert to EIP-55 format or else SIWE complains
    version: "1",
    chainId,
    expirationTime: expiration,
    nonce
  };
  if (resources && resources.length > 0) {
    preparedMessage.resources = resources;
  }
  if (uri) {
    preparedMessage.uri = uri;
  } else {
    preparedMessage.uri = globalThis.location.href;
  }
  const message = new SiweMessage3(preparedMessage);
  const body = message.prepareMessage();
  const formattedAccount = (0, import_utils11.getAddress)(account);
  let signedResult = await signMessage({
    body,
    web3,
    account: formattedAccount
  });
  let authSig = {
    sig: signedResult.signature,
    derivedVia: "web3.eth.personal.sign",
    signedMessage: body,
    address: signedResult.address
  };
  if (isBrowser()) {
    localStorage.setItem(
      LOCAL_STORAGE_KEYS.AUTH_SIGNATURE,
      JSON.stringify(authSig)
    );
  }
  const commsKeyPair = nacl2.box.keyPair();
  if (isBrowser()) {
    localStorage.setItem(
      LOCAL_STORAGE_KEYS.KEY_PAIR,
      JSON.stringify({
        publicKey: naclUtil.encodeBase64(commsKeyPair.publicKey),
        secretKey: naclUtil.encodeBase64(commsKeyPair.secretKey)
      })
    );
  }
  log(`generated and saved ${LOCAL_STORAGE_KEYS.KEY_PAIR}`);
  return authSig;
};
var signMessage = async ({
  body,
  web3,
  account
}) => {
  if (isNode()) {
    log("signMessage is not supported in nodejs.");
    return {
      signature: "",
      address: ""
    };
  }
  if (!web3 || !account) {
    log(`web3: ${web3} OR ${account} not found. Connecting web3..`);
    let res = await connectWeb3({ chainId: 1 });
    web3 = res.web3;
    account = res.account;
  }
  log("pausing...");
  await new Promise((resolve) => setTimeout(resolve, 500));
  log("signing with ", account);
  const signature2 = await signMessageAsync(web3.getSigner(), account, body);
  const address = verifyMessage(body, signature2).toLowerCase();
  log("Signature: ", signature2);
  log("recovered address: ", address);
  if (address.toLowerCase() !== account.toLowerCase()) {
    const msg = `ruh roh, the user signed with a different address (${address}) then they're using with web3 (${account}).  this will lead to confusion.`;
    log(msg);
    alert(
      "something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address"
    );
    throw new Error(msg);
  }
  return { signature: signature2, address };
};
var signMessageAsync = async (signer, address, message) => {
  if (isNode()) {
    log("signMessageAsync is not supported in nodejs.");
    return null;
  }
  const messageBytes = toUtf8Bytes(message);
  if (signer instanceof JsonRpcSigner) {
    try {
      log("Signing with personal_sign");
      const signature2 = await signer.provider.send("personal_sign", [
        hexlify(messageBytes),
        address.toLowerCase()
      ]);
      return signature2;
    } catch (e2) {
      log(
        "Signing with personal_sign failed, trying signMessage as a fallback"
      );
      if (e2.message.includes("personal_sign")) {
        return await signer.signMessage(messageBytes);
      }
      throw e2;
    }
  } else {
    log("signing with signMessage");
    return await signer.signMessage(messageBytes);
  }
};

// packages/auth-browser/src/lib/chains/sol.ts
init_shim();
var getProvider2 = () => {
  let resultOrError;
  if ("solana" in window || "backpack" in window) {
    resultOrError = ERight(window?.solana ?? window?.backpack);
  } else {
    const message = "No web3 wallet was found that works with Solana.  Install a Solana wallet or choose another chain";
    resultOrError = ELeft({
      message,
      errorKind: LIT_ERROR.NO_WALLET_EXCEPTION.kind,
      errorCode: LIT_ERROR.NO_WALLET_EXCEPTION.name
    });
  }
  return resultOrError;
};
var connectSolProvider = async () => {
  const providerOrError = getProvider2();
  if (providerOrError.type === "ERROR") {
    throwError(providerOrError.result);
    return;
  }
  let provider = providerOrError.result;
  if (!provider.isConnected) {
    await provider.connect();
  }
  const account = provider.publicKey.toBase58();
  return { provider, account };
};
var checkAndSignSolAuthMessage = async () => {
  const res = await connectSolProvider();
  if (!res) {
    log("Failed to connect sol provider");
  }
  const provider = res?.provider;
  const account = res?.account;
  const key2 = LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE;
  let authSigOrError = getStorageItem(key2);
  let authSig;
  if (authSigOrError.type === "ERROR" /* ERROR */) {
    log("signing auth message because sig is not in local storage");
    await signAndSaveAuthMessage3({ provider });
    authSigOrError.type = "SUCCESS" /* SUCCESS */;
    authSigOrError.result = getStorageItem(key2);
  }
  window.test = authSigOrError;
  try {
    authSig = JSON.parse(authSigOrError.result.result);
  } catch (e2) {
    authSig = JSON.parse(authSigOrError.result);
  }
  if (account !== authSig.address) {
    log(
      "signing auth message because account is not the same as the address in the auth sig"
    );
    await signAndSaveAuthMessage3({ provider });
    authSigOrError.type = "SUCCESS" /* SUCCESS */;
    authSigOrError.result = getStorageItem(key2);
    authSig = JSON.parse(authSigOrError.result);
  }
  log("authSig", authSig);
  return authSig;
};
var signAndSaveAuthMessage3 = async ({
  provider
}) => {
  const now2 = (/* @__PURE__ */ new Date()).toISOString();
  const body = AUTH_SIGNATURE_BODY.replace("{{timestamp}}", now2);
  const data = uint8arrayFromString(body, "utf8");
  let payload;
  let derivedVia = "solana.signMessage";
  if (provider?.isBackpack) {
    const result = await provider.signMessage(data);
    payload = { signature: result };
    derivedVia = "backpack.signMessage";
  } else {
    payload = await provider.signMessage(data, "utf8");
  }
  const hexSig = uint8arrayToString(payload.signature, "base16");
  const authSig = {
    sig: hexSig,
    derivedVia,
    signedMessage: body,
    address: provider.publicKey.toBase58()
  };
  localStorage.setItem(
    LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE,
    JSON.stringify(authSig)
  );
  return authSig;
};

// packages/auth-browser/src/lib/auth-browser.ts
var checkAndSignAuthMessage = ({
  chain,
  resources,
  switchChain,
  expiration,
  uri,
  cosmosWalletType,
  walletConnectProjectId,
  nonce
}) => {
  const chainInfo = ALL_LIT_CHAINS[chain];
  if (!chainInfo) {
    throwError({
      message: `Unsupported chain selected.  Please select one of: ${Object.keys(
        ALL_LIT_CHAINS
      )}`,
      errorKind: LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.kind,
      errorCode: LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.name
    });
  }
  if (!expiration) {
    expiration = new Date(Date.now() + 1e3 * 60 * 60 * 24 * 7).toISOString();
  }
  if (chainInfo.vmType === "EVM" /* EVM */) {
    return checkAndSignEVMAuthMessage({
      chain,
      resources,
      switchChain,
      expiration,
      uri,
      walletConnectProjectId,
      nonce
    });
  } else if (chainInfo.vmType === "SVM" /* SVM */) {
    return checkAndSignSolAuthMessage();
  } else if (chainInfo.vmType === "CVM" /* CVM */) {
    return checkAndSignCosmosAuthMessage({
      chain,
      walletType: cosmosWalletType || "keplr"
    });
  } else {
    return throwError({
      message: `vmType not found for this chain: ${chain}.  This should not happen.  Unsupported chain selected.  Please select one of: ${Object.keys(
        ALL_LIT_CHAINS
      )}`,
      errorKind: LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.kind,
      errorCode: LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.name
    });
  }
};

// packages/lit-node-client/src/lib/lit-node-client.ts
var LitNodeClient = class extends LitNodeClientNodeJs {
  constructor(args) {
    super({
      ...args,
      defaultAuthCallback: checkAndSignAuthMessage
    });
    /**
     *
     * (Browser Only) Get the config from browser local storage and override default config
     *
     * @returns { void }
     *
     */
    this.overrideConfigsFromLocalStorage = () => {
      if (isNode())
        return;
      const storageKey = "LitNodeClientConfig";
      const storageConfigOrError = getStorageItem(storageKey);
      if (storageConfigOrError.type === "ERROR" /* ERROR */) {
        log(
          `[overrideConfigsFromLocalStorage] Storage key "${storageKey}" is missing. `
        );
        return;
      }
      const storageConfig = JSON.parse(storageConfigOrError.result);
      this.config = { ...this.config, ...storageConfig };
    };
    this.overrideConfigsFromLocalStorage();
  }
};

// packages/lit-node-client/src/index.ts
if (isNode()) {
  log("Oh hey you are running in Node.js!");
  const fetch2 = __require("node-fetch");
  globalThis.fetch = fetch2;
}
var LitNodeClient2 = LitNodeClient;
if (!globalThis.LitNodeClient) {
  globalThis.LitNodeClient = LitNodeClient2;
}

// local-tests/setup/networkContext.json
var networkContext_default = {
  Allowlist: {
    address: "0x67d269191c92Caf3cD7723F116c85e6E9bf55933",
    abi: [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "AdminAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "AdminRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          }
        ],
        name: "ItemAllowed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          }
        ],
        name: "ItemNotAllowed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "addAdmin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allowAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "allowedItems",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          }
        ],
        name: "isAllowed",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "removeAdmin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "_allowAll",
            type: "bool"
          }
        ],
        name: "setAllowAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          }
        ],
        name: "setAllowed",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          }
        ],
        name: "setNotAllowed",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "Allowlist"
  },
  LITToken: {
    address: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    abi: [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "cap",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidShortString",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "str",
            type: "string"
          }
        ],
        name: "StringTooLong",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "fromDelegate",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "toDelegate",
            type: "address"
          }
        ],
        name: "DelegateChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegate",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "previousBalance",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newBalance",
            type: "uint256"
          }
        ],
        name: "DelegateVotesChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "EIP712DomainChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Paused",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Unpaused",
        type: "event"
      },
      {
        inputs: [],
        name: "ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "CLOCK_MODE",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "MINTER_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PAUSER_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burnFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "cap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint32",
            name: "pos",
            type: "uint32"
          }
        ],
        name: "checkpoints",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "fromBlock",
                type: "uint32"
              },
              {
                internalType: "uint224",
                name: "votes",
                type: "uint224"
              }
            ],
            internalType: "struct ERC20Votes.Checkpoint",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "clock",
        outputs: [
          {
            internalType: "uint48",
            name: "",
            type: "uint48"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "subtractedValue",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          }
        ],
        name: "delegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "delegateBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "delegates",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "eip712Domain",
        outputs: [
          {
            internalType: "bytes1",
            name: "fields",
            type: "bytes1"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "version",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "verifyingContract",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
          },
          {
            internalType: "uint256[]",
            name: "extensions",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "timepoint",
            type: "uint256"
          }
        ],
        name: "getPastTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "timepoint",
            type: "uint256"
          }
        ],
        name: "getPastVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "numCheckpoints",
        outputs: [
          {
            internalType: "uint32",
            name: "",
            type: "uint32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "paused",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "LITToken"
  },
  Multisender: {
    address: "0x5f3f1dBD7B74C6B46e8c44f98792A1dAf8d69154",
    abi: [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_recipients",
            type: "address[]"
          }
        ],
        name: "sendEth",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_recipients",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "tokenContract",
            type: "address"
          }
        ],
        name: "sendTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "tokenContract",
            type: "address"
          }
        ],
        name: "withdrawTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "Multisender"
  },
  PKPHelper: {
    address: "0x21dF544947ba3E8b3c32561399E88B52Dc8b2823",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "_resolver",
            type: "address"
          },
          {
            internalType: "enum ContractResolver.Env",
            name: "_env",
            type: "uint8"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "ContractResolverAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "derivedKeyId",
                type: "bytes32"
              },
              {
                components: [
                  {
                    internalType: "bytes32",
                    name: "r",
                    type: "bytes32"
                  },
                  {
                    internalType: "bytes32",
                    name: "s",
                    type: "bytes32"
                  },
                  {
                    internalType: "uint8",
                    name: "v",
                    type: "uint8"
                  }
                ],
                internalType: "struct IPubkeyRouter.Signature[]",
                name: "signatures",
                type: "tuple[]"
              }
            ],
            internalType: "struct LibPKPNFTStorage.ClaimMaterial",
            name: "claimMaterial",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes[]",
                name: "permittedIpfsCIDs",
                type: "bytes[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedIpfsCIDScopes",
                type: "uint256[][]"
              },
              {
                internalType: "address[]",
                name: "permittedAddresses",
                type: "address[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedAddressScopes",
                type: "uint256[][]"
              },
              {
                internalType: "uint256[]",
                name: "permittedAuthMethodTypes",
                type: "uint256[]"
              },
              {
                internalType: "bytes[]",
                name: "permittedAuthMethodIds",
                type: "bytes[]"
              },
              {
                internalType: "bytes[]",
                name: "permittedAuthMethodPubkeys",
                type: "bytes[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedAuthMethodScopes",
                type: "uint256[][]"
              },
              {
                internalType: "bool",
                name: "addPkpEthAddressAsPermittedAddress",
                type: "bool"
              },
              {
                internalType: "bool",
                name: "sendPkpToItself",
                type: "bool"
              }
            ],
            internalType: "struct PKPHelper.AuthMethodData",
            name: "authMethodData",
            type: "tuple"
          }
        ],
        name: "claimAndMintNextAndAddAuthMethods",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "derivedKeyId",
                type: "bytes32"
              },
              {
                components: [
                  {
                    internalType: "bytes32",
                    name: "r",
                    type: "bytes32"
                  },
                  {
                    internalType: "bytes32",
                    name: "s",
                    type: "bytes32"
                  },
                  {
                    internalType: "uint8",
                    name: "v",
                    type: "uint8"
                  }
                ],
                internalType: "struct IPubkeyRouter.Signature[]",
                name: "signatures",
                type: "tuple[]"
              }
            ],
            internalType: "struct LibPKPNFTStorage.ClaimMaterial",
            name: "claimMaterial",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes[]",
                name: "permittedIpfsCIDs",
                type: "bytes[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedIpfsCIDScopes",
                type: "uint256[][]"
              },
              {
                internalType: "address[]",
                name: "permittedAddresses",
                type: "address[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedAddressScopes",
                type: "uint256[][]"
              },
              {
                internalType: "uint256[]",
                name: "permittedAuthMethodTypes",
                type: "uint256[]"
              },
              {
                internalType: "bytes[]",
                name: "permittedAuthMethodIds",
                type: "bytes[]"
              },
              {
                internalType: "bytes[]",
                name: "permittedAuthMethodPubkeys",
                type: "bytes[]"
              },
              {
                internalType: "uint256[][]",
                name: "permittedAuthMethodScopes",
                type: "uint256[][]"
              },
              {
                internalType: "bool",
                name: "addPkpEthAddressAsPermittedAddress",
                type: "bool"
              },
              {
                internalType: "bool",
                name: "sendPkpToItself",
                type: "bool"
              }
            ],
            internalType: "struct PKPHelper.AuthMethodData",
            name: "authMethodData",
            type: "tuple"
          }
        ],
        name: "claimAndMintNextAndAddAuthMethodsWithTypes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "contractResolver",
        outputs: [
          {
            internalType: "contract ContractResolver",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "env",
        outputs: [
          {
            internalType: "enum ContractResolver.Env",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDomainWalletRegistry",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPKPNftMetdataAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpNftAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpPermissionsAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "permittedAuthMethodTypes",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodIds",
            type: "bytes[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodPubkeys",
            type: "bytes[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedAuthMethodScopes",
            type: "uint256[][]"
          },
          {
            internalType: "bool",
            name: "addPkpEthAddressAsPermittedAddress",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "sendPkpToItself",
            type: "bool"
          }
        ],
        name: "mintNextAndAddAuthMethods",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "bytes[]",
            name: "permittedIpfsCIDs",
            type: "bytes[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedIpfsCIDScopes",
            type: "uint256[][]"
          },
          {
            internalType: "address[]",
            name: "permittedAddresses",
            type: "address[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedAddressScopes",
            type: "uint256[][]"
          },
          {
            internalType: "uint256[]",
            name: "permittedAuthMethodTypes",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodIds",
            type: "bytes[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodPubkeys",
            type: "bytes[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedAuthMethodScopes",
            type: "uint256[][]"
          },
          {
            internalType: "bool",
            name: "addPkpEthAddressAsPermittedAddress",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "sendPkpToItself",
            type: "bool"
          }
        ],
        name: "mintNextAndAddAuthMethodsWithTypes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "permittedAuthMethodTypes",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodIds",
            type: "bytes[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodPubkeys",
            type: "bytes[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedAuthMethodScopes",
            type: "uint256[][]"
          },
          {
            internalType: "string[]",
            name: "nftMetadata",
            type: "string[]"
          },
          {
            internalType: "bool",
            name: "addPkpEthAddressAsPermittedAddress",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "sendPkpToItself",
            type: "bool"
          }
        ],
        name: "mintNextAndAddDomainWalletMetadata",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "removePkpMetadata",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string[]",
            name: "nftMetadata",
            type: "string[]"
          }
        ],
        name: "setPkpMetadata",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "PKPHelper"
  },
  PKPNFT: {
    address: "0xf5059a5D33d5853360D16C683c16e67980206f36",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "ContractResolverAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newFreeMintSigner",
            type: "address"
          }
        ],
        name: "FreeMintSignerSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newMintCost",
            type: "uint256"
          }
        ],
        name: "MintCostSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "pubkey",
            type: "bytes"
          }
        ],
        name: "PKPMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrew",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "derivedKeyId",
            type: "bytes32"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "r",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "s",
                type: "bytes32"
              },
              {
                internalType: "uint8",
                name: "v",
                type: "uint8"
              }
            ],
            internalType: "struct IPubkeyRouter.Signature[]",
            name: "signatures",
            type: "tuple[]"
          }
        ],
        name: "claimAndMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "exists",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "freeMintSigner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getEthAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNextDerivedKeyId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpNftMetadataAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpPermissionsAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPubkey",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRouterAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getStakingAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "mintCost",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "ipfsCID",
            type: "bytes"
          }
        ],
        name: "mintGrantAndBurnNext",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          }
        ],
        name: "mintNext",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
          }
        ],
        name: "prefixed",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "redeemedFreeMintIds",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newFreeMintSigner",
            type: "address"
          }
        ],
        name: "setFreeMintSigner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMintCost",
            type: "uint256"
          }
        ],
        name: "setMintCost",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenOfOwnerByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "PKPNFT"
  },
  PKPNFTMetadata: {
    address: "0x7969c5eD335650692Bc04293B07F5BF2e7A673C0",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "_resolver",
            type: "address"
          },
          {
            internalType: "enum ContractResolver.Env",
            name: "_env",
            type: "uint8"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "buffer",
            type: "bytes"
          }
        ],
        name: "bytesToHex",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractResolver",
        outputs: [
          {
            internalType: "contract ContractResolver",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "env",
        outputs: [
          {
            internalType: "enum ContractResolver.Env",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "removeProfileForPkp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "removeUrlForPKP",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "imgUrl",
            type: "string"
          }
        ],
        name: "setProfileForPKP",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "url",
            type: "string"
          }
        ],
        name: "setUrlForPKP",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "pubKey",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "ethAddress",
            type: "address"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    name: "PKPNFTMetadata"
  },
  PKPPermissions: {
    address: "0x4C4a2f8c81640e47606d3fd77B353E87Ba015584",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "ContractResolverAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "userPubkey",
            type: "bytes"
          }
        ],
        name: "PermittedAuthMethodAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "PermittedAuthMethodRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "scopeId",
            type: "uint256"
          }
        ],
        name: "PermittedAuthMethodScopeAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "scopeId",
            type: "uint256"
          }
        ],
        name: "PermittedAuthMethodScopeRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "group",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "root",
            type: "bytes32"
          }
        ],
        name: "RootHashUpdated",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "ipfsCID",
            type: "bytes"
          },
          {
            internalType: "uint256[]",
            name: "scopes",
            type: "uint256[]"
          }
        ],
        name: "addPermittedAction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "user",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "scopes",
            type: "uint256[]"
          }
        ],
        name: "addPermittedAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "authMethodType",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "id",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "userPubkey",
                type: "bytes"
              }
            ],
            internalType: "struct LibPKPPermissionsStorage.AuthMethod",
            name: "authMethod",
            type: "tuple"
          },
          {
            internalType: "uint256[]",
            name: "scopes",
            type: "uint256[]"
          }
        ],
        name: "addPermittedAuthMethod",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "scopeId",
            type: "uint256"
          }
        ],
        name: "addPermittedAuthMethodScope",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "permittedAuthMethodTypesToAdd",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodIdsToAdd",
            type: "bytes[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodPubkeysToAdd",
            type: "bytes[]"
          },
          {
            internalType: "uint256[][]",
            name: "permittedAuthMethodScopesToAdd",
            type: "uint256[][]"
          },
          {
            internalType: "uint256[]",
            name: "permittedAuthMethodTypesToRemove",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "permittedAuthMethodIdsToRemove",
            type: "bytes[]"
          }
        ],
        name: "batchAddRemoveAuthMethods",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "getAuthMethodId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getEthAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPermittedActions",
        outputs: [
          {
            internalType: "bytes[]",
            name: "",
            type: "bytes[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPermittedAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "maxScopeId",
            type: "uint256"
          }
        ],
        name: "getPermittedAuthMethodScopes",
        outputs: [
          {
            internalType: "bool[]",
            name: "",
            type: "bool[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPermittedAuthMethods",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "authMethodType",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "id",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "userPubkey",
                type: "bytes"
              }
            ],
            internalType: "struct LibPKPPermissionsStorage.AuthMethod[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpNftAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPubkey",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRouterAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "getTokenIdsForAuthMethod",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "getUserPubkeyForAuthMethod",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "ipfsCID",
            type: "bytes"
          }
        ],
        name: "isPermittedAction",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "user",
            type: "address"
          }
        ],
        name: "isPermittedAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "isPermittedAuthMethod",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "scopeId",
            type: "uint256"
          }
        ],
        name: "isPermittedAuthMethodScopePresent",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "ipfsCID",
            type: "bytes"
          }
        ],
        name: "removePermittedAction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "user",
            type: "address"
          }
        ],
        name: "removePermittedAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          }
        ],
        name: "removePermittedAuthMethod",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "authMethodType",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "id",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "scopeId",
            type: "uint256"
          }
        ],
        name: "removePermittedAuthMethodScope",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "group",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "root",
            type: "bytes32"
          }
        ],
        name: "setRootHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "group",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "bytes32",
            name: "leaf",
            type: "bytes32"
          }
        ],
        name: "verifyState",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "group",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "bool[]",
            name: "proofFlags",
            type: "bool[]"
          },
          {
            internalType: "bytes32[]",
            name: "leaves",
            type: "bytes32[]"
          }
        ],
        name: "verifyStates",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    name: "PKPPermissions"
  },
  PubkeyRouter: {
    address: "0x1291Be112d480055DaFd8a610b7d1e203891C274",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "ContractResolverAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "pubkey",
            type: "bytes"
          },
          {
            indexed: false,
            internalType: "address",
            name: "stakingContract",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "derivedKeyId",
            type: "bytes32"
          }
        ],
        name: "PubkeyRoutingDataSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "stakingContract",
            type: "address"
          },
          {
            components: [
              {
                internalType: "bytes",
                name: "pubkey",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              }
            ],
            indexed: false,
            internalType: "struct IPubkeyRouter.RootKey",
            name: "rootKey",
            type: "tuple"
          }
        ],
        name: "RootKeySet",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakingContract",
            type: "address"
          }
        ],
        name: "adminResetRootKeys",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "r",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "s",
                type: "bytes32"
              },
              {
                internalType: "uint8",
                name: "v",
                type: "uint8"
              }
            ],
            internalType: "struct IPubkeyRouter.Signature[]",
            name: "signatures",
            type: "tuple[]"
          },
          {
            internalType: "bytes",
            name: "signedMessage",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "stakingContractAddress",
            type: "address"
          }
        ],
        name: "checkNodeSignatures",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "pubkey",
            type: "bytes"
          }
        ],
        name: "deriveEthAddressFromPubkey",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "ethAddress",
            type: "address"
          }
        ],
        name: "ethAddressToPkpId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakingContract",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "derivedKeyId",
            type: "bytes32"
          }
        ],
        name: "getDerivedPubkey",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getEthAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPkpNftAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getPubkey",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakingContract",
            type: "address"
          }
        ],
        name: "getRootKeys",
        outputs: [
          {
            components: [
              {
                internalType: "bytes",
                name: "pubkey",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              }
            ],
            internalType: "struct IPubkeyRouter.RootKey[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getRoutingData",
        outputs: [
          {
            components: [
              {
                internalType: "bytes",
                name: "pubkey",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "derivedKeyId",
                type: "bytes32"
              }
            ],
            internalType: "struct LibPubkeyRouterStorage.PubkeyRoutingData",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "isRouted",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "pubkeys",
        outputs: [
          {
            components: [
              {
                internalType: "bytes",
                name: "pubkey",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "derivedKeyId",
                type: "bytes32"
              }
            ],
            internalType: "struct LibPubkeyRouterStorage.PubkeyRoutingData",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "pubkey",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "stakingContractAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "derivedKeyId",
            type: "bytes32"
          }
        ],
        name: "setRoutingData",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "pubkey",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "stakingContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "keyType",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "derivedKeyId",
            type: "bytes32"
          }
        ],
        name: "setRoutingDataAsAdmin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakingContractAddress",
            type: "address"
          },
          {
            components: [
              {
                internalType: "bytes",
                name: "pubkey",
                type: "bytes"
              },
              {
                internalType: "uint256",
                name: "keyType",
                type: "uint256"
              }
            ],
            internalType: "struct IPubkeyRouter.RootKey[]",
            name: "newRootKeys",
            type: "tuple[]"
          }
        ],
        name: "voteForRootKeys",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "PubkeyRouter"
  },
  RateLimitNFT: {
    address: "0x8f86403A4DE0BB5791fa46B8e795C547942fE4Cf",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newAdditionalRequestsPerKilosecondCost",
            type: "uint256"
          }
        ],
        name: "AdditionalRequestsPerKilosecondCostSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newFreeMintSigner",
            type: "address"
          }
        ],
        name: "FreeMintSignerSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newFreeRequestsPerRateLimitWindow",
            type: "uint256"
          }
        ],
        name: "FreeRequestsPerRateLimitWindowSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newRLIHolderRateLimitWindowSeconds",
            type: "uint256"
          }
        ],
        name: "RLIHolderRateLimitWindowSecondsSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newRateLimitWindowSeconds",
            type: "uint256"
          }
        ],
        name: "RateLimitWindowSecondsSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrew",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "requestsPerKilosecond",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "sVal",
            type: "bytes32"
          }
        ],
        name: "freeMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newAdditionalRequestsPerKilosecondCost",
            type: "uint256"
          }
        ],
        name: "setAdditionalRequestsPerKilosecondCost",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newFreeMintSigner",
            type: "address"
          }
        ],
        name: "setFreeMintSigner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newFreeRequestsPerRateLimitWindow",
            type: "uint256"
          }
        ],
        name: "setFreeRequestsPerRateLimitWindow",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMaxExpirationSeconds",
            type: "uint256"
          }
        ],
        name: "setMaxExpirationSeconds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMaxRequestsPerKilosecond",
            type: "uint256"
          }
        ],
        name: "setMaxRequestsPerKilosecond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newRLIHolderRateLimitWindowSeconds",
            type: "uint256"
          }
        ],
        name: "setRLIHolderRateLimitWindowSeconds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newRateLimitWindowSeconds",
            type: "uint256"
          }
        ],
        name: "setRateLimitWindowSeconds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenOfOwnerByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "RLIHolderRateLimitWindowSeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "additionalRequestsPerKilosecondCost",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "requestsPerKilosecond",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          }
        ],
        name: "calculateCost",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "payingAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          }
        ],
        name: "calculateRequestsPerKilosecond",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "capacity",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "requestsPerKilosecond",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "expiresAt",
                type: "uint256"
              }
            ],
            internalType: "struct LibRateLimitNFTStorage.RateLimit",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "requestedRequestsPerKilosecond",
            type: "uint256"
          }
        ],
        name: "checkBelowMaxRequestsPerKilosecond",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "currentSoldRequestsPerKilosecond",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "defaultRateLimitWindowSeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "requestsPerKilosecond",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "sVal",
            type: "bytes32"
          }
        ],
        name: "freeMintSigTest",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "freeMintSigner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "freeRequestsPerRateLimitWindow",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "isExpired",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maxExpirationSeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maxRequestsPerKilosecond",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
          }
        ],
        name: "prefixed",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "redeemedFreeMints",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tokenIdCounter",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "tokenSVG",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
          }
        ],
        name: "totalSoldRequestsPerKilosecondByExpirationTime",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    name: "RateLimitNFT"
  },
  Staking: {
    address: "0xc5a5C42992dECbae36851359345FE25997F5C42d",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "ActiveValidatorsCannotLeave",
        type: "error"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "CannotKickBelowCurrentValidatorThreshold",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakingAddress",
            type: "address"
          }
        ],
        name: "CannotRejoinUntilNextEpochBecauseKicked",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "senderPubKey",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "receiverPubKey",
            type: "uint256"
          }
        ],
        name: "CannotReuseCommsKeys",
        type: "error"
      },
      {
        inputs: [],
        name: "CannotStakeZero",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "CannotVoteTwice",
        type: "error"
      },
      {
        inputs: [],
        name: "CannotWithdrawZero",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "nodeAddress",
            type: "address"
          }
        ],
        name: "CouldNotMapNodeAddressToStakerAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInActiveOrUnlockedOrPausedState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInActiveOrUnlockedState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInNextValidatorSetLockedOrReadyForNextEpochState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInNextValidatorSetLockedState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "state",
            type: "uint8"
          }
        ],
        name: "MustBeInReadyForNextEpochState",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "MustBeValidatorInNextEpochToKick",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "currentTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "epochEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeout",
            type: "uint256"
          }
        ],
        name: "NotEnoughTimeElapsedForTimeoutSinceLastEpoch",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "currentTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "epochEndTime",
            type: "uint256"
          }
        ],
        name: "NotEnoughTimeElapsedSinceLastEpoch",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "validatorCount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumValidatorCount",
            type: "uint256"
          }
        ],
        name: "NotEnoughValidatorsInNextEpoch",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "currentReadyValidatorCount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nextReadyValidatorCount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumValidatorCountToBeReady",
            type: "uint256"
          }
        ],
        name: "NotEnoughValidatorsReadyForNextEpoch",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "currentEpochNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "receivedEpochNumber",
            type: "uint256"
          }
        ],
        name: "SignaledReadyForWrongEpochNumber",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "StakerNotPermitted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "yourBalance",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "requestedWithdrawlAmount",
            type: "uint256"
          }
        ],
        name: "TryingToWithdrawMoreThanStaked",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "validator",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "validatorsInNextEpoch",
            type: "address[]"
          }
        ],
        name: "ValidatorIsNotInNextEpoch",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "tolerance",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "intervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "kickPenaltyPercent",
                type: "uint256"
              }
            ],
            indexed: false,
            internalType: "struct LibStakingStorage.ComplaintConfig",
            name: "config",
            type: "tuple"
          }
        ],
        name: "ComplaintConfigSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newTokenRewardPerTokenPerEpoch",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "newKeyTypes",
            type: "uint256[]"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newMinimumValidatorCount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newMaxConcurrentRequests",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newMaxTripleCount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newMinTripleCount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newPeerCheckingIntervalSecs",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newMaxTripleConcurrency",
            type: "uint256"
          }
        ],
        name: "ConfigSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newEpochEndTime",
            type: "uint256"
          }
        ],
        name: "EpochEndTimeSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newEpochLength",
            type: "uint256"
          }
        ],
        name: "EpochLengthSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newEpochTimeout",
            type: "uint256"
          }
        ],
        name: "EpochTimeoutSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newKickPenaltyPercent",
            type: "uint256"
          }
        ],
        name: "KickPenaltyPercentSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "epochNumber",
            type: "uint256"
          }
        ],
        name: "ReadyForNextEpoch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Recovered",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "RequestToJoin",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "RequestToLeave",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverContractAddress",
            type: "address"
          }
        ],
        name: "ResolverContractAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newDuration",
            type: "uint256"
          }
        ],
        name: "RewardsDurationUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newStakingTokenAddress",
            type: "address"
          }
        ],
        name: "StakingTokenSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "enum LibStakingStorage.States",
            name: "newState",
            type: "uint8"
          }
        ],
        name: "StateChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amountBurned",
            type: "uint256"
          }
        ],
        name: "ValidatorKickedFromNextEpoch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "ValidatorRejoinedNextEpoch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "validatorStakerAddress",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "VotedToKickValidatorInNextEpoch",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "validatorStakerAddress",
            type: "address"
          }
        ],
        name: "adminKickValidatorInNextEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "adminRejoinValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "adminResetEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "validatorStakerAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountToPenalize",
            type: "uint256"
          }
        ],
        name: "adminSlashValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "advanceEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "exit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getReward",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "validatorStakerAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "kickValidatorInNextEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "lockValidatorsForNextEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "ip",
            type: "uint32"
          },
          {
            internalType: "uint128",
            name: "ipv6",
            type: "uint128"
          },
          {
            internalType: "uint32",
            name: "port",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "nodeAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "senderPubKey",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "receiverPubKey",
            type: "uint256"
          }
        ],
        name: "requestToJoin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "requestToLeave",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "requestToLeaveAsNode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "tolerance",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "intervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "kickPenaltyPercent",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.ComplaintConfig",
            name: "config",
            type: "tuple"
          }
        ],
        name: "setComplaintConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "tokenRewardPerTokenPerEpoch",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "DEPRECATED_complaintTolerance",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "DEPRECATED_complaintIntervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256[]",
                name: "keyTypes",
                type: "uint256[]"
              },
              {
                internalType: "uint256",
                name: "minimumValidatorCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxConcurrentRequests",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxTripleCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minTripleCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "peerCheckingIntervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxTripleConcurrency",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Config",
            name: "newConfig",
            type: "tuple"
          }
        ],
        name: "setConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newEpochEndTime",
            type: "uint256"
          }
        ],
        name: "setEpochEndTime",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newEpochLength",
            type: "uint256"
          }
        ],
        name: "setEpochLength",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "newState",
            type: "uint8"
          }
        ],
        name: "setEpochState",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newEpochTimeout",
            type: "uint256"
          }
        ],
        name: "setEpochTimeout",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint32",
            name: "ip",
            type: "uint32"
          },
          {
            internalType: "uint128",
            name: "ipv6",
            type: "uint128"
          },
          {
            internalType: "uint32",
            name: "port",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "nodeAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "senderPubKey",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "receiverPubKey",
            type: "uint256"
          }
        ],
        name: "setIpPortNodeAddressAndCommunicationPubKeys",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "newKickPenaltyPercent",
            type: "uint256"
          }
        ],
        name: "setKickPenaltyPercent",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "epochNumber",
            type: "uint256"
          }
        ],
        name: "signalReadyForNextEpoch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "stake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "ip",
            type: "uint32"
          },
          {
            internalType: "uint128",
            name: "ipv6",
            type: "uint128"
          },
          {
            internalType: "uint32",
            name: "port",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "nodeAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "senderPubKey",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "receiverPubKey",
            type: "uint256"
          }
        ],
        name: "stakeAndJoin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            indexed: false,
            internalType: "struct LibStakingStorage.Version",
            name: "version",
            type: "tuple"
          }
        ],
        name: "VersionRequirementsUpdated",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Version",
            name: "version",
            type: "tuple"
          }
        ],
        name: "checkVersion",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getMaxVersion",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Version",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getMaxVersionString",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getMinVersion",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Version",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getMinVersionString",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Version",
            name: "version",
            type: "tuple"
          }
        ],
        name: "setMaxVersion",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "major",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minor",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "patch",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Version",
            name: "version",
            type: "tuple"
          }
        ],
        name: "setMinVersion",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          }
        ],
        name: "complaintConfig",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "tolerance",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "intervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "kickPenaltyPercent",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.ComplaintConfig",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "config",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "tokenRewardPerTokenPerEpoch",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "DEPRECATED_complaintTolerance",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "DEPRECATED_complaintIntervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256[]",
                name: "keyTypes",
                type: "uint256[]"
              },
              {
                internalType: "uint256",
                name: "minimumValidatorCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxConcurrentRequests",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxTripleCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "minTripleCount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "peerCheckingIntervalSecs",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxTripleConcurrency",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Config",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractResolver",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "countOfCurrentValidatorsReadyForNextEpoch",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "countOfNextValidatorsReadyForNextEpoch",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "currentValidatorCountForConsensus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "epoch",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "epochLength",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "number",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endTime",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "retries",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "timeout",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Epoch",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getKeyTypes",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getKickedValidators",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "addresses",
            type: "address[]"
          }
        ],
        name: "getNodeStakerAddressMappings",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "nodeAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "stakerAddress",
                type: "address"
              }
            ],
            internalType: "struct LibStakingStorage.AddressMapping[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getStakingBalancesAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getValidatorsInCurrentEpoch",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getValidatorsInCurrentEpochLength",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getValidatorsInNextEpoch",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "addresses",
            type: "address[]"
          }
        ],
        name: "getValidatorsStructs",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "ip",
                type: "uint32"
              },
              {
                internalType: "uint128",
                name: "ipv6",
                type: "uint128"
              },
              {
                internalType: "uint32",
                name: "port",
                type: "uint32"
              },
              {
                internalType: "address",
                name: "nodeAddress",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reward",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "senderPubKey",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "receiverPubKey",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Validator[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getValidatorsStructsInCurrentEpoch",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "ip",
                type: "uint32"
              },
              {
                internalType: "uint128",
                name: "ipv6",
                type: "uint128"
              },
              {
                internalType: "uint32",
                name: "port",
                type: "uint32"
              },
              {
                internalType: "address",
                name: "nodeAddress",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reward",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "senderPubKey",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "receiverPubKey",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Validator[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getValidatorsStructsInNextEpoch",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "ip",
                type: "uint32"
              },
              {
                internalType: "uint128",
                name: "ipv6",
                type: "uint128"
              },
              {
                internalType: "uint32",
                name: "port",
                type: "uint32"
              },
              {
                internalType: "address",
                name: "nodeAddress",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reward",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "senderPubKey",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "receiverPubKey",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Validator[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "epochNumber",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "validatorStakerAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "voterStakerAddress",
            type: "address"
          }
        ],
        name: "getVotingStatusToKickValidator",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "isActiveValidator",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "isActiveValidatorByNodeAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isReadyForNextEpoch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reason",
            type: "uint256"
          }
        ],
        name: "kickPenaltyPercentByReason",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextValidatorCountForConsensus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "nodeAddress",
            type: "address"
          }
        ],
        name: "nodeAddressToStakerAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "readyForNextEpoch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "shouldKickValidator",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "state",
        outputs: [
          {
            internalType: "enum LibStakingStorage.States",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "validators",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "ip",
                type: "uint32"
              },
              {
                internalType: "uint128",
                name: "ipv6",
                type: "uint128"
              },
              {
                internalType: "uint32",
                name: "port",
                type: "uint32"
              },
              {
                internalType: "address",
                name: "nodeAddress",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reward",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "senderPubKey",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "receiverPubKey",
                type: "uint256"
              }
            ],
            internalType: "struct LibStakingStorage.Validator",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    name: "Staking"
  },
  StakingBalances: {
    address: "0xc6e7DF5E7b4f2A278906862b61205850344D4e7d",
    abi: [
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotAddFunctionToDiamondThatAlreadyExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotAddSelectorsToZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveFunctionThatDoesNotExist",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotRemoveImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionThatDoesNotExists",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4[]",
            name: "_selectors",
            type: "bytes4[]"
          }
        ],
        name: "CannotReplaceFunctionsFromFacetWithZeroAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "CannotReplaceImmutableFunction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint8",
            name: "_action",
            type: "uint8"
          }
        ],
        name: "IncorrectFacetCutAction",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_initializationContractAddress",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "InitializationFunctionReverted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "_message",
            type: "string"
          }
        ],
        name: "NoBytecodeAtAddress",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "NoSelectorsProvidedForFacetForCut",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            internalType: "address",
            name: "_contractOwner",
            type: "address"
          }
        ],
        name: "NotContractOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facetAddress",
            type: "address"
          }
        ],
        name: "RemoveFacetAddressMustBeZeroAddress",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            indexed: false,
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "DiamondCut",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "enum IDiamond.FacetCutAction",
                name: "action",
                type: "uint8"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamond.FacetCut[]",
            name: "_diamondCut",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_init",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          }
        ],
        name: "diamondCut",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_functionSelector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facetAddress_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facetAddresses_",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "_facetFunctionSelectors",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "facetAddress",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "functionSelectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IDiamondLoupe.Facet[]",
            name: "facets_",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "ActiveValidatorsCannotLeave",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          },
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "AliasNotOwnedBySender",
        type: "error"
      },
      {
        inputs: [],
        name: "CallerNotOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "CannotRemoveAliasOfActiveValidator",
        type: "error"
      },
      {
        inputs: [],
        name: "CannotStakeZero",
        type: "error"
      },
      {
        inputs: [],
        name: "CannotWithdrawZero",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "aliasCount",
            type: "uint256"
          }
        ],
        name: "MaxAliasCountReached",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "OnlyStakingContract",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amountStaked",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumStake",
            type: "uint256"
          }
        ],
        name: "StakeMustBeGreaterThanMinimumStake",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amountStaked",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maximumStake",
            type: "uint256"
          }
        ],
        name: "StakeMustBeLessThanMaximumStake",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "stakerAddress",
            type: "address"
          }
        ],
        name: "StakerNotPermitted",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "yourBalance",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "requestedWithdrawlAmount",
            type: "uint256"
          }
        ],
        name: "TryingToWithdrawMoreThanStaked",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "AliasAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "AliasRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newMaxAliasCount",
            type: "uint256"
          }
        ],
        name: "MaxAliasCountSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newMaximumStake",
            type: "uint256"
          }
        ],
        name: "MaximumStakeSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newMinimumStake",
            type: "uint256"
          }
        ],
        name: "MinimumStakeSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "PermittedStakerAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "PermittedStakerRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bool",
            name: "permittedStakersOn",
            type: "bool"
          }
        ],
        name: "PermittedStakersOnChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "ResolverContractAddressSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "reward",
            type: "uint256"
          }
        ],
        name: "RewardPaid",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Staked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "newTokenRewardPerTokenPerEpoch",
            type: "uint256"
          }
        ],
        name: "TokenRewardPerTokenPerEpochSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "ValidatorNotRewardedBecauseAlias",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "ValidatorRewarded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "ValidatorTokensPenalized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Withdrawn",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "addAlias",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "addPermittedStaker",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "stakers",
            type: "address[]"
          }
        ],
        name: "addPermittedStakers",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "checkStakingAmounts",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractResolver",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getReward",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getStakingAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "isPermittedStaker",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maximumStake",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumStake",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "penalizeTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "permittedStakersOn",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "aliasAccount",
            type: "address"
          }
        ],
        name: "removeAlias",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "staker",
            type: "address"
          }
        ],
        name: "removePermittedStaker",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "staker",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "balance",
            type: "uint256"
          }
        ],
        name: "restakePenaltyTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "rewardOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "rewardValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newResolverAddress",
            type: "address"
          }
        ],
        name: "setContractResolver",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMaxAliasCount",
            type: "uint256"
          }
        ],
        name: "setMaxAliasCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMaximumStake",
            type: "uint256"
          }
        ],
        name: "setMaximumStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMinimumStake",
            type: "uint256"
          }
        ],
        name: "setMinimumStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "permitted",
            type: "bool"
          }
        ],
        name: "setPermittedStakersOn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "stake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "totalStaked",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "balance",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "transferPenaltyTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "balance",
            type: "uint256"
          }
        ],
        name: "withdrawPenaltyTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    name: "StakingBalances"
  },
  ContractResolver: {
    address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    abi: [
      {
        inputs: [
          {
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "AdminRoleRequired",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        name: "AllowedEnvAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        name: "AllowedEnvRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "typ",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "SetContract",
        type: "event"
      },
      {
        inputs: [],
        name: "ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "ALLOWLIST_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "BACKUP_RECOVERY_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_WALLET_REGISTRY",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "HD_KEY_DERIVER_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "LIT_TOKEN_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "MULTI_SENDER_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PAYMENT_DELEGATION_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PKP_HELPER_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PKP_NFT_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PKP_NFT_METADATA_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PKP_PERMISSIONS_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PUB_KEY_ROUTER_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "RATE_LIMIT_NFT_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "RELEASE_REGISTER_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "STAKING_BALANCES_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "STAKING_CONTRACT",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newAdmin",
            type: "address"
          }
        ],
        name: "addAdmin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        name: "addAllowedEnv",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "typ",
            type: "bytes32"
          },
          {
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        name: "getContract",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "adminBeingRemoved",
            type: "address"
          }
        ],
        name: "removeAdmin",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          }
        ],
        name: "removeAllowedEnv",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "typ",
            type: "bytes32"
          },
          {
            internalType: "enum ContractResolver.Env",
            name: "env",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "setContract",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          },
          {
            internalType: "enum ContractResolver.Env",
            name: "",
            type: "uint8"
          }
        ],
        name: "typeAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    name: "ContractResolver"
  }
};

// packages/lit-auth-client/src/index.ts
init_shim();

// packages/lit-auth-client/src/lib/lit-auth-client.ts
init_shim();

// packages/lit-auth-client/src/lib/relay.ts
init_shim();

// packages/lit-auth-client/src/lib/utils.ts
init_shim();
import * as cbor from "cbor-web";
var STATE_PARAM_KEY = "lit-state-param";
var LIT_LOGIN_GATEWAY = "https://login.litgateway.com";
async function prepareLoginUrl(provider, redirectUri, baseUrl = LIT_LOGIN_GATEWAY) {
  const loginUrl = `${baseUrl}${getLoginRoute(provider)}`;
  const state = encode5(await setStateParam());
  const authParams = {
    app_redirect: redirectUri
  };
  const queryAuthParams = createQueryParams(authParams);
  return `${loginUrl}?${queryAuthParams}&state=${state}`;
}
function getLoginRoute(provider) {
  switch (provider) {
    case "google":
      return "/auth/google";
    case "discord":
      return "/auth/discord";
    default:
      throw new Error(
        `No login route available for the given provider "${provider}".`
      );
  }
}
function createQueryParams(params) {
  const filteredParams = Object.keys(params).filter((k) => typeof params[k] !== "undefined").reduce((acc, key2) => ({ ...acc, [key2]: params[key2] }), {});
  return new URLSearchParams(filteredParams).toString();
}
function parseLoginParams(search) {
  const searchParams = new URLSearchParams(search);
  const provider = searchParams.get("provider");
  const accessToken = searchParams.get("access_token");
  const idToken = searchParams.get("id_token");
  const state = searchParams.get("state");
  const error = searchParams.get("error");
  return {
    provider,
    accessToken,
    idToken,
    state,
    error
  };
}
async function setStateParam() {
  const { nanoid } = await import("nanoid");
  const state = nanoid(15);
  sessionStorage.setItem(STATE_PARAM_KEY, state);
  return state;
}
function getStateParam() {
  return sessionStorage.getItem(STATE_PARAM_KEY);
}
function encode5(value) {
  return window.btoa(value);
}
function decode5(value) {
  return window.atob(value);
}
function getRPIdFromOrigin(origin) {
  const newOrigin = origin.replace(/(^\w+:|^)\/\//, "");
  return newOrigin.replace(/:\d+$/, "");
}
function parseAuthenticatorData(authDataBuffer) {
  try {
    let authDataBufferDecoded = cbor.decode(authDataBuffer);
    const authenticatorData = {};
    let authData = authDataBufferDecoded.authData;
    authenticatorData.rpIdHash = authData.slice(0, 32);
    authenticatorData.flags = authData[32];
    authenticatorData.signCount = authData[33] << 24 | authData[34] << 16 | authData[35] << 8 | authData[36];
    if (authenticatorData.flags & 64) {
      const attestedCredentialData = {};
      attestedCredentialData["aaguid"] = unparse(authData.slice(37, 53));
      attestedCredentialData["credentialIdLength"] = authData[53] << 8 | authData[54];
      attestedCredentialData["credentialId"] = authData.slice(
        55,
        55 + attestedCredentialData["credentialIdLength"]
      );
      let publicKeyCoseBufferCbor = authData.slice(
        55 + attestedCredentialData["credentialIdLength"],
        authData.length
      );
      const publicKey = cbor.decode(publicKeyCoseBufferCbor);
      publicKeyCoseBufferCbor = cbor.encode(publicKey);
      attestedCredentialData["credentialPublicKey"] = publicKeyCoseBufferCbor;
      authenticatorData.attestedCredentialData = attestedCredentialData;
    }
    if (authenticatorData.flags & 128) {
      let extensionDataCbor;
      if (authenticatorData.attestedCredentialData) {
        extensionDataCbor = cbor.decode(
          // decodeAllSync(
          authData.slice(
            55 + authenticatorData.attestedCredentialData.credentialIdLength,
            authData.length
          )
        );
        extensionDataCbor = extensionDataCbor[1];
      } else {
        extensionDataCbor = cbor.decode(authData.slice(37, authData.length));
      }
      authenticatorData.extensionData = cbor.encode(extensionDataCbor).toString("base64");
    }
    return authenticatorData;
  } catch (e2) {
    throw new Error("Authenticator Data could not be parsed");
  }
}
function unparse(buf) {
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i2 = 0; i2 < 256; i2++) {
    _byteToHex[i2] = (i2 + 256).toString(16).substr(1);
    _hexToByte[_byteToHex[i2]] = i2;
  }
  var i2 = 0;
  var bth = _byteToHex;
  return bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]];
}
function log2(...args) {
  const logger47 = getLoggerbyId("auth-client");
  logger47.debug(...args);
}

// packages/lit-auth-client/src/lib/relay.ts
var LitRelay = class {
  /**
   * Create a Relay instance
   *
   * @param {LitRelayConfig} config
   * @param {string} [config.relayApiKey] - API key for Lit's relay server
   * @param {string} [config.relayUrl] - URL for Lit's relay server
   */
  constructor(config) {
    /**
     * Route for minting PKP
     */
    this.mintRoute = "/mint-next-and-add-auth-methods";
    /**
     * Route for fetching PKPs
     */
    this.fetchRoute = "/fetch-pkps-by-auth-method";
    this.relayUrl = config.relayUrl || "https://relayer-server-staging-cayenne.getlit.dev";
    this.relayApiKey = config.relayApiKey || "";
    log2("Lit's relay server URL:", this.relayUrl);
  }
  /**
   * Mint a new PKP for the given auth method
   *
   * @param {string} body - Body of the request
   *
   * @returns {Promise<IRelayMintResponse>} Response from the relay server
   */
  async mintPKP(body) {
    const response = await fetch(`${this.relayUrl}${this.mintRoute}`, {
      method: "POST",
      headers: {
        "api-key": this.relayApiKey,
        "Content-Type": "application/json"
      },
      body
    });
    if (response.status < 200 || response.status >= 400) {
      log2("Something wrong with the API call", await response.json());
      const err = new Error("Unable to mint PKP through relay server");
      throw err;
    } else {
      const resBody = await response.json();
      log2("Successfully initiated minting PKP with relayer");
      return resBody;
    }
  }
  /**
   * Poll the relay server for status of minting request
   *
   * @param {string} requestId - Request ID to poll, likely the minting transaction hash
   * @param {number} [pollInterval] - Polling interval in milliseconds
   * @param {number} [maxPollCount] - Maximum number of times to poll
   *
   * @returns {Promise<IRelayPollStatusResponse>} Response from the relay server
   */
  async pollRequestUntilTerminalState(requestId, pollInterval = 15e3, maxPollCount = 20) {
    for (let i2 = 0; i2 < maxPollCount; i2++) {
      const response = await fetch(
        `${this.relayUrl}/auth/status/${requestId}`,
        {
          method: "GET",
          headers: {
            "api-key": this.relayApiKey
          }
        }
      );
      if (response.status < 200 || response.status >= 400) {
        log2("Something wrong with the API call", await response.json());
        const err2 = new Error(
          `Unable to poll the status of this mint PKP transaction: ${requestId}`
        );
        throw err2;
      }
      const resBody = await response.json();
      log2("Response OK", { body: resBody });
      if (resBody.error) {
        log2("Something wrong with the API call", {
          error: resBody.error
        });
        const err2 = new Error(resBody.error);
        throw err2;
      } else if (resBody.status === "Succeeded") {
        log2("Successfully authed", { ...resBody });
        return resBody;
      }
      await new Promise((r3) => setTimeout(r3, pollInterval));
    }
    const err = new Error("Polling for mint PKP transaction status timed out");
    throw err;
  }
  /**
   * Fetch PKPs associated with the given auth method
   *
   * @param {string} body - Body of the request
   *
   * @returns {Promise<IRelayFetchResponse>} Response from the relay server
   */
  async fetchPKPs(body) {
    const response = await fetch(`${this.relayUrl}${this.fetchRoute}`, {
      method: "POST",
      headers: {
        "api-key": this.relayApiKey,
        "Content-Type": "application/json"
      },
      body
    });
    if (response.status < 200 || response.status >= 400) {
      console.warn("Something wrong with the API call", await response.json());
      const err = new Error("Unable to fetch PKPs through relay server");
      throw err;
    } else {
      const resBody = await response.json();
      console.log("Successfully fetched PKPs with relayer");
      return resBody;
    }
  }
  /**
   * Generate options for registering a new credential to pass to the authenticator
   *
   * @param {string} [username] - Optional username to associate with the credential
   *
   * @returns {Promise<any>} Registration options for the browser to pass to the authenticator
   */
  async generateRegistrationOptions(username) {
    let url = `${this.relayUrl}/auth/webauthn/generate-registration-options`;
    if (username && username !== "") {
      url = `${url}?username=${encodeURIComponent(username)}`;
    }
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "api-key": this.relayApiKey
      }
    });
    if (response.status < 200 || response.status >= 400) {
      const err = new Error(
        `Unable to generate registration options: ${response}`
      );
      throw err;
    }
    const registrationOptions = await response.json();
    return registrationOptions;
  }
};

// packages/lit-auth-client/src/lib/providers/GoogleProvider.ts
init_shim();

// packages/lit-auth-client/src/lib/providers/BaseProvider.ts
init_shim();

// packages/lit-auth-client/src/lib/validators.ts
init_shim();
var validateMintRequestBody = (customArgs) => {
  let isValid = true;
  const validKeys = [
    "keyType",
    "permittedAuthMethodTypes",
    "permittedAuthMethodIds",
    "permittedAuthMethodPubkeys",
    "permittedAuthMethodScopes",
    "addPkpEthAddressAsPermittedAddress",
    "sendPkpToItself"
  ];
  for (const key2 of Object.keys(customArgs)) {
    if (!validKeys.includes(key2)) {
      console.error(
        `Invalid key found: ${key2}. This key is not allowed. Valid keys are: ${validKeys.join(
          ", "
        )}`
      );
      isValid = false;
    }
  }
  if (customArgs.keyType !== void 0 && typeof customArgs.keyType !== "number") {
    console.error("Invalid type for keyType: expected a number.");
    isValid = false;
  }
  if (customArgs.permittedAuthMethodTypes !== void 0 && (!Array.isArray(customArgs.permittedAuthMethodTypes) || !customArgs.permittedAuthMethodTypes.every(
    (type) => typeof type === "number"
  ))) {
    console.error(
      "Invalid type for permittedAuthMethodTypes: expected an array of numbers."
    );
    isValid = false;
  }
  if (customArgs.permittedAuthMethodIds !== void 0 && (!Array.isArray(customArgs.permittedAuthMethodIds) || !customArgs.permittedAuthMethodIds.every((id2) => typeof id2 === "string"))) {
    console.error(
      "Invalid type for permittedAuthMethodIds: expected an array of strings."
    );
    isValid = false;
  }
  if (customArgs.permittedAuthMethodPubkeys !== void 0 && (!Array.isArray(customArgs.permittedAuthMethodPubkeys) || !customArgs.permittedAuthMethodPubkeys.every(
    (pubkey) => typeof pubkey === "string"
  ))) {
    console.error(
      "Invalid type for permittedAuthMethodPubkeys: expected an array of strings."
    );
    isValid = false;
  }
  if (customArgs.permittedAuthMethodScopes !== void 0 && (!Array.isArray(customArgs.permittedAuthMethodScopes) || !customArgs.permittedAuthMethodScopes.every(
    (scope) => Array.isArray(scope) && scope.every((s2) => typeof s2 === "number")
  ))) {
    console.error(
      "Invalid type for permittedAuthMethodScopes: expected an array of arrays of numberr."
    );
    isValid = false;
  }
  if (customArgs.addPkpEthAddressAsPermittedAddress !== void 0 && typeof customArgs.addPkpEthAddressAsPermittedAddress !== "boolean") {
    console.error(
      "Invalid type for addPkpEthAddressAsPermittedAddress: expected a boolean."
    );
    isValid = false;
  }
  if (customArgs.sendPkpToItself !== void 0 && typeof customArgs.sendPkpToItself !== "boolean") {
    console.error("Invalid type for sendPkpToItself: expected a boolean.");
    isValid = false;
  }
  return isValid;
};

// packages/lit-auth-client/src/lib/providers/BaseProvider.ts
var BaseProvider2 = class {
  constructor(options) {
    /**
     * Calculates a public key for a given `key identifier` which is an `Auth Method Identifier`
     * the Auth Method Identifier is a hash of a user identifier and app idendtifer.
     * These identifiers are specific to each auth method and will derive the public key protion of a pkp which will be persited
     * when a key is claimed.
     * | Auth Method | User ID | App ID |
     * |:------------|:-------|:-------|
     * | Google OAuth | token `sub` | token `aud` |
     * | Discord OAuth | user id | client app identifier |
     * | Stytch OTP |token `sub` | token `aud`|
     * @param userId
     * @param appId
     * @returns
     */
    this.computePublicKeyFromAuthMethod = async (authMethod) => {
      let authMethodId = await this.getAuthMethodId(authMethod);
      authMethodId = authMethodId.slice(2);
      if (!this.litNodeClient) {
        throw new Error("Lit Node Client is configured");
      }
      return this.litNodeClient.computeHDPubKey(authMethodId);
    };
    this.rpcUrl = options.rpcUrl;
    this.relay = options.relay;
    this.litNodeClient = options.litNodeClient;
  }
  /**
   * Mint a new PKP for the given auth method through the relay server
   *
   * @param {AuthMethod} authMethod - Auth method object
   * @param {MintRequestBody} [customArgs] - Extra data to overwrite default params
   *
   * @returns {Promise<string>} - Mint transaction hash
   */
  async mintPKPThroughRelayer(authMethod, customArgs) {
    const data = await this.prepareRelayRequestData(authMethod);
    if (customArgs && !validateMintRequestBody(customArgs)) {
      throw new Error("Invalid mint request body");
    }
    const body = this.prepareMintBody(
      data,
      customArgs ?? {}
    );
    const mintRes = await this.relay.mintPKP(body);
    if (!mintRes || !mintRes.requestId) {
      throw new Error("Missing mint response or request ID from relay server");
    }
    return mintRes.requestId;
  }
  /**
   * Fetch PKPs associated with given auth method from relay server
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<IRelayPKP[]>} - Array of PKPs
   */
  async fetchPKPsThroughRelayer(authMethod) {
    const data = await this.prepareRelayRequestData(authMethod);
    const body = this.prepareFetchBody(data);
    const fetchRes = await this.relay.fetchPKPs(body);
    if (!fetchRes || !fetchRes.pkps) {
      throw new Error("Missing PKPs in fetch response from relay server");
    }
    return fetchRes.pkps;
  }
  /**
   * Generate session sigs for given auth method and PKP
   *
   * @param {BaseProviderSessionSigsParams} params
   * @param {string} params.pkpPublicKey - Public key of PKP to auth with
   * @param {AuthMethod} params.authMethod - Auth method verifying ownership of PKP
   * @param {GetSessionSigsProps} params.sessionSigsParams - Params for getSessionSigs function
   * @param {LitNodeClient} [params.litNodeClient] - Lit Node Client to use. If not provided, will use an existing Lit Node Client or create a new one
   *
   * @returns {Promise<SessionSigs>} - Session sigs
   */
  async getSessionSigs(params) {
    if (params.litNodeClient && params.litNodeClient instanceof LitNodeClient) {
      this.litNodeClient = params.litNodeClient;
    }
    if (!this.litNodeClient.ready) {
      await this.litNodeClient.connect();
    }
    let authNeededCallback = params.sessionSigsParams.authNeededCallback;
    if (!authNeededCallback) {
      const nodeClient = this.litNodeClient;
      authNeededCallback = async (authCallbackParams) => {
        let chainId = 1;
        try {
          const chainInfo = ALL_LIT_CHAINS[authCallbackParams.chain];
          chainId = chainInfo.chainId;
        } catch {
        }
        let response;
        if (params.authMethod.authMethodType === 1 /* EthWallet */) {
          const authSig = JSON.parse(params.authMethod.accessToken);
          response = await nodeClient.signSessionKey({
            statement: authCallbackParams.statement,
            sessionKey: params.sessionSigsParams.sessionKey,
            authMethods: [],
            authSig,
            pkpPublicKey: params.pkpPublicKey,
            expiration: authCallbackParams.expiration,
            resources: authCallbackParams.resources,
            chainId,
            // optional
            ...params.resourceAbilityRequests && {
              resourceAbilityRequests: params.resourceAbilityRequests
            }
          });
        } else {
          response = await nodeClient.signSessionKey({
            sessionKey: params.sessionSigsParams.sessionKey,
            statement: authCallbackParams.statement,
            authMethods: [params.authMethod],
            pkpPublicKey: params.pkpPublicKey,
            expiration: authCallbackParams.expiration,
            resources: authCallbackParams.resources,
            chainId,
            // optional
            ...params.resourceAbilityRequests && {
              resourceAbilityRequests: params.resourceAbilityRequests
            }
          });
        }
        return response.authSig;
      };
    }
    const sessionSigs = await this.litNodeClient.getSessionSigs({
      ...params.sessionSigsParams,
      authNeededCallback
    });
    return sessionSigs;
  }
  /**
   * Authenticates an auth Method for claiming a Programmable Key Pair (PKP).
   * Uses the underyling {@link litNodeClient} instance to authenticate a given auth method
   * @param claimRequest
   * @returns {Promise<ClaimKeyResponse>} - Response from the network for the claim
   */
  async claimKeyId(claimRequest) {
    if (!this.litNodeClient.ready) {
      await this.litNodeClient.connect().catch((err) => {
        throw err;
      });
    }
    const res = await this.litNodeClient.claimKeyId(claimRequest);
    return res;
  }
  /**
   * Generate request data for minting and fetching PKPs via relay server
   *
   * @param {AuthMethod} authMethod - Auth method obejct
   *
   * @returns {Promise<IRelayRequestData>} - Relay request data
   */
  async prepareRelayRequestData(authMethod) {
    const authMethodType = authMethod.authMethodType;
    const authMethodId = await this.getAuthMethodId(authMethod);
    const data = {
      authMethodType,
      authMethodId
    };
    return data;
  }
  /**
   * Generate request body for minting PKP using auth methods via relay server
   *
   * @param {IRelayRequestData} data - Data for minting PKP
   * @param {number} data.authMethodType - Type of auth method
   * @param {string} data.authMethodId - ID of auth method
   * @param {string} [data.authMethodPubKey] - Public key associated with the auth method (used only in WebAuthn)
   * @param {MintRequestBody} [customArgs] - Extra data to overwrite default params
   *
   * @returns {string} - Relay request body for minting PKP
   */
  prepareMintBody(data, customArgs) {
    const pubkey = data.authMethodPubKey || "0x";
    const defaultArgs = {
      // default params
      keyType: 2,
      permittedAuthMethodTypes: [data.authMethodType],
      permittedAuthMethodIds: [data.authMethodId],
      permittedAuthMethodPubkeys: [pubkey],
      permittedAuthMethodScopes: [[ethers_exports.BigNumber.from("1")]],
      addPkpEthAddressAsPermittedAddress: true,
      sendPkpToItself: true
    };
    const args = {
      ...defaultArgs,
      ...customArgs
    };
    const body = JSON.stringify(args);
    return body;
  }
  /**
   * Generate request body to fetch PKPs using auth method info via relay server
   *
   * @param {IRelayRequestData} data - Data for fetching PKP
   * @param {string} data.authMethodType - Type of auth method
   * @param {string} data.authMethodId - ID of auth method
   * @param {string} [data.authMethodPubKey] - Public key associated with the auth method (used only in WebAuthn)
   *
   * @returns {string} - Relay request body to fetch PKPs
   */
  prepareFetchBody(data) {
    const args = {
      authMethodId: data.authMethodId,
      authMethodType: data.authMethodType,
      authMethodPubKey: data.authMethodPubKey
    };
    const body = JSON.stringify(args);
    return body;
  }
};

// packages/lit-auth-client/src/lib/providers/GoogleProvider.ts
import * as jose2 from "jose";
var GoogleProvider = class _GoogleProvider extends BaseProvider2 {
  constructor(options) {
    super(options);
    this.redirectUri = options.redirectUri || window.location.origin;
  }
  /**
   * Redirect user to the Lit's Google login page
   *
   * @param {Function} [callback] - Optional callback to handle login URL
   * @returns {Promise<void>} - Redirects user to Lit login page
   */
  async signIn(callback) {
    const loginUrl = await prepareLoginUrl("google", this.redirectUri);
    if (callback) {
      callback(loginUrl);
    } else {
      window.location.assign(loginUrl);
    }
  }
  /**
   * Validate the URL parameters returned from Lit's login server and return the authentication data
   *
   * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
   */
  async authenticate(_, urlCheckCallback) {
    const isUrlValid = urlCheckCallback ? urlCheckCallback(window.location.href, this.redirectUri) : window.location.href.startsWith(this.redirectUri);
    if (!isUrlValid) {
      throw new Error(
        `Current url "${window.location.href}" does not match provided redirect uri "${this.redirectUri}"`
      );
    }
    const { provider, idToken, state, error } = parseLoginParams(
      window.location.search
    );
    if (error) {
      throw new Error(error);
    }
    if (!provider || provider !== "google") {
      throw new Error(
        `OAuth provider "${provider}" passed in redirect callback URL does not match "google"`
      );
    }
    if (!state || decode5(decodeURIComponent(state)) !== getStateParam()) {
      throw new Error(
        `Invalid state parameter "${state}" passed in redirect callback URL`
      );
    }
    window.history.replaceState(
      null,
      window.document.title,
      window.location.pathname
    );
    if (!idToken) {
      throw new Error(
        `Missing ID token in redirect callback URL for Google OAuth"`
      );
    }
    const authMethod = {
      authMethodType: 6 /* GoogleJwt */,
      accessToken: idToken
    };
    return authMethod;
  }
  /**
   * Sign in using popup window
   *
   * @param baseURL
   */
  async signInUsingPopup(baseURL) {
    const width = 500;
    const height = 600;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;
    const url = await prepareLoginUrl("google", this.redirectUri, baseURL);
    const popup = window.open(
      `${url}&caller=${window.location.origin}`,
      "popup",
      `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, copyhistory=no, width=${width}, height=${height}, top=${top}, left=${left}`
    );
    if (!popup) {
      throw new Error("Failed to open popup window");
    }
    return new Promise((resolve, reject) => {
      const interval = setInterval(() => {
        if (popup.closed) {
          clearInterval(interval);
          reject(new Error("User closed popup window"));
        }
      }, 1e3);
      window.addEventListener("message", (event) => {
        if (event.origin !== (baseURL || LIT_LOGIN_GATEWAY)) {
          return;
        }
        const { provider, token, error } = event.data;
        if (error) {
          clearInterval(interval);
          reject(new Error(error));
        }
        if (provider === "google" && token) {
          clearInterval(interval);
          popup.close();
          resolve({
            authMethodType: 6 /* GoogleJwt */,
            accessToken: token
          });
        }
      });
    });
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _GoogleProvider.authMethodId(authMethod);
  }
  static async authMethodId(authMethod) {
    const tokenPayload = jose2.decodeJwt(authMethod.accessToken);
    const userId = tokenPayload["sub"];
    const audience = tokenPayload["aud"];
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId}:${audience}`)
    );
    return authMethodId;
  }
};

// packages/lit-auth-client/src/lib/providers/DiscordProvider.ts
init_shim();
var DiscordProvider = class extends BaseProvider2 {
  constructor(options) {
    super(options);
    this.redirectUri = options.redirectUri || window.location.origin;
    this.clientId = options.clientId || "1052874239658692668";
  }
  /**
   * Redirect user to the Lit's Discord login page
   *
   * @returns {Promise<void>} - Redirects user to Lit login page
   */
  async signIn() {
    const loginUrl = await prepareLoginUrl("discord", this.redirectUri);
    window.location.assign(loginUrl);
  }
  /**
   * Validate the URL parameters returned from Lit's login server and return the authentication data
   *
   * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
   */
  async authenticate() {
    if (!window.location.href.startsWith(this.redirectUri)) {
      throw new Error(
        `Current url "${window.location.href}" does not match provided redirect uri "${this.redirectUri}"`
      );
    }
    const { provider, accessToken, state, error } = parseLoginParams(
      window.location.search
    );
    if (error) {
      throw new Error(error);
    }
    if (!provider || provider !== "discord") {
      throw new Error(
        `OAuth provider "${provider}" passed in redirect callback URL does not match "discord"`
      );
    }
    if (!state || decode5(decodeURIComponent(state)) !== getStateParam()) {
      throw new Error(
        `Invalid state parameter "${state}" passed in redirect callback URL`
      );
    }
    window.history.replaceState(
      null,
      window.document.title,
      window.location.pathname
    );
    if (!accessToken) {
      throw new Error(
        `Missing access token in redirect callback URL for Discord OAuth"`
      );
    }
    const authMethod = {
      authMethodType: 4 /* Discord */,
      accessToken
    };
    return authMethod;
  }
  /**
   * Sign in using popup window
   *
   * @param baseURL
   */
  async signInUsingPopup(baseURL) {
    const width = 500;
    const height = 600;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;
    const url = await prepareLoginUrl("discord", this.redirectUri, baseURL);
    const popup = window.open(
      `${url}&caller=${window.location.origin}`,
      "popup",
      `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, copyhistory=no, width=${width}, height=${height}, top=${top}, left=${left}`
    );
    if (!popup) {
      throw new Error("Failed to open popup window");
    }
    return new Promise((resolve, reject) => {
      const interval = setInterval(() => {
        if (popup.closed) {
          clearInterval(interval);
          reject(new Error("User closed popup window"));
        }
      }, 1e3);
      window.addEventListener("message", (event) => {
        if (event.origin !== (baseURL || LIT_LOGIN_GATEWAY)) {
          return;
        }
        const { provider, token, error } = event.data;
        if (error) {
          clearInterval(interval);
          reject(new Error(error));
        }
        if (provider === "discord" && token) {
          clearInterval(interval);
          popup.close();
          resolve({
            authMethodType: 4 /* Discord */,
            accessToken: token
          });
        }
      });
    });
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    const userId = await this.#fetchDiscordUser(authMethod.accessToken);
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId}:${this.clientId}`)
    );
    return authMethodId;
  }
  static async authMethodId(authMethod, clientId) {
    const _clientId = clientId || "1052874239658692668";
    let userId;
    const meResponse = await fetch("https://discord.com/api/users/@me", {
      method: "GET",
      headers: {
        authorization: `Bearer ${authMethod.accessToken}`
      }
    });
    if (meResponse.ok) {
      const user = await meResponse.json();
      userId = user.id;
    } else {
      throw new Error("Unable to verify Discord account");
    }
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId}:${_clientId}`)
    );
    return authMethodId;
  }
  /**
   * Fetch Discord user ID
   *
   * @param {string} accessToken - Discord access token
   *
   * @returns {Promise<string>} - Discord user ID
   */
  async #fetchDiscordUser(accessToken) {
    const meResponse = await fetch("https://discord.com/api/users/@me", {
      method: "GET",
      headers: {
        authorization: `Bearer ${accessToken}`
      }
    });
    if (meResponse.ok) {
      const user = await meResponse.json();
      return user.id;
    } else {
      throw new Error("Unable to verify Discord account");
    }
  }
};

// packages/lit-auth-client/src/lib/providers/EthWalletProvider.ts
init_shim();
import { SiweMessage as SiweMessage4 } from "siwe";
var EthWalletProvider = class _EthWalletProvider extends BaseProvider2 {
  constructor(options) {
    super(options);
    try {
      this.domain = options.domain || window.location.hostname;
      this.origin = options.origin || window.location.origin;
    } catch (e2) {
      log(
        '\u26A0\uFE0F Error getting "domain" and "origin" from window object, defaulting to "localhost" and "http://localhost"'
      );
      this.domain = options.domain || "localhost";
      this.origin = options.origin || "http://localhost";
    }
  }
  /**
   * Generate a wallet signature to use as an auth method
   *
   * @param {EthWalletAuthenticateOptions} options
   * @param {string} [options.address] - Address to sign with
   * @param {function} [options.signMessage] - Function to sign message with
   * @param {string} [options.chain] - Name of chain to use for signature
   * @param {number} [options.expiration] - When the auth signature expires
   *
   * @returns {Promise<AuthMethod>} - Auth method object containing the auth signature
   */
  async authenticate(options) {
    if (!options) {
      throw new Error(
        "Options are required to authenticate with EthWalletProvider."
      );
    }
    return _EthWalletProvider.authenticate({
      signer: options,
      address: options?.address,
      chain: options?.chain,
      litNodeClient: this.litNodeClient,
      expiration: options?.expiration,
      domain: this.domain,
      origin: this.origin
    });
  }
  /**
   * Generate a wallet signature to use as an auth method
   *
   * @param {EthWalletAuthenticateOptions} options
   * @param {string} [options.address] - Address to sign with
   * @param {function} [options.signMessage] - Function to sign message with
   * @param {string} [options.chain] - Name of chain to use for signature
   * @param {number} [options.expiration] - When the auth signature expires
   * @returns {Promise<AuthMethod>} - Auth method object containing the auth signature
   * @static
   * @memberof EthWalletProvider
   *
   * @example
   * ```typescript
   *   const authMethod = await EthWalletProvider.authenticate({
   *      signer: wallet,
   *      litNodeClient: client,
   *   });
   * ```
   */
  static async authenticate({
    signer,
    address,
    chain,
    litNodeClient,
    expiration,
    domain,
    origin
  }) {
    if (!litNodeClient.latestBlockhash) {
      throwError({
        message: "Eth Blockhash is undefined. Try connecting to the Lit network again.",
        errorKind: LIT_ERROR.INVALID_ETH_BLOCKHASH.kind,
        errorCode: LIT_ERROR.INVALID_ETH_BLOCKHASH.name
      });
    }
    chain = chain || "ethereum";
    let authSig;
    address = address || await signer?.getAddress() || signer?.address;
    if (!address) {
      throw new Error(
        `Address is required to authenticate with EthWalletProvider. Cannot find it in signer or options.`
      );
    }
    address = ethers_exports.utils.getAddress(address);
    if (signer?.signMessage) {
      const selectedChain = LIT_CHAINS[chain];
      const chainId = selectedChain?.chainId ? selectedChain.chainId : 1;
      expiration = expiration || new Date(Date.now() + 1e3 * 60 * 60 * 24).toISOString();
      const preparedMessage = {
        domain: domain || "localhost",
        uri: origin || "http://localhost",
        address,
        version: "1",
        chainId,
        expirationTime: expiration,
        nonce: litNodeClient.latestBlockhash
      };
      const message = new SiweMessage4(preparedMessage);
      const toSign = message.prepareMessage();
      const signature2 = await signer.signMessage(toSign);
      authSig = {
        sig: signature2,
        derivedVia: "web3.eth.personal.sign",
        signedMessage: toSign,
        address
      };
    } else {
      authSig = await checkAndSignAuthMessage({
        chain,
        nonce: litNodeClient.latestBlockhash
      });
    }
    const authMethod = {
      authMethodType: 1 /* EthWallet */,
      accessToken: JSON.stringify(authSig)
    };
    return authMethod;
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _EthWalletProvider.authMethodId(authMethod);
  }
  static async authMethodId(authMethod) {
    let address;
    try {
      address = JSON.parse(authMethod.accessToken).address;
    } catch (err) {
      throw new Error(
        `Error when parsing auth method to generate auth method ID for Eth wallet: ${err}`
      );
    }
    return ethers_exports.utils.keccak256(ethers_exports.utils.toUtf8Bytes(`${address}:lit`));
  }
};

// packages/lit-auth-client/src/lib/providers/WebAuthnProvider.ts
init_shim();
import base64url from "base64url";
var WebAuthnProvider = class _WebAuthnProvider extends BaseProvider2 {
  constructor(options) {
    super(options);
    this.rpName = options.rpName || "lit";
  }
  /**
   * Generate registration options for the browser to pass to a supported authenticator
   *
   * @param {string} username - Username to register credential with
   *
   * @returns {Promise<PublicKeyCredentialCreationOptionsJSON>} - Options to pass to the authenticator
   */
  async register(username) {
    return await this.relay.generateRegistrationOptions(username);
  }
  /**
   * Mint PKP with verified registration data
   *
   * @param {PublicKeyCredentialCreationOptionsJSON} options - Registration options to pass to the authenticator
   * @param {MintRequestBody} [customArgs] - Extra data to overwrite default params
   *
   * @returns {Promise<string>} - Mint transaction hash
   */
  async verifyAndMintPKPThroughRelayer(options, customArgs) {
    const { startRegistration } = await import("@simplewebauthn/browser");
    const attResp = await startRegistration(options);
    const authMethodId = await this.getAuthMethodId({
      authMethodType: 3 /* WebAuthn */,
      accessToken: JSON.stringify(attResp)
    });
    const authMethodPubkey = _WebAuthnProvider.getPublicKeyFromRegistration(attResp);
    const defaultArgs = {
      keyType: 2,
      permittedAuthMethodTypes: [3 /* WebAuthn */],
      permittedAuthMethodIds: [authMethodId],
      permittedAuthMethodPubkeys: [authMethodPubkey],
      permittedAuthMethodScopes: [[ethers_exports.BigNumber.from("1")]],
      addPkpEthAddressAsPermittedAddress: true,
      sendPkpToItself: true
    };
    const args = {
      ...defaultArgs,
      ...customArgs
    };
    const body = JSON.stringify(args);
    const mintRes = await this.relay.mintPKP(body);
    if (!mintRes || !mintRes.requestId) {
      throw new Error("Missing mint response or request ID from relay server");
    }
    return mintRes.requestId;
  }
  /**
   * @override
   * This method is not applicable for WebAuthnProvider and should not be used.
   * Use verifyAndMintPKPThroughRelayer instead to mint a PKP for a WebAuthn credential.
   *
   * @throws {Error} - Throws an error when called for WebAuthnProvider.
   */
  async mintPKPThroughRelayer() {
    throw new Error(
      "Use verifyAndMintPKPThroughRelayer for WebAuthnProvider instead."
    );
  }
  /**
   * Authenticate with a WebAuthn credential and return the relevant authentication data
   *
   * @returns {Promise<AuthMethod>} - Auth method object containing WebAuthn authentication data
   */
  async authenticate() {
    const provider = new ethers_exports.providers.JsonRpcProvider(this.rpcUrl);
    const block = await provider.getBlock("latest");
    const blockHash = block.hash;
    const blockHashBytes = ethers_exports.utils.arrayify(blockHash);
    const rpId = getRPIdFromOrigin(window.location.origin);
    const authenticationOptions = {
      challenge: base64url(Buffer.from(blockHashBytes)),
      timeout: 6e4,
      userVerification: "required",
      rpId
    };
    const { startAuthentication } = await import("@simplewebauthn/browser");
    const authenticationResponse = await startAuthentication(
      authenticationOptions
    );
    const actualAuthenticationResponse = JSON.parse(
      JSON.stringify(authenticationResponse)
    );
    const userHandle = authenticationResponse.response?.userHandle;
    if (userHandle) {
      actualAuthenticationResponse.response.userHandle = base64url.encode(userHandle);
    }
    const authMethod = {
      authMethodType: 3 /* WebAuthn */,
      accessToken: JSON.stringify(actualAuthenticationResponse)
    };
    return authMethod;
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _WebAuthnProvider.authMethodId(authMethod, this.rpName);
  }
  static async authMethodId(authMethod, rpName) {
    let credentialId;
    const rpNameToUse = rpName || "lit";
    try {
      credentialId = JSON.parse(authMethod.accessToken).rawId;
    } catch (err) {
      throw new Error(
        `Error when parsing auth method to generate auth method ID for WebAuthn: ${err}`
      );
    }
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${credentialId}:${rpNameToUse}`)
    );
    return authMethodId;
  }
  /**
   * Parse the WebAuthn registration response to get the WebAuthn credential public key
   *
   * @param {RegistrationResponseJSON} attResp - WebAuthn registration response
   *
   * @returns {string} - WebAuthn credential public key in hex format
   */
  static getPublicKeyFromRegistration(attResp) {
    let publicKey;
    try {
      const attestationBuffer = Buffer.from(
        attResp.response.attestationObject,
        "base64"
      );
      const authenticationResponse = parseAuthenticatorData(attestationBuffer);
      const publicKeyCoseBuffer = authenticationResponse.attestedCredentialData.credentialPublicKey;
      publicKey = ethers_exports.utils.hexlify(
        ethers_exports.utils.arrayify(publicKeyCoseBuffer)
      );
    } catch (e2) {
      throw new Error(
        `Error while decoding WebAuthn registration response for public key retrieval. Attestation response not encoded as expected: ${e2}`
      );
    }
    return publicKey;
  }
};

// packages/lit-auth-client/src/lib/providers/StytchOtpProvider.ts
init_shim();
var StytchOtpProvider = class _StytchOtpProvider extends BaseProvider2 {
  constructor(params, config) {
    super(params);
    this._provider = "https://stytch.com/session";
    this._params = config;
  }
  /**
   * Validates claims within a stytch authenticated JSON Web Token
   * @param options authentication option containing the authenticated token
   * @returns {AuthMethod} Authentication Method for auth method type OTP
   * */
  authenticate(options) {
    return new Promise((resolve, reject) => {
      if (!options) {
        reject(
          new Error(
            "No Authentication options provided, please supply an authenticated JWT"
          )
        );
      }
      const userId = this._params.userId ?? options.userId;
      const accessToken = options?.accessToken;
      if (!accessToken) {
        reject(
          new Error("No access token provided, please provide a stych auth jwt")
        );
      }
      const parsedToken = _StytchOtpProvider._parseJWT(accessToken);
      const audience = parsedToken["aud"][0];
      if (audience != this._params.appId) {
        reject(new Error("Parsed application id does not match parameters"));
      }
      if (!audience) {
        reject(
          new Error(
            "could not find project id in token body, is this a stych token?"
          )
        );
      }
      const session = parsedToken[this._provider];
      const authFactor = session["authentication_factors"][0];
      if (!authFactor) {
        reject(new Error("Could not find authentication info in session"));
      }
      if (userId && userId != parsedToken["sub"]) {
        reject(
          new Error(
            "UserId does not match token contents. is this the right token for your application?"
          )
        );
      }
      resolve({
        authMethodType: 9 /* StytchOtp */,
        accessToken
      });
    });
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _StytchOtpProvider.authMethodId(authMethod);
  }
  static async authMethodId(authMethod) {
    const tokenBody = _StytchOtpProvider._parseJWT(authMethod.accessToken);
    const userId = tokenBody["sub"];
    const orgId = tokenBody["aud"][0];
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId.toLowerCase()}:${orgId.toLowerCase()}`)
    );
    return authMethodId;
  }
  /**
   *
   * @param jwt token to parse
   * @returns {string}- userId contained within the token message
   */
  static _parseJWT(jwt) {
    const parts = jwt.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid token length");
    }
    const body = Buffer.from(parts[1], "base64");
    const parsedBody = JSON.parse(body.toString("ascii"));
    console.log("JWT body: ", parsedBody);
    return parsedBody;
  }
};

// packages/lit-auth-client/src/lib/providers/AppleProvider.ts
init_shim();
import * as jose3 from "jose";
var AppleProvider = class _AppleProvider extends BaseProvider2 {
  constructor(options) {
    super(options);
    this.redirectUri = options.redirectUri || window.location.origin;
  }
  /**
   * Redirect user to the Lit's Apple login page
   *
   * @returns {Promise<void>} - Redirects user to Lit login page
   */
  async signIn() {
    const loginUrl = await prepareLoginUrl("apple", this.redirectUri);
    window.location.assign(loginUrl);
  }
  /**
   * Validate the URL parameters returned from Lit's login server and return the authentication data
   *
   * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
   */
  async authenticate() {
    if (!window.location.href.startsWith(this.redirectUri)) {
      throw new Error(
        `Current url "${window.location.href}" does not match provided redirect uri "${this.redirectUri}"`
      );
    }
    const { provider, idToken, state, error } = parseLoginParams(
      window.location.search
    );
    if (error) {
      throw new Error(error);
    }
    if (!provider || provider !== "apple") {
      throw new Error(
        `OAuth provider "${provider}" passed in redirect callback URL does not match "apple"`
      );
    }
    if (!state || decode5(decodeURIComponent(state)) !== getStateParam()) {
      throw new Error(
        `Invalid state parameter "${state}" passed in redirect callback URL`
      );
    }
    window.history.replaceState(
      null,
      window.document.title,
      window.location.pathname
    );
    if (!idToken) {
      throw new Error(
        `Missing ID token in redirect callback URL for Apple OAuth"`
      );
    }
    const authMethod = {
      authMethodType: 8 /* AppleJwt */,
      accessToken: idToken
    };
    return authMethod;
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _AppleProvider.authMethodId(authMethod);
  }
  static async authMethodId(authMethod) {
    const tokenPayload = jose3.decodeJwt(authMethod.accessToken);
    const userId = tokenPayload["sub"];
    const audience = tokenPayload["aud"];
    const authMethodId = ethers_exports.utils.keccak256(
      ethers_exports.utils.toUtf8Bytes(`${userId}:${audience}`)
    );
    return authMethodId;
  }
};

// packages/lit-auth-client/src/lib/providers/StytchAuthFactorOtp.ts
init_shim();

// packages/lit-auth-client/src/lib/providers/StytchAuthFactors.ts
init_shim();
var emailOtpAuthFactorParser2 = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.email_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.email_factor.email_address;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var smsOtpAuthFactorParser2 = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.phone_number_factor.phone_number;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var whatsAppOtpAuthFactorParser2 = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.phone_number_factor.phone_number;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};
var totpAuthFactorParser2 = (parsedToken, provider) => {
  const session = parsedToken[provider];
  const authFactors = session["authentication_factors"];
  let authFactor = authFactors.find((value, _index, _obj) => {
    if (value.phone_number_factor)
      return value;
  });
  if (!authFactor) {
    throw new Error("Could not find email authentication info in session");
  }
  const audience = parsedToken["aud"][0];
  if (!audience) {
    throw new Error(
      "Token does not contain an audience (project identifier), aborting"
    );
  }
  const userId = authFactor.authenticator_app_factor.totp_id;
  const authMethodId = ethers_exports.utils.keccak256(
    ethers_exports.utils.toUtf8Bytes(
      `${userId.toLowerCase()}:${audience.toLowerCase()}`
    )
  );
  return authMethodId;
};

// packages/lit-auth-client/src/lib/providers/StytchAuthFactorOtp.ts
var StytchAuthFactorOtpProvider = class _StytchAuthFactorOtpProvider extends BaseProvider2 {
  static {
    this._provider = "https://stytch.com/session";
  }
  constructor(params, config, factor) {
    super(params);
    this._params = config;
    this._factor = factor;
  }
  /**
   * Validates claims within a stytch authenticated JSON Web Token
   * Will parse out the given `authentication factor` and use the transport
   * for the otp code as the `user identifier` for the given auth method.
   * @param options authentication option containing the authenticated token
   * @returns {AuthMethod} Authentication Method for auth method type OTP
   *
   */
  async authenticate(options) {
    return new Promise((resolve, reject) => {
      if (!options) {
        reject(
          new Error(
            "No Authentication options provided, please supply an authenticated JWT"
          )
        );
      }
      const accessToken = options?.accessToken;
      if (!accessToken) {
        reject(
          new Error("No access token provided, please provide a stych auth jwt")
        );
      }
      const parsedToken = _StytchAuthFactorOtpProvider._parseJWT(accessToken);
      const factorParser = _StytchAuthFactorOtpProvider._resolveAuthFactor(
        this._factor
      );
      try {
        factorParser.parser(parsedToken, _StytchAuthFactorOtpProvider._provider);
      } catch (e2) {
        reject(e2);
      }
      resolve({
        authMethodType: factorParser.authMethodType,
        accessToken
      });
    });
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method
   *
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  async getAuthMethodId(authMethod) {
    return _StytchAuthFactorOtpProvider.authMethodId(authMethod);
  }
  /**
   * Get auth method id that can be used to look up and interact with
   * PKPs associated with the given auth method.
   * Will parse out the given `authentication factor` and use the transport
   * for the otp code as the `user identifier` for the given auth method.
   * @param {AuthMethod} authMethod - Auth method object
   *
   * @returns {Promise<string>} - Auth method id
   */
  static async authMethodId(authMethod) {
    return new Promise((resolve, reject) => {
      const accessToken = authMethod.accessToken;
      const parsedToken = _StytchAuthFactorOtpProvider._parseJWT(accessToken);
      let factor = "email";
      switch (authMethod.authMethodType) {
        case 10 /* StytchEmailFactorOtp */:
          factor = "email";
          break;
        case 11 /* StytchSmsFactorOtp */:
          factor = "sms";
          break;
        case 12 /* StytchWhatsAppFactorOtp */:
          factor = "whatsApp";
          break;
        case 13 /* StytchTotpFactorOtp */:
          factor = "totp";
          break;
        default:
          throw new Error("Unsupport stytch auth type");
      }
      const factorParser = this._resolveAuthFactor(factor).parser;
      try {
        resolve(factorParser(parsedToken, this._provider));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  static _resolveAuthFactor(factor) {
    switch (factor) {
      case "email":
        return {
          parser: emailOtpAuthFactorParser2,
          authMethodType: 10 /* StytchEmailFactorOtp */
        };
      case "sms":
        return {
          parser: smsOtpAuthFactorParser2,
          authMethodType: 11 /* StytchSmsFactorOtp */
        };
      case "whatsApp":
        return {
          parser: whatsAppOtpAuthFactorParser2,
          authMethodType: 12 /* StytchWhatsAppFactorOtp */
        };
      case "totp":
        return {
          parser: totpAuthFactorParser2,
          authMethodType: 13 /* StytchTotpFactorOtp */
        };
    }
  }
  /**
   *
   * @param jwt token to parse
   * @returns {string}- userId contained within the token message
   */
  static _parseJWT(jwt) {
    const parts = jwt.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid token length");
    }
    const body = Buffer.from(parts[1], "base64");
    const parsedBody = JSON.parse(body.toString("ascii"));
    return parsedBody;
  }
};

// packages/lit-auth-client/src/lib/lit-auth-client.ts
var LitAuthClient = class _LitAuthClient {
  /**
   * Create a LitAuthClient instance
   *
   * @param {LitAuthClientOptions} options
   * @param {string} [options.rpcUrl] - Endpoint to interact with a blockchain network
   * @param {LitRelayConfig} [options.litRelayConfig] - Options for Lit's relay server
   * @param {IRelay} [options.customRelay] - Custom relay server to subsidize minting of PKPs
   * @param {LitNodeClient} [options.litNodeClient] - Client to connect to Lit nodes
   */
  constructor(options) {
    this.providers = /* @__PURE__ */ new Map();
    bootstrapLogManager("auth-client");
    this.debug = options?.debug ?? false;
    if (options?.customRelay) {
      this.relay = options?.customRelay;
    } else {
      if (options?.litRelayConfig?.relayApiKey) {
        this.relay = new LitRelay(options.litRelayConfig);
      } else {
        throw new Error(
          "An API key is required to use the default Lit Relay server. Please provide either an API key or a custom relay server."
        );
      }
    }
    if (options?.litNodeClient) {
      this.litNodeClient = options?.litNodeClient;
    } else {
      this.litNodeClient = new LitNodeClient({
        litNetwork: "cayenne",
        debug: options.debug ?? false
      });
    }
    if (!options?.litRelayConfig?.relayUrl) {
      if (!options?.litRelayConfig?.relayApiKey) {
        throw new Error(
          "2 An API key is required to use the default Lit Relay server. Please provide either an API key or a custom relay server."
        );
      }
      const supportedNetworks = ["cayenne", "habanero", "manzano"];
      if (!supportedNetworks.includes(this.litNodeClient.config.litNetwork)) {
        throw new Error(
          `Unsupported litNetwork: ${this.litNodeClient.config.litNetwork}. Supported networks are: ${supportedNetworks.join(", ")}`
        );
      }
      let url;
      switch (this.litNodeClient.config.litNetwork) {
        case "cayenne":
          url = RELAY_URL_CAYENNE;
          break;
        case "habanero":
          url = RELAY_URL_HABANERO;
          break;
        case "manzano":
          url = RELAY_URL_MANZANO;
          break;
      }
      if (this.litNodeClient.config.litNetwork)
        this.relay = new LitRelay({
          relayUrl: url,
          relayApiKey: options?.litRelayConfig?.relayApiKey
        });
    }
    this.rpcUrl = options?.rpcUrl || "https://chain-rpc.litprotocol.com/http";
    log("rpc url: ", this.rpcUrl);
    log("relay config: ", options.litRelayConfig);
    log("relay instance: ", this.relay);
  }
  /**
   * Initialize a provider
   *
   * @param {ProviderType} type - Type of provider to initialize
   * @param {ProviderOptions} options - Options for the provider
   *
   * @returns {T} - Provider
   */
  initProvider(type, options) {
    const baseParams = {
      rpcUrl: this.rpcUrl,
      relay: this.relay,
      litNodeClient: this.litNodeClient
    };
    let provider;
    log("resolving provider of type: ", type);
    switch (type) {
      case "google":
        provider = new GoogleProvider({
          ...baseParams,
          ...options
        });
        break;
      case "apple":
        provider = new AppleProvider({
          ...baseParams,
          ...options
        });
        break;
      case "discord":
        provider = new DiscordProvider({
          ...baseParams,
          ...options
        });
        break;
      case "ethwallet":
        provider = new EthWalletProvider({
          ...baseParams,
          ...options
        });
        break;
      case "webauthn":
        provider = new WebAuthnProvider({
          ...baseParams,
          ...options
        });
        break;
      case "stytchOtp":
        provider = new StytchOtpProvider(
          {
            ...baseParams
          },
          options
        );
        break;
      case "stytchEmailFactorOtp":
        provider = new StytchAuthFactorOtpProvider(
          { ...baseParams },
          options,
          "email"
        );
        break;
      case "stytchSmsFactorOtp":
        provider = new StytchAuthFactorOtpProvider(
          { ...baseParams },
          options,
          "sms"
        );
        break;
      case "stytchWhatsAppFactorOtp":
        provider = new StytchAuthFactorOtpProvider(
          { ...baseParams },
          options,
          "whatsApp"
        );
        break;
      case "stytchTotpFactor":
        provider = new StytchAuthFactorOtpProvider(
          { ...baseParams },
          options,
          "totp"
        );
        break;
      default:
        throw new Error(
          "Invalid provider type provided. Only 'google', 'discord', 'ethereum', and 'webauthn', 'Stytch', and 'StytchFactor' are supported at the moment."
        );
    }
    this.providers.set(type, provider);
    return provider;
  }
  /**
   * Returns an initialized provider by type
   *
   * @param {ProviderType} type - Type of provider to get
   *
   * @returns {BaseProvider | undefined} - Provider if found, undefined otherwise
   */
  getProvider(type) {
    return this.providers.get(type);
  }
  /**
   * Retrieves the authentication ID based on the provided authentication method.
   *
   * @param {AuthMethod} authMethod - The authentication method
   * @returns {Promise<string>} - The authentication ID
   */
  static async getAuthIdByAuthMethod(authMethod) {
    let authId;
    switch (authMethod.authMethodType) {
      case 1 /* EthWallet */:
        authId = await EthWalletProvider.authMethodId(authMethod);
        break;
      case 4 /* Discord */:
        authId = await DiscordProvider.authMethodId(authMethod);
        break;
      case 3 /* WebAuthn */:
        authId = await WebAuthnProvider.authMethodId(authMethod);
        break;
      case 6 /* GoogleJwt */:
        authId = await GoogleProvider.authMethodId(authMethod);
        break;
      case 9 /* StytchOtp */:
        authId = await StytchOtpProvider.authMethodId(authMethod);
        break;
      case 10 /* StytchEmailFactorOtp */:
      case 11 /* StytchSmsFactorOtp */:
      case 13 /* StytchTotpFactorOtp */:
      case 12 /* StytchWhatsAppFactorOtp */:
        authId = await StytchAuthFactorOtpProvider.authMethodId(authMethod);
        break;
      default:
        log(`unsupported AuthMethodType: ${authMethod.authMethodType}`);
        throw new Error(
          `Unsupported auth method type: ${authMethod.authMethodType}`
        );
    }
    return authId;
  }
  /**
   * Mints a new pkp with all AuthMethods provided. Allows for permissions and flags to be set seperately.
   * If no permissions are provided then each auth method will be assigned `1` for sign anything
   * If no flags are provided then `sendPkpToitself` will be false, and `addPkpEthAddressAsPermittedAddress` will be true
   * It is then up to the implementor to transfer the pkp nft to the pkp address.
   * **note** When adding permissions, each permission should be added in the same order the auth methods are ordered
   * @throws {Error} - Throws an error if no AuthMethods are given
   * @param {AuthMethod[]} - AuthMethods authentication methods to be added to the pkp
   * @param {{ pkpPermissionScopes?: number[][]; sendPkpToitself?: boolean; addPkpEthAddressAsPermittedAddress?: boolean;}}
   * @returns {Promise<{pkpTokenId?: string; pkpEthAddress?: string; pkpPublicKey?: string}>} pkp information
   */
  async mintPKPWithAuthMethods(authMethods, options) {
    if (authMethods.length < 1) {
      throw new Error("Must provide atleast one auth method");
    }
    if (!options.pkpPermissionScopes || options.pkpPermissionScopes.length < 1) {
      options.pkpPermissionScopes = [];
      for (let i2 = 0; i2 < authMethods.length; i2++) {
        options.pkpPermissionScopes.push([
          ethers_exports.BigNumber.from("1").toNumber()
        ]);
      }
    }
    const reqBody = {
      keyType: 2,
      permittedAuthMethodTypes: authMethods.map((value) => {
        return value.authMethodType;
      }),
      permittedAuthMethodScopes: options.pkpPermissionScopes,
      addPkpEthAddressAsPermittedAddress: options.addPkpEthAddressAsPermittedAddress ?? true,
      sendPkpToItself: options.sendPkpToitself ?? false
    };
    const permittedAuthMethodIds = [];
    const permittedAuthMethodPubkeys = [];
    for (const authMethod of authMethods) {
      const id2 = await _LitAuthClient.getAuthIdByAuthMethod(authMethod);
      permittedAuthMethodIds.push(id2);
      if (authMethod.authMethodType === 3 /* WebAuthn */) {
        permittedAuthMethodPubkeys.push(
          WebAuthnProvider.getPublicKeyFromRegistration(
            JSON.parse(authMethod.accessToken)
          )
        );
      } else {
        permittedAuthMethodPubkeys.push("0x");
      }
    }
    reqBody.permittedAuthMethodIds = permittedAuthMethodIds;
    reqBody.permittedAuthMethodPubkeys = permittedAuthMethodPubkeys;
    const mintRes = await this.relay.mintPKP(JSON.stringify(reqBody));
    if (!mintRes || !mintRes.requestId) {
      throw new Error(
        `Missing mint response or request ID from mint response ${mintRes.error}`
      );
    }
    const pollerResult = await this.relay.pollRequestUntilTerminalState(
      mintRes.requestId
    );
    return {
      pkpTokenId: pollerResult.pkpTokenId,
      pkpPublicKey: pollerResult.pkpPublicKey,
      pkpEthAddress: pollerResult.pkpEthAddress
    };
  }
};

// packages/lit-auth-client/src/index.ts
var LitAuthClient2 = LitAuthClient;
if (!globalThis.LitAuthClient) {
  globalThis.LitAuthClient = LitAuthClient2;
}

// local-tests/setup/env-setup.ts
var getDevEnv = async ({
  env,
  debug
} = {
  env: "localchain" /* LOCALCHAIN */,
  debug: true
}) => {
  log("\u{1F9EA} [env-setup.ts] Starting devEnv");
  const PRIVATE_KEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
  const LIT_RPC_URL = "http://127.0.0.1:8545";
  const BOOTSTRAP_URLS = [
    "http://127.0.0.1:7470",
    "http://127.0.0.1:7471",
    "http://127.0.0.1:7472"
  ];
  log("\u{1F9EA} [env-setup.ts] Setting up LitNodeClient");
  let litNodeClient;
  if (env === "localchain" /* LOCALCHAIN */) {
    litNodeClient = new LitNodeClient({
      litNetwork: "custom",
      bootstrapUrls: BOOTSTRAP_URLS,
      rpcUrl: LIT_RPC_URL,
      debug,
      checkNodeAttestation: false,
      // disable node attestation check for local testing
      contractContext: networkContext_default
      // FIXME: When this  is not provided, we are having issues of verified siwe session key mistmatched with the
      // one being signed, because we generate a new session key again when we cannot find the storage provider.
      // storageProvider: {
      //   provider: new LocalStorage('./storage.test.db'),
      // },
    });
  } else if (env === "habanero" /* HABANERO */ || env === "manzano" /* MANZANO */) {
    litNodeClient = new LitNodeClient({
      litNetwork: env,
      // 'habanero' or 'manzano'
      checkNodeAttestation: true,
      debug
      // FIXME: When this  is not provided, we are having issues of verified siwe session key mistmatched with the
      // one being signed, because we generate a new session key again when we cannot find the storage provider.
      // storageProvider: {
      //   provider: new LocalStorage('./storage.test.db'),
      // },
    });
  } else {
    litNodeClient = new LitNodeClient({
      litNetwork: env,
      checkNodeAttestation: false,
      debug
    });
  }
  await litNodeClient.connect();
  if (!litNodeClient.ready) {
    console.error("\u274C litNodeClient not ready");
    process.exit();
  }
  log(
    "\u{1F9EA} [env-setup.ts] Setup EOA Wallet using private key, and connects to LIT RPC URL"
  );
  let rpc;
  if (env === "localchain" /* LOCALCHAIN */) {
    rpc = LIT_RPC_URL;
  } else {
    rpc = "https://chain-rpc.litprotocol.com/http";
  }
  const provider = new ethers_exports.providers.JsonRpcProvider(rpc);
  const wallet = new ethers_exports.Wallet(PRIVATE_KEY, provider);
  log("\u{1F9EA} [env-setup.ts] Get nonce from lit node");
  const nonce = await litNodeClient.getLatestBlockhash();
  log("\u{1F9EA} [env-setup.ts] Get Hot Wallet Auth Sig");
  const siweMessage = await createSiweMessage({
    nonce,
    walletAddress: wallet.address
  });
  log("\u{1F9EA} [env-setup.ts] Crafting Auth Sig");
  const hotWalletAuthSig = await craftAuthSig({
    signer: wallet,
    toSign: siweMessage
  });
  log(
    "\u{1F9EA} [env-setup.ts] Craft an authMethod from the authSig for the eth wallet auth method"
  );
  const hotWalletAuthMethod = {
    authMethodType: 1 /* EthWallet */,
    accessToken: JSON.stringify(hotWalletAuthSig)
  };
  log("\u{1F9EA} [env-setup.ts] Setting up contracts-sdk client");
  let litContractsClient;
  if (env === "localchain" /* LOCALCHAIN */) {
    litContractsClient = new LitContracts({
      signer: wallet,
      debug,
      rpc: LIT_RPC_URL,
      // anvil rpc
      customContext: networkContext_default
    });
  } else {
    litContractsClient = new LitContracts({
      signer: wallet,
      debug: false,
      network: env
    });
  }
  await litContractsClient.connect();
  if (!litContractsClient.connected) {
    console.error("\u274C litContractsClient not connected");
    process.exit();
  }
  log(
    "\u{1F9EA} [env-setup.ts] Mint a Capacity Credits NFT and get a capacity delegation authSig with it"
  );
  const { capacityTokenIdStr } = await litContractsClient.mintCapacityCreditsNFT({
    requestsPerDay: 14400,
    // 10 request per minute
    daysUntilUTCMidnightExpiration: 2
  });
  log("\u{1F9EA} [env-setup.ts] Creating a delegation auth sig");
  const { capacityDelegationAuthSig } = await litNodeClient.createCapacityDelegationAuthSig({
    uses: "1",
    dAppOwnerWallet: wallet,
    capacityTokenId: capacityTokenIdStr,
    delegateeAddresses: [wallet.address]
  });
  log("\u{1F9EA} [env-setup.ts] Mint a PKP");
  const mintRes = await litContractsClient.pkpNftContractUtils.write.mint();
  const hotWalletOwnedPkp = mintRes.pkp;
  log("\u{1F9EA} [env-setup.ts] Mint a PKP using the hot wallet auth method");
  const mintWithAuthRes = await litContractsClient.mintWithAuth({
    authMethod: hotWalletAuthMethod,
    scopes: [1 /* SignAnything */]
  });
  let { pkp: hotWalletAuthMethodOwnedPkp } = mintWithAuthRes;
  log(
    "\u{1F9EA} [env-setup.ts] Creates a Capacity Delegation AuthSig that has PKP as one of the delegatees"
  );
  const { capacityDelegationAuthSig: capacityDelegationAuthSigWithPkp } = await litNodeClient.createCapacityDelegationAuthSig({
    uses: "1",
    dAppOwnerWallet: wallet,
    capacityTokenId: capacityTokenIdStr,
    delegateeAddresses: [hotWalletAuthMethodOwnedPkp.ethAddress]
  });
  const toSignBytes32 = ethers_exports.utils.arrayify(
    ethers_exports.utils.keccak256([1, 2, 3, 4, 5])
  );
  const bobsPrivateKey = "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d";
  const bobsWallet = new ethers_exports.Wallet(bobsPrivateKey, provider);
  const bobsWalletAuthMethod = await EthWalletProvider.authenticate({
    signer: bobsWallet,
    litNodeClient
  });
  log("\u{1F9EA} [env-setup.ts] Bobs mints a PKP");
  let bobsContractsClient;
  if (env === "localchain" /* LOCALCHAIN */) {
    bobsContractsClient = new LitContracts({
      signer: bobsWallet,
      debug,
      rpc: LIT_RPC_URL,
      // anvil rpc
      customContext: networkContext_default
    });
  } else {
    bobsContractsClient = new LitContracts({
      signer: bobsWallet,
      debug: false,
      network: env
    });
  }
  const getContractsClient = async (signer) => {
    let contractsClient;
    if (env === "localchain" /* LOCALCHAIN */) {
      contractsClient = new LitContracts({
        signer,
        debug,
        rpc: LIT_RPC_URL,
        // anvil rpc
        customContext: networkContext_default
      });
    } else {
      contractsClient = new LitContracts({
        signer,
        debug: false,
        network: env
      });
    }
    await contractsClient.connect();
    return contractsClient;
  };
  await bobsContractsClient.connect();
  const bobsMintRes = await bobsContractsClient.pkpNftContractUtils.write.mint();
  const bobsOwnedPkp = bobsMintRes.pkp;
  log("\u{1F9EA} [env-setup.ts] Bob mints a PKP using the hot wallet auth method");
  const bobsMintWithAuthRes = await bobsContractsClient.mintWithAuth({
    authMethod: bobsWalletAuthMethod,
    scopes: [1 /* SignAnything */]
  });
  const bobsWalletAuthMethoedOwnedPkp = bobsMintWithAuthRes.pkp;
  log(`
----- Development Environment Configuration -----
\u2705 Chain RPC URL: ${LIT_RPC_URL}
\u2705 Bootstrap URLs: ${BOOTSTRAP_URLS}
\u2705 Wallet Address: ${await wallet.getAddress()}
\u2705 Hot Wallet Auth Sig: ${JSON.stringify(hotWalletAuthSig)}
\u2705 Hot Wallet Owned PKP ${JSON.stringify(hotWalletOwnedPkp)}
\u2705 Hot Wallet Auth Method: ${JSON.stringify(hotWalletAuthMethod)}
\u2705 Hot Wallet Auth Method Owned PKP: ${JSON.stringify(
    hotWalletAuthMethodOwnedPkp
  )}
\u2705 Capacity Token ID: ${capacityTokenIdStr}
\u2705 Capacity Delegation Auth Sig: ${JSON.stringify(capacityDelegationAuthSig)}
\u2705 Capacity Delegation Auth Sig With PKP: ${JSON.stringify(
    capacityDelegationAuthSigWithPkp
  )}
\u2705 Bob's Wallet Address: ${await bobsWallet.getAddress()}
----- Test Starts Below -----
`);
  log("\u{1F9EA} [env-setup.ts] End of devEnv");
  return {
    litNodeClient,
    litContractsClient,
    hotWallet: wallet,
    hotWalletAuthSig,
    hotWalletOwnedPkp,
    hotWalletAuthMethod,
    hotWalletAuthMethodOwnedPkp,
    lastestBlockhash: nonce,
    capacityTokenId: capacityTokenIdStr,
    capacityDelegationAuthSig,
    capacityDelegationAuthSigWithPkp,
    toSignBytes32,
    // All about Bob
    bobsWallet,
    bobsOwnedPkp,
    bobsContractsClient,
    bobsWalletAuthMethod,
    bobsWalletAuthMethoedOwnedPkp,
    // Utility
    getContractsClient
  };
};

// local-tests/setup/mini-test-framework.ts
init_shim();
var getNetworkFlag = () => {
  const networkArg = process.argv.find(
    (arg) => arg.startsWith("--network=" /* NETWORK */)
  );
  const network = networkArg ? networkArg.replace("--network=" /* NETWORK */, "") : "localchain";
  if (network !== "localchain" /* LOCALCHAIN */ && network !== "habanero" /* HABANERO */ && network !== "manzano" /* MANZANO */ && network !== "cayenne" /* CAYENNE */) {
    log(
      "[getNetworkFlag] Invalid network argument. Please use --network=localchain, --network=habanero, --network=manzano, or --network=cayenne"
    );
    process.exit();
  }
  return network;
};
var getFiltersFlag = () => {
  const filterArg = process.argv.find(
    (arg) => arg.startsWith("--filter=" /* FILTER */)
  );
  return filterArg ? filterArg.replace("--filter=" /* FILTER */, "").split(",") : [];
};
var runTests = async ({
  tests,
  devEnv,
  silent = true
  // Default silent to true if not provided
}) => {
  const filters = getFiltersFlag();
  const testsToRun = Object.entries(tests).filter(
    ([testName]) => filters.length === 0 || filters.includes(testName)
  );
  const shouldWait = testsToRun.length > 1;
  let index = 1;
  let failedTests = [];
  let passedTests = [];
  for (const [testName, testFunction] of testsToRun) {
    const startTime = performance.now();
    if (silent) {
    }
    try {
      console.log(`\x1B[90m[runTests] Running ${index}. ${testName}...\x1B[0m`);
      await testFunction(devEnv);
      const endTime = performance.now();
      const timeTaken = (endTime - startTime).toFixed(2);
      console.log(
        `\x1B[32m\u2714\x1B[90m ${index}. ${testName} - Passed (${timeTaken} ms)\x1B[0m`
      );
      passedTests.push(`${testName} (Passed in ${timeTaken} ms)`);
    } catch (error) {
      const endTime = performance.now();
      const timeTaken = (endTime - startTime).toFixed(2);
      console.error(
        `\x1B[31m\u2716\x1B[90m ${index}. ${testName} - Failed (${timeTaken} ms)\x1B[0m`
      );
      console.error(`\x1B[31mError:\x1B[90m ${error.message}\x1B[0m`);
      failedTests.push(`${testName} (Failed in ${timeTaken} ms)`);
    } finally {
    }
    index++;
    if (shouldWait) {
      await new Promise((resolve) => setTimeout(resolve, 2e3));
    }
  }
  if (failedTests.length > 0) {
    console.log(`\x1B[31mTest Report: Some tests failed.\x1B[0m`);
    failedTests.forEach((failedTest) => {
      console.log(`\x1B[31m- ${failedTest}\x1B[0m`);
    });
    passedTests.forEach((passedTest) => {
      console.log(`\x1B[32m- ${passedTest}\x1B[0m`);
    });
    process.exit(1);
  } else {
    console.log(
      `\x1B[32mTest Report: ${testsToRun.length} test(s) passed successfully.\x1B[0m`
    );
    passedTests.forEach((passedTest) => {
      console.log(`\x1B[32m- ${passedTest}\x1B[0m`);
    });
    process.exit(0);
  }
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsSigning.ts
init_shim();

// local-tests/setup/session-sigs/get-eoa-session-sigs.ts
init_shim();
var getEoaSessionSigs = async (devEnv, resourceAbilityRequests) => {
  const _resourceAbilityRequests = resourceAbilityRequests || [
    {
      resource: new LitPKPResource("*"),
      ability: "pkp-signing" /* PKPSigning */
    },
    {
      resource: new LitActionResource("*"),
      ability: "lit-action-execution" /* LitActionExecution */
    }
  ];
  const sessionSigs = await devEnv.litNodeClient.getSessionSigs({
    chain: "ethereum",
    resourceAbilityRequests: _resourceAbilityRequests,
    authNeededCallback: async ({
      uri,
      expiration,
      resourceAbilityRequests: resourceAbilityRequests2
    }) => {
      if (!expiration) {
        throw new Error("expiration is required");
      }
      if (!resourceAbilityRequests2) {
        throw new Error("resourceAbilityRequests is required");
      }
      if (!uri) {
        throw new Error("uri is required");
      }
      const toSign = await createSiweMessageWithRecaps({
        uri,
        expiration,
        resources: resourceAbilityRequests2,
        walletAddress: devEnv.hotWallet.address,
        nonce: devEnv.lastestBlockhash,
        litNodeClient: devEnv.litNodeClient
      });
      const authSig = await craftAuthSig({
        signer: devEnv.hotWallet,
        toSign
      });
      return authSig;
    }
  });
  log("[getEoaSessionSigs]: ", getEoaSessionSigs);
  return sessionSigs;
};
var getEoaSessionSigsWithCapacityDelegations = async (devEnv, fromWallet, capacityDelegationAuthSig) => {
  const sessionSigs = await devEnv.litNodeClient.getSessionSigs({
    chain: "ethereum",
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: "pkp-signing" /* PKPSigning */
      },
      {
        resource: new LitActionResource("*"),
        ability: "lit-action-execution" /* LitActionExecution */
      }
    ],
    authNeededCallback: async ({
      uri,
      expiration,
      resourceAbilityRequests
    }) => {
      if (!expiration) {
        throw new Error("expiration is required");
      }
      if (!resourceAbilityRequests) {
        throw new Error("resourceAbilityRequests is required");
      }
      if (!uri) {
        throw new Error("uri is required");
      }
      const toSign = await createSiweMessageWithRecaps({
        uri,
        expiration,
        resources: resourceAbilityRequests,
        walletAddress: fromWallet.address,
        nonce: devEnv.lastestBlockhash,
        litNodeClient: devEnv.litNodeClient
      });
      const authSig = await craftAuthSig({
        signer: fromWallet,
        toSign
      });
      return authSig;
    },
    capabilityAuthSigs: [capacityDelegationAuthSig]
  });
  log("[getEoaSessionSigs]: ", getEoaSessionSigs);
  return sessionSigs;
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsSigning.ts
var testUseEoaSessionSigsToExecuteJsSigning = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: eoaSessionSigs,
    code: `(async () => {
      const sigShare = await LitActions.signEcdsa({
        toSign: dataToSign,
        publicKey,
        sigName: "sig",
      });
    })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.hotWalletOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  log("\u2705 testUseEoaSessionSigsToExecuteJsSigning");
};

// local-tests/tests/testUseEoaSessionSigsToPkpSign.ts
init_shim();
var testUseEoaSessionSigsToPkpSign = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const runWithSessionSigs = await devEnv.litNodeClient.pkpSign({
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.hotWalletOwnedPkp.publicKey,
    sessionSigs: eoaSessionSigs
  });
  if (!runWithSessionSigs.r) {
    throw new Error(`Expected "r" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.s) {
    throw new Error(`Expected "s" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.dataSigned) {
    throw new Error(`Expected "dataSigned" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.publicKey) {
    throw new Error(`Expected "publicKey" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(runWithSessionSigs.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  log("\u2705 testUseEoaSessionSigsToPkpSign");
};

// local-tests/tests/testUsePkpSessionSigsToExecuteJsSigning.ts
init_shim();

// local-tests/setup/session-sigs/get-pkp-session-sigs.ts
init_shim();
var getPkpSessionSigs = async (devEnv) => {
  const pkpSessionSigs = await devEnv.litNodeClient.getPkpSessionSigs({
    pkpPublicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
    authMethods: [devEnv.hotWalletAuthMethod],
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: "pkp-signing" /* PKPSigning */
      },
      {
        resource: new LitActionResource("*"),
        ability: "lit-action-execution" /* LitActionExecution */
      }
    ]
  });
  log("[getPkpSessionSigs]: ", pkpSessionSigs);
  return pkpSessionSigs;
};

// local-tests/tests/testUsePkpSessionSigsToExecuteJsSigning.ts
var testUsePkpSessionSigsToExecuteJsSigning = async (devEnv) => {
  const pkpSessionSigs = await getPkpSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: pkpSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  if (!res.signatures.sig.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.signatures.sig.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  log("\u2705 res:", res);
};

// local-tests/tests/testUsePkpSessionSigsToPkpSign.ts
init_shim();
var testUsePkpSessionSigsToPkpSign = async (devEnv) => {
  const pkpSessionSigs = await getPkpSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.pkpSign({
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
    sessionSigs: pkpSessionSigs
  });
  if (!res.r) {
    throw new Error(`Expected "r" in res`);
  }
  if (!res.s) {
    throw new Error(`Expected "s" in res`);
  }
  if (!res.dataSigned) {
    throw new Error(`Expected "dataSigned" in res`);
  }
  if (!res.publicKey) {
    throw new Error(`Expected "publicKey" in res`);
  }
  if (!res.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  log("\u2705 res:", res);
};

// local-tests/tests/testUseValidLitActionCodeGeneratedSessionSigsToPkpSign.ts
init_shim();

// local-tests/setup/session-sigs/get-lit-action-session-sigs.ts
init_shim();
var VALID_SESSION_SIG_LIT_ACTION_CODE = `
// Works with an AuthSig AuthMethod
if (Lit.Auth.authMethodContexts.some(e => e.authMethodType === 1)) {
  LitActions.setResponse({ response: "true" });
} else {
  LitActions.setResponse({ response: "false" });
}
`;
var getLitActionSessionSigs = async (devEnv) => {
  const litActionSessionSigs = await devEnv.litNodeClient.getPkpSessionSigs({
    pkpPublicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
    authMethods: [devEnv.hotWalletAuthMethod],
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: "pkp-signing" /* PKPSigning */
      }
    ],
    litActionCode: Buffer.from(VALID_SESSION_SIG_LIT_ACTION_CODE).toString(
      "base64"
    ),
    jsParams: {
      publicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
      sigName: "unified-auth-sig"
    }
  });
  return litActionSessionSigs;
};
var getLitActionSessionSigsForExecuteJs = async (devEnv) => {
  const litActionSessionSigs = await devEnv.litNodeClient.getPkpSessionSigs({
    pkpPublicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
    authMethods: [devEnv.hotWalletAuthMethod],
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: "pkp-signing" /* PKPSigning */
      },
      {
        resource: new LitActionResource("*"),
        ability: "lit-action-execution" /* LitActionExecution */
      }
    ],
    litActionCode: Buffer.from(VALID_SESSION_SIG_LIT_ACTION_CODE).toString(
      "base64"
    ),
    jsParams: {
      publicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
      sigName: "unified-auth-sig"
    }
  });
  return litActionSessionSigs;
};

// local-tests/tests/testUseValidLitActionCodeGeneratedSessionSigsToPkpSign.ts
var testUseValidLitActionCodeGeneratedSessionSigsToPkpSign = async (devEnv) => {
  const litActionSessionSigs = await getLitActionSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.pkpSign({
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey,
    sessionSigs: litActionSessionSigs
  });
  if (!res.r) {
    throw new Error(`Expected "r" in res`);
  }
  if (!res.s) {
    throw new Error(`Expected "s" in res`);
  }
  if (!res.dataSigned) {
    throw new Error(`Expected "dataSigned" in res`);
  }
  if (!res.publicKey) {
    throw new Error(`Expected "publicKey" in res`);
  }
  if (!res.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  log("\u2705 res:", res);
};

// local-tests/tests/testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsSigning.ts
init_shim();
var testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsSigning = async (devEnv) => {
  const litActionSessionSigs = await getLitActionSessionSigsForExecuteJs(
    devEnv
  );
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: litActionSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.hotWalletAuthMethodOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  log("\u2705 res:", res);
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsSigningInParallel.ts
init_shim();
var testUseEoaSessionSigsToExecuteJsSigningInParallel = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const fn = async (index) => {
    log(`Index: ${index}`);
    return await devEnv.litNodeClient.executeJs({
      sessionSigs: eoaSessionSigs,
      code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
      jsParams: {
        dataToSign: devEnv.toSignBytes32,
        publicKey: devEnv.hotWalletOwnedPkp.publicKey
      }
    });
  };
  const res = await Promise.all([fn(1), fn(2), fn(3)]);
  log("res:", res);
  res.forEach((r3) => {
    if (!r3.signatures.sig.r) {
      throw new Error(`Expected "r" in res.signatures.sig`);
    }
    if (!r3.signatures.sig.s) {
      throw new Error(`Expected "s" in res.signatures.sig`);
    }
    if (!r3.signatures.sig.dataSigned) {
      throw new Error(`Expected "dataSigned" in res.signatures.sig`);
    }
    if (!r3.signatures.sig.publicKey) {
      throw new Error(`Expected "publicKey" in res.signatures.sig`);
    }
    if (!r3.signatures.sig.signature.startsWith("0x")) {
      throw new Error(`Expected "signature" to start with 0x`);
    }
    if (isNaN(r3.signatures.sig.recid)) {
      throw new Error(`Expected "recid" to be parseable as a number`);
    }
  });
  log("\u2705 testUseEoaSessionSigsToExecuteJsSigningInParallel");
};

// local-tests/tests/testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs.ts
init_shim();
var testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs = async (devEnv) => {
  const ccNft = devEnv.capacityTokenId;
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet,
    capacityTokenId: ccNft,
    delegateeAddresses: [bobsWallet.address]
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: bobsSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.bobsWalletOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  if (!res.signatures.sig.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.signatures.sig.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  console.log(
    "\u2705 testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs"
  );
};

// local-tests/tests/testDelegatingCapacityCreditsNFTToAnotherWalletToPkpSign.ts
init_shim();
var testDelegatingCapacityCreditsNFTToAnotherWalletToPkpSign = async (devEnv) => {
  const ccNft = devEnv.capacityTokenId;
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet,
    capacityTokenId: ccNft,
    delegateeAddresses: [bobsWallet.address]
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const res = await devEnv.litNodeClient.pkpSign({
    sessionSigs: bobsSessionSigs,
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.bobsWalletOwnedPkp.publicKey
  });
  if (!res.r) {
    throw new Error(`Expected "r" in res`);
  }
  if (!res.s) {
    throw new Error(`Expected "s" in res`);
  }
  if (!res.dataSigned) {
    throw new Error(`Expected "dataSigned" in res`);
  }
  if (!res.publicKey) {
    throw new Error(`Expected "publicKey" in res`);
  }
  if (!res.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  console.log("\u2705 res:", res);
};

// local-tests/tests/testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToPkpSign.ts
init_shim();
var testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToPkpSign = async (devEnv) => {
  const ccNft = devEnv.capacityTokenId;
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet,
    capacityTokenId: ccNft
    // No delegatee addresses provided. It means that the capability will not restrict access based on delegatee list, but it may still enforce other restrictions such as usage limits and specific NFT IDs.
    // delegateeAddresses: [bobsWallet.address],
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const runWithSessionSigs = await devEnv.litNodeClient.pkpSign({
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.bobsWalletOwnedPkp.publicKey,
    sessionSigs: bobsSessionSigs
  });
  if (!runWithSessionSigs.r) {
    throw new Error(`Expected "r" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.s) {
    throw new Error(`Expected "s" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.dataSigned) {
    throw new Error(`Expected "dataSigned" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.publicKey) {
    throw new Error(`Expected "publicKey" in runWithSessionSigs`);
  }
  if (!runWithSessionSigs.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(runWithSessionSigs.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
};

// local-tests/tests/testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToExecuteJs.ts
init_shim();
var testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToExecuteJs = async (devEnv) => {
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: bobsSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.bobsWalletOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  if (!res.signatures.sig.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.signatures.sig.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  console.log(
    "\u2705 testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs"
  );
};

// local-tests/tests/testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToPkpSign.ts
init_shim();
var testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToPkpSign = async (devEnv) => {
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const res = await devEnv.litNodeClient.pkpSign({
    sessionSigs: bobsSessionSigs,
    toSign: devEnv.toSignBytes32,
    pubKey: devEnv.bobsWalletOwnedPkp.publicKey
  });
  if (!res.r) {
    throw new Error(`Expected "r" in res`);
  }
  if (!res.s) {
    throw new Error(`Expected "s" in res`);
  }
  if (!res.dataSigned) {
    throw new Error(`Expected "dataSigned" in res`);
  }
  if (!res.publicKey) {
    throw new Error(`Expected "publicKey" in res`);
  }
  if (!res.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  console.log("\u2705 res:", res);
};

// local-tests/tests/testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToExecuteJs.ts
init_shim();
var testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToExecuteJs = async (devEnv) => {
  const ccNft = devEnv.capacityTokenId;
  const bobsWallet = devEnv.bobsWallet;
  const { capacityDelegationAuthSig: appOwnersCapacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet,
    capacityTokenId: ccNft
    // No delegatee addresses provided. It means that the capability will not restrict access based on delegatee list, but it may still enforce other restrictions such as usage limits and specific NFT IDs.
    // delegateeAddresses: [bobsWallet.address],
  });
  const bobsSessionSigs = await getEoaSessionSigsWithCapacityDelegations(
    devEnv,
    bobsWallet,
    appOwnersCapacityDelegationAuthSig
  );
  const bobsSingleSessionSig = bobsSessionSigs[devEnv.litNodeClient.config.bootstrapUrls[0]];
  console.log("bobsSingleSessionSig:", bobsSingleSessionSig);
  const regex = /urn:recap:[\w+\/=]+/g;
  const recaps = bobsSingleSessionSig.signedMessage.match(regex) || [];
  recaps.forEach((r3) => {
    const encodedRecap = r3.split(":")[2];
    const decodedRecap = Buffer.from(encodedRecap, "base64").toString();
    console.log(decodedRecap);
  });
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: bobsSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.bobsWalletOwnedPkp.publicKey
    }
  });
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  if (!res.signatures.sig.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
  if (isNaN(res.signatures.sig.recid)) {
    throw new Error(`Expected "recid" to be parseable as a number`);
  }
  console.log(
    "\u2705 testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs"
  );
};

// local-tests/tests/testDelegatingCapacityCreditsNFTToAnotherPkpToExecuteJs.ts
init_shim();
var testDelegatingCapacityCreditsNFTToAnotherPkpToExecuteJs = async (devEnv) => {
  const bobsAuthMethodAuthId = await LitAuthClient.getAuthIdByAuthMethod(
    devEnv.bobsWalletAuthMethod
  );
  const scopes = await devEnv.bobsContractsClient.pkpPermissionsContract.read.getPermittedAuthMethodScopes(
    devEnv.bobsWalletAuthMethoedOwnedPkp.tokenId,
    1 /* EthWallet */,
    bobsAuthMethodAuthId,
    3
  );
  if (!scopes[1 /* SignAnything */]) {
    throw new Error('Bob does not have the "SignAnything" scope on his PKP');
  }
  const { capacityDelegationAuthSig } = await devEnv.litNodeClient.createCapacityDelegationAuthSig({
    dAppOwnerWallet: devEnv.hotWallet,
    capacityTokenId: devEnv.capacityTokenId,
    delegateeAddresses: [devEnv.bobsWalletAuthMethoedOwnedPkp.ethAddress]
  });
  const bobPkpSessionSigs = await devEnv.litNodeClient.getPkpSessionSigs({
    pkpPublicKey: devEnv.bobsWalletAuthMethoedOwnedPkp.publicKey,
    authMethods: [devEnv.bobsWalletAuthMethod],
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: "pkp-signing" /* PKPSigning */
      },
      {
        resource: new LitActionResource("*"),
        ability: "lit-action-execution" /* LitActionExecution */
      }
    ],
    capabilityAuthSigs: [capacityDelegationAuthSig]
  });
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: bobPkpSessionSigs,
    code: `(async () => {
        const sigShare = await LitActions.signEcdsa({
          toSign: dataToSign,
          publicKey,
          sigName: "sig",
        });
      })();`,
    jsParams: {
      dataToSign: devEnv.toSignBytes32,
      publicKey: devEnv.bobsWalletAuthMethoedOwnedPkp.publicKey
    }
  });
  console.log("\u2705 res:", res);
  if (!res.signatures.sig.r) {
    throw new Error(`Expected "r" in res.signatures.sig`);
  }
  if (!res.signatures.sig.s) {
    throw new Error(`Expected "s" in res.signatures.sig`);
  }
  if (!res.signatures.sig.dataSigned) {
    throw new Error(`Expected "dataSigned" in res.signatures.sig`);
  }
  if (!res.signatures.sig.publicKey) {
    throw new Error(`Expected "publicKey" in res.signatures.sig`);
  }
  if (!res.signatures.sig.signature.startsWith("0x")) {
    throw new Error(`Expected "signature" to start with 0x`);
  }
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsClaimKeys.ts
init_shim();
var testUseEoaSessionSigsToExecuteJsClaimKeys = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: eoaSessionSigs,
    code: `(async () => {
      Lit.Actions.claimKey({keyId: "foo"});
    })();`
  });
  console.log("res:", res);
  if (!res.claims.foo) {
    throw new Error(`Expected "foo" in res.claims`);
  }
  if (!res.claims.foo.derivedKeyId) {
    throw new Error(`Expected "derivedKeyId" in res.claims.foo`);
  }
  if (!res.claims.foo.signatures) {
    throw new Error(`Expected "signatures" in res.claims.foo`);
  }
  res.claims.foo.signatures.forEach((sig) => {
    if (!sig.r) {
      throw new Error(`Expected "r" in sig`);
    }
    if (!sig.s) {
      throw new Error(`Expected "s" in sig`);
    }
    if (!sig.v) {
      throw new Error(`Expected "v" in sig`);
    }
  });
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsClaimMultipleKeys.ts
init_shim();
var testUseEoaSessionSigsToExecuteJsClaimMultipleKeys = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: eoaSessionSigs,
    code: `(async () => {
      Lit.Actions.claimKey({keyId: "foo"});
      Lit.Actions.claimKey({keyId: "bar"});
    })();`
  });
  if (!res.claims.foo) {
    throw new Error(`Expected "foo" in res.claims`);
  }
  if (!res.claims.foo.derivedKeyId) {
    throw new Error(`Expected "derivedKeyId" in res.claims.foo`);
  }
  if (!res.claims.foo.signatures) {
    throw new Error(`Expected "signatures" in res.claims.foo`);
  }
  res.claims.foo.signatures.forEach((sig) => {
    if (!sig.r) {
      throw new Error(`Expected "r" in sig`);
    }
    if (!sig.s) {
      throw new Error(`Expected "s" in sig`);
    }
    if (!sig.v) {
      throw new Error(`Expected "v" in sig`);
    }
  });
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsJsonResponse.ts
init_shim();
var testUseEoaSessionSigsToExecuteJsJsonResponse = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: eoaSessionSigs,
    code: `(async () => {
      console.log('hello world')

      LitActions.setResponse({
        response: JSON.stringify({hello: 'world'})
      });

    })();`
  });
  if (!res.response) {
    throw new Error(`Expected "response" in res`);
  }
  if (!res.response.startsWith("{")) {
    throw new Error(`Expected "response" to start with {`);
  }
  if (!res.response.endsWith("}")) {
    throw new Error(`Expected "response" to end with }`);
  }
  if (!res.logs) {
    throw new Error(`Expected "logs" in res`);
  }
  if (!res.logs.includes("hello world")) {
    throw new Error(`Expected "logs" to include 'hello world'`);
  }
  if (!res.success) {
    throw new Error(`Expected "success" in res`);
  }
  if (res.success !== true) {
    throw new Error(`Expected "success" to be true`);
  }
};

// local-tests/tests/testUseEoaSessionSigsToExecuteJsConsoleLog.ts
init_shim();
var testUseEoaSessionSigsToExecuteJsConsoleLog = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const res = await devEnv.litNodeClient.executeJs({
    sessionSigs: eoaSessionSigs,
    code: `(async () => {
      console.log('hello world')
    })();`
  });
  console.log("res:", res);
  if (res.response) {
    throw new Error(`Expected "response" to be falsy`);
  }
  if (!res.logs) {
    throw new Error(`Expected "logs" in res`);
  }
  if (!res.logs.includes("hello world")) {
    throw new Error(`Expected "logs" to include 'hello world'`);
  }
  if (!res.success) {
    throw new Error(`Expected "success" in res`);
  }
};

// local-tests/tests/testUseEoaSessionSigsToEncryptDecryptString.ts
init_shim();

// local-tests/setup/accs/accs.ts
init_shim();
var AccessControlConditions;
((AccessControlConditions2) => {
  let Success;
  ((Success2) => {
    Success2.getEmvBasicAccessControlConditions = ({
      userAddress
    }) => {
      return [
        {
          contractAddress: "",
          standardContractType: "",
          chain: "ethereum",
          method: "",
          parameters: [":userAddress"],
          returnValueTest: {
            comparator: "=",
            value: userAddress
          }
        }
      ];
    };
    Success2.evmBasicBooleanAccessControlConditions = [
      {
        contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        standardContractType: "POAP",
        chain: "xdai",
        method: "eventId",
        parameters: [],
        returnValueTest: {
          comparator: "=",
          value: "37582"
        }
      },
      {
        operator: "or"
      },
      {
        contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        standardContractType: "POAP",
        chain: "ethereum",
        method: "eventId",
        parameters: [],
        returnValueTest: {
          comparator: "=",
          value: "37582"
        }
      }
    ];
    Success2.evmContractAccessControlConditions = [
      {
        contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
        functionName: "balanceOf",
        functionParams: [":userAddress", "8"],
        functionAbi: {
          type: "function",
          stateMutability: "view",
          outputs: [
            {
              type: "uint256",
              name: "",
              internalType: "uint256"
            }
          ],
          name: "balanceOf",
          inputs: [
            {
              type: "address",
              name: "account",
              internalType: "address"
            },
            {
              type: "uint256",
              name: "id",
              internalType: "uint256"
            }
          ]
        },
        chain: "ethereum",
        returnValueTest: {
          key: "",
          comparator: ">",
          value: "0"
        }
      }
    ];
    Success2.solAccessControlConditions = [
      {
        method: "getBalance",
        params: [":userAddress"],
        pdaParams: [],
        pdaInterface: { offset: 0, fields: {} },
        pdaKey: "",
        chain: "solanaTestnet",
        returnValueTest: {
          key: "",
          comparator: ">=",
          value: "100000000"
          // equals 0.1 SOL
        }
      }
    ];
    Success2.cosmosAccessControlConditions = [
      {
        conditionType: "cosmos",
        path: ":userAddress",
        chain: "cosmos",
        returnValueTest: {
          key: "",
          comparator: "=",
          value: "cosmos1vn6zl0924yj86jrp330wcwjclzdharljq03a8h"
        }
      }
    ];
    Success2.unifiedAccessControlConditions = [
      {
        conditionType: "solRpc",
        method: "getBalance",
        params: [":userAddress"],
        chain: "solana",
        pdaParams: [],
        pdaInterface: { offset: 0, fields: {} },
        pdaKey: "",
        returnValueTest: {
          key: "",
          comparator: ">=",
          value: "100000000"
          // equals 0.1 SOL
        }
      },
      { operator: "or" },
      {
        conditionType: "evmBasic",
        contractAddress: "",
        standardContractType: "",
        chain: "ethereum",
        method: "eth_getBalance",
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "10000000000000"
        }
      },
      { operator: "or" },
      {
        conditionType: "evmContract",
        contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
        functionName: "balanceOf",
        functionParams: [":userAddress", "8"],
        functionAbi: {
          type: "function",
          stateMutability: "view",
          outputs: [
            {
              type: "uint256",
              name: "",
              internalType: "uint256"
            }
          ],
          name: "balanceOf",
          inputs: [
            {
              type: "address",
              name: "account",
              internalType: "address"
            },
            {
              type: "uint256",
              name: "id",
              internalType: "uint256"
            }
          ]
        },
        chain: "polygon",
        returnValueTest: {
          key: "",
          comparator: ">",
          value: "0"
        }
      }
    ];
  })(Success = AccessControlConditions2.Success || (AccessControlConditions2.Success = {}));
  let Failture;
  ((Failture2) => {
    Failture2.noConditions = [];
    Failture2.evmBasicAccessControlConditionsWithMissingFields = [
      {
        contractAddress: "",
        // standardContractType: '',
        // chain,
        // method: 'eth_getBalance',
        // parameters: [':userAddress', 'latest'],
        returnValueTest: {
          comparator: ">=",
          value: "0"
        }
      }
    ];
    Failture2.evmBasicNestedAccessControlConditionsWithMissingFields = [
      {
        contractAddress: "",
        standardContractType: "",
        chain: "etherum",
        method: "eth_getBalance",
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "0"
        }
      },
      {
        operator: "and"
      },
      [
        {
          contractAddress: "",
          standardContractType: "",
          chain: "ethereum",
          method: "eth_getBalance",
          parameters: [":userAddress", "latest"],
          returnValueTest: {
            comparator: ">=",
            value: "1"
          }
        },
        {
          operator: "and"
        },
        {
          contractAddress: "",
          // standardContractType: '',
          // chain,
          // method: 'eth_getBalance',
          // parameters: [':userAddress', 'latest'],
          returnValueTest: {
            comparator: ">=",
            value: "2"
          }
        }
      ]
    ];
    Failture2.evmBasicAccessControlConditionsWithInvalidFields = [
      {
        contractAddress: 6973231634015965e32,
        standardContractType: "AMM",
        chain: "bitcoin",
        method: "eth_getBalance",
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "0"
        }
      }
    ];
    Failture2.evmContractAccessControlConditionsWithMissingFields = [
      {
        // contractAddress: '0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88',
        functionName: "balanceOf",
        // functionParams: [':userAddress', '8'],
        functionAbi: {
          type: "function",
          stateMutability: "view",
          outputs: [
            {
              type: "uint256",
              name: "",
              internalType: "uint256"
            }
          ],
          name: "balanceOf",
          inputs: [
            {
              type: "address",
              name: "account",
              internalType: "address"
            },
            {
              type: "uint256",
              name: "id",
              internalType: "uint256"
            }
          ]
        },
        // chain: 'polygon',
        returnValueTest: {
          key: "",
          comparator: ">",
          value: "0"
        }
      }
    ];
    Failture2.evmContractNestedAccessControlConditionsWithInvalidFields = [
      {
        contractAddress: 7105762806747812e32,
        functionName: "balanceOf",
        functionParams: [":userAddress", "8"],
        functionAbi: {
          type: "function",
          stateMutability: "view",
          outputs: [
            {
              type: "uint256",
              name: "",
              internalType: "uint256"
            }
          ],
          name: "balanceOf",
          inputs: [
            {
              type: "address",
              name: "account",
              internalType: "address"
            },
            {
              type: "uint256",
              name: "id",
              internalType: "uint256"
            }
          ]
        },
        chain: "eth",
        returnValueTest: {
          key: "",
          comparator: ">",
          value: "0"
        }
      }
    ];
    Failture2.solAccessControlConditionsWithMissingFields = [
      {
        method: "getBalance",
        params: [":userAddress"],
        chain: "solana",
        pdaParams: [],
        // pdaInterface: { offset: 0, fields: {} },
        // pdaKey: '',
        returnValueTest: {
          key: "",
          comparator: ">=",
          value: "100000000"
          // equals 0.1 SOL
        }
      }
    ];
    Failture2.invalidUnifiedAccessControlConditions = [
      {
        conditionType: "solRpc",
        method: "getBalance",
        params: [":userAddress"],
        // chain: 'solana',
        pdaParams: [],
        pdaInterface: { offset: 0, fields: {} },
        pdaKey: "",
        returnValueTest: {
          key: "",
          comparator: ">=",
          value: "100000000"
          // equals 0.1 SOL
        }
      },
      { operator: "or" },
      {
        conditionType: "evmBasic",
        contractAddress: "",
        standardContractType: "",
        chain: "ethereum",
        // method: 'eth_getBalance',
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "10000000000000"
        }
      },
      { operator: "or" },
      {
        conditionType: "evmContract",
        contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
        // functionName: 'balanceOf',
        functionParams: [":userAddress", "8"],
        functionAbi: {
          type: "function",
          stateMutability: "view",
          outputs: [
            {
              type: "uint256",
              name: "",
              internalType: "uint256"
            }
          ],
          name: "balanceOf",
          inputs: [
            {
              type: "address",
              name: "account",
              internalType: "address"
            },
            {
              type: "uint256",
              name: "id",
              internalType: "uint256"
            }
          ]
        },
        // chain: 'polygon',
        returnValueTest: {
          key: "",
          comparator: ">",
          value: "0"
        }
      }
    ];
    Failture2.invalidConditionUnifiedAccessControlConditions = [
      {
        conditionType: "zkSync",
        // Does not exist
        contractAddress: "",
        standardContractType: "",
        chain: "ethereum",
        method: "eth_getBalance",
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "10000000000000"
        }
      }
    ];
    Failture2.noTypeUnifiedAccessControlConditions = [
      {
        // conditionType: 'evmBasic',
        contractAddress: "",
        standardContractType: "",
        chain: "ethereum",
        method: "eth_getBalance",
        parameters: [":userAddress", "latest"],
        returnValueTest: {
          comparator: ">=",
          value: "10000000000000"
        }
      }
    ];
  })(Failture = AccessControlConditions2.Failture || (AccessControlConditions2.Failture = {}));
})(AccessControlConditions || (AccessControlConditions = {}));

// local-tests/tests/testUseEoaSessionSigsToEncryptDecryptString.ts
var testUseEoaSessionSigsToEncryptDecryptString = async (devEnv) => {
  const eoaSessionSigs = await getEoaSessionSigs(devEnv);
  const encryptRes = await encryptString(
    {
      accessControlConditions: AccessControlConditions.getEmvBasicAccessControlConditions({
        userAddress: devEnv.hotWallet.address
      }),
      chain: "ethereum",
      sessionSigs: eoaSessionSigs,
      dataToEncrypt: "Hello world"
    },
    devEnv.litNodeClient
  );
  console.log("encryptRes:", encryptRes);
  if (!encryptRes.ciphertext) {
    throw new Error(`Expected "ciphertext" in encryptRes`);
  }
  if (!encryptRes.dataToEncryptHash) {
    throw new Error(`Expected "dataToEncryptHash" to in encryptRes`);
  }
  const eoaSessionSigs2 = await getEoaSessionSigs(devEnv, [
    {
      resource: new LitAccessControlConditionResource(
        encryptRes.dataToEncryptHash
      ),
      ability: "access-control-condition-decryption" /* AccessControlConditionDecryption */
    }
  ]);
  const decryptRes = await decryptToString(
    {
      accessControlConditions: AccessControlConditions.getEmvBasicAccessControlConditions({
        userAddress: devEnv.hotWallet.address
      }),
      ciphertext: encryptRes.ciphertext,
      dataToEncryptHash: encryptRes.dataToEncryptHash,
      sessionSigs: eoaSessionSigs2,
      chain: "ethereum"
    },
    devEnv.litNodeClient
  );
  if (decryptRes !== "Hello world") {
    throw new Error(
      `Expected decryptRes to be 'Hello world' but got ${decryptRes}`
    );
  }
};

// local-tests/test.ts
(async () => {
  const devEnv = await getDevEnv({
    env: getNetworkFlag(),
    debug: process.env.DEBUG === "true" || true
  });
  const eoaSessionSigsTests = {
    testUseEoaSessionSigsToExecuteJsSigning,
    testUseEoaSessionSigsToPkpSign,
    testUseEoaSessionSigsToExecuteJsSigningInParallel,
    testUseEoaSessionSigsToExecuteJsClaimKeys,
    testUseEoaSessionSigsToExecuteJsClaimMultipleKeys,
    testUseEoaSessionSigsToExecuteJsJsonResponse,
    testUseEoaSessionSigsToExecuteJsConsoleLog,
    testUseEoaSessionSigsToEncryptDecryptString
  };
  const pkpSessionSigsTests = {
    testUsePkpSessionSigsToExecuteJsSigning,
    testUsePkpSessionSigsToPkpSign
    // testUsePkpSessionSigsToExecuteJsSigningInParallel,
    // testUsePkpSessionSigsToExecuteJsClaimKeys,
    // testUsePkpSessionSigsToExecuteJsClaimMultipleKeys,
    // testUsePkpSessionSigsToExecuteJsJsonResponse,
    // testUsePkpSessionSigsToExecuteJsConsoleLog,
    // testUsePkpSessionSigsToEncryptDecryptString
  };
  const litActionSessionSigsTests = {
    testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsSigning,
    testUseValidLitActionCodeGeneratedSessionSigsToPkpSign
    // testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsSigningInParallel,
    // testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsClaimKeys,
    // testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsClaimMultipleKeys,
    // testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsJsonResponse,
    // testUseValidLitActionCodeGeneratedSessionSigsToExecuteJsConsoleLog,
    // testUseValidLitActionCodeGeneratedSessionSigsToEncryptDecryptString
  };
  const capacityDelegationTests = {
    testDelegatingCapacityCreditsNFTToAnotherWalletToExecuteJs,
    testDelegatingCapacityCreditsNFTToAnotherWalletToPkpSign,
    testDelegatingCapacityCreditsNFTToAnotherPkpToExecuteJs,
    testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToExecuteJs,
    testUseCapacityDelegationAuthSigWithUnspecifiedDelegateesToPkpSign,
    testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToExecuteJs,
    testUseCapacityDelegationAuthSigWithUnspecifiedCapacityTokenIdToPkpSign
  };
  await runTests({
    tests: {
      ...eoaSessionSigsTests,
      ...pkpSessionSigsTests,
      ...litActionSessionSigsTests,
      ...capacityDelegationTests
    },
    devEnv
  });
})();
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/
